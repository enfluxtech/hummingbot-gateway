import { utils, keyStores, Near, WalletConnection, providers, InMemorySigner } from 'near-api-js';
import BN from 'bn.js';
import { divide, evaluate, format } from 'mathjs';
import Big from 'big.js';
import _ from 'lodash-es';

var FEE_DIVISOR = 10000;
var STABLE_LP_TOKEN_DECIMALS = 18;
var RATED_POOL_LP_TOKEN_DECIMALS = 24;
function getConfig(env) {
  if (env === void 0) {
    env = process.env.NEAR_ENV;
  }

  switch (env) {
    case 'mainnet':
      return {
        networkId: 'mainnet',
        nodeUrl: 'https://rpc.mainnet.near.org',
        walletUrl: 'https://wallet.near.org',
        WRAP_NEAR_CONTRACT_ID: 'wrap.near',
        REF_FI_CONTRACT_ID: 'v2.ref-finance.near'
      };

    case 'testnet':
      return {
        networkId: 'testnet',
        nodeUrl: 'https://rpc.testnet.near.org',
        walletUrl: 'https://wallet.testnet.near.org',
        WRAP_NEAR_CONTRACT_ID: 'wrap.testnet',
        REF_FI_CONTRACT_ID: 'ref-finance-101.testnet'
      };

    default:
      return {
        networkId: 'mainnet',
        nodeUrl: 'https://rpc.mainnet.near.org',
        walletUrl: 'https://wallet.near.org',
        REF_FI_CONTRACT_ID: 'v2.ref-finance.near',
        WRAP_NEAR_CONTRACT_ID: 'wrap.near'
      };
  }
}
var config = /*#__PURE__*/getConfig();
var REF_FI_CONTRACT_ID = config.REF_FI_CONTRACT_ID;
var STORAGE_TO_REGISTER_WITH_MFT = '0.1';
var ONE_YOCTO_NEAR = '0.000000000000000000000001'; // export const REF_FI_CONTRACT_ID = 'exchange.ref-dev.testnet';
// export const config = {
//   networkId: 'testnet',
//   nodeUrl: 'https://rpc.testnet.near.org',
//   walletUrl: 'https://wallet.testnet.near.org',
// };

var formatError = function formatError(msg) {
  return new Error(msg);
};
var unNamedError = /*#__PURE__*/formatError('Something wrong happened');
var SameInputTokenError = /*#__PURE__*/formatError('Input token should be different with output token');
var ZeroInputError = /*#__PURE__*/formatError('Input amount should be greater than 0');
var NoPoolError = /*#__PURE__*/formatError('No pool found for the input tokens');
var NotLoginError = /*#__PURE__*/formatError('Please login in first');
var SwapRouteError = /*#__PURE__*/formatError("Something wrong happened, we don't get correct routes corrreponding to current input");
var TokenNotExistError = /*#__PURE__*/formatError("This token doesn't exist in " + /*#__PURE__*/getConfig().networkId);

var parsePool = function parsePool(pool, id) {
  return {
    id: Number(id && id >= 0 ? id : pool.id),
    tokenIds: pool.token_account_ids,
    supplies: pool.amounts.reduce(function (acc, amount, i) {
      acc[pool.token_account_ids[i]] = amount;
      return acc;
    }, {}),
    fee: pool.total_fee,
    shareSupply: pool.shares_total_supply,
    tvl: pool.tvl,
    token0_ref_price: pool.token0_ref_price,
    pool_kind: pool.pool_kind
  };
};
var poolFormatter = function poolFormatter(pool) {
  return {
    id: pool.id,
    token1Id: pool.tokenIds[0],
    token2Id: pool.tokenIds[1],
    token1Supply: pool.supplies[pool.tokenIds[0]],
    token2Supply: pool.supplies[pool.tokenIds[1]],
    fee: pool.fee,
    shares: pool.shareSupply,
    token0_price: pool.token0_ref_price || '0'
  };
};
var isStablePoolToken = function isStablePoolToken(stablePools, tokenId) {
  return stablePools.map(function (p) {
    return p.token_account_ids;
  }).flat().includes(tokenId.toString());
};
var isStablePool = function isStablePool(stablePools, poolId) {
  return stablePools.map(function (p) {
    return p.id.toString();
  }).includes(poolId.toString());
};
var getStablePoolDecimal = function getStablePoolDecimal(stablePool) {
  return stablePool.pool_kind === 'RATED_SWAP' ? RATED_POOL_LP_TOKEN_DECIMALS : STABLE_LP_TOKEN_DECIMALS;
};
var round = function round(decimals, minAmountOut) {
  return Number.isInteger(Number(minAmountOut)) ? minAmountOut : Math.ceil(Math.round(Number(minAmountOut) * Math.pow(10, decimals)) / Math.pow(10, decimals)).toString();
};
var convertToPercentDecimal = function convertToPercentDecimal(percent) {
  return divide(percent, 100);
};
var percentOf = function percentOf(percent, num) {
  return evaluate(convertToPercentDecimal(percent) + " * " + num);
};
var percentLess = function percentLess(percent, num) {
  return format(evaluate(num + " - " + percentOf(percent, num)), {
    notation: 'fixed'
  });
};
var getGas = function getGas(gas) {
  return gas ? new BN(gas) : new BN('100000000000000');
};
var getAmount = function getAmount(amount) {
  return amount ? new BN(utils.format.parseNearAmount(amount) || '0') : new BN('0');
};
var ONLY_ZEROS = /^0*\.?0*$/;
var toReadableNumber = function toReadableNumber(decimals, number) {
  if (number === void 0) {
    number = '0';
  }

  if (!decimals) return number;
  var wholeStr = number.substring(0, number.length - decimals) || '0';
  var fractionStr = number.substring(number.length - decimals).padStart(decimals, '0').substring(0, decimals);
  return (wholeStr + "." + fractionStr).replace(/\.?0+$/, '');
};
var toNonDivisibleNumber = function toNonDivisibleNumber(decimals, number) {
  if (decimals === null || decimals === undefined) return number;

  var _number$split = number.split('.'),
      wholePart = _number$split[0],
      _number$split$ = _number$split[1],
      fracPart = _number$split$ === void 0 ? '' : _number$split$;

  return ("" + wholePart + fracPart.padEnd(decimals, '0').slice(0, decimals)).replace(/^0+/, '').padStart(1, '0');
};
var scientificNotationToString = function scientificNotationToString(strParam) {
  var _strParam$match, _strParam$match2;

  var flag = /e/.test(strParam);
  if (!flag || !strParam) return strParam;
  var sysbol = true;

  if (/e-/.test(strParam)) {
    sysbol = false;
  }

  var negative = Number(strParam) < 0 ? '-' : '';
  var index = Number((_strParam$match = strParam.match(/\d+$/)) == null ? void 0 : _strParam$match[0]);
  var basis = (_strParam$match2 = strParam.match(/[\d\.]+/)) == null ? void 0 : _strParam$match2[0];
  if (!index || !basis) return strParam;
  var ifFraction = basis.includes('.');
  var wholeStr;
  var fractionStr;

  if (ifFraction) {
    wholeStr = basis.split('.')[0];
    fractionStr = basis.split('.')[1];
  } else {
    wholeStr = basis;
    fractionStr = '';
  }

  if (sysbol) {
    if (!ifFraction) {
      return negative + wholeStr.padEnd(index + wholeStr.length, '0');
    } else {
      if (fractionStr.length <= index) {
        return negative + wholeStr + fractionStr.padEnd(index, '0');
      } else {
        return negative + wholeStr + fractionStr.substring(0, index) + '.' + fractionStr.substring(index);
      }
    }
  } else {
    if (!ifFraction) return negative + wholeStr.padStart(index + wholeStr.length, '0').replace(/^0/, '0.');else {
      return negative + wholeStr.padStart(index + wholeStr.length, '0').replace(/^0/, '0.') + fractionStr;
    }
  }
};
var formatWithCommas = function formatWithCommas(value) {
  var pattern = /(-?\d+)(\d{3})/;

  while (pattern.test(value)) {
    value = value.replace(pattern, '$1,$2');
  }

  return value;
};
var toPrecision = function toPrecision(number, precision, withCommas, atLeastOne) {
  if (withCommas === void 0) {
    withCommas = false;
  }

  if (atLeastOne === void 0) {
    atLeastOne = true;
  }

  var _number$split2 = number.split('.'),
      whole = _number$split2[0],
      _number$split2$ = _number$split2[1],
      decimal = _number$split2$ === void 0 ? '' : _number$split2$;

  var str = ((withCommas ? formatWithCommas(whole) : whole) + "." + decimal.slice(0, precision)).replace(/\.$/, '');

  if (atLeastOne && Number(str) === 0 && str.length > 1) {
    var n = str.lastIndexOf('0');
    str = str.slice(0, n) + str.slice(n).replace('0', '1');
  }

  return str;
};

function _regeneratorRuntime() {
  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */

  _regeneratorRuntime = function () {
    return exports;
  };

  var exports = {},
      Op = Object.prototype,
      hasOwn = Op.hasOwnProperty,
      $Symbol = "function" == typeof Symbol ? Symbol : {},
      iteratorSymbol = $Symbol.iterator || "@@iterator",
      asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
      toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value: value,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), obj[key];
  }

  try {
    define({}, "");
  } catch (err) {
    define = function (obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
        generator = Object.create(protoGenerator.prototype),
        context = new Context(tryLocsList || []);
    return generator._invoke = function (innerFn, self, context) {
      var state = "suspendedStart";
      return function (method, arg) {
        if ("executing" === state) throw new Error("Generator is already running");

        if ("completed" === state) {
          if ("throw" === method) throw arg;
          return doneResult();
        }

        for (context.method = method, context.arg = arg;;) {
          var delegate = context.delegate;

          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);

            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }

          if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
            if ("suspendedStart" === state) throw state = "completed", context.arg;
            context.dispatchException(context.arg);
          } else "return" === context.method && context.abrupt("return", context.arg);
          state = "executing";
          var record = tryCatch(innerFn, self, context);

          if ("normal" === record.type) {
            if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
            return {
              value: record.arg,
              done: context.done
            };
          }

          "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
        }
      };
    }(innerFn, self, context), generator;
  }

  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }

  exports.wrap = wrap;
  var ContinueSentinel = {};

  function Generator() {}

  function GeneratorFunction() {}

  function GeneratorFunctionPrototype() {}

  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });
  var getProto = Object.getPrototypeOf,
      NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);

  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      define(prototype, method, function (arg) {
        return this._invoke(method, arg);
      });
    });
  }

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);

      if ("throw" !== record.type) {
        var result = record.arg,
            value = result.value;
        return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
          invoke("next", value, resolve, reject);
        }, function (err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function (unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function (error) {
          return invoke("throw", error, resolve, reject);
        });
      }

      reject(record.arg);
    }

    var previousPromise;

    this._invoke = function (method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    };
  }

  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];

    if (undefined === method) {
      if (context.delegate = null, "throw" === context.method) {
        if (delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel;
        context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }

  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }

  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
  }

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next) return iterable;

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;

          return next.value = undefined, next.done = !0, next;
        };

        return next.next = next;
      }
    }

    return {
      next: doneResult
    };
  }

  function doneResult() {
    return {
      value: undefined,
      done: !0
    };
  }

  return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function (genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function (arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
    return this;
  }), define(Gp, "toString", function () {
    return "[object Generator]";
  }), exports.keys = function (object) {
    var keys = [];

    for (var key in object) keys.push(key);

    return keys.reverse(), function next() {
      for (; keys.length;) {
        var key = keys.pop();
        if (key in object) return next.value = key, next.done = !1, next;
      }

      return next.done = !0, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function (skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
    },
    stop: function () {
      this.done = !0;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type) throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function (exception) {
      if (this.done) throw exception;
      var context = this;

      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i],
            record = entry.completion;
        if ("root" === entry.tryLoc) return handle("end");

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"),
              hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
          } else {
            if (!hasFinally) throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function (type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function (record, afterLoc) {
      if ("throw" === record.type) throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function (finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    catch: function (tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;

          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }

          return thrown;
        }
      }

      throw new Error("illegal catch attempt");
    },
    delegateYield: function (iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
    }
  }, exports;
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends.apply(this, arguments);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);

  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }

  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var instantSwap = /*#__PURE__*/function () {
  var _ref2 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref) {
    var _swapTodos$at;

    var tokenIn, tokenOut, amountIn, slippageTolerance, swapTodos, transactions, actionsList, allSwapsTokens, i, swapTokens;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            tokenIn = _ref.tokenIn, tokenOut = _ref.tokenOut, amountIn = _ref.amountIn, slippageTolerance = _ref.slippageTolerance, swapTodos = _ref.swapTodos;
            transactions = [];

            if (!(((_swapTodos$at = swapTodos.at(-1)) == null ? void 0 : _swapTodos$at.outputToken) !== tokenOut.id)) {
              _context.next = 4;
              break;
            }

            throw SwapRouteError;

          case 4:
            // const registerToken = async (token: TokenMetadata) => {
            //   const tokenRegistered = await ftGetStorageBalance(token.id).catch(() => {
            //     throw new Error(`${token.id} doesn't exist.`);
            //   });
            //   if (tokenRegistered === null) {
            //     transactions.push({
            //       receiverId: token.id,
            //       functionCalls: [
            //         {
            //           methodName: 'storage_deposit',
            //           args: {
            //             registration_only: true,
            //             account_id: wallet.getAccountId(),
            //           },
            //           gas: '30000000000000',
            //           amount: STORAGE_TO_REGISTER_WITH_MFT,
            //         },
            //       ],
            //     });
            //   }
            // };
            // await registerToken(tokenOut);
            actionsList = [];
            allSwapsTokens = swapTodos.map(function (s) {
              return [s.inputToken, s.outputToken];
            }); // to get the hop tokens

            for (i in allSwapsTokens) {
              swapTokens = allSwapsTokens[i];

              if (swapTokens[0] === tokenIn.id && swapTokens[1] === tokenOut.id) {
                // parallel, direct hop route.
                actionsList.push({
                  pool_id: swapTodos[i].pool.id,
                  token_in: tokenIn.id,
                  token_out: tokenOut.id,
                  amount_in: swapTodos[i].pool.partialAmountIn,
                  min_amount_out: round(tokenOut.decimals, toNonDivisibleNumber(tokenOut.decimals, percentLess(slippageTolerance, swapTodos[i].estimate)))
                });
              } else if (swapTokens[0] === tokenIn.id) {
                // first hop in double hop route
                //TODO -- put in a check to make sure this first hop matches with the next (i+1) hop as a second hop.
                actionsList.push({
                  pool_id: swapTodos[i].pool.id,
                  token_in: swapTokens[0],
                  token_out: swapTokens[1],
                  amount_in: swapTodos[i].pool.partialAmountIn,
                  min_amount_out: '0'
                });
              } else {
                // second hop in double hop route.
                //TODO -- put in a check to make sure this second hop matches with the previous (i-1) hop as a first hop.
                actionsList.push({
                  pool_id: swapTodos[i].pool.id,
                  token_in: swapTokens[0],
                  token_out: swapTokens[1],
                  min_amount_out: round(tokenOut.decimals, toNonDivisibleNumber(tokenOut.decimals, percentLess(slippageTolerance, swapTodos[i].estimate)))
                });
              }
            }

            transactions.push({
              receiverId: tokenIn.id,
              functionCalls: [{
                methodName: 'ft_transfer_call',
                args: {
                  receiver_id: REF_FI_CONTRACT_ID,
                  amount: toNonDivisibleNumber(tokenIn.decimals, amountIn),
                  msg: JSON.stringify({
                    force: 0,
                    actions: actionsList
                  })
                },
                gas: '180000000000000',
                amount: ONE_YOCTO_NEAR
              }]
            }); // if (tokenIn.id === config.WRAP_NEAR_CONTRACT_ID) {
            //   const registered = await ftGetStorageBalance(config.WRAP_NEAR_CONTRACT_ID);
            //   if (registered === null) {
            //     await registerToken(tokenIn);
            //   }
            // }

            return _context.abrupt("return", transactions);

          case 9:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function instantSwap(_x) {
    return _ref2.apply(this, arguments);
  };
}();

var keyStore = /*#__PURE__*/new keyStores.BrowserLocalStorageKeyStore();
var near = /*#__PURE__*/new Near( /*#__PURE__*/_extends({
  keyStore: keyStore,
  headers: {}
}, config));
var wallet = /*#__PURE__*/new WalletConnection(near, REF_FI_CONTRACT_ID);
var refFiViewFunction = function refFiViewFunction(_ref) {
  var methodName = _ref.methodName,
      args = _ref.args;
  return wallet.account().viewFunction(REF_FI_CONTRACT_ID, methodName, args);
};
var ftViewFunction = function ftViewFunction(tokenId, _ref2) {
  var methodName = _ref2.methodName,
      args = _ref2.args;
  return wallet.account().viewFunction(tokenId, methodName, args);
};
var ftGetStorageBalance = function ftGetStorageBalance(tokenId, accountId) {
  if (accountId === void 0) {
    accountId = wallet.getAccountId();
  }

  return ftViewFunction(tokenId, {
    methodName: 'storage_balance_of',
    args: {
      account_id: accountId
    }
  });
};
var getTotalPools = /*#__PURE__*/function () {
  var _ref3 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            return _context.abrupt("return", refFiViewFunction({
              methodName: 'get_number_of_pools'
            }));

          case 1:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function getTotalPools() {
    return _ref3.apply(this, arguments);
  };
}();
var ftGetTokenMetadata = /*#__PURE__*/function () {
  var _ref4 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(id) {
    var metadata;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return ftViewFunction(id, {
              methodName: 'ft_metadata'
            })["catch"](function () {
              throw TokenNotExistError;
            });

          case 2:
            metadata = _context2.sent;
            return _context2.abrupt("return", _extends({}, metadata, {
              id: id
            }));

          case 4:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function ftGetTokenMetadata(_x) {
    return _ref4.apply(this, arguments);
  };
}();
var ftGetTokensMetadata = /*#__PURE__*/function () {
  var _ref5 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(tokenIds) {
    var tokensMetadata;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return Promise.all(tokenIds.map(function (id) {
              return ftGetTokenMetadata(id);
            }));

          case 2:
            tokensMetadata = _context3.sent;
            return _context3.abrupt("return", tokensMetadata.reduce(function (pre, cur, i) {
              var _extends2;

              return _extends({}, pre, (_extends2 = {}, _extends2[tokenIds[i]] = cur, _extends2));
            }, {}));

          case 4:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));

  return function ftGetTokensMetadata(_x2) {
    return _ref5.apply(this, arguments);
  };
}(); // export const executeMultipleTransactions = async (
//   transactions: Transaction[],
//   callbackUrl?: string
// ) => {
//   const currentTransactions = await Promise.all(
//     transactions.map((t, i) => {
//       return wallet.createTransaction({
//         receiverId: t.receiverId,
//         nonceOffset: i + 1,
//         actions: t.functionCalls.map(fc =>
//           functionCall(
//             fc.methodName,
//             fc.args as object,
//             getGas(fc.gas || ''),
//             getAmount(fc.amount || '')
//           )
//         ),
//       });
//     })
//   );
//   return wallet.requestSignTransactions(currentTransactions, callbackUrl);
// };

var DEFAULT_PAGE_LIMIT = 100;
var getRatedPoolDetail = /*#__PURE__*/function () {
  var _ref2 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref) {
    var id;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            id = _ref.id;
            return _context.abrupt("return", refFiViewFunction({
              methodName: 'get_rated_pool',
              args: {
                pool_id: Number(id)
              }
            }).then(function (pool_info) {
              return _extends({}, pool_info, {
                id: Number(id),
                pool_kind: 'RATED_SWAP'
              });
            })["catch"](function () {
              throw unNamedError;
            }));

          case 2:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function getRatedPoolDetail(_x) {
    return _ref2.apply(this, arguments);
  };
}();
var getUnRatedPoolDetail = /*#__PURE__*/function () {
  var _ref4 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_ref3) {
    var id;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            id = _ref3.id;
            return _context2.abrupt("return", refFiViewFunction({
              methodName: 'get_stable_pool',
              args: {
                pool_id: Number(id)
              }
            }).then(function (pool_info) {
              return _extends({}, pool_info, {
                id: Number(id),
                pool_kind: 'STABLE_SWAP',
                rates: pool_info.c_amounts.map(function (_) {
                  return toNonDivisibleNumber(STABLE_LP_TOKEN_DECIMALS, '1');
                })
              });
            })["catch"](function () {
              throw unNamedError;
            }));

          case 2:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function getUnRatedPoolDetail(_x2) {
    return _ref4.apply(this, arguments);
  };
}();
var getStablePoolsDetail = /*#__PURE__*/function () {
  var _ref5 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(stablePools) {
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            return _context3.abrupt("return", Promise.all(stablePools.map(function (pool) {
              return pool.pool_kind === 'RATED_SWAP' ? getRatedPoolDetail({
                id: pool.id
              }) : getUnRatedPoolDetail({
                id: pool.id
              });
            })));

          case 1:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));

  return function getStablePoolsDetail(_x3) {
    return _ref5.apply(this, arguments);
  };
}();
var getRefPools = /*#__PURE__*/function () {
  var _ref6 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(page, perPage) {
    var index, poolData;
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            if (page === void 0) {
              page = 1;
            }

            if (perPage === void 0) {
              perPage = DEFAULT_PAGE_LIMIT;
            }

            index = (page - 1) * perPage;
            _context4.next = 5;
            return refFiViewFunction({
              methodName: 'get_pools',
              args: {
                from_index: index,
                limit: perPage
              }
            });

          case 5:
            poolData = _context4.sent;
            return _context4.abrupt("return", poolData.map(function (rawPool, i) {
              return parsePool(rawPool, i + index);
            }));

          case 7:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));

  return function getRefPools(_x4, _x5) {
    return _ref6.apply(this, arguments);
  };
}(); // TODO: differentiate by network, include simple pools and stable pools

var fetchAllRefPools = /*#__PURE__*/function () {
  var _ref7 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
    var totalPools, pages, pools;
    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            _context5.next = 2;
            return getTotalPools();

          case 2:
            totalPools = _context5.sent;
            pages = Math.ceil(totalPools / DEFAULT_PAGE_LIMIT);
            _context5.next = 6;
            return Promise.all([].concat(Array(pages)).map(function (_, i) {
              return getRefPools(i + 1);
            }));

          case 6:
            pools = _context5.sent.flat();
            return _context5.abrupt("return", {
              simplePools: pools.filter(function (p) {
                return p.pool_kind && p.pool_kind === 'SIMPLE_POOL';
              }),
              unRatedPools: pools.filter(function (p) {
                return p.pool_kind && p.pool_kind === 'STABLE_SWAP';
              }),
              ratedPools: pools.filter(function (p) {
                return p.pool_kind && p.pool_kind === 'RATED_SWAP';
              })
            });

          case 8:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5);
  }));

  return function fetchAllRefPools() {
    return _ref7.apply(this, arguments);
  };
}();

var tradeFee = function tradeFee(amount, trade_fee) {
  return amount * trade_fee / FEE_DIVISOR;
};

var calc_d = function calc_d(amp, c_amounts) {
  var token_num = c_amounts.length;

  var sum_amounts = _.sum(c_amounts);

  var d_prev = 0;
  var d = sum_amounts;

  for (var i = 0; i < 256; i++) {
    var d_prod = d;

    for (var _iterator = _createForOfIteratorHelperLoose(c_amounts), _step; !(_step = _iterator()).done;) {
      var c_amount = _step.value;
      d_prod = d_prod * d / (c_amount * token_num);
    }

    d_prev = d;
    var ann = amp * Math.pow(token_num, token_num);
    var numerator = d_prev * (d_prod * token_num + ann * sum_amounts);
    var denominator = d_prev * (ann - 1) + d_prod * (token_num + 1);
    d = numerator / denominator;
    if (Math.abs(d - d_prev) <= 1) break;
  }

  return d;
};
var calc_y = function calc_y(amp, x_c_amount, current_c_amounts, index_x, index_y) {
  var token_num = current_c_amounts.length;
  var ann = amp * Math.pow(token_num, token_num);
  var d = calc_d(amp, current_c_amounts);
  var s = x_c_amount;
  var c = d * d / x_c_amount;

  for (var i = 0; i < token_num; i++) {
    if (i != index_x && i != index_y) {
      s += current_c_amounts[i];
      c = c * d / current_c_amounts[i];
    }
  }

  c = c * d / (ann * Math.pow(token_num, token_num));
  var b = d / ann + s;
  var y_prev = 0;
  var y = d;

  for (var _i = 0; _i < 256; _i++) {
    y_prev = y;
    var y_numerator = Math.pow(y, 2) + c;
    var y_denominator = 2 * y + b - d;
    y = y_numerator / y_denominator;
    if (Math.abs(y - y_prev) <= 1) break;
  }

  return y;
};
var calc_swap = function calc_swap(amp, in_token_idx, in_c_amount, out_token_idx, old_c_amounts, trade_fee) {
  var y = calc_y(amp, in_c_amount + old_c_amounts[in_token_idx], old_c_amounts, in_token_idx, out_token_idx);
  var dy = old_c_amounts[out_token_idx] - y;
  var fee = tradeFee(dy, trade_fee);
  var amount_swapped = dy - fee;
  return [amount_swapped, fee, dy];
};
var getSwappedAmount = function getSwappedAmount(tokenInId, tokenOutId, amountIn, stablePool, STABLE_LP_TOKEN_DECIMALS) {
  var amp = stablePool.amp;
  var trade_fee = stablePool.total_fee; // depended on pools

  var in_token_idx = stablePool.token_account_ids.findIndex(function (id) {
    return id === tokenInId;
  });
  var out_token_idx = stablePool.token_account_ids.findIndex(function (id) {
    return id === tokenOutId;
  });
  var rates = stablePool.rates.map(function (r) {
    return toReadableNumber(STABLE_LP_TOKEN_DECIMALS, r);
  });
  var base_old_c_amounts = stablePool.c_amounts.map(function (amount) {
    return toReadableNumber(STABLE_LP_TOKEN_DECIMALS, amount);
  });
  var old_c_amounts = base_old_c_amounts.map(function (amount, i) {
    return toNonDivisibleNumber(STABLE_LP_TOKEN_DECIMALS, scientificNotationToString(new Big(amount || 0).times(new Big(rates[i])).toString()));
  }).map(function (amount) {
    return Number(amount);
  });
  var in_c_amount = Number(toNonDivisibleNumber(STABLE_LP_TOKEN_DECIMALS, scientificNotationToString(new Big(amountIn).times(new Big(rates[in_token_idx])).toString())));

  var _calc_swap = calc_swap(amp, in_token_idx, in_c_amount, out_token_idx, old_c_amounts, trade_fee),
      amount_swapped = _calc_swap[0],
      fee = _calc_swap[1],
      dy = _calc_swap[2];

  return [amount_swapped / Number(rates[out_token_idx]), fee, dy / Number(rates[out_token_idx])];
};

//@ts-nocheck
Big.RM = 0;
Big.DP = 40;
Big.NE = -40;
Big.PE = 40; ///////////////////////////////
function checkIntegerSumOfAllocations(allocations, totalInput) {
  var totalInput = new Big(totalInput);
  var allocations = allocations.map(function (item) {
    return new Big(item).round();
  });
  var alloSum = allocations.map(function (item) {
    return new Big(item);
  }).reduce(function (a, b) {
    return a.plus(b);
  }, new Big(0));
  var offset = totalInput.minus(alloSum); //get largest allocation.

  var currMax = new Big(0);
  var currMaxInd = 0;

  for (var i = 0; i < allocations.length; i++) {
    if (allocations[i].gt(currMax)) {
      currMaxInd = i;
      currMax = allocations[i];
    }
  }

  var newAllocations = [];

  for (var j = 0; j < allocations.length; j++) {
    if (j === currMaxInd) {
      newAllocations.push(allocations[j].plus(offset).toString());
    } else {
      newAllocations.push(allocations[j].toString());
    }
  }

  return newAllocations;
}

var _marked5 = /*#__PURE__*/_regeneratorRuntime().mark(yenFromPy);
Big.RM = 0;
Big.DP = 40;
Big.NE = -40;
Big.PE = 40;

function bisqrt(value) {
  // For some ridiculous reason, the .sqrt() method for Big decimals is extremely slow (~10-20ms),
  // which isn't so bad until you need to use it a bunch of times.
  // Since we're dealing with super large numbers anyway, we can convert the Big decimal number into a BigInt,
  // then run this BigInt Newton iteration square root function instead, and then convert back into a
  // Big number. And it speeds up the operation by a crazy factor, ~10x faster.
  if (value < BigInt(0)) {
    throw 'square root of negative numbers is not supported';
  }

  if (value < BigInt(2)) {
    return value;
  }

  function newtonIteration(n, x0) {
    var x1 = n / x0 + x0 >> BigInt(1);

    if (x0 === x1 || x0 === x1 - BigInt(1)) {
      return x0;
    }

    return newtonIteration(n, x1);
  }

  return newtonIteration(value, BigInt(1));
}

function getBetaForRoute(route, path) {
  if (!route.length) {
    route = [route];
  }

  if (route.length == 1) {
    var p = route[0];
    var beta = new Big(p.reserves[path[0]]);
  } else if (route.length == 2) {
    var p1 = route[0];
    var p2 = route[1];
    var beta = new Big(p1.reserves[path[0]]).times(new Big(p2.reserves[path[1]]));
  }

  return beta;
}

function getEpsilonForRoute(route, path) {
  if (!route.length) {
    route = [route];
  }

  if (route.length == 1) {
    // Single Hop case
    var p = route[0];
    var gamma = new Big(10000).minus(new Big(p.fee)).div(new Big(10000));
    var epsilon = Big(gamma);
  } else if (route.length == 2) {
    //Double Hop Case
    var p1 = route[0];
    var p2 = route[1];
    var gamma1 = new Big(10000).minus(new Big(p1.fee)).div(new Big(10000));
    var gamma2 = new Big(10000).minus(new Big(p2.fee)).div(Big(10000));
    var epsilon = new Big(p2.reserves[path[1]]).times(new Big(gamma1)).plus(new Big(p1.reserves[path[1]]).times(gamma1).times(gamma2));
  }

  return epsilon;
}

function getAlphaForRoute(route, path) {
  if (!route.length) {
    route = [route];
  }

  if (route.length == 1) {
    var _p$reserves;

    //console.log('single hop')
    var p = route[0];
    var inputToken = path[0];
    var outputToken = path[1];
    var gamma = new Big(10000).minus(new Big(p.fee)).div(new Big(10000));
    var key1 = p.token1Id;
    var key2 = p.token2Id;
    var val1 = p.token1Supply;
    var val2 = p.token2Supply;
    p['reserves'] = (_p$reserves = {}, _p$reserves[key1] = val1, _p$reserves[key2] = val2, _p$reserves);
    var alpha = new Big(p.reserves[inputToken]).times(new Big(p.reserves[outputToken]).times(new Big(gamma)));
  } else if (route.length == 2) {
    var _p1$reserves, _p2$reserves;

    //console.log('double hop')
    var p1 = route[0];
    var p2 = route[1];
    var key11 = p1.token1Id;
    var key12 = p1.token2Id;
    var val11 = p1.token1Supply;
    var val12 = p1.token2Supply;
    p1['reserves'] = (_p1$reserves = {}, _p1$reserves[key11] = val11, _p1$reserves[key12] = val12, _p1$reserves);
    var key21 = p2.token1Id;
    var key22 = p2.token2Id;
    var val21 = p2.token1Supply;
    var val22 = p2.token2Supply;
    p2['reserves'] = (_p2$reserves = {}, _p2$reserves[key21] = val21, _p2$reserves[key22] = val22, _p2$reserves);
    var _inputToken = path[0];
    var middleToken = path[1];
    var _outputToken = path[2];
    var gamma1 = new Big(10000).minus(Big(p1.fee)).div(new Big(10000));
    var gamma2 = new Big(10000).minus(new Big(p2.fee)).div(new Big(10000));
    var alpha1 = new Big(p1.reserves[_inputToken]).times(new Big(p1.reserves[middleToken])).times(gamma1);
    var alpha2 = new Big(p2.reserves[middleToken]).times(new Big(p2.reserves[_outputToken])).times(gamma2);
    var alpha = alpha1.times(alpha2);
  }

  return alpha;
}

function getAlphaSumFromRoutes(routes, nodeRoutes) {
  var alphaSum = new Big(0);

  for (var i in routes) {
    var route = routes[i];
    var nodeRoute = nodeRoutes[i];
    var alpha = getAlphaForRoute(route, nodeRoute); // console.log('alpha is...');
    // console.log(alpha.toString());
    // below, we are replacing the built-in Big sqrt() method with a
    // newton-iteration BigInt sqrt function, to speed it up by 10x.

    var radical = new Big(bisqrt(BigInt(new Big(alpha).round().toFixed()))); // let radical = new Big(alpha).sqrt();

    var epsilon = getEpsilonForRoute(route, nodeRoute);
    var denom = new Big(epsilon);
    alphaSum = alphaSum.plus(radical.div(denom));
  }

  return alphaSum;
}

function getBetaSumFromRoutes(routes, nodeRoutes) {
  var betaSum = new Big(0);

  for (var i in routes) {
    var route = routes[i];
    var nodeRoute = nodeRoutes[i];
    var num = new Big(getBetaForRoute(route, nodeRoute));
    var denom = new Big(getEpsilonForRoute(route, nodeRoute));
    betaSum = betaSum.plus(num.div(denom));
  }

  return betaSum;
}

function getPhiFromRoutes(routes, nodeRoutes, totalInput) {
  var alphaSum = getAlphaSumFromRoutes(routes, nodeRoutes);
  var betaSum = getBetaSumFromRoutes(routes, nodeRoutes);
  var phi = new Big(totalInput).plus(betaSum).div(alphaSum);
  return phi;
}

function getAllocationForRoute(phi, route, path) {
  var alpha = getAlphaForRoute(route, path);
  var beta = getBetaForRoute(route, path);
  var epsilon = getEpsilonForRoute(route, path); // below, we are replacing the built-in Big sqrt() method with a
  // newton-iteration BigInt sqrt function, to speed it up by 10x.

  var allocation = new Big(phi).abs().times(new Big(bisqrt(BigInt(new Big(alpha).round().toFixed())))).minus(beta).div(epsilon);
  return allocation;
}

function getAllocationVectorForRoutes(phi, routes, nodeRoutes) {
  var allocationVec = [];

  for (var i in routes) {
    allocationVec.push(getAllocationForRoute(phi, routes[i], nodeRoutes[i]));
  }

  return allocationVec;
}

function getOptimalAllocationForRoutes(routes, nodeRoutes, totalInput) {
  // console.log("CALLING GET OPTIMAL ALLOCATION FOR ROUTES:")
  // console.log(routes)
  var totalInput = new Big(totalInput);
  var phi = getPhiFromRoutes(routes, nodeRoutes, totalInput); // console.log('PHI CALCULATED TO BE...')
  // console.log(phi.toString())

  var allocations = getAllocationVectorForRoutes(phi, routes, nodeRoutes);

  if (allocations.every(function (item) {
    return item.lt(new Big(0));
  })) {
    allocations = allocations.map(function (item) {
      return item.times(new Big(-1.0));
    });
  }

  if (allocations.some(function (item) {
    return item.lt(new Big(0));
  })) {
    allocations = reduceRoutes(routes, nodeRoutes, allocations, totalInput);
  }

  var sumAllocations = allocations.reduce(function (a, b) {
    return a.plus(b);
  }, new Big(0));
  var normalizedAllocations = allocations.map(function (a) {
    return a.div(sumAllocations).times(new Big(totalInput));
  });
  return normalizedAllocations;
}

function reduceRoutes(routes, nodeRoutes, allocationVec, totalInput) {
  // console.log("RUNNING REDUCE ROUTES")
  var totalInput = new Big(totalInput);
  var goodIndices = [];

  for (var i in allocationVec) {
    var dx = allocationVec[i]; // console.log('DX IS...')
    // console.log(dx.toString())

    if (dx.gt(new Big(0))) {
      goodIndices.push(i);
    }
  } // console.log('GOOD INDICES ARE...');
  // console.log(goodIndices);


  var newRoutes = [];
  var newNodeRoutes = [];

  for (var i in goodIndices) {
    var goodIndex = goodIndices[i];
    newRoutes.push(routes[goodIndex]);
    newNodeRoutes.push(nodeRoutes[goodIndex]);
  }

  allocationVec = getOptimalAllocationForRoutes(newRoutes, newNodeRoutes, totalInput);
  var allocationDict = {};

  for (var i in goodIndices) {
    allocationDict[goodIndices[i]] = allocationVec[i];
  }

  var allocationVecNew = [];

  for (var i in routes) {
    if (goodIndices.includes(i)) {
      allocationVecNew.push(allocationDict[i]);
    } else {
      var zeroAllocation = new Big(0);
      allocationVecNew.push(zeroAllocation);
    }
  }

  return allocationVecNew;
}

function getNodeRoutesFromPathsAndPoolChains(paths, poolChains) {
  var multiplicity = [];

  for (var i in poolChains) {
    var pc = poolChains[i];
    var mul = pc.map(function (item) {
      return item.length;
    }).reduce(function (elem1, elem2) {
      return elem1 * elem2;
    }, 1);
    multiplicity.push(mul);
  }

  var nodeRoutes = [];

  for (var j in paths) {
    var path = paths[j];
    var m = multiplicity[j];

    for (var k = 0; k < m; k++) {
      nodeRoutes.push(path);
    }
  }

  return nodeRoutes;
}

function getPoolChainFromPaths(paths, pools, threshold) {
  if (threshold === void 0) {
    threshold = 0.001;
  }

  var poolChains = [];

  for (var pathInd in paths) {
    var path = paths[pathInd];
    var chain = [];
    var pairs = [];

    for (var i = 0; i < path.length - 1; i++) {
      pairs.push([path[i], path[i + 1]]);
    }

    for (var pairInd in pairs) {
      var pair = pairs[pairInd]; // console.log(pair);

      var tokenPools = getPoolsByToken1ANDToken2(pools, pair[0], pair[1]);
      chain.push(tokenPools);
    }

    poolChains.push(chain);
  } // return poolChains;


  var culledPoolChains = getCulledPoolChains(poolChains, threshold);
  return culledPoolChains;
}

function getCulledPoolChains(poolChains, threshold) {
  if (threshold === void 0) {
    threshold = 0.001;
  }

  var newChains = [];

  for (var pathInd in poolChains) {
    var path = poolChains[pathInd];
    var newPath = [];

    for (var legInd in path) {
      var leg = path[legInd];
      var culledPath = cullPoolsWithInsufficientLiquidity(leg, threshold);
      newPath.push(culledPath);
    }

    newChains.push(newPath);
  }

  return newChains;
}

function getRoutesFromPoolChain(poolChains) {
  var routes = [];

  for (var pci in poolChains) {
    var poolChain = poolChains[pci]; //get cartesian product of each pool chain to get the list of routes.

    var newRoutes = cartesianProduct(poolChain);
    routes.push.apply(routes, newRoutes);
  }

  for (var i in routes) {
    if (!routes[i].length) {
      routes[i] = [routes[i]];
    }
  }

  return routes;
}

function getOutputSingleHop(pool, inputToken, outputToken, totalInput) {
  var totalInput = new Big(totalInput); // check if pool is forward or backward for inputToken/outputToken cf. token1Id/token2Id

  if (inputToken === pool.token1Id && outputToken === pool.token2Id) {
    var _reserves;

    // forward Pool
    var reserves = (_reserves = {}, _reserves[inputToken] = new Big(pool.token1Supply), _reserves[outputToken] = new Big(pool.token2Supply), _reserves);
  } else if (inputToken === pool.token2Id && outputToken === pool.token1Id) {
    var _reserves2;

    // reverse pool
    var reserves = (_reserves2 = {}, _reserves2[outputToken] = new Big(pool.token1Supply), _reserves2[inputToken] = new Big(pool.token2Supply), _reserves2);
  } else {
    return new Big(0);
  }

  var gamma = new Big(10000).minus(new Big(pool.fee)).div(new Big(10000)); // console.log(totalInput)
  // console.log(gamma)
  // console.log(reserves)

  var num = totalInput.times(gamma).times(reserves[outputToken]);
  var denom = reserves[inputToken].plus(gamma.times(totalInput));
  return num.div(denom);
}

function getOutputDoubleHop(pools, inputToken, middleToken, outputToken, totalInput) {
  var totalInput = new Big(totalInput);

  for (var poolIndex in pools) {
    var p = pools[poolIndex];
    p['gamma'] = new Big(10000).minus(new Big(p.fee)).div(new Big(10000));
  }

  var p1 = pools[0];
  var p2 = pools[1];

  if (inputToken === p1.token1Id && middleToken === p1.token2Id) {
    var _p1$reserves2;

    // forward Pool
    p1['reserves'] = (_p1$reserves2 = {}, _p1$reserves2[inputToken] = new Big(p1.token1Supply), _p1$reserves2[middleToken] = new Big(p1.token2Supply), _p1$reserves2);
  } else if (middleToken === p1.token1Id && inputToken === p1.token2Id) {
    var _p1$reserves3;

    //reverse pool
    p1['reserves'] = (_p1$reserves3 = {}, _p1$reserves3[middleToken] = new Big(p1.token1Supply), _p1$reserves3[inputToken] = new Big(p1.token2Supply), _p1$reserves3);
  }

  if (middleToken === p2.token1Id && outputToken === p2.token2Id) {
    var _p2$reserves2;

    // forward Pool
    p2['reserves'] = (_p2$reserves2 = {}, _p2$reserves2[middleToken] = new Big(p2.token1Supply), _p2$reserves2[outputToken] = new Big(p2.token2Supply), _p2$reserves2);
  } else if (outputToken === p2.token1Id && middleToken === p2.token2Id) {
    var _p2$reserves3;

    //reverse pool
    p2['reserves'] = (_p2$reserves3 = {}, _p2$reserves3[outputToken] = new Big(p2.token1Supply), _p2$reserves3[middleToken] = new Big(p2.token2Supply), _p2$reserves3);
  }

  var c1 = new Big(p1.reserves[middleToken]);
  var a1 = new Big(p1.reserves[inputToken]);
  var c2 = new Big(p2.reserves[middleToken]);
  var b2 = new Big(p2.reserves[outputToken]);
  var gamma1 = p1.gamma;
  var gamma2 = p2.gamma;
  var num = totalInput.times(c1).times(b2).times(gamma1).times(gamma2);
  var denom = c2.times(a1).plus(totalInput.times(c2.times(gamma1).plus(c1.times(gamma1).times(gamma2)))); // denom = c2*a1 + totalInput * (c2*gamma1 + c1*gamma1*gamma2)

  return num.div(denom);
}

function getOutputFromRoute(route, nodeRoute, allocation) {
  if (new Big(allocation).eq(new Big(0))) {
    return new Big(0);
  } else {
    var allocation = new Big(allocation);
  }

  if (!route.length) {
    route = [route];
  }

  if (route.length == 1) {
    // single hop
    var inputToken = nodeRoute[0];
    var outputToken = nodeRoute[1];
    var pool = route[0];
    var output = getOutputSingleHop(pool, inputToken, outputToken, allocation);
  } else if (route.length == 2) {
    // DOUBLE HOP
    var _inputToken2 = nodeRoute[0];
    var middleToken = nodeRoute[1];
    var _outputToken2 = nodeRoute[2];
    var pools = route;
    var output = getOutputDoubleHop(pools, _inputToken2, middleToken, _outputToken2, allocation);
  }

  return output;
}

function getOptOutputVec(routes, nodeRoutes, totalInput) {
  var allocations = getOptimalAllocationForRoutes(routes, nodeRoutes, totalInput);
  var result = [];

  for (var i in routes) {
    var route = routes[i];
    var nodeRoute = nodeRoutes[i];
    var allocation = allocations[i];
    var output = getOutputFromRoute(route, nodeRoute, allocation);
    result.push(output);
  }

  return {
    result: result,
    allocations: allocations
  }; //NOTE -- I made this return an object instead of the tuple returned in python. need to check the places it is called, and specify
  // result field instead of tuple 0 position, and allocations field instead of tuple 1 position.
}

function getBestOptInputAndOutput(routes, nodeRoutes, totalInput) {
  // let refDict = getOptOutputVecRefined(routes, nodeRoutes, totalInput);
  // let outputRefined = refDict.result;
  // let inputRefined = refDict.allocations;
  // inputRefined = checkIntegerSumOfAllocations(inputRefined, totalInput);
  var rawDict = getOptOutputVec(routes, nodeRoutes, totalInput);
  var outputRaw = rawDict.result;
  var inputRaw = rawDict.allocations;
  inputRaw = checkIntegerSumOfAllocations(inputRaw, totalInput);
  var res1 = new Big(0);
  var res2 = new Big(0);
  var res = outputRaw.map(function (v) {
    return new Big(v);
  }).reduce(function (bv1, bv2) {
    return bv1.plus(bv2);
  }, new Big(0));
  return {
    input: inputRaw,
    output: res
  };
}

function getBestOptimalAllocationsAndOutputs(_x, _x2, _x3, _x4, _x5, _x6) {
  return _getBestOptimalAllocationsAndOutputs.apply(this, arguments);
}

function _getBestOptimalAllocationsAndOutputs() {
  _getBestOptimalAllocationsAndOutputs = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(pools, inputToken, outputToken, totalInput, maxPathLength, threshold) {
    return _regeneratorRuntime().wrap(function _callee2$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            if (maxPathLength === void 0) {
              maxPathLength = 3;
            }

            if (threshold === void 0) {
              threshold = 0.001;
            }

            return _context7.abrupt("return", function () {
              var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(totalInput) {
                var paths, poolChains, routes, nodeRoutes, inputOutput, allocations, outputs;
                return _regeneratorRuntime().wrap(function _callee$(_context6) {
                  while (1) {
                    switch (_context6.prev = _context6.next) {
                      case 0:
                        totalInput = new Big(totalInput);
                        _context6.next = 3;
                        return getPathsFromPools(pools, inputToken, outputToken, maxPathLength);

                      case 3:
                        paths = _context6.sent;

                        if (paths.length) {
                          _context6.next = 6;
                          break;
                        }

                        return _context6.abrupt("return", {
                          allocations: [],
                          outputs: new Big(0),
                          routes: [],
                          nodeRoutes: []
                        });

                      case 6:
                        _context6.next = 8;
                        return getPoolChainFromPaths(paths, pools, threshold);

                      case 8:
                        poolChains = _context6.sent;
                        _context6.next = 11;
                        return getRoutesFromPoolChain(poolChains);

                      case 11:
                        routes = _context6.sent;
                        _context6.next = 14;
                        return getNodeRoutesFromPathsAndPoolChains(paths, poolChains);

                      case 14:
                        nodeRoutes = _context6.sent;
                        _context6.next = 17;
                        return getBestOptInputAndOutput(routes, nodeRoutes, totalInput);

                      case 17:
                        inputOutput = _context6.sent;
                        allocations = inputOutput.input;
                        outputs = inputOutput.output;
                        return _context6.abrupt("return", {
                          allocations: allocations,
                          outputs: outputs,
                          routes: routes,
                          nodeRoutes: nodeRoutes
                        });

                      case 21:
                      case "end":
                        return _context6.stop();
                    }
                  }
                }, _callee);
              }));

              return function (_x31) {
                return _ref.apply(this, arguments);
              };
            }()(totalInput));

          case 3:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee2);
  }));
  return _getBestOptimalAllocationsAndOutputs.apply(this, arguments);
}

function getHopActionsFromRoutes(routes, nodeRoutes, allocations) {
  // console.log('INSIDE GET HOP ACTIONS FROM ROUTES');
  // console.log('ROUTES ARE...');
  // console.log(routes);
  // console.log('NODE ROUTES ARE...');
  // console.log(nodeRoutes);
  // console.log('ALLOCATIONS ARE...');
  // console.log(allocations);
  var totalInput = allocations.map(function (a) {
    return new Big(a);
  }).reduce(function (a, b) {
    return a.plus(b);
  }, new Big(0)).toString();
  var hops = [];

  for (var i in routes) {
    var route = routes[i];
    var nodeRoute = nodeRoutes[i];
    var allocation = allocations[i];

    if (new Big(allocation).eq(new Big(0))) {
      continue;
    }

    if (!route.length) {
      route = [route];
    }

    if (!route[0]) {
      continue;
    }

    for (var j in route) {
      var pool = route[j]; // console.log('J IS...');
      // console.log(j);
      // console.log('NODE ROUTE IS...');
      // console.log(nodeRoute);

      if (j == 0) {
        //first hop.
        // console.log(nodeRoute[0]);
        // console.log(nodeRoute[1]);
        var hop = {
          pool: pool,
          allocation: allocation.toString(),
          inputToken: nodeRoute[0],
          outputToken: nodeRoute[1],
          nodeRoute: nodeRoute,
          route: route,
          allRoutes: routes,
          allNodeRoutes: nodeRoutes,
          totalInputAmount: totalInput,
          allAllocations: allocations
        }; // console.log('FIRST HOP IS...');
        // console.log(hop);

        hops.push(hop);

        if (nodeRoute.length > 2) {
          var middleTokenAllocation = getOutputSingleHop(pool, nodeRoute[0], nodeRoute[1], allocation);
        }
      } else {
        // second hop
        var hop = {
          pool: pool,
          allocation: middleTokenAllocation.toString(),
          inputToken: nodeRoute[1],
          outputToken: nodeRoute[2],
          nodeRoute: nodeRoute,
          route: route,
          allRoutes: routes,
          allNodeRoutes: nodeRoutes,
          totalInputAmount: totalInput,
          allAllocations: allocations
        }; // console.log('SECOND HOP IS...');
        // console.log(hop);

        hops.push(hop);
      }
    }
  } // console.log('HOP ACTIONS FOUND TO BE');
  // console.log(hops);


  return hops;
} // TODO: Clean this function. I don't need all the "actions" just the hops.
// TODO: re-order actions to ensure each route is complete with zero input for second hop before starting next route.


function getActionListFromRoutesAndAllocations(routes, nodeRoutes, allocations) {
  // REPLACE THE CODE BELOW WITH THE FUNCTION HERE.
  return getHopActionsFromRoutes(routes, nodeRoutes, allocations);
}
//     #TODO: complete this function with middle token checks.
//     #consider all routes of length 2 with non-zero allocation. (double-hops)
//     # among these, check for parallel swaps. That is, check for common node routes
//     # for first hop. Then check for common node routes on second hop.
//     # when common node routes occur for the first hop:
//     # 1. Calculate the total expected output of intermediate token.
//     # 2.
//     # when common node routes occur for the second hop:
//     # 1. get a ratio of the input allocations of the full routes associated with
//     # these common node routes. allocate the total intermediate token output
//     # toward these 2nd hop routes in the same ratio as their route input allocations.


function getSmartRouteSwapActions(_x7, _x8, _x9, _x10, _x11, _x12, _x13, _x14, _x15) {
  return _getSmartRouteSwapActions.apply(this, arguments);
}

function _getSmartRouteSwapActions() {
  _getSmartRouteSwapActions = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(pools, inputToken, outputToken, totalInput, maxPathLength, threshold, numberOfRoutesLimit, MAX_NUMBER_PARALLEL_POOLS, decimalsCulledPoolIds) {
    return _regeneratorRuntime().wrap(function _callee5$(_context10) {
      while (1) {
        switch (_context10.prev = _context10.next) {
          case 0:
            if (maxPathLength === void 0) {
              maxPathLength = 3;
            }

            if (threshold === void 0) {
              threshold = 0.001;
            }

            if (numberOfRoutesLimit === void 0) {
              numberOfRoutesLimit = 2;
            }

            if (MAX_NUMBER_PARALLEL_POOLS === void 0) {
              MAX_NUMBER_PARALLEL_POOLS = 4;
            }

            if (decimalsCulledPoolIds === void 0) {
              decimalsCulledPoolIds = [];
            }

            return _context10.abrupt("return", function () {
              var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(totalInput) {
                var resDict, allocations, routes, nodeRoutes, sortedIndexValues, topIndices, reducedRoutes, reducedNodeRoutes, _iterator3, _step3, ind, currentBestOutput, bestAllocations, bestNodeRoutes, bestRoutes, parallelNodeRoutes, parallelRoutes, n, currentNodeRoute, bestRoutesAreParallel, _filteredAllocationsAndOutputs, parallellAllocations, parallelOutputs, sortIndices, filteredParallelRoutes, filteredParallelNodeRoutes, i, parallelOutput, canHaveTwoRoutes, j, route1, route2, nodeRoute1, nodeRoute2, _route1PoolIds, route2PoolIds, sharePool, _iterator4, _step4, route1PoolId, currentRoutes, currentNodeRoutes, _filteredAllocationsAndOutputs2, _filteredAllocations, _filteredOutputs, totalOutput, _currentRoutes, _currentNodeRoutes, _filteredAllocationsAndOutputs3, _filteredAllocations2, _filteredOutputs2, _totalOutput, allSortedIndices, sortedIndices, filteredRoutes, filteredNodeRoutes, index, route1PoolIds, _route2PoolIds, sharedRoute, allFilteredRoutes, allFilteredNodeRoutes, firstRoute, firstRoutePoolIds, allFilteredRouteIds, secondRoute, filteredAllocationsAndOutputs, filteredAllocations, hops, actions, _supplies, hopInputTokenMeta, hopOutputTokenMeta, hopOutputTokenDecimals, expectedHopOutput, decimalEstimate, status, tokens, overallPriceImpact, action;

                return _regeneratorRuntime().wrap(function _callee4$(_context9) {
                  while (1) {
                    switch (_context9.prev = _context9.next) {
                      case 0:
                        if (totalInput) {
                          _context9.next = 2;
                          break;
                        }

                        return _context9.abrupt("return", []);

                      case 2:
                        totalInput = new Big(totalInput); // remove pools that have an id from the decimalCulledPoolIds

                        pools = pools.filter(function (p) {
                          return !decimalsCulledPoolIds.includes(p.id);
                        });
                        _context9.next = 6;
                        return getBestOptimalAllocationsAndOutputs(pools, inputToken, outputToken, totalInput, maxPathLength, threshold);

                      case 6:
                        resDict = _context9.sent;
                        allocations = resDict.allocations; // let outputs = resDict.outputs;

                        routes = resDict.routes;
                        nodeRoutes = resDict.nodeRoutes;
                        sortedIndexValues = argsort(allocations);
                        topIndices = sortedIndexValues.slice(0, 10);
                        reducedRoutes = [];
                        reducedNodeRoutes = [];

                        for (_iterator3 = _createForOfIteratorHelperLoose(topIndices); !(_step3 = _iterator3()).done;) {
                          ind = _step3.value;
                          reducedRoutes.push(routes[ind]);
                          reducedNodeRoutes.push(nodeRoutes[ind]);
                        }

                        routes = reducedRoutes;
                        nodeRoutes = reducedNodeRoutes; // TODO: compare pairs of routes to get the best allocation pair-wise.

                        currentBestOutput = new Big(0);
                        bestAllocations = resDict.allocations;
                        bestNodeRoutes = resDict.nodeRoutes;
                        bestRoutes = resDict.routes; // first check parallel swap with 4 actions. store result.

                        parallelNodeRoutes = [];
                        parallelRoutes = [];

                        for (n in bestRoutes) {
                          currentNodeRoute = bestNodeRoutes[n];

                          if (currentNodeRoute.length == 2) {
                            parallelNodeRoutes.push(currentNodeRoute);
                            parallelRoutes.push(bestRoutes[n]);
                          }
                        } // console.log(`${parallelNodeRoutes.length} parallel routes found...`);


                        bestRoutesAreParallel = false;

                        if (parallelNodeRoutes.length > 0) {
                          // first calculate the expected result using only parallel routes.
                          // let filteredAllocationsAndOutputs = getOptOutputVecRefined(parallelRoutes, parallelNodeRoutes, totalInput);
                          _filteredAllocationsAndOutputs = getOptOutputVec(parallelRoutes, parallelNodeRoutes, totalInput);
                          parallellAllocations = _filteredAllocationsAndOutputs.allocations;
                          parallelOutputs = _filteredAllocationsAndOutputs.result;

                          if (parallellAllocations.length > MAX_NUMBER_PARALLEL_POOLS) {
                            // now sort by allocation value to the top 4 parallel swaps:
                            sortIndices = argsort(parallellAllocations);
                            sortIndices = sortIndices.slice(0, MAX_NUMBER_PARALLEL_POOLS);
                            filteredParallelRoutes = [];
                            filteredParallelNodeRoutes = [];

                            for (i in sortIndices) {
                              filteredParallelRoutes.push(parallelRoutes[sortIndices[i]]);
                              filteredParallelNodeRoutes.push(parallelNodeRoutes[sortIndices[i]]);
                            }

                            _filteredAllocationsAndOutputs = getOptOutputVec(filteredParallelRoutes, filteredParallelNodeRoutes, totalInput);
                            parallellAllocations = _filteredAllocationsAndOutputs.allocations;
                            parallelOutputs = _filteredAllocationsAndOutputs.result;
                          }

                          parallelOutput = parallelOutputs.reduce(function (a, b) {
                            return a.plus(b);
                          }, new Big(0));

                          if (new Big(parallelOutput).gt(currentBestOutput)) {
                            bestAllocations = parallellAllocations;
                            currentBestOutput = parallelOutput; // console.log(
                            //   'BEST OUTPUT FROM PARALLEL SWAPS IS NOW... ',
                            //   currentBestOutput.toString()
                            // );

                            bestRoutes = parallelRoutes;
                            bestNodeRoutes = parallelNodeRoutes;
                            bestRoutesAreParallel = true;
                          }
                        }

                        canHaveTwoRoutes = false; // initialize this variable to check if we can have two routes, or if all routes share a pool for an edge case.
                        // console.log('THE NUMBER OF ROUTES IS...', routes.length);

                        _context9.t0 = _regeneratorRuntime().keys(routes);

                      case 29:
                        if ((_context9.t1 = _context9.t0()).done) {
                          _context9.next = 59;
                          break;
                        }

                        i = _context9.t1.value;
                        _context9.t2 = _regeneratorRuntime().keys(routes);

                      case 32:
                        if ((_context9.t3 = _context9.t2()).done) {
                          _context9.next = 57;
                          break;
                        }

                        j = _context9.t3.value;

                        if (!(j > i)) {
                          _context9.next = 55;
                          break;
                        }

                        route1 = routes[i];
                        route2 = routes[j];
                        nodeRoute1 = nodeRoutes[i];
                        nodeRoute2 = nodeRoutes[j]; // check if they share a pool.

                        _route1PoolIds = new Set(route1.map(function (r) {
                          return r.id;
                        }));
                        route2PoolIds = new Set(route2.map(function (r) {
                          return r.id;
                        }));
                        sharePool = false;

                        for (_iterator4 = _createForOfIteratorHelperLoose(_route1PoolIds); !(_step4 = _iterator4()).done;) {
                          route1PoolId = _step4.value;

                          if (route2PoolIds.has(route1PoolId)) {
                            sharePool = true;
                          }
                        }

                        if (!sharePool) {
                          _context9.next = 47;
                          break;
                        }

                        return _context9.abrupt("continue", 32);

                      case 47:
                        canHaveTwoRoutes = true;
                        currentRoutes = [route1, route2];
                        currentNodeRoutes = [nodeRoute1, nodeRoute2];
                        _filteredAllocationsAndOutputs2 = getOptOutputVec(currentRoutes, currentNodeRoutes, totalInput);
                        _filteredAllocations = _filteredAllocationsAndOutputs2.allocations;
                        _filteredOutputs = _filteredAllocationsAndOutputs2.result; // console.log('FILTERED ALLOCATIONS:');
                        // console.log(filteredAllocations.map((i) => i.toString()));
                        // console.log(filteredOutputs);

                        totalOutput = _filteredOutputs.reduce(function (a, b) {
                          return a.plus(b);
                        }, new Big(0));

                        if (new Big(totalOutput).gt(currentBestOutput)) {
                          bestAllocations = _filteredAllocations;
                          currentBestOutput = totalOutput; // console.log('BEST OUTPUT IS NOW... ', currentBestOutput.toString());

                          bestRoutes = currentRoutes;
                          bestNodeRoutes = currentNodeRoutes;
                          bestRoutesAreParallel = false; // bestResDict = currentResDict
                        } // if (currentResDict.outputs.gt(currentBestOutput)) {
                        // console.log('DIFF IS...', currentResDict.outputs.minus(currentBestOutput).toString());
                        // bestResDict = currentResDict;
                        // currentBestOutput = bestResDict.outputs;
                        // console.log('BEST OUTPUT IS NOW... ', currentBestOutput.toString());
                        // console.log(bestResDict.routes);
                        // console.log(bestResDict.allocations.map((i) => i.toString()));
                        // console.log(bestResDict.outputs.toString());


                      case 55:
                        _context9.next = 32;
                        break;

                      case 57:
                        _context9.next = 29;
                        break;

                      case 59:
                        if (!canHaveTwoRoutes) {
                          // now we need to check through the routes in single manner to find the best one:
                          for (i in routes) {
                            _currentRoutes = [routes[i]];
                            _currentNodeRoutes = [nodeRoutes[i]]; // let filteredAllocationsAndOutputs = getOptOutputVecRefined(currentRoutes, currentNodeRoutes, totalInput);

                            _filteredAllocationsAndOutputs3 = getOptOutputVec(_currentRoutes, _currentNodeRoutes, totalInput);
                            _filteredAllocations2 = _filteredAllocationsAndOutputs3.allocations;
                            _filteredOutputs2 = _filteredAllocationsAndOutputs3.result; // console.log('FILTERED ALLOCATIONS:');
                            // console.log(filteredAllocations.map((i) => i.toString()));
                            // console.log(filteredOutputs);

                            _totalOutput = _filteredOutputs2.reduce(function (a, b) {
                              return a.plus(b);
                            }, new Big(0));

                            if (new Big(_totalOutput).gt(currentBestOutput)) {
                              bestAllocations = _filteredAllocations2;
                              currentBestOutput = _totalOutput; // console.log('BEST OUTPUT IS NOW... ', currentBestOutput.toString());

                              bestRoutes = _currentRoutes;
                              bestNodeRoutes = _currentNodeRoutes;
                              bestRoutesAreParallel = false; // bestResDict = currentResDict
                            }
                          }
                        } // resDict = bestResDict;


                        allocations = bestAllocations; // let outputs = resDict.outputs;

                        routes = bestRoutes;
                        nodeRoutes = bestNodeRoutes;

                        if (!(routes.length < 1)) {
                          _context9.next = 65;
                          break;
                        }

                        return _context9.abrupt("return", []);

                      case 65:
                        // check the top numberOfRoutesLimit
                        // console.log('initial allocations are...');
                        // console.log(allocations.map((a) => a.toString()));
                        // console.log('fixed allocations are...');
                        // console.log(allocations.map((a) => new Big(a).toFixed()));
                        //SORT BY ALLOCATIONS
                        allSortedIndices = argsort(allocations.map(function (a) {
                          return new Big(a);
                        }));

                        if (bestRoutesAreParallel) {
                          numberOfRoutesLimit = 4;
                        }

                        sortedIndices = allSortedIndices.slice(0, numberOfRoutesLimit); // console.log('sorted Indices are');
                        // console.log(sortedIndices);

                        filteredRoutes = [];
                        filteredNodeRoutes = [];

                        for (i in sortedIndices) {
                          index = sortedIndices[i];
                          filteredRoutes.push(routes[index]);
                          filteredNodeRoutes.push(nodeRoutes[index]);
                        } // console.log('filteredRoutes are ...');
                        // console.log(filteredRoutes);


                        for (i in filteredRoutes) {
                          if (!filteredRoutes[i].length) {
                            filteredRoutes[i] = [filteredRoutes[i]];
                          }
                        } // console.log('filtered Node routes are...');
                        // console.log(filteredNodeRoutes);
                        // THE BELOW CODE WILL ENSURE THAT ROUTES ARE INDEPENDENT (e.g. THE ROUTES WILL NOT SHARE A POOL)


                        route1PoolIds = filteredRoutes[0].map(function (pool) {
                          return pool.id;
                        }); // console.log('route 1 pool ids:');
                        // console.log(route1PoolIds);

                        if (!(filteredRoutes.length > 1)) {
                          _context9.next = 84;
                          break;
                        }

                        _route2PoolIds = filteredRoutes[1].map(function (pool) {
                          return pool.id;
                        }); // console.log('route 2 pool ids:');
                        // console.log(route2PoolIds);

                        sharedRoute = false;
                        _context9.t4 = _regeneratorRuntime().keys(_route2PoolIds);

                      case 77:
                        if ((_context9.t5 = _context9.t4()).done) {
                          _context9.next = 84;
                          break;
                        }

                        i = _context9.t5.value;

                        if (!route1PoolIds.includes(_route2PoolIds[i])) {
                          _context9.next = 82;
                          break;
                        }

                        // a pool was shared between routes. need to calculate a new second route.
                        // console.log(
                        //   'a pool was shared between routes. going to calculate a new second route'
                        // );
                        sharedRoute = true;
                        return _context9.abrupt("break", 84);

                      case 82:
                        _context9.next = 77;
                        break;

                      case 84:
                        if (!sharedRoute) {
                          _context9.next = 109;
                          break;
                        }

                        allFilteredRoutes = [];
                        allFilteredNodeRoutes = [];

                        for (i in allSortedIndices) {
                          allFilteredRoutes.push(routes[allSortedIndices[i]]);
                          allFilteredNodeRoutes.push(nodeRoutes[allSortedIndices[i]]);
                        }

                        firstRoute = allFilteredRoutes[0]; // console.log('first route is...');
                        // console.log(firstRoute);

                        firstRoutePoolIds = firstRoute.map(function (pool) {
                          return pool.id;
                        });

                        for (i in allFilteredRoutes) {
                          if (!allFilteredRoutes[i].length) {
                            allFilteredRoutes[i] = [allFilteredRoutes[i]];
                          }
                        } // console.log('FIRST ROUTE POOL IDS ARE');
                        // console.log(firstRoutePoolIds);


                        allFilteredRouteIds = allFilteredRoutes.map(function (route) {
                          return route.map(function (pool) {
                            return pool.id;
                          });
                        }); // console.log('allFilteredRouteIds are ...');
                        // console.log(allFilteredRouteIds);

                        _context9.t6 = _regeneratorRuntime().keys(allFilteredRouteIds);

                      case 93:
                        if ((_context9.t7 = _context9.t6()).done) {
                          _context9.next = 109;
                          break;
                        }

                        i = _context9.t7.value;
                        _context9.t8 = _regeneratorRuntime().keys(allFilteredRouteIds[i]);

                      case 96:
                        if ((_context9.t9 = _context9.t8()).done) {
                          _context9.next = 107;
                          break;
                        }

                        j = _context9.t9.value;

                        if (!firstRoutePoolIds.includes(allFilteredRouteIds[i][j])) {
                          _context9.next = 100;
                          break;
                        }

                        return _context9.abrupt("break", 107);

                      case 100:
                        secondRoute = allFilteredRoutes[i];

                        if (!secondRoute.length) {
                          secondRoute = [secondRoute];
                        }

                        filteredRoutes = [allFilteredRoutes[0], secondRoute];
                        filteredNodeRoutes = [allFilteredNodeRoutes[0], allFilteredNodeRoutes[i]];
                        return _context9.abrupt("break", 107);

                      case 107:
                        _context9.next = 93;
                        break;

                      case 109:
                        // let filteredAllocations_check = getBestOptInput(
                        //   filteredRoutes,
                        //   filteredNodeRoutes,
                        //   totalInput
                        // );
                        // let filteredAllocationsAndOutputs = getOptOutputVecRefined(filteredRoutes, filteredNodeRoutes, totalInput);
                        filteredAllocationsAndOutputs = getOptOutputVec(filteredRoutes, filteredNodeRoutes, totalInput);
                        filteredAllocations = filteredAllocationsAndOutputs.allocations;
                        filteredAllocations = checkIntegerSumOfAllocations(filteredAllocations, totalInput).map(function (stringAllo) {
                          return new Big(stringAllo);
                        });
                        hops = getActionListFromRoutesAndAllocations(filteredRoutes, filteredNodeRoutes, filteredAllocations);
                        actions = []; // console.log('hops are...');
                        // console.log(hops);

                        _context9.t10 = _regeneratorRuntime().keys(hops);

                      case 116:
                        if ((_context9.t11 = _context9.t10()).done) {
                          _context9.next = 139;
                          break;
                        }

                        i = _context9.t11.value;
                        _context9.next = 120;
                        return ftGetTokenMetadata(hops[i].inputToken);

                      case 120:
                        hopInputTokenMeta = _context9.sent;
                        _context9.next = 123;
                        return ftGetTokenMetadata(hops[i].outputToken);

                      case 123:
                        hopOutputTokenMeta = _context9.sent;
                        hopOutputTokenDecimals = hopOutputTokenMeta.decimals;
                        expectedHopOutput = getOutputSingleHop(hops[i].pool, hops[i].inputToken, hops[i].outputToken, hops[i].allocation);
                        decimalEstimate = new Big(expectedHopOutput).div(new Big(10).pow(hopOutputTokenDecimals)).toString(); // Need to check if expected Hop Output is > 1. If not, then cull the corresponding pool and re-calculate.

                        if (!new Big(expectedHopOutput).lt(new Big(1))) {
                          _context9.next = 130;
                          break;
                        }

                        // purge the pool and recalculate.
                        decimalsCulledPoolIds.push(hops[i].pool.id);
                        return _context9.abrupt("return", getSmartRouteSwapActions(pools, inputToken, outputToken, totalInput, maxPathLength = maxPathLength, threshold = threshold, numberOfRoutesLimit = numberOfRoutesLimit, MAX_NUMBER_PARALLEL_POOLS = MAX_NUMBER_PARALLEL_POOLS, decimalsCulledPoolIds = decimalsCulledPoolIds));

                      case 130:
                        if (hops[i].inputToken == inputToken && hops[i].outputToken == outputToken) {
                          status = 'parallel swap';
                        } else {
                          status = 'stableSmart';
                        }

                        _context9.next = 133;
                        return Promise.all(hops[i].nodeRoute.map( /*#__PURE__*/function () {
                          var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(t) {
                            return _regeneratorRuntime().wrap(function _callee3$(_context8) {
                              while (1) {
                                switch (_context8.prev = _context8.next) {
                                  case 0:
                                    _context8.next = 2;
                                    return ftGetTokenMetadata(t);

                                  case 2:
                                    return _context8.abrupt("return", _context8.sent);

                                  case 3:
                                  case "end":
                                    return _context8.stop();
                                }
                              }
                            }, _callee3);
                          }));

                          return function (_x33) {
                            return _ref3.apply(this, arguments);
                          };
                        }()));

                      case 133:
                        tokens = _context9.sent;
                        actions[i] = {
                          estimate: decimalEstimate,
                          pool: {
                            fee: hops[i].pool.fee,
                            gamma_bps: new Big(10000).minus(new Big(hops[i].pool.fee)),
                            //.div(new Big(10000)), //hops[i].pool.gamma, //new Big(10000).minus(new Big(hops[i].pool.fee)).div(new Big(10000));
                            id: hops[i].pool.id,
                            partialAmountIn: new Big(hops[i].allocation).round().toString(),
                            supplies: (_supplies = {}, _supplies[hops[i].pool.token1Id] = hops[i].pool.token1Supply, _supplies[hops[i].pool.token2Id] = hops[i].pool.token2Supply, _supplies),
                            token0_ref_price: hops[i].pool.token0_price,
                            tokenIds: [hops[i].pool.token1Id, hops[i].pool.token2Id],
                            Dex: hops[i].pool.Dex
                          },
                          status: status,
                          token: hopInputTokenMeta,
                          outputToken: hops[i].outputToken,
                          inputToken: hops[i].inputToken,
                          nodeRoute: hops[i].nodeRoute,
                          route: hops[i].route,
                          allRoutes: hops[i].allRoutes,
                          allNodeRoutes: hops[i].allNodeRoutes,
                          totalInputAmount: hops[i].totalInputAmount,
                          allAllocations: hops[i].allAllocations,
                          tokens: tokens,
                          routeInputToken: inputToken,
                          routeOutputToken: outputToken,
                          overallPriceImpact: '0'
                        }; // console.log('INPUT TOKEN IS...');
                        // console.log(hops[i].inputToken);

                        actions[i].pool.x = actions[i].pool.supplies[hops[i].inputToken];
                        actions[i].pool.y = actions[i].pool.supplies[hops[i].outputToken];
                        _context9.next = 116;
                        break;

                      case 139:
                        _context9.next = 141;
                        return calculateSmartRouteV2PriceImpact(actions);

                      case 141:
                        overallPriceImpact = _context9.sent;

                        for (i in actions) {
                          action = actions[i];
                          action.overallPriceImpact = overallPriceImpact;

                          if (action.outputToken === outputToken && action.inputToken != inputToken) {
                            // only want to set second hop partial amount in to zero
                            action.pool.partialAmountIn = '0';
                          }
                        }

                        return _context9.abrupt("return", actions);

                      case 144:
                      case "end":
                        return _context9.stop();
                    }
                  }
                }, _callee4);
              }));

              return function (_x32) {
                return _ref2.apply(this, arguments);
              };
            }()(totalInput));

          case 6:
          case "end":
            return _context10.stop();
        }
      }
    }, _callee5);
  }));
  return _getSmartRouteSwapActions.apply(this, arguments);
}

function calculateSmartRouteV2PriceImpact(_x16) {
  return _calculateSmartRouteV2PriceImpact.apply(this, arguments);
}

function _calculateSmartRouteV2PriceImpact() {
  _calculateSmartRouteV2PriceImpact = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(actions) {
    var deltaY, inputTokenMeta, deltaX, R, P, routes, nodeRoutes, allocations, totalAllocations, weights, i, route, nodeRoute, tokens, weight, num, denom, routeMarketPrice, num1, denom1, num2, denom2, priceImpact;
    return _regeneratorRuntime().wrap(function _callee7$(_context12) {
      while (1) {
        switch (_context12.prev = _context12.next) {
          case 0:
            // the goal is to take a weighted average of the price impact per route, treating each one at a time.
            // for single hop (parallel swaps), the price impact is calculated as before.
            // for double-hop, the market price, P, is determined using reserves of tokens in each pool in the route.
            // in both cases, we compare the 'market price', P , determined solely by reserves in pools, and the actual
            // average price, R,  expected to be paid in the transaction.
            // the price impact is then defined as (P-R)/R * 100 and is a percentage number, returned as a string.
            deltaY = actions.filter(function (a) {
              return a.outputToken == a.routeOutputToken;
            }).map(function (a) {
              return new Big(a.estimate);
            }).reduce(function (a, b) {
              return a.plus(b);
            }, new Big(0)); // console.log('DELTA Y IS...');
            // console.log(deltaY.toString());

            inputTokenMeta = actions[0].tokens[0];
            deltaX = new Big(actions[0].totalInputAmount).div(new Big(10).pow(inputTokenMeta.decimals));
            R = deltaY.div(deltaX);
            P = new Big(0);
            routes = actions[0].allRoutes;
            nodeRoutes = actions[0].allNodeRoutes;
            allocations = actions[0].allAllocations.map(function (a) {
              return new Big(a);
            });
            totalAllocations = allocations.map(function (a) {
              return new Big(a);
            }).reduce(function (a, b) {
              return a.plus(b);
            }, new Big(0));
            weights = allocations.map(function (a) {
              return a.div(totalAllocations);
            });
            _context12.t0 = _regeneratorRuntime().keys(routes);

          case 11:
            if ((_context12.t1 = _context12.t0()).done) {
              _context12.next = 23;
              break;
            }

            i = _context12.t1.value;
            route = routes[i];
            nodeRoute = nodeRoutes[i];
            _context12.next = 17;
            return Promise.all(nodeRoute.map( /*#__PURE__*/function () {
              var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(t) {
                return _regeneratorRuntime().wrap(function _callee6$(_context11) {
                  while (1) {
                    switch (_context11.prev = _context11.next) {
                      case 0:
                        _context11.next = 2;
                        return ftGetTokenMetadata(t);

                      case 2:
                        return _context11.abrupt("return", _context11.sent);

                      case 3:
                      case "end":
                        return _context11.stop();
                    }
                  }
                }, _callee6);
              }));

              return function (_x34) {
                return _ref4.apply(this, arguments);
              };
            }()));

          case 17:
            tokens = _context12.sent;
            weight = weights[i];

            if (route.length == 1) {
              num = new Big(route[0].reserves[nodeRoute[0]]).div(new Big(10).pow(tokens[0].decimals));
              denom = new Big(route[0].reserves[nodeRoute[1]]).div(new Big(10).pow(tokens[1].decimals));
              routeMarketPrice = num.div(denom);
            } else {
              num1 = new Big(route[0].reserves[nodeRoute[0]]).div(new Big(10).pow(tokens[0].decimals));
              denom1 = new Big(route[0].reserves[nodeRoute[1]]).div(new Big(10).pow(tokens[1].decimals));
              num2 = new Big(route[1].reserves[nodeRoute[1]]).div(new Big(10).pow(tokens[1].decimals));
              denom2 = new Big(route[1].reserves[nodeRoute[2]]).div(new Big(10).pow(tokens[2].decimals));
              routeMarketPrice = num1.div(denom1).times(num2).div(denom2);
            }

            P = P.plus(weight.times(new Big(1).div(routeMarketPrice)));
            _context12.next = 11;
            break;

          case 23:
            priceImpact = P.minus(R).div(R).times(new Big(100)).toString();
            return _context12.abrupt("return", priceImpact);

          case 25:
          case "end":
            return _context12.stop();
        }
      }
    }, _callee7);
  }));
  return _calculateSmartRouteV2PriceImpact.apply(this, arguments);
}

function decor(arr) {
  var res = [];

  for (var i in arr) {
    res.push([arr[i], i]);
  }

  return res;
}

function argsort(arr) {
  var undecor = function undecor(a) {
    return a[1];
  }; // leave only index


  var decorated = decor(arr);
  return decorated.sort(function (a, b) {
    return new Big(b[0]).minus(new Big(a[0]));
  }).map(undecor);
}

function getPoolsByToken1ANDToken2(pools, token1, token2, cullZeroLiquidityPools) {
  if (cullZeroLiquidityPools === void 0) {
    cullZeroLiquidityPools = true;
  }

  var filteredPools = pools.filter(function (item) {
    return item.token1Id === token1 && item.token2Id === token2 || item.token1Id === token2 && item.token2Id === token1;
  });

  if (cullZeroLiquidityPools) {
    filteredPools = filteredPools.filter(function (item) {
      return item.token1Supply != '0' && item.token2Supply != '0';
    });
  }

  return filteredPools;
}

function getLiqudityOfPoolsFromList(pools) {
  var liquidities = [];

  for (var poolInd in pools) {
    var pool = pools[poolInd];
    pool.amounts = [pool.token1Supply, pool.token2Supply];
    var poolBigAmounts = pool.amounts.map(function (item) {
      return new Big(item);
    });
    var liquidity = poolBigAmounts[0].times(poolBigAmounts[1]);
    liquidities.push(liquidity);
  }

  return liquidities;
}

function getNormalizedLiquiditiesFromList(pools) {
  var liquidities = getLiqudityOfPoolsFromList(pools);
  var maxLiq = bigMax(liquidities);
  var normalizedLiquidities = liquidities.map(function (item) {
    return item.div(maxLiq);
  });
  return normalizedLiquidities;
}

function bigMax(arrayOfBigs) {
  if (arrayOfBigs.length < 1) {
    return null;
  }

  var maxElem = arrayOfBigs[0];

  for (var ind in arrayOfBigs) {
    var val = arrayOfBigs[ind];

    if (val.gt(maxElem)) {
      maxElem = val;
    }
  }

  return maxElem;
}

function cullPoolsWithInsufficientLiquidity(pools, threshold) {
  if (threshold === void 0) {
    threshold = 0.0001;
  }

  var thresh = new Big(threshold);
  var normLiq = getNormalizedLiquiditiesFromList(pools);
  var filteredPools = [];

  for (var i = 0; i < normLiq.length; i++) {
    if (normLiq[i] > thresh) {
      filteredPools.push(pools[i]);
    }
  }

  return filteredPools;
}

function cartesianProduct(a) {
  var result = a.reduce(function (a, b) {
    return a.flatMap(function (d) {
      return b.map(function (e) {
        return [d, e].flat();
      });
    });
  });
  return result;
}

function addEdge(g, edge) {
  var src = edge[0];
  var dst = edge[1];

  if (Object.keys(g).includes(src)) {
    if (!Object.keys(g[src]).includes(dst)) {
      g[src][dst] = 1;
    }
  } else {
    g[src] = {};
    g[src][dst] = 1;
  }

  if (Object.keys(g).includes(dst)) {
    if (!Object.keys(g[dst]).includes(src)) {
      g[dst][src] = 1;
    }
  } else {
    g[dst] = {};
    g[dst][src] = 1;
  }
}

function addEdges(g, edgeList) {
  for (var n in edgeList) {
    var edge = edgeList[n];
    addEdge(g, edge);
  }
}

function deleteEdge(g, edge) {
  var gNew = JSON.parse(JSON.stringify(g)); // using this to deep clone graph structure

  var e1 = edge[0];
  var e2 = edge[1];

  if (Object.keys(gNew).includes(e1)) {
    if (Object.keys(gNew[e1]).includes(e2)) {
      delete gNew[e1][e2];
    }
  }

  if (Object.keys(gNew).includes(e2)) {
    if (Object.keys(gNew[e2]).includes(e1)) {
      delete gNew[e2][e1];
    }
  }

  return gNew;
}

function deleteNode(g, node) {
  var gNew = JSON.parse(JSON.stringify(g)); // using this to deep clone graph structure

  if (Object.keys(gNew).includes(node)) {
    delete gNew[node];
  }

  var keys = Object.keys(gNew);

  for (var nodeInd in keys) {
    var nodeNow = keys[nodeInd];

    if (Object.keys(gNew[nodeNow]).includes(node)) {
      delete gNew[nodeNow][node];
    }
  }

  return gNew;
}

function dijkstra(graph, s) {
  var solutions = {};
  solutions[s] = {};
  solutions[s].path = [];
  solutions[s].dist = 0;

  while (true) {
    var parent = null;
    var nearest = null;
    var dist = Infinity; //for each existing solution

    for (var n in solutions) {
      if (!solutions[n]) {
        solutions[n] = {};
      }

      if (!solutions[n].path) continue;
      var ndist = solutions[n].dist;
      var adj = graph[n]; //for each of its adjacent nodes...

      for (var a in adj) {
        //without a solution already...
        if (!solutions[a]) {
          solutions[a] = {};
        }

        if (solutions[a].path) continue; //choose nearest node with lowest *total* cost

        var d = adj[a] + ndist;

        if (d < dist) {
          //reference parent
          parent = solutions[n].path;
          nearest = a;
          dist = d;
        }
      }
    } //no more solutions


    if (dist === Infinity) {
      break;
    } //extend parent's solution path


    solutions[nearest].path = parent.concat(nearest); //extend parent's cost

    solutions[nearest].dist = dist;
  }

  return solutions;
}

function shortestPath(g, src, dst, ignore_nodes, ignore_edges) {
  if (ignore_nodes === void 0) {
    ignore_nodes = [];
  }

  if (ignore_edges === void 0) {
    ignore_edges = [];
  }

  var gTemp = JSON.parse(JSON.stringify(g)); // using this to deep clone graph structure. If we can use lodash, could use  _.cloneDeep(obj)
  // remove nodes

  for (var nodeInd in ignore_nodes) {
    var nodeNow = ignore_nodes[nodeInd];
    gTemp = deleteNode(gTemp, nodeNow);
  } // remove edges


  for (var edgeInd in ignore_edges) {
    var edgeNow = ignore_edges[edgeInd];
    gTemp = deleteEdge(gTemp, edgeNow);
  }

  var solution = dijkstra(gTemp, src)[dst];
  solution.path.unshift(src); // original algorithm doesn't include source node in path

  return solution;
}

var PathBuffer = /*#__PURE__*/function () {
  function PathBuffer() {
    this.paths = [];
    this.sortedpaths = []; //this.counter = count();
  }

  var _proto = PathBuffer.prototype;

  _proto.len = function len() {
    return this.sortedpaths.length;
  };

  _proto.push = function push(cost, path) {
    if (path && !arrayContains(this.paths, path)) {
      this.sortedpaths.push([cost, path]);
      this.sortedpaths.sort(function (a, b) {
        return a[0] - b[0];
      }); //heappush(this.sortedpaths, (cost, this.counter.next().value,path));

      this.paths.push(path);
    }
  };

  _proto.pop = function pop() {
    //let val = heappop(this.sortedpaths);
    var val = this.sortedpaths.shift();
    var path = val[1];
    this.paths.splice(this.paths.indexOf(path), 1);
    return path;
  };

  return PathBuffer;
}();

function arrayEquals(a, b) {
  return Array.isArray(a) && Array.isArray(b) && a.length === b.length && a.every(function (val, index) {
    return val === b[index];
  });
}

function arrayContains(arr, obj) {
  // checks to see if the input array contains a reference object, obj, using
  // JSON.stringify() .
  var obj_json = JSON.stringify(obj);

  for (var itemInd in arr) {
    if (JSON.stringify(arr[itemInd]) == obj_json) {
      return true;
    }
  }

  return false;
}

function yenFromPy(g, source, target) {
  var listA, listB, prev_path, sol, length, path, ignore_nodes, ignore_edges, i, root, root_length, pathInd, _path, edgeToIgnore, _sol, _length, spur, _path2, _path3;

  return _regeneratorRuntime().wrap(function yenFromPy$(_context5) {
    while (1) {
      switch (_context5.prev = _context5.next) {
        case 0:
          //adapted from the python implementation in networkx.algorithms.simple_paths.shortest_simple_paths()
          listA = [];
          listB = new PathBuffer();
          prev_path = null;

        case 3:

          if (!prev_path) {
            sol = shortestPath(g, source, target);
            length = sol.dist;
            path = sol.path;
            listB.push(length, path);
          } else {
            ignore_nodes = [];
            ignore_edges = [];

            for (i = 1; i < prev_path.length; i++) {
              root = prev_path.slice(0, i);
              root_length = root.length;

              for (pathInd in listA) {
                _path = listA[pathInd];

                if (arrayEquals(_path.slice(0, i), root)) {
                  edgeToIgnore = [_path[i - 1], _path[i]];
                  ignore_edges.push(edgeToIgnore);
                }
              }

              try {
                _sol = shortestPath(g, root[root.length - 1], target, ignore_nodes = ignore_nodes, ignore_edges = ignore_edges);
                _length = _sol.dist;
                spur = _sol.path;
                _path2 = root.slice(0, root.length - 1).concat(spur);
                listB.push(root_length + _length, _path2);
              } catch (e) {//console.log(`yenFromPy error was... ${e}`)
                //dont do anything.
              }

              ignore_nodes.push(root[root.length - 1]);
            }
          }

          if (!listB.sortedpaths) {
            _context5.next = 19;
            break;
          }

          _context5.prev = 6;
          _path3 = listB.pop();
          _context5.next = 10;
          return _path3;

        case 10:
          listA.push(_path3);
          prev_path = _path3;
          _context5.next = 17;
          break;

        case 14:
          _context5.prev = 14;
          _context5.t0 = _context5["catch"](6);
          return _context5.abrupt("break", 22);

        case 17:
          _context5.next = 20;
          break;

        case 19:
          return _context5.abrupt("break", 22);

        case 20:
          _context5.next = 3;
          break;

        case 22:
        case "end":
          return _context5.stop();
      }
    }
  }, _marked5, null, [[6, 14]]);
}

function getKShortestPaths(g, source, target, k, maxPathLength) {
  if (maxPathLength === void 0) {
    maxPathLength = 3;
  }

  return function (maxPathLength) {
    var paths = [];

    if (maxPathLength < 2) {
      var maxPathLength = 2;
    }

    var gen = yenFromPy(g, source, target);

    for (var n = 1; n <= k; n++) {
      try {
        var res = gen.next().value;

        if (res && !arrayContains(paths, res)) {
          if (res.length > maxPathLength) {
            // console.log(
            //   `found all hops of length ${
            //     maxPathLength - 1
            //   } or less... breaking out of generator`
            // );
            break;
          }

          paths.push(res);
        }
      } catch (e) {
        break;
      }
    }

    return paths;
  }(maxPathLength);
}

function getPathsFromPools(_x17, _x18, _x19, _x20) {
  return _getPathsFromPools.apply(this, arguments);
}

function _getPathsFromPools() {
  _getPathsFromPools = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(pools, inputToken, outputToken, maxPathLength) {
    var graph;
    return _regeneratorRuntime().wrap(function _callee8$(_context13) {
      while (1) {
        switch (_context13.prev = _context13.next) {
          case 0:
            if (maxPathLength === void 0) {
              maxPathLength = 3;
            }

            graph = getGraphFromPoolList(pools);
            return _context13.abrupt("return", getKShortestPaths(graph, inputToken, outputToken, 100, maxPathLength));

          case 3:
          case "end":
            return _context13.stop();
        }
      }
    }, _callee8);
  }));
  return _getPathsFromPools.apply(this, arguments);
}

function getGraphFromPoolList(poolList) {
  var pools = poolList.filter(function (item) {
    return item.token1Supply != '0' && item.token2Supply != '0';
  });
  var transitions = pools.map(function (item) {
    return [item.token1Id, item.token2Id];
  });
  var g = {};
  addEdges(g, transitions);
  return g;
} ////////////////////////////////////
// MAIN FUNCTION
////////////////////////////////////
// TODO -- incorporate the following integrated function, which tries to
// account for stablecoins within the context of smart routing.
//TODO -- need the right API / hooks for GETSTABLESWAPACTION function and GETPARALLELSWAPACTIONS functions.
//TODO -- transform the actions generated in this function into tranaction to execute.
//TRYING: GETSTABLESWAPACTION <==> instantSwapGetTransactions


function stableSmart(_x26, _x27, _x28, _x29, _x30) {
  return _stableSmart.apply(this, arguments);
}

function _stableSmart() {
  _stableSmart = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(pools, inputToken, outputToken, totalInput, slippageTolerance) {
    var smartRouteActions;
    return _regeneratorRuntime().wrap(function _callee10$(_context15) {
      while (1) {
        switch (_context15.prev = _context15.next) {
          case 0:
            _context15.next = 2;
            return getSmartRouteSwapActions(pools, inputToken, outputToken, totalInput, slippageTolerance);

          case 2:
            smartRouteActions = _context15.sent;
            return _context15.abrupt("return", smartRouteActions);

          case 4:
          case "end":
            return _context15.stop();
        }
      }
    }, _callee10);
  }));
  return _stableSmart.apply(this, arguments);
}

function getExpectedOutputFromActionsORIG(actions, outputToken) {
  return actions.filter(function (item) {
    return item.outputToken === outputToken;
  }).map(function (item) {
    return new Big(item.estimate);
  }).reduce(function (a, b) {
    return a.plus(b);
  }, new Big(0));
}

var getSimplePoolEstimate = function getSimplePoolEstimate(_ref) {
  var tokenIn = _ref.tokenIn,
      tokenOut = _ref.tokenOut,
      pool = _ref.pool,
      amountIn = _ref.amountIn;
  var amount_with_fee = Number(amountIn) * (FEE_DIVISOR - pool.fee);
  var in_balance = toReadableNumber(tokenIn.decimals, pool.supplies[tokenIn.id]);
  var out_balance = toReadableNumber(tokenOut.decimals, pool.supplies[tokenOut.id]);
  var estimate = new Big((amount_with_fee * Number(out_balance) / (FEE_DIVISOR * Number(in_balance) + amount_with_fee)).toString()).toFixed();
  return {
    token: tokenIn,
    estimate: estimate,
    pool: pool,
    outputToken: tokenOut.id,
    inputToken: tokenIn.id
  };
};
var getStablePoolEstimate = function getStablePoolEstimate(_ref2) {
  var tokenIn = _ref2.tokenIn,
      tokenOut = _ref2.tokenOut,
      amountIn = _ref2.amountIn,
      stablePool = _ref2.stablePool;
  var STABLE_LP_TOKEN_DECIMALS = getStablePoolDecimal(stablePool);

  var _getSwappedAmount = getSwappedAmount(tokenIn.id, tokenOut.id, amountIn, stablePool, STABLE_LP_TOKEN_DECIMALS),
      amount_swapped = _getSwappedAmount[0],
      dy = _getSwappedAmount[2];

  var amountOut = amount_swapped < 0 || isNaN(amount_swapped) ? '0' : toPrecision(scientificNotationToString(amount_swapped.toString()), 0);
  var dyOut = amount_swapped < 0 || isNaN(amount_swapped) || isNaN(dy) ? '0' : toPrecision(scientificNotationToString(dy.toString()), 0);
  return {
    estimate: toReadableNumber(STABLE_LP_TOKEN_DECIMALS, amountOut),
    noFeeAmountOut: toReadableNumber(STABLE_LP_TOKEN_DECIMALS, dyOut),
    pool: stablePool,
    token: tokenIn,
    outputToken: tokenOut.id,
    inputToken: tokenIn.id
  };
};
/**
 * @description Get the estimate of the amount of tokenOut that can be received
 *
 */

var singlePoolSwap = function singlePoolSwap(_ref3) {
  var tokenIn = _ref3.tokenIn,
      tokenOut = _ref3.tokenOut,
      simplePools = _ref3.simplePools,
      amountIn = _ref3.amountIn,
      stablePools = _ref3.stablePools;

  if (!simplePools || simplePools.length === 0) {
    throw NoPoolError;
  } // const pools = simplePools.concat(stablePools);


  var simplePoolsThisPair = simplePools.filter(function (p) {
    return p.tokenIds.includes(tokenIn.id) && p.tokenIds.includes(tokenOut.id);
  });
  var estimatesSimplePool = simplePoolsThisPair.map(function (pool) {
    return getSimplePoolEstimate({
      tokenIn: tokenIn,
      tokenOut: tokenOut,
      pool: pool,
      amountIn: amountIn
    });
  });
  var stablePoolThisPair = stablePools == null ? void 0 : stablePools.filter(function (sp) {
    return sp.token_account_ids.includes(tokenIn.id) && sp.token_account_ids.includes(tokenOut.id);
  }); // different stable lp token decimal for different type of pools

  var estimatesStablePool = stablePoolThisPair == null ? void 0 : stablePoolThisPair.map(function (stablePool) {
    return getStablePoolEstimate({
      tokenIn: tokenIn,
      tokenOut: tokenOut,
      amountIn: amountIn,
      stablePool: stablePool
    });
  });
  var maxSimplePoolEstimate = estimatesSimplePool.length === 1 ? estimatesSimplePool[0] : _.maxBy(estimatesSimplePool, function (estimate) {
    return Number(estimate.estimate);
  });
  if (!estimatesStablePool) return maxSimplePoolEstimate;
  var maxStablePoolEstimate = estimatesStablePool.length === 1 ? estimatesStablePool[0] : _.maxBy(estimatesStablePool, function (estimate) {
    return Number(estimate.estimate);
  });
  return Number(maxSimplePoolEstimate == null ? void 0 : maxSimplePoolEstimate.estimate) > Number(maxStablePoolEstimate == null ? void 0 : maxStablePoolEstimate.estimate) ? maxSimplePoolEstimate : maxStablePoolEstimate;
};
var getStablePoolsThisPair = function getStablePoolsThisPair(_ref4) {
  var tokenInId = _ref4.tokenInId,
      tokenOutId = _ref4.tokenOutId,
      stablePools = _ref4.stablePools;
  return stablePools.filter(function (p) {
    return p.tokenIds.includes(tokenInId) && p.tokenIds.includes(tokenOutId) && tokenInId !== tokenOutId;
  });
};
var getPoolsByTokens = function getPoolsByTokens(_ref5) {
  var pools = _ref5.pools,
      tokenInId = _ref5.tokenInId,
      tokenOutId = _ref5.tokenOutId;
  if (tokenInId === tokenOutId) return [];
  return pools.filter(function (p) {
    return p.tokenIds.includes(tokenInId) && p.tokenIds.includes(tokenOutId);
  });
};
var getPoolEstimate = /*#__PURE__*/function () {
  var _ref7 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref6) {
    var tokenIn, tokenOut, amountIn, stablePoolDetail, pool;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            tokenIn = _ref6.tokenIn, tokenOut = _ref6.tokenOut, amountIn = _ref6.amountIn, stablePoolDetail = _ref6.stablePoolDetail, pool = _ref6.pool;

            if (!stablePoolDetail) {
              _context.next = 5;
              break;
            }

            return _context.abrupt("return", getStablePoolEstimate({
              tokenIn: tokenIn,
              tokenOut: tokenOut,
              stablePool: stablePoolDetail,
              amountIn: amountIn
            }));

          case 5:
            return _context.abrupt("return", getSimplePoolEstimate({
              tokenIn: tokenIn,
              tokenOut: tokenOut,
              pool: pool,
              amountIn: amountIn
            }));

          case 6:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function getPoolEstimate(_x) {
    return _ref7.apply(this, arguments);
  };
}();
function getHybridStableSmart(_x2, _x3, _x4, _x5, _x6, _x7) {
  return _getHybridStableSmart.apply(this, arguments);
} // simple pools and stable pools for this pair

function _getHybridStableSmart() {
  _getHybridStableSmart = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(tokenIn, tokenOut, amountIn, stablePools, stablePoolsDetail, simplePools) {
    var stablePoolsDetailById, parsedAmountIn, pool1, pool2, pools1, pools2, pools1Right, pools2Right, candidatePools, otherStables, _iterator, _step, otherStable, stablePoolsThisPair, tmpPools, tobeAddedPools, _otherStables, _iterator2, _step2, _otherStable, _stablePoolsThisPair, _tmpPools, _tobeAddedPools, _iterator3, _step3, _p, _middleTokens, _loop2, _iterator5, _step5, _i, _pools1Right, p1, middleTokens, _loop, _iterator4, _step4, tokensMedata, BestPoolPair, bestPool, estimate, tokenMidId, tokenMidMeta, estimate1, estimate2;

    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            if (!(!isStablePoolToken(stablePoolsDetail, tokenIn.id) && !isStablePoolToken(stablePoolsDetail, tokenOut.id))) {
              _context3.next = 2;
              break;
            }

            return _context3.abrupt("return", {
              actions: [],
              estimate: '0'
            });

          case 2:
            stablePoolsDetailById = stablePoolsDetail.reduce(function (acc, cur) {
              var _extends2;

              return _extends({}, acc, (_extends2 = {}, _extends2[cur.id] = cur, _extends2));
            }, {});
            parsedAmountIn = toNonDivisibleNumber(tokenIn.decimals, amountIn);
            pools1 = [];
            pools2 = [];
            pools1Right = [];
            pools2Right = [];
            candidatePools = [];
            /**
             * find possible routes for this pair
             *
             *
             */

            if (isStablePoolToken(stablePoolsDetail, tokenIn.id)) {
              // first hop will be through stable pool.
              pools1 = stablePools.filter(function (pool) {
                return pool.tokenIds.includes(tokenIn.id);
              });
              otherStables = pools1.map(function (pool) {
                return pool.tokenIds.filter(function (id) {
                  return id !== tokenIn.id;
                });
              }).flat();

              for (_iterator = _createForOfIteratorHelperLoose(otherStables); !(_step = _iterator()).done;) {
                otherStable = _step.value;
                stablePoolsThisPair = getStablePoolsThisPair({
                  tokenInId: otherStable,
                  tokenOutId: tokenOut.id,
                  stablePools: stablePools
                });
                tmpPools = getPoolsByTokens({
                  tokenInId: otherStable,
                  tokenOutId: tokenOut.id,
                  pools: simplePools
                });
                tobeAddedPools = tmpPools.concat(stablePoolsThisPair);
                pools2.push.apply(pools2, tobeAddedPools.filter(function (p) {
                  var supplies = Object.values(p.supplies);
                  return new Big(supplies[0]).times(new Big(supplies[1])).gt(0);
                }));
              }
            }

            if (isStablePoolToken(stablePoolsDetail, tokenOut.id)) {
              // second hop will be through stable pool.
              pools2Right = stablePools.filter(function (pool) {
                return pool.tokenIds.includes(tokenOut.id);
              });
              _otherStables = pools2Right.map(function (pool) {
                return pool.tokenIds.filter(function (id) {
                  return id !== tokenOut.id;
                });
              }).flat();

              for (_iterator2 = _createForOfIteratorHelperLoose(_otherStables); !(_step2 = _iterator2()).done;) {
                _otherStable = _step2.value;
                _stablePoolsThisPair = getStablePoolsThisPair({
                  tokenInId: tokenIn.id,
                  tokenOutId: _otherStable,
                  stablePools: stablePools
                });
                _tmpPools = getPoolsByTokens({
                  tokenInId: tokenIn.id,
                  tokenOutId: _otherStable,
                  pools: simplePools
                });
                _tobeAddedPools = _tmpPools.concat(_stablePoolsThisPair);
                pools1Right.push.apply(pools1Right, _tobeAddedPools.filter(function (p) {
                  var supplies = Object.values(p.supplies);
                  return new Big(supplies[0]).times(new Big(supplies[1])).gt(0);
                }));
              }
            } // find candidate pools


            for (_iterator3 = _createForOfIteratorHelperLoose(pools1); !(_step3 = _iterator3()).done;) {
              _p = _step3.value;
              _middleTokens = _p.tokenIds.filter(function (id) {
                return id !== tokenIn.id;
              });

              _loop2 = function _loop2() {
                var middleToken = _step5.value;
                var p2s = pools2.filter(function (p) {
                  return p.tokenIds.includes(middleToken) && p.tokenIds.includes(tokenOut.id) && middleToken !== tokenOut.id;
                });

                var p2 = _.maxBy(p2s, function (p) {
                  return Number(new Big(toReadableNumber(tokenOut.decimals, p.supplies[tokenOut.id])));
                });

                if (middleToken === tokenOut.id) {
                  p2 = _p;
                }

                if (_p && p2) {
                  if (_p.id === p2.id) candidatePools.push([_p]);else candidatePools.push([_p, p2]);
                }
              };

              for (_iterator5 = _createForOfIteratorHelperLoose(_middleTokens); !(_step5 = _iterator5()).done;) {
                _loop2();
              }
            }

            for (_i = 0, _pools1Right = pools1Right; _i < _pools1Right.length; _i++) {
              p1 = _pools1Right[_i];
              middleTokens = p1.tokenIds.filter(function (id) {
                return id !== tokenIn.id;
              });

              _loop = function _loop() {
                var middleToken = _step4.value;
                var p2s = pools2Right.filter(function (p) {
                  return p.tokenIds.includes(middleToken) && p.tokenIds.includes(tokenOut.id) && middleToken !== tokenOut.id;
                });

                var p2 = _.maxBy(p2s, function (p) {
                  return Number(new Big(toReadableNumber(tokenOut.decimals, p.supplies[tokenOut.id])));
                });

                if (middleToken === tokenOut.id) {
                  p2 = p1;
                }

                if (p1 && p2) {
                  if (p1.id === p2.id) candidatePools.push([p1]);else candidatePools.push([p1, p2]);
                }
              };

              for (_iterator4 = _createForOfIteratorHelperLoose(middleTokens); !(_step4 = _iterator4()).done;) {
                _loop();
              }
            }

            if (!(candidatePools.length > 0)) {
              _context3.next = 36;
              break;
            }

            _context3.next = 16;
            return ftGetTokensMetadata(candidatePools.map(function (cp) {
              return cp.map(function (p) {
                return p.tokenIds;
              }).flat();
            }).flat());

          case 16:
            tokensMedata = _context3.sent;
            BestPoolPair = candidatePools.length === 1 ? candidatePools[0] : _.maxBy(candidatePools, function (poolPair) {
              // only one pool case, only for stable tokens
              if (poolPair.length === 1) {
                if (isStablePool(stablePoolsDetail, poolPair[0].id)) {
                  var stablePoolThisPair = getStablePoolsThisPair({
                    tokenInId: tokenIn.id,
                    tokenOutId: tokenOut.id,
                    stablePools: stablePools
                  })[0];
                  var stablePoolDetailThisPair = stablePoolsDetail.find(function (spd) {
                    return spd.id === stablePoolThisPair.id;
                  });
                  return Number(getStablePoolEstimate({
                    tokenIn: tokenIn,
                    tokenOut: tokenOut,
                    stablePool: stablePoolDetailThisPair,
                    amountIn: amountIn
                  }).estimate);
                } else {
                  return Number(getSimplePoolEstimate({
                    tokenIn: tokenIn,
                    tokenOut: tokenOut,
                    amountIn: amountIn,
                    pool: poolPair[0]
                  }).estimate);
                }
              }

              var tmpPool1 = poolPair[0],
                  tmpPool2 = poolPair[1];
              var tokenMidId = poolPair[0].tokenIds.find(function (t) {
                return poolPair[1].tokenIds.includes(t);
              });
              var tokenMidMeta = tokensMedata[tokenMidId];

              var estimate1 = _extends({}, isStablePool(stablePoolsDetail, tmpPool1.id) ? getStablePoolEstimate({
                tokenIn: tokenIn,
                tokenOut: tokenMidMeta,
                amountIn: amountIn,
                stablePool: stablePoolsDetailById[tmpPool1.id]
              }) : getSimplePoolEstimate({
                tokenIn: tokenIn,
                tokenOut: tokenMidMeta,
                amountIn: amountIn,
                pool: tmpPool1
              }));

              var estimate2 = _extends({}, isStablePool(stablePoolsDetail, tmpPool2.id) ? getStablePoolEstimate({
                tokenIn: tokenMidMeta,
                tokenOut: tokenOut,
                amountIn: estimate1.estimate,
                stablePool: stablePoolsDetailById[tmpPool2.id]
              }) : getSimplePoolEstimate({
                tokenIn: tokenMidMeta,
                tokenOut: tokenOut,
                pool: tmpPool2,
                amountIn: estimate1.estimate
              }));

              return Number(estimate2.estimate);
            }); // one pool case only get best price

            if (BestPoolPair) {
              _context3.next = 20;
              break;
            }

            return _context3.abrupt("return", {
              actions: [],
              estimate: '0'
            });

          case 20:
            if (!(BestPoolPair.length === 1)) {
              _context3.next = 26;
              break;
            }

            bestPool = BestPoolPair[0];
            _context3.next = 24;
            return getPoolEstimate({
              tokenIn: tokenIn,
              tokenOut: tokenOut,
              amountIn: amountIn,
              pool: bestPool,
              stablePoolDetail: stablePoolsDetailById[bestPool.id]
            });

          case 24:
            estimate = _context3.sent;
            return _context3.abrupt("return", {
              actions: [_extends({}, estimate, {
                pool: _extends({}, bestPool, {
                  parsedAmountIn: parsedAmountIn
                }),
                tokens: [tokenIn, tokenOut],
                inputToken: tokenIn.id,
                outputToken: tokenOut.id,
                totalInputAmount: toNonDivisibleNumber(tokenIn.decimals, amountIn)
              })],
              estimate: estimate.estimate
            });

          case 26:
            pool1 = BestPoolPair[0];
            pool2 = BestPoolPair[1];
            tokenMidId = BestPoolPair[0].tokenIds.find(function (t) {
              return BestPoolPair[1].tokenIds.includes(t);
            });
            _context3.next = 31;
            return ftGetTokenMetadata(tokenMidId);

          case 31:
            tokenMidMeta = _context3.sent;
            estimate1 = _extends({}, isStablePool(stablePoolsDetail, pool1.id) ? getStablePoolEstimate({
              tokenIn: tokenIn,
              tokenOut: tokenMidMeta,
              amountIn: amountIn,
              stablePool: stablePoolsDetailById[pool1.id]
            }) : getSimplePoolEstimate({
              tokenIn: tokenIn,
              tokenOut: tokenMidMeta,
              amountIn: amountIn,
              pool: pool1
            }), {
              tokens: [tokenIn, tokenMidMeta, tokenOut],
              inputToken: tokenIn.id,
              outputToken: tokenMidMeta.id
            });
            estimate1.pool.partialAmountIn = parsedAmountIn;
            estimate2 = _extends({}, isStablePool(stablePoolsDetail, pool2.id) ? getStablePoolEstimate({
              tokenIn: tokenMidMeta,
              tokenOut: tokenOut,
              amountIn: estimate1.estimate,
              stablePool: stablePoolsDetailById[pool2.id]
            }) : getSimplePoolEstimate({
              tokenIn: tokenMidMeta,
              tokenOut: tokenOut,
              amountIn: estimate1.estimate,
              pool: pool2
            }), {
              tokens: [tokenIn, tokenMidMeta, tokenOut],
              inputToken: tokenMidMeta.id,
              outputToken: tokenOut.id
            });
            return _context3.abrupt("return", {
              actions: [estimate1, estimate2],
              estimate: estimate2.estimate
            });

          case 36:
            return _context3.abrupt("return", {
              actions: [],
              estimate: '0'
            });

          case 37:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _getHybridStableSmart.apply(this, arguments);
}

var estimateSwap = /*#__PURE__*/function () {
  var _ref9 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_ref8) {
    var tokenIn, tokenOut, amountIn, simplePools, options, _ref10, enableSmartRouting, stablePools, stablePoolsDetail, parsedAmountIn, estimate, inputPools, simplePoolSmartRoutingActions, simplePoolSmartRoutingEstimate, hybridSmartRoutingRes, hybridSmartRoutingEstimate;

    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            tokenIn = _ref8.tokenIn, tokenOut = _ref8.tokenOut, amountIn = _ref8.amountIn, simplePools = _ref8.simplePools, options = _ref8.options;

            if (!(tokenIn.id === tokenOut.id)) {
              _context2.next = 3;
              break;
            }

            throw SameInputTokenError;

          case 3:
            if (!ONLY_ZEROS.test(amountIn)) {
              _context2.next = 5;
              break;
            }

            throw ZeroInputError;

          case 5:
            _ref10 = options || {}, enableSmartRouting = _ref10.enableSmartRouting, stablePools = _ref10.stablePools, stablePoolsDetail = _ref10.stablePoolsDetail;
            parsedAmountIn = toNonDivisibleNumber(tokenIn.decimals, amountIn);

            if (enableSmartRouting) {
              _context2.next = 12;
              break;
            }

            estimate = singlePoolSwap({
              tokenIn: tokenIn,
              tokenOut: tokenOut,
              simplePools: simplePools,
              amountIn: amountIn,
              stablePools: stablePoolsDetail
            });
            return _context2.abrupt("return", [_extends({}, estimate, {
              pool: _extends({}, estimate == null ? void 0 : estimate.pool, {
                partialAmountIn: parsedAmountIn
              })
            })]);

          case 12:
            inputPools = simplePools.map(function (p) {
              return poolFormatter(p);
            });
            _context2.next = 15;
            return stableSmart(inputPools, tokenIn.id, tokenOut.id, parsedAmountIn);

          case 15:
            simplePoolSmartRoutingActions = _context2.sent;
            simplePoolSmartRoutingEstimate = getExpectedOutputFromActionsORIG(simplePoolSmartRoutingActions, tokenOut.id).toString();
            _context2.next = 19;
            return getHybridStableSmart(tokenIn, tokenOut, amountIn, stablePools || [], stablePoolsDetail || [], simplePools);

          case 19:
            hybridSmartRoutingRes = _context2.sent;
            hybridSmartRoutingEstimate = hybridSmartRoutingRes.estimate.toString();

            if (!new Big(simplePoolSmartRoutingEstimate || '0').gte(hybridSmartRoutingEstimate || '0')) {
              _context2.next = 27;
              break;
            }

            if (simplePoolSmartRoutingActions != null && simplePoolSmartRoutingActions.length) {
              _context2.next = 24;
              break;
            }

            throw NoPoolError;

          case 24:
            return _context2.abrupt("return", simplePoolSmartRoutingActions);

          case 27:
            return _context2.abrupt("return", hybridSmartRoutingRes.actions);

          case 28:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function estimateSwap(_x8) {
    return _ref9.apply(this, arguments);
  };
}();

var provider = /*#__PURE__*/new providers.JsonRpcProvider({
  url: /*#__PURE__*/getConfig().nodeUrl
});
var getMemorySigner = function getMemorySigner(_ref) {

  var homedir = require('os').homedir();

  var CREDENTIALS_DIR = '.near-credentials';

  var credentialsPath = require('path').join(homedir, CREDENTIALS_DIR);

  var myKeyStore = new keyStores.UnencryptedFileSystemKeyStore(credentialsPath); // myKeyStore.setKey(
  //   getConfig().networkId,
  //   AccountId,
  //   KeyPair.fromString(credentials.private_key)
  // );

  var signer = new InMemorySigner(myKeyStore);
  console.log(signer); // return signer;
}; // export const getSignedTransactions = async () => {
//   const block = await provider.block({ finality: 'final' });
//   for (let i = 0; i < transactions.length; i += 1) {
//     const transaction = transactions[i];
//     const publicKey = await signer.getPublicKey(
//       transaction.signerId,
//       getConfig().networkId
//     );
//     if (!publicKey) {
//       throw new Error('No public key found');
//     }
//     const accessKey = await provider.query<AccessKeyView>({
//       request_type: 'view_access_key',
//       finality: 'final',
//       account_id: transaction.signerId,
//       public_key: publicKey.toString(),
//     });
//     if (!validateAccessKey(transaction, accessKey)) {
//       throw new Error('Invalid access key');
//     }
//     const tx = nearTransactions.createTransaction(
//       transactions[i].signerId,
//       utils.PublicKey.from(publicKey.toString()),
//       transactions[i].receiverId,
//       accessKey.nonce + i + 1,
//       transaction.actions.map(action => createAction(action)),
//       utils.serialize.base_decode(block.header.hash)
//     );
//     const [, signedTx] = await nearTransactions.signTransaction(
//       tx,
//       signer,
//       transactions[i].signerId,
//       options.network.networkId
//     );
//     signedTransactions.push(signedTx);
//   }
// };

export { DEFAULT_PAGE_LIMIT, FEE_DIVISOR, NoPoolError, NotLoginError, ONE_YOCTO_NEAR, ONLY_ZEROS, RATED_POOL_LP_TOKEN_DECIMALS, REF_FI_CONTRACT_ID, STABLE_LP_TOKEN_DECIMALS, STORAGE_TO_REGISTER_WITH_MFT, SameInputTokenError, SwapRouteError, TokenNotExistError, ZeroInputError, calc_d, calc_swap, calc_y, config, convertToPercentDecimal, estimateSwap, fetchAllRefPools, formatError, formatWithCommas, ftGetStorageBalance, ftGetTokenMetadata, ftGetTokensMetadata, ftViewFunction, getAmount, getConfig, getGas, getHybridStableSmart, getMemorySigner, getPoolEstimate, getPoolsByTokens, getRatedPoolDetail, getRefPools, getSimplePoolEstimate, getStablePoolDecimal, getStablePoolEstimate, getStablePoolsDetail, getStablePoolsThisPair, getSwappedAmount, getTotalPools, getUnRatedPoolDetail, instantSwap, isStablePool, isStablePoolToken, keyStore, near, parsePool, percentLess, percentOf, poolFormatter, provider, refFiViewFunction, round, scientificNotationToString, singlePoolSwap, toNonDivisibleNumber, toPrecision, toReadableNumber, unNamedError, wallet };
//# sourceMappingURL=ref-sdk.esm.js.map
