import{Channel as e}from"../../internal/Channel.js";import{ChannelEventSource as t}from"../../internal/ChannelEventSource.js";import{createMemoizedFetcher as a,hasNumberChange as s}from"../../internal/createMemoizedFetcher.js";import{getSwapRate as i,getPriceImpact as r,getTransactionFee as n,getNextAccountValue as o,getNextTotalCollateralValue as c,getNextOpenOrderMarginReq as h,getNextFreeCollateral as u,getBuyingPower as l}from"../clearingHouse/utils.js";import"../../constants/envVariables.js";import{BIG_ZERO as p}from"../../constants/numbers.js";import d from"big.js";import{PositionSide as m}from"./types.js";import{UnauthorizedError as g}from"../../errors/errors.js";import{invariant as w}from"../../utils/errorChecker.js";import"ethers";import"../../utils/tick.js";class _ extends e{constructor(e,{market:t,side:a=m.LONG,amountInput:s=p,isAmountInputBase:i=!1}){super(e.channelRegistry),this._perp=e,this._cache=new Map,this.market=t,this.side=a,this.amountInput=s,this.isAmountInputBase=i,this._feeRatio=e.clearingHouseConfig.marketExchangeFeeRatios[t.baseAddress],this._imRatio=e.clearingHouseConfig.imRatio,this._contractReader=e.contractReader}get isBaseToQuote(){return this.side===m.SHORT}get isExactInput(){return this.isBaseToQuote?this.isAmountInputBase:!this.isAmountInputBase}async getOppositeAmountBound(e){const{output:t}=await this._fetch("swap",{cache:!1});let a;return this.isExactInput?a=t.mul(new d(1).sub(e)):(a=t.mul(new d(1).add(e)),e.eq(0)&&!this.isBaseToQuote&&(a=a.add(new d(1).mul(1e-18)))),a}_getEventSourceMap(){const e=this._createFetchUpdateData();return{updated:new t({eventSourceStarter:()=>this.market.on("updated",(async()=>{this._handleMarketUpdate()}))}),buyingPowerUpdated:new t({eventSourceStarter:()=>{w(this._perp.hasConnected(),(()=>new g({functionName:"_getEventSourceMap"})));const t=this._perp.vault.on("updated",(()=>{e(!1,!0)})),a=this._perp.positions.on("updated",(()=>{e(!1,!0)}));return()=>{t(),a()}}})}}_createFetchUpdateData(){const e=async()=>{try{return await this.getBuyingPower({cache:!1})}catch(e){this.emit("updateError",{error:e})}};return a((()=>e()),(()=>{this.emit("buyingPowerUpdated",this)}),((e,t)=>!e||!t||s(e,t)))}async _handleMarketUpdate(){if(!this.amountInput.lte(0))try{await this._fetch("swap",{cache:!1}),this._perp.hasConnected()&&await this._fetch("relatedData",{cache:!1}),this.emit("updated",this)}catch(e){this.emit("updateError",{error:e})}}async getSwap({cache:e=!0}={}){return this._fetch("swap",{cache:e})}async getEntryPrice({cache:e=!0}={}){const{exchangedPositionSize:t,exchangedPositionNotional:a}=await this._fetch("swap",{cache:e});return i({amountBase:t,amountQuote:a})}async getPriceImpact({cache:e=!0}={}){const t=await this.getEntryPrice({cache:e}),{markPrice:a}=await this.market.getPrices({cache:e});return r({price:t,markPrice:a})}async getTransactionFee({cache:e=!0}={}){const{deltaAvailableQuote:t,exchangedPositionNotional:a}=await this._fetch("swap",{cache:e});return n({isBaseToQuote:this.isBaseToQuote,exchangedPositionNotional:a,deltaAvailableQuote:t,feeRatio:this._feeRatio})}async getBuyingPower({cache:e=!0}={}){w(this._perp.hasConnected(),(()=>new g({functionName:"getBuyingPower"})));const[{indexTwapPrice:t},a,s,i,r,n]=await Promise.all([this.market.getPrices({cache:e}),this._fetch("relatedData",{cache:e}),this._perp.clearingHouse.getAccountValue({cache:e}),this._perp.vault.getFreeCollateral({cache:e}),this._perp.positions.getTotalPositionValue(this.market.baseAddress,{cache:e}),this.getExistingPositionSize()]),{deltaAvailableBase:_=p,deltaAvailableQuote:A=p}=a.swap,P=this.side===m.LONG,b=_.mul(P?1:-1),f=A.mul(P?-1:1),k=o({indexTwapPrice:t,accountValue:s,signedDeltaAvailableBase:b,signedDeltaAvailableQuote:f}),B=await this._perp.positions.getTotalUnrealizedPnlFromAllMarkets(),x=c({nextAccountValue:k,signedDeltaAvailableBase:b,signedDeltaAvailableQuote:f,indexTwapPrice:t,totalUnrealizedPNLFromAllMarkets:B}),{otherBaseDebts:y,otherMarketIndexPrices:v,quoteDebts:R}=a,T=p;for(let e=0;e<y.length;e++){const t=y[e],a=v[e];t.lt(0)&&T.add(t.mul(a))}const D=R.reduce(((e,t)=>e.add(t)),p),E=h({sumOfOtherBaseDebtValue:T,sumOfQuoteDebtValue:D,thisBaseBalance:n,signedDeltaAvailableBase:b,signedDeltaAvailableQuote:f,indexTwapPrice:t,imRatio:this._imRatio}),Q=u({nextTotalCollateralValue:x,nextAccountValue:k,nextOpenOrderMarginReq:E}),I=l({imRatio:this._imRatio,freeCollateral:i,existingPositionValue:r,side:this.side,nextFreeCollateral:Q});return I.lt(0)?d(0):I}async getExistingPositionSize({cache:e=!0}={}){w(this._perp.hasConnected(),(()=>new g({functionName:"getExistingPositionSize"})));const t=await this._perp.positions.getTakerPosition(this.market.baseAddress,{cache:e}),a=await this._perp.positions.getMakerPosition(this.market.baseAddress);return d((null==t?void 0:t.sizeAbs)||0).add((null==a?void 0:a.sizeAbs)||0)}async simulateOpenPosition(){return this._contractReader.simulateOpenPosition({baseTokenAddress:this.market.baseAddress,isBaseToQuote:this.isBaseToQuote,isExactInput:this.isExactInput,amount:this.amountInput,oppositeAmountBound:p})}async getRelatedData({cache:e=!0}={}){return this._fetch("relatedData",{cache:e})}async _fetch(e,{cache:t=!0}={}){if(this._cache.has(e)&&t)return this._cache.get(e);let a;switch(e){case"swap":a=await this._perp.contractReader.getQuoterSwap({baseTokenAddress:this.market.baseAddress,amount:this.amountInput,isBaseToQuote:this.isBaseToQuote,isExactInput:this.isExactInput});break;case"relatedData":{w(this._perp.hasConnected(),(()=>new g({functionName:"getRelatedData"})));const e=await this.getExistingPositionSize({cache:!1});a=await this._perp.contractReader.getPositionDraftRelatedData({trader:this._perp.wallet.account,marketBaseAddresses:Object.values(this._perp.markets.marketMap).map((e=>e.baseAddress)),currentMarketBaseSize:e,currentMarketBaseAddress:this.market.baseAddress})}}return this._cache.set(e,a),a}}export{_ as PositionDraft};
//# sourceMappingURL=PositionDraft.js.map
