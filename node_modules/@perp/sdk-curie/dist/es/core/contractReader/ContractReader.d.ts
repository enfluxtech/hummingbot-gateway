import { BigNumber } from "ethers";
import { Contracts } from "../../contracts";
import { NonSettlementCollateralToken, SettlementToken } from "../wallet";
import Big from "big.js";
import { Metadata } from "../../metadata";
import { RetryProvider } from "../../network";
import { MarketMap } from "../market";
import { marketInfo } from "../market/Markets";
interface ContractsReaderConfig {
    contracts: Contracts;
    provider: RetryProvider;
    metadata: Metadata;
}
interface GetLiquidityPendingFeeParams {
    trader: string;
    baseTokenAddress: string;
    lowerTick: number;
    upperTick: number;
}
interface GetOpenLiquiditiesParams {
    trader: string;
    baseTokenAddress: string;
}
interface GetOpenLiquidityParams {
    trader: string;
    baseTokenAddress: string;
    lowerTick: number;
    upperTick: number;
}
export declare type GetTotalTokenAmountInPoolAndPendingFeeOfAllMarketsReturn = Record<string, {
    totalTokenAmount: Big;
    totalPendingFee: Big;
}>;
interface GetQuoterSwapParams {
    baseTokenAddress: string;
    isBaseToQuote: boolean;
    isExactInput: boolean;
    amount: Big;
}
interface SimulateOpenPositionParams {
    baseTokenAddress: string;
    isBaseToQuote: boolean;
    isExactInput: boolean;
    amount: Big;
    oppositeAmountBound: Big;
}
export interface GetQuoterSwapReturn {
    deltaAvailableBase: Big;
    deltaAvailableQuote: Big;
    exchangedPositionNotional: Big;
    exchangedPositionSize: Big;
    output: Big;
}
export interface SimulateOpenPositionReturn {
    deltaBase: Big;
    deltaQuote: Big;
}
export interface GetPositionDraftRelatedDataReturn {
    swap: {
        deltaAvailableBase: Big;
        deltaAvailableQuote: Big;
        exchangedPositionNotional: Big;
        exchangedPositionSize: Big;
        output: Big;
    };
    getPnlAndPendingFee: {
        owedPNL: Big;
        unrealizedPNL: Big;
        pendingFee: Big;
    };
    otherBaseDebts: Big[];
    otherMarketIndexPrices: Big[];
    quoteDebts: Big[];
}
export interface GetPositionDraftRelatedData {
    trader: string;
    marketBaseAddresses: string[];
    currentMarketBaseSize: Big;
    currentMarketBaseAddress: string;
}
export declare type GetOpenLiquidityReturn = {
    baseDebt: Big;
    quoteDebt: Big;
    liquidity: Big;
    lowerTick: number;
    upperTick: number;
}[][];
export interface GetMarketStatusReturn {
    isPaused: boolean;
    isClosed: boolean;
}
export declare type MarketTickSpacings = {
    [poolAddress: string]: number;
};
export declare type MarketExchangeFeeRatios = {
    [baseAddress: string]: Big;
};
export declare type MarketInsuranceFundFeeRatios = {
    [baseAddress: string]: Big;
};
interface MulticallMarketDataArgs {
    poolAddress: string;
    baseAddress: string;
    twapTimeRange: number;
}
export declare class ContractReader {
    readonly contracts: Contracts;
    private _provider;
    private _metadata;
    private _multicallReader;
    constructor({ contracts, provider, metadata }: ContractsReaderConfig);
    getNativeBalance(account: string): Promise<Big>;
    getAccountValue(account: string): Promise<Big>;
    getFreeCollateral(account: string): Promise<Big>;
    getFreeCollateralByToken(account: string, token: NonSettlementCollateralToken | SettlementToken): Promise<Big>;
    getVaultBalanceOfSettlementToken(account: string): Promise<Big>;
    getVaultBalanceByToken(account: string, token: NonSettlementCollateralToken): Promise<Big>;
    getCollateralConfig(tokenAddress: string): Promise<{
        priceFeed: string;
        collateralRatio: number;
        discountRatio: number;
        depositCap: Big;
    }>;
    getAllowanceByToken(account: string, spender: string, tokenAddress: string): Promise<Big>;
    getAllowanceOfSettlementToken(account: string, spender: string): Promise<Big>;
    getBalanceByToken(account: string, tokenAddress: string, decimals: number): Promise<Big>;
    getBalanceOfSettlementToken(account: string): Promise<Big>;
    getPriceFeedAggregator(baseTokenAddress: string): Promise<{
        address: string;
        contract: import("../../contracts/type").AggregatorV3Interface;
    }>;
    /**
     * Check if the market is paused.
     * @param baseTokenAddress - token address of baseToken
     */
    isMarketPaused(baseTokenAddress: string): Promise<boolean>;
    /**
     * Check if the market is closed.
     * @param baseTokenAddress - token address of baseToken
     */
    isMarketClosed(baseTokenAddress: string): Promise<boolean>;
    /**
     * Check if the market is paused or closed.
     * @param baseTokenAddress - token address of baseToken
     */
    getMarketStatus(baseTokenAddress: string): Promise<{
        isPaused: boolean;
        isClosed: boolean;
    }>;
    /**
     * get closed price.
     * @constructor
     * @param {string} baseTokenAddress -  token address of baseToken
     */
    getClosedPrice(baseTokenAddress: string): Promise<Big>;
    /**
     * get index price (twap index price).
     * @constructor
     * @param {string} baseTokenAddress -  token address of baseToken
     * @param {number} interval - interval of twap
     */
    getIndexPrice(baseTokenAddress: string, interval?: number): Promise<Big>;
    getSlot0(poolAddress: string): Promise<[BigNumber, number, number, number, number, number, boolean] & {
        sqrtPriceX96: BigNumber;
        tick: number;
        observationIndex: number;
        observationCardinality: number;
        observationCardinalityNext: number;
        feeProtocol: number;
        unlocked: boolean;
    }>;
    getQuoterSwap({ baseTokenAddress, isBaseToQuote, isExactInput, amount, }: GetQuoterSwapParams): Promise<GetQuoterSwapReturn>;
    getLiquidityPendingFee({ trader, baseTokenAddress, lowerTick, upperTick }: GetLiquidityPendingFeeParams): Promise<Big>;
    getOpenLiquidityIdsByMarket({ trader, baseTokenAddress }: GetOpenLiquiditiesParams): Promise<string[]>;
    getOpenLiquidityIds(marketMap: MarketMap, account: string): Promise<import("@ethersproject/abi").Result>;
    getOpenLiquidities(marketMap: MarketMap, account: string): Promise<GetOpenLiquidityReturn>;
    getOpenLiquiditiesByMarket({ trader, baseTokenAddress }: GetOpenLiquiditiesParams): Promise<{
        baseDebt: Big;
        quoteDebt: Big;
        liquidity: Big;
        lowerTick: any;
        upperTick: any;
    }[]>;
    getOpenOrder({ trader, baseTokenAddress, lowerTick, upperTick }: GetOpenLiquidityParams): Promise<{
        baseDebt: Big;
        quoteDebt: Big;
        liquidity: Big;
        lowerTick: number;
        upperTick: number;
    }>;
    getTotalTokenAmountInPoolAndPendingFeeOfAllMarkets(marketMap: MarketMap, trader: string): Promise<GetTotalTokenAmountInPoolAndPendingFeeOfAllMarketsReturn>;
    simulateOpenPosition({ baseTokenAddress, isBaseToQuote, isExactInput, amount, oppositeAmountBound, }: SimulateOpenPositionParams): Promise<{
        deltaBase: Big;
        deltaQuote: Big;
    }>;
    getMarketsBaseTokenAndQuoteTokenAmount(marketsInfo: marketInfo[]): Promise<{}>;
    getClearingHouseMetadata(): Promise<{
        mmRatio: Big;
        imRatio: Big;
        maxFundingRate: Big;
        twapInterval: Big;
        exchangeFeeRatios: Record<string, Big>;
        insuranceFundFeeRatios: Record<string, Big>;
        tickSpacings: Record<string, number>;
    }>;
    getTakerPositionSizeList(marketMap: MarketMap, account: string): Promise<Big[]>;
    getTotalPositionSizeList(marketMap: MarketMap, account: string): Promise<Big[]>;
    getTakerOpenNotionalList(marketMap: MarketMap, account: string): Promise<Big[]>;
    getTotalOpenNotionalList(marketMap: MarketMap, account: string): Promise<Big[]>;
    getTotalPositionValueList(marketMap: MarketMap, account: string): Promise<Big[]>;
    getPendingFundingPayments(marketMap: MarketMap, account: string): Promise<Record<string, Big>>;
    getMarketData(args: MulticallMarketDataArgs): Promise<{
        markPrice: Big;
        indexPrice: Big;
        indexTwapPrice: Big;
    }>;
    getPositionDraftRelatedData({ trader, marketBaseAddresses, currentMarketBaseSize, currentMarketBaseAddress, }: GetPositionDraftRelatedData): Promise<{
        swap: {
            deltaAvailableBase: any;
            deltaAvailableQuote: any;
            exchangedPositionNotional: any;
            exchangedPositionSize: any;
            output: any;
        };
        getPnlAndPendingFee: {
            owedPNL: Big;
            unrealizedPNL: Big;
            pendingFee: Big;
        };
        otherBaseDebts: any;
        otherMarketIndexPrices: any;
        quoteDebts: any;
    }>;
    getAccountValues(account: string): Promise<{
        freeCollateral: Big;
        accountValue: Big;
    }>;
    getTotalPositionValue(trader: string, baseToken: string): Promise<Big>;
    getTotalAbsPositionValue(trader: string): Promise<Big>;
    getLiquidationPrice(trader: string, baseToken: string): Promise<Big>;
    getLiquidationPriceList(marketMap: MarketMap, account: string): Promise<Big[]>;
    getClearingHouseOpenPositionAction(): Promise<number>;
    canOpenPositionFor(trader: string, delegate: string): Promise<boolean>;
}
export {};
