{"version":3,"file":"coinalpha-ref-sdk.cjs.development.js","sources":["../src/constant.ts","../src/error.ts","../src/utils.ts","../src/near.ts","../src/ref.ts","../src/instantSwap.ts","../src/pool.ts","../src/stable-swap.ts","../src/parallelSwapLogic.ts","../src/smartRoutingLogic.js","../src/swap.ts"],"sourcesContent":["export const FEE_DIVISOR = 10000;\n\nexport const STABLE_LP_TOKEN_DECIMALS = 18;\nexport const RATED_POOL_LP_TOKEN_DECIMALS = 24;\n\nexport function getConfig(env: string | undefined = process.env.NEAR_ENV) {\n  switch (env) {\n    case 'mainnet':\n      return {\n        networkId: 'mainnet',\n        nodeUrl: 'https://rpc.mainnet.near.org',\n        walletUrl: 'https://wallet.near.org',\n        WRAP_NEAR_CONTRACT_ID: 'wrap.near',\n        REF_FI_CONTRACT_ID: 'v2.ref-finance.near',\n      };\n    case 'testnet':\n      return {\n        networkId: 'testnet',\n        nodeUrl: 'https://rpc.testnet.near.org',\n        walletUrl: 'https://wallet.testnet.near.org',\n        WRAP_NEAR_CONTRACT_ID: 'wrap.testnet',\n        REF_FI_CONTRACT_ID: 'ref-finance-101.testnet',\n      };\n    default:\n      return {\n        networkId: 'mainnet',\n        nodeUrl: 'https://rpc.mainnet.near.org',\n        walletUrl: 'https://wallet.near.org',\n        REF_FI_CONTRACT_ID: 'v2.ref-finance.near',\n        WRAP_NEAR_CONTRACT_ID: 'wrap.near',\n      };\n  }\n}\n\nexport const config = getConfig();\n\nexport const REF_FI_CONTRACT_ID = config.REF_FI_CONTRACT_ID;\n\nexport const STORAGE_TO_REGISTER_WITH_MFT = '0.1';\n\nexport const ONE_YOCTO_NEAR = '0.000000000000000000000001';\n","import { getConfig } from './constant';\n\nexport const formatError = (msg: string) => {\n  return new Error(msg);\n};\n\nexport const unNamedError = formatError('Something wrong happened');\n\nexport const SameInputTokenError = formatError(\n  'Input token should be different with output token'\n);\n\nexport const ZeroInputError = formatError(\n  'Input amount should be greater than 0'\n);\n\nexport const NoPoolError = formatError('No pool found for the input tokens');\n\nexport const NotLoginError = formatError('Please login in first');\n\nexport const SwapRouteError = formatError(\n  \"Something wrong happened, we don't get correct routes corrreponding to current input\"\n);\n\nexport const TokenNotExistError = formatError(\n  `This token doesn't exist in ${getConfig().networkId}`\n);\n\nexport const NoPuiblicKeyError = formatError('No public key found');\n\nexport const NoLocalSignerError = formatError('No local signer found');\n\nexport const InValidAccessKeyError = formatError('Invalid access key');\n\nexport const AccountIdMisMatch = formatError(\n  \"Your input account id doesn't match the account id in the credential\"\n);\n\nexport const NoCredential = formatError('No Credential to such path');\n","import {\n  Pool,\n  PoolRPCView,\n  StablePool,\n  SmartRoutingInputPool,\n  Transaction,\n} from './types';\nimport {\n  RATED_POOL_LP_TOKEN_DECIMALS,\n  STABLE_LP_TOKEN_DECIMALS,\n} from './constant';\n\nimport { transactions, utils } from 'near-api-js';\n\nimport BN from 'bn.js';\n\nimport * as math from 'mathjs';\nimport { REF_FI_CONTRACT_ID } from './constant';\n\nexport const parsePool = (pool: PoolRPCView, id?: number): Pool => ({\n  id: Number(typeof id === 'number' ? id : pool.id),\n  tokenIds: pool.token_account_ids,\n  supplies: pool.amounts.reduce(\n    (acc: { [tokenId: string]: string }, amount: string, i: number) => {\n      acc[pool.token_account_ids[i]] = amount;\n      return acc;\n    },\n    {}\n  ),\n  fee: pool.total_fee,\n  shareSupply: pool.shares_total_supply,\n  tvl: pool.tvl,\n  token0_ref_price: pool.token0_ref_price,\n  pool_kind: pool.pool_kind,\n});\n\nexport const poolFormatter = (pool: Pool) => {\n  return {\n    id: pool.id,\n    token1Id: pool.tokenIds[0],\n    token2Id: pool.tokenIds[1],\n    token1Supply: pool.supplies[pool.tokenIds[0]],\n    token2Supply: pool.supplies[pool.tokenIds[1]],\n    fee: pool.fee,\n    shares: pool.shareSupply,\n    token0_price: pool.token0_ref_price || '0',\n  } as SmartRoutingInputPool;\n};\n\nexport const isStablePoolToken = (\n  stablePools: StablePool[],\n  tokenId: string | Number\n) => {\n  return stablePools\n    .map(p => p.token_account_ids)\n    .flat()\n    .includes(tokenId.toString());\n};\n\nexport const isStablePool = (\n  stablePools: StablePool[],\n  poolId: string | number\n) => {\n  return stablePools.map(p => p.id.toString()).includes(poolId.toString());\n};\n\nexport const getStablePoolDecimal = (stablePool: StablePool) => {\n  return stablePool.pool_kind === 'RATED_SWAP'\n    ? RATED_POOL_LP_TOKEN_DECIMALS\n    : STABLE_LP_TOKEN_DECIMALS;\n};\n\nexport const round = (decimals: number, minAmountOut: string) => {\n  return Number.isInteger(Number(minAmountOut))\n    ? minAmountOut\n    : Math.ceil(\n        Math.round(Number(minAmountOut) * Math.pow(10, decimals)) /\n          Math.pow(10, decimals)\n      ).toString();\n};\n\nexport const convertToPercentDecimal = (percent: number) => {\n  return math.divide(percent, 100);\n};\n\nexport const percentOf = (percent: number, num: number | string) => {\n  return math.evaluate(`${convertToPercentDecimal(percent)} * ${num}`);\n};\n\nexport const percentLess = (percent: number, num: number | string) => {\n  return math.format(math.evaluate(`${num} - ${percentOf(percent, num)}`), {\n    notation: 'fixed',\n  });\n};\n\nexport const getGas = (gas: string | undefined) =>\n  gas ? new BN(gas) : new BN('100000000000000');\n\nexport const getAmount = (amount: string) =>\n  amount ? new BN(utils.format.parseNearAmount(amount) || '0') : new BN('0');\n\nexport const ONLY_ZEROS = /^0*\\.?0*$/;\n\nexport const toReadableNumber = (\n  decimals: number,\n  number: string = '0'\n): string => {\n  if (!decimals) return number;\n\n  const wholeStr = number.substring(0, number.length - decimals) || '0';\n  const fractionStr = number\n    .substring(number.length - decimals)\n    .padStart(decimals, '0')\n    .substring(0, decimals);\n\n  return `${wholeStr}.${fractionStr}`.replace(/\\.?0+$/, '');\n};\n\nexport const toNonDivisibleNumber = (\n  decimals: number,\n  number: string\n): string => {\n  if (decimals === null || decimals === undefined) return number;\n  const [wholePart, fracPart = ''] = number.split('.');\n\n  return `${wholePart}${fracPart.padEnd(decimals, '0').slice(0, decimals)}`\n    .replace(/^0+/, '')\n    .padStart(1, '0');\n};\n\nexport const scientificNotationToString = (strParam: string) => {\n  let flag = /e/.test(strParam);\n  if (!flag || !strParam) return strParam;\n\n  let sysbol = true;\n  if (/e-/.test(strParam)) {\n    sysbol = false;\n  }\n\n  const negative = Number(strParam) < 0 ? '-' : '';\n\n  let index = Number(strParam.match(/\\d+$/)?.[0]);\n\n  let basis = strParam.match(/[\\d\\.]+/)?.[0];\n\n  if (!index || !basis) return strParam;\n\n  const ifFraction = basis.includes('.');\n\n  let wholeStr;\n  let fractionStr;\n\n  if (ifFraction) {\n    wholeStr = basis.split('.')[0];\n    fractionStr = basis.split('.')[1];\n  } else {\n    wholeStr = basis;\n    fractionStr = '';\n  }\n\n  if (sysbol) {\n    if (!ifFraction) {\n      return negative + wholeStr.padEnd(index + wholeStr.length, '0');\n    } else {\n      if (fractionStr.length <= index) {\n        return negative + wholeStr + fractionStr.padEnd(index, '0');\n      } else {\n        return (\n          negative +\n          wholeStr +\n          fractionStr.substring(0, index) +\n          '.' +\n          fractionStr.substring(index)\n        );\n      }\n    }\n  } else {\n    if (!ifFraction)\n      return (\n        negative +\n        wholeStr.padStart(index + wholeStr.length, '0').replace(/^0/, '0.')\n      );\n    else {\n      return (\n        negative +\n        wholeStr.padStart(index + wholeStr.length, '0').replace(/^0/, '0.') +\n        fractionStr\n      );\n    }\n  }\n};\n\nexport const formatWithCommas = (value: string) => {\n  const pattern = /(-?\\d+)(\\d{3})/;\n  while (pattern.test(value)) {\n    value = value.replace(pattern, '$1,$2');\n  }\n  return value;\n};\n\nexport const toPrecision = (\n  number: string,\n  precision: number,\n  withCommas: boolean = false,\n  atLeastOne: boolean = true\n): string => {\n  const [whole, decimal = ''] = number.split('.');\n\n  let str = `${withCommas ? formatWithCommas(whole) : whole}.${decimal.slice(\n    0,\n    precision\n  )}`.replace(/\\.$/, '');\n  if (atLeastOne && Number(str) === 0 && str.length > 1) {\n    var n = str.lastIndexOf('0');\n    str = str.slice(0, n) + str.slice(n).replace('0', '1');\n  }\n\n  return str;\n};\n\nexport const transformTransactions = (\n  transactions: Transaction[],\n  AccountId: string\n) => {\n  return transactions.map((t: Transaction) => {\n    return {\n      signerId: AccountId,\n      receiverId: t.receiverId,\n      actions: t.functionCalls.map(fc => {\n        return {\n          type: 'FunctionCall',\n          params: {\n            methodName: fc.methodName,\n            args: fc.args || {},\n            gas: getGas(fc.gas)\n              .toNumber()\n              .toFixed(),\n            deposit: utils.format.parseNearAmount(fc.amount || '0')!,\n          },\n        };\n      }),\n    };\n  });\n};\n","import {\n  keyStores,\n  KeyPair,\n  InMemorySigner,\n  providers,\n  transactions as nearTransactions,\n  utils,\n} from 'near-api-js';\nimport BN from 'bn.js';\nimport { getConfig } from './constant';\nimport fs from 'fs';\nimport os from 'os';\nimport {\n  NoPuiblicKeyError,\n  InValidAccessKeyError,\n  NoCredential,\n} from './error';\nimport { AccessKeyView } from 'near-api-js/lib/providers/provider';\nimport { TransformedTransaction } from './types';\nimport { Transaction } from './types';\nimport { transformTransactions } from './utils';\nimport { AccountIdMisMatch } from './error';\n\nexport const getKeyStore = () => {\n  return typeof window === 'undefined'\n    ? new keyStores.InMemoryKeyStore()\n    : new keyStores.BrowserLocalStorageKeyStore();\n};\n\nexport const provider = new providers.JsonRpcProvider({\n  url: getConfig().nodeUrl,\n});\n\nexport const getMemorySigner = async ({\n  AccountId,\n  keyPath,\n}: {\n  AccountId: string;\n  keyPath: string;\n}) => {\n  try {\n    const homedir = os.homedir();\n    const credentials = JSON.parse(\n      fs.readFileSync(homedir + keyPath).toString()\n    );\n\n    const credentialAccountId = credentials?.account_id;\n\n    if (!credentialAccountId) throw NoCredential;\n\n    if (credentialAccountId !== AccountId) throw AccountIdMisMatch;\n\n    const myKeyStore = new keyStores.InMemoryKeyStore();\n    myKeyStore.setKey(\n      getConfig().networkId,\n      AccountId,\n      KeyPair.fromString(credentials.private_key)\n    );\n\n    const signer = new InMemorySigner(myKeyStore);\n\n    return signer;\n  } catch (error) {\n    throw error;\n  }\n};\n\nconst validateAccessKey = (\n  transaction: TransformedTransaction,\n  accessKey: AccessKeyView\n) => {\n  if (accessKey.permission === 'FullAccess') {\n    return accessKey;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  const { receiver_id, method_names } = accessKey.permission.FunctionCall;\n\n  if (transaction.receiverId !== receiver_id) {\n    return null;\n  }\n\n  return transaction.actions.every(action => {\n    if (action.type !== 'FunctionCall') {\n      return false;\n    }\n\n    const { methodName, deposit } = action.params;\n\n    if (method_names.length && method_names.includes(methodName)) {\n      return false;\n    }\n\n    return parseFloat(deposit) <= 0;\n  });\n};\n\nexport const getSignedTransactionsByMemoryKey = async ({\n  transactionsRef,\n  AccountId,\n  keyPath,\n}: {\n  transactionsRef: Transaction[];\n  AccountId: string;\n  keyPath: string;\n}) => {\n  const transactions = transformTransactions(transactionsRef, AccountId);\n\n  const block = await provider.block({ finality: 'final' });\n\n  const signedTransactions: Array<nearTransactions.SignedTransaction> = [];\n  const signer = await getMemorySigner({\n    AccountId,\n    keyPath,\n  });\n\n  for (let i = 0; i < transactions.length; i += 1) {\n    const transaction = transactions[i];\n\n    const publicKey = await signer.getPublicKey(\n      AccountId,\n      getConfig().networkId\n    );\n    if (!publicKey) {\n      throw NoPuiblicKeyError;\n    }\n\n    const accessKey = await provider.query<AccessKeyView>({\n      request_type: 'view_access_key',\n      finality: 'final',\n      account_id: AccountId,\n      public_key: publicKey.toString(),\n    });\n\n    if (!validateAccessKey(transaction, accessKey)) {\n      throw InValidAccessKeyError;\n    }\n\n    const tx = nearTransactions.createTransaction(\n      AccountId,\n      utils.PublicKey.from(publicKey.toString()),\n      transactions[i].receiverId,\n      accessKey.nonce + i + 1,\n      transaction.actions.map(action => {\n        const { methodName, args, gas, deposit } = action.params;\n        return nearTransactions.functionCall(\n          methodName,\n          args,\n          new BN(gas),\n          new BN(deposit)\n        );\n      }),\n      utils.serialize.base_decode(block.header.hash)\n    );\n\n    const [, signedTx] = await nearTransactions.signTransaction(\n      tx,\n      signer,\n      transactions[i].signerId,\n      getConfig().networkId\n    );\n    signedTransactions.push(signedTx);\n  }\n\n  return signedTransactions;\n};\n\nexport const sendTransactionsByMemoryKey = async ({\n  signedTransactions,\n}: {\n  signedTransactions: nearTransactions.SignedTransaction[];\n}) => {\n  try {\n    const results: Array<providers.FinalExecutionOutcome> = [];\n\n    for (let i = 0; i < signedTransactions.length; i += 1) {\n      results.push(await provider.sendTransaction(signedTransactions[i]));\n    }\n\n    return results;\n  } catch (err) {\n    throw err;\n  }\n};\n","import { REF_FI_CONTRACT_ID, config } from './constant';\nimport { keyStores, Near, WalletConnection } from 'near-api-js';\nimport { TokenNotExistError } from './error';\nimport { getKeyStore } from './near';\n\nimport {\n  TokenMetadata,\n  FTStorageBalance,\n  RefFiViewFunctionOptions,\n} from './types';\n\n// export const keyStore = new keyStores.BrowserLocalStorageKeyStore();\n\nexport const near = new Near({\n  keyStore: getKeyStore(),\n  headers: {},\n  ...config,\n});\n\nexport const refFiViewFunction = async ({\n  methodName,\n  args,\n}: RefFiViewFunctionOptions) => {\n  const nearConnection = await near.account(REF_FI_CONTRACT_ID);\n\n  return nearConnection.viewFunction(REF_FI_CONTRACT_ID, methodName, args);\n};\n\nexport const ftViewFunction = async (\n  tokenId: string,\n  { methodName, args }: RefFiViewFunctionOptions\n) => {\n  const nearConnection = await near.account(REF_FI_CONTRACT_ID);\n\n  return nearConnection.viewFunction(tokenId, methodName, args);\n};\n\nexport const ftGetStorageBalance = (\n  tokenId: string,\n  AccountId: string\n): Promise<FTStorageBalance | null> => {\n  return ftViewFunction(tokenId, {\n    methodName: 'storage_balance_of',\n    args: { account_id: AccountId },\n  });\n};\n\nexport const getTotalPools = async () => {\n  return refFiViewFunction({\n    methodName: 'get_number_of_pools',\n  });\n};\n\nexport const ftGetTokenMetadata = async (\n  id: string\n): Promise<TokenMetadata> => {\n  const metadata = await ftViewFunction(id, {\n    methodName: 'ft_metadata',\n  }).catch(() => {\n    throw TokenNotExistError;\n  });\n\n  return { ...metadata, id };\n};\n\nexport const ftGetTokensMetadata = async (tokenIds: string[]) => {\n  const tokensMetadata = await Promise.all(\n    tokenIds.map((id: string) => ftGetTokenMetadata(id))\n  );\n\n  return tokensMetadata.reduce((pre, cur, i) => {\n    return {\n      ...pre,\n      [tokenIds[i]]: cur,\n    };\n  }, {}) as Record<string, TokenMetadata>;\n};\n","import { TokenMetadata, EstimateSwapView, Transaction } from './types';\nimport { ftGetStorageBalance } from './ref';\nimport {\n  STORAGE_TO_REGISTER_WITH_MFT,\n  REF_FI_CONTRACT_ID,\n  ONE_YOCTO_NEAR,\n} from './constant';\nimport { round, percentLess } from './utils';\nimport { toNonDivisibleNumber } from './utils';\nimport { config } from './constant';\nimport { SwapRouteError } from './error';\n\nexport const instantSwap = async ({\n  tokenIn,\n  tokenOut,\n  amountIn,\n  slippageTolerance,\n  swapTodos,\n  AccountId,\n}: {\n  tokenIn: TokenMetadata;\n  tokenOut: TokenMetadata;\n  amountIn: string;\n  slippageTolerance: number;\n  swapTodos: EstimateSwapView[];\n  AccountId: string;\n}) => {\n  const transactions: Transaction[] = [];\n\n  if (swapTodos?.at(-1)?.outputToken !== tokenOut.id) throw SwapRouteError;\n\n  const registerToken = async (token: TokenMetadata) => {\n    const tokenRegistered = await ftGetStorageBalance(\n      token.id,\n      AccountId\n    ).catch(() => {\n      throw new Error(`${token.id} doesn't exist.`);\n    });\n\n    if (tokenRegistered === null) {\n      transactions.push({\n        receiverId: token.id,\n        functionCalls: [\n          {\n            methodName: 'storage_deposit',\n            args: {\n              registration_only: true,\n              account_id: AccountId,\n            },\n            gas: '30000000000000',\n            amount: STORAGE_TO_REGISTER_WITH_MFT,\n          },\n        ],\n      });\n    }\n  };\n\n  await registerToken(tokenOut);\n  let actionsList: any = [];\n  let allSwapsTokens = swapTodos.map(s => [s.inputToken, s.outputToken]); // to get the hop tokens\n  for (let i in allSwapsTokens) {\n    let swapTokens = allSwapsTokens[i];\n    if (swapTokens[0] === tokenIn.id && swapTokens[1] === tokenOut.id) {\n      // parallel, direct hop route.\n      actionsList.push({\n        pool_id: swapTodos[i].pool.id,\n        token_in: tokenIn.id,\n        token_out: tokenOut.id,\n        amount_in: swapTodos[i].pool.partialAmountIn,\n        min_amount_out: round(\n          tokenOut.decimals,\n          toNonDivisibleNumber(\n            tokenOut.decimals,\n            percentLess(slippageTolerance, swapTodos[i].estimate)\n          )\n        ),\n      });\n    } else if (swapTokens[0] === tokenIn.id) {\n      // first hop in double hop route\n      //TODO -- put in a check to make sure this first hop matches with the next (i+1) hop as a second hop.\n      actionsList.push({\n        pool_id: swapTodos[i].pool.id,\n        token_in: swapTokens[0],\n        token_out: swapTokens[1],\n        amount_in: swapTodos[i].pool.partialAmountIn,\n        min_amount_out: '0',\n      });\n    } else {\n      // second hop in double hop route.\n      //TODO -- put in a check to make sure this second hop matches with the previous (i-1) hop as a first hop.\n      actionsList.push({\n        pool_id: swapTodos[i].pool.id,\n        token_in: swapTokens[0],\n        token_out: swapTokens[1],\n        min_amount_out: round(\n          tokenOut.decimals,\n          toNonDivisibleNumber(\n            tokenOut.decimals,\n            percentLess(slippageTolerance, swapTodos[i].estimate)\n          )\n        ),\n      });\n    }\n  }\n\n  transactions.push({\n    receiverId: tokenIn.id,\n    functionCalls: [\n      {\n        methodName: 'ft_transfer_call',\n        args: {\n          receiver_id: REF_FI_CONTRACT_ID,\n          amount: toNonDivisibleNumber(tokenIn.decimals, amountIn),\n          msg: JSON.stringify({\n            force: 0,\n            actions: actionsList,\n          }),\n        },\n        gas: '180000000000000',\n        amount: ONE_YOCTO_NEAR,\n      },\n    ],\n  });\n\n  if (tokenIn.id === config.WRAP_NEAR_CONTRACT_ID) {\n    const registered = await ftGetStorageBalance(\n      config.WRAP_NEAR_CONTRACT_ID,\n      AccountId\n    );\n    if (registered === null) {\n      await registerToken(tokenIn);\n    }\n  }\n\n  return transactions;\n};\n","import { getTotalPools, refFiViewFunction } from './ref';\nimport { Pool, PoolRPCView } from './types';\nimport { parsePool, toNonDivisibleNumber } from './utils';\nimport { unNamedError } from './error';\nimport { STABLE_LP_TOKEN_DECIMALS } from './constant';\n\nexport const DEFAULT_PAGE_LIMIT = 100;\n\nexport const getRatedPoolDetail = async ({ id }: { id: string | number }) => {\n  return refFiViewFunction({\n    methodName: 'get_rated_pool',\n    args: { pool_id: Number(id) },\n  })\n    .then(pool_info => ({\n      ...pool_info,\n      id: Number(id),\n      pool_kind: 'RATED_SWAP',\n    }))\n    .catch(() => {\n      throw unNamedError;\n    });\n};\n\nexport const getUnRatedPoolDetail = async ({ id }: { id: string | number }) => {\n  return refFiViewFunction({\n    methodName: 'get_stable_pool',\n    args: { pool_id: Number(id) },\n  })\n    .then(pool_info => ({\n      ...pool_info,\n      id: Number(id),\n      pool_kind: 'STABLE_SWAP',\n      rates: pool_info.c_amounts.map((_: any) =>\n        toNonDivisibleNumber(STABLE_LP_TOKEN_DECIMALS, '1')\n      ),\n    }))\n    .catch(() => {\n      throw unNamedError;\n    });\n};\n\nexport const getStablePools = async (stablePools: Pool[]) => {\n  return Promise.all(\n    stablePools.map(pool =>\n      pool.pool_kind === 'RATED_SWAP'\n        ? getRatedPoolDetail({ id: pool.id })\n        : getUnRatedPoolDetail({ id: pool.id })\n    )\n  );\n};\n\nexport const getRefPools = async (\n  page: number = 1,\n  perPage: number = DEFAULT_PAGE_LIMIT\n): Promise<Pool[]> => {\n  const index = (page - 1) * perPage;\n\n  const poolData: PoolRPCView[] = await refFiViewFunction({\n    methodName: 'get_pools',\n    args: { from_index: index, limit: perPage },\n  });\n\n  return poolData.map((rawPool, i) => parsePool(rawPool, i + index));\n};\n\nexport const fetchAllPools = async () => {\n  const totalPools = await getTotalPools();\n  const pages = Math.ceil(totalPools / DEFAULT_PAGE_LIMIT);\n\n  const pools = (\n    await Promise.all(\n      [...Array(pages)].fill(0).map((_, i) => getRefPools(i + 1))\n    )\n  ).flat() as Pool[];\n\n  return {\n    simplePools: pools.filter(\n      p => p.pool_kind && p.pool_kind === 'SIMPLE_POOL'\n    ),\n    unRatedPools: pools.filter(\n      p => p.pool_kind && p.pool_kind === 'STABLE_SWAP'\n    ),\n    ratedPools: pools.filter(p => p.pool_kind && p.pool_kind === 'RATED_SWAP'),\n  };\n};\n","import { StablePool } from './types';\nimport { FEE_DIVISOR } from './constant';\n\nimport {\n  toReadableNumber,\n  toNonDivisibleNumber,\n  scientificNotationToString,\n} from './utils';\n\nimport Big from 'big.js';\n\nimport _ from 'lodash';\n\nconst tradeFee = (amount: number, trade_fee: number) => {\n  return (amount * trade_fee) / FEE_DIVISOR;\n};\n\nexport const calc_d = (amp: number, c_amounts: number[]) => {\n  const token_num = c_amounts.length;\n  const sum_amounts = _.sum(c_amounts);\n  let d_prev = 0;\n  let d = sum_amounts;\n  for (let i = 0; i < 256; i++) {\n    let d_prod = d;\n    for (let c_amount of c_amounts) {\n      d_prod = (d_prod * d) / (c_amount * token_num);\n    }\n    d_prev = d;\n    const ann = amp * token_num ** token_num;\n    const numerator = d_prev * (d_prod * token_num + ann * sum_amounts);\n    const denominator = d_prev * (ann - 1) + d_prod * (token_num + 1);\n    d = numerator / denominator;\n    if (Math.abs(d - d_prev) <= 1) break;\n  }\n  return d;\n};\n\nexport const calc_y = (\n  amp: number,\n  x_c_amount: number,\n  current_c_amounts: number[],\n  index_x: number,\n  index_y: number\n) => {\n  const token_num = current_c_amounts.length;\n  const ann = amp * token_num ** token_num;\n  const d = calc_d(amp, current_c_amounts);\n  let s = x_c_amount;\n  let c = (d * d) / x_c_amount;\n  for (let i = 0; i < token_num; i++) {\n    if (i != index_x && i != index_y) {\n      s += current_c_amounts[i];\n      c = (c * d) / current_c_amounts[i];\n    }\n  }\n  c = (c * d) / (ann * token_num ** token_num);\n  const b = d / ann + s;\n  let y_prev = 0;\n  let y = d;\n  for (let i = 0; i < 256; i++) {\n    y_prev = y;\n    const y_numerator = y ** 2 + c;\n    const y_denominator = 2 * y + b - d;\n    y = y_numerator / y_denominator;\n    if (Math.abs(y - y_prev) <= 1) break;\n  }\n\n  return y;\n};\n\nexport const calc_swap = (\n  amp: number,\n  in_token_idx: number,\n  in_c_amount: number,\n  out_token_idx: number,\n  old_c_amounts: number[],\n  trade_fee: number\n) => {\n  const y = calc_y(\n    amp,\n    in_c_amount + old_c_amounts[in_token_idx],\n    old_c_amounts,\n    in_token_idx,\n    out_token_idx\n  );\n  const dy = old_c_amounts[out_token_idx] - y;\n  const fee = tradeFee(dy, trade_fee);\n  const amount_swapped = dy - fee;\n  return [amount_swapped, fee, dy];\n};\n\nexport const getSwappedAmount = (\n  tokenInId: string,\n  tokenOutId: string,\n  amountIn: string,\n  stablePool: StablePool,\n  STABLE_LP_TOKEN_DECIMALS: number\n) => {\n  const amp = stablePool.amp;\n  const trade_fee = stablePool.total_fee;\n\n  // depended on pools\n  const in_token_idx = stablePool.token_account_ids.findIndex(\n    id => id === tokenInId\n  );\n  const out_token_idx = stablePool.token_account_ids.findIndex(\n    id => id === tokenOutId\n  );\n\n  const rates = stablePool.rates.map(r =>\n    toReadableNumber(STABLE_LP_TOKEN_DECIMALS, r)\n  );\n\n  const base_old_c_amounts = stablePool.c_amounts.map(amount =>\n    toReadableNumber(STABLE_LP_TOKEN_DECIMALS, amount)\n  );\n\n  const old_c_amounts = base_old_c_amounts\n    .map((amount, i) =>\n      toNonDivisibleNumber(\n        STABLE_LP_TOKEN_DECIMALS,\n        scientificNotationToString(\n          new Big(amount || 0).times(new Big(rates[i])).toString()\n        )\n      )\n    )\n    .map(amount => Number(amount));\n\n  const in_c_amount = Number(\n    toNonDivisibleNumber(\n      STABLE_LP_TOKEN_DECIMALS,\n      scientificNotationToString(\n        new Big(amountIn).times(new Big(rates[in_token_idx])).toString()\n      )\n    )\n  );\n\n  const [amount_swapped, fee, dy] = calc_swap(\n    amp,\n    in_token_idx,\n    in_c_amount,\n    out_token_idx,\n    old_c_amounts,\n    trade_fee\n  );\n\n  return [\n    amount_swapped / Number(rates[out_token_idx]),\n    fee,\n    dy / Number(rates[out_token_idx]),\n  ];\n};\n","//@ts-nocheck\nimport Big from 'big.js';\n\nimport { Pool } from './types';\n\nBig.RM = 0;\nBig.DP = 40;\nBig.NE = -40;\nBig.PE = 40;\n\ninterface FormatedPool extends Pool {\n  x?: string;\n  y?: string;\n  gamma_bps?: Big;\n}\n\n///////////////////////////////\n// Parallel Swap Logic Below //\n///////////////////////////////\n\n/** formatPoolNew\n * This function appends to the existing standard Pool struct and adds attributes that simplify the parallel swap algorithms.\n * Adds attributes \"x\" (for input token reserves in pool), \"y\" (for output token reserves in pool), and \"gamma_bps\" (for 1- fee in bps)\n * Our convention for our algorithm has been to use \"x\" as the input token and \"y\" as the output token.\n * @param pool    AMM structure containing reserves of inputToken and outputToken\n * @param inputToken the name of the inputToken being traded in.\n * @param outputToken the name of the outputToken being traded out.\n * @returns newFormatPool\n */\nexport function formatPoolNew(\n  pool: Pool,\n  inputToken: string,\n  outputToken: string\n) {\n  let p: FormatedPool = pool;\n  let x = p.supplies[inputToken];\n  let y = p.supplies[outputToken];\n  p['gamma_bps'] = new Big(10000).minus(p.fee);\n  p['x'] = x;\n  p['y'] = y;\n  return p;\n}\n\n/** solveForMuFloat\n * This function takes the set of token pools, the total input of inputToken, and the names of inputToken and outputToken and\n * solves for the Lagrange Multiplier \"mu\". Note that mu must be allowed to be aritrary precision floating point number. Mu will\n * be used in subsequent function calls to determine the best allocations of intputToken to be made per pool.\n * For more detailed math on how this function was derived, please see the white paper:\n * https://github.com/giddyphysicist/ParallelSwapForRefFinance/blob/main/ParallelSwapWhitePaper.pdf\n * @param pools   list of pools that contain inputToken and outputToken\n * @param totalDeltaX  total allocation (among all pools) being input of inputToken\n * @param inputToken   the name of the inputToken being traded in.\n * @param outputToken   the name of the outputToken being traded out.\n * @returns mu   the lagrange multiplier value calculated for a set of pools and inputToken amount.\n */\nexport function solveForMuFloat(\n  pools: Pool[],\n  totalDeltaX: string,\n  inputToken: string,\n  outputToken: string\n) {\n  if (pools.length > 0) {\n    let numerator = new Big(totalDeltaX);\n    let denominator = new Big(0);\n\n    for (var i = 0; i < pools.length; i++) {\n      let p = formatPoolNew(pools[i], inputToken, outputToken);\n      let numAdd = new Big(p.x).times(10000).div(p.gamma_bps);\n      numerator = numerator.plus(numAdd);\n      let denomAdd = new Big(p.x)\n        .times(p.y)\n        .div(p.gamma_bps)\n        .sqrt()\n        .times(100);\n      denominator = denominator.plus(denomAdd);\n    }\n\n    const mu = new Big(numerator).div(denominator);\n    return mu;\n  } else {\n    // console.log('ERROR - could not find pools that satisfy token pair');\n    const mu = NaN;\n    return mu;\n  }\n}\n\n/** calculate_dx_float\n * Once mu has been calculated for a set of pools and total input amount, the next step is\n * determining the total allocation per pool. This function evaluates the amount of input Token to be\n * allocated to the given pool. Note, in our original algorithmic convention, the 'x' variable was for the input token,\n * and the 'y' variable was for the output token. Here, the value dx is the part of the full amount of input token X.\n * Again, the detailed formulae for these operations can be found in the white paper referenced above.\n * @param mu   the lagrange multiplier value calculated for a set of pools and inputToken amount.\n * @param pool   AMM structure containing reserves of inputToken and outputToken\n * @param inputToken the name of the inputToken being traded in.\n * @param outputToken  the name of the outputToken being traded out.\n * @returns dxFloat   the allocation amount determined for the given pool\n */\nexport function calculate_dx_float(\n  mu: number | Big,\n  pool: FormatedPool,\n  inputToken: string,\n  outputToken: string\n) {\n  let p = formatPoolNew(pool, inputToken, outputToken);\n  let radical = new Big(p.x).times(p.y).div(p.gamma_bps);\n  let dxFloat = new Big(mu)\n    .times(100)\n    .times(radical.sqrt())\n    .minus(new Big(p.x).times(10000).div(p.gamma_bps));\n  return dxFloat;\n}\n\n/** calculate_dy_float\n * Once you have an allocation amount for a given pool, you can use the AMM constant-product formula to determine\n * the expected output amount of output Token.\n * Note, here, as earlier, our algorithmic convention uses \"y\" as the output token, and so \"dy\" is the fraction of\n * the total output of output Token, assuming there could be dy contributions from other parallel pools as well.\n * @param dx_float  input allocation amount of inputToken for the given pool\n * @param pool   a structure representing the reserves and fees for a given pool.\n * @param inputToken  the name of the inputToken being traded in.\n * @param outputToken  the name of the outputToken being traded out.\n * @returns dyFloat  the expected trade out amount out of outputToken\n */\nexport function calculate_dy_float(\n  dx_float: number,\n  pool: FormatedPool,\n  inputToken: string,\n  outputToken: string\n) {\n  if (dx_float <= 0) {\n    return new Big(0);\n  }\n  let p = formatPoolNew(pool, inputToken, outputToken);\n  let dx = new Big(dx_float);\n  let denom = new Big(10000).times(p.x).plus(new Big(p.gamma_bps).times(dx));\n  let numerator = new Big(p.y).times(dx).times(p.gamma_bps);\n  let dyFloat = numerator.div(denom).round();\n  return dyFloat;\n}\n\n/** calculateOptimalOutput\n * This is the main function, which calculates optimal values of inputToken to swap into each pool.\n * @param pools  list of relevant AMM pools containing inputToken and outputToken\n * @param inputAmount   the numeric total amount of inputToken to be traded into the group of swap pools.\n * @param inputToken   the name of the inputToken being traded in.\n * @param outputToken  the name of the outputToken being traded out.\n * @returns normalizedDxArray an array containing the amount allocations of inputToken per pool in the list of pools.\n */\nexport function calculateOptimalOutput(\n  pools: Pool[],\n  inputAmount: string,\n  inputToken: string,\n  outputToken: string\n) {\n  let mu = solveForMuFloat(pools, inputAmount, inputToken, outputToken);\n  let dxArray: Big[] = new Array();\n  let negativeDxValsFlag = false;\n  for (var i = 0; i < pools.length; i++) {\n    let pool = formatPoolNew(pools[i], inputToken, outputToken);\n    let dx = calculate_dx_float(mu, pool, inputToken, outputToken);\n    if (dx.lt(0)) {\n      negativeDxValsFlag = true;\n    }\n    let dxInt = new Big(dx).round();\n    dxArray.push(dxInt);\n  }\n  if (negativeDxValsFlag) {\n    dxArray = reducePools(pools, dxArray, inputAmount, inputToken, outputToken);\n  }\n  let dxArraySum = new Big(0);\n  for (var i = 0; i < dxArray.length; i++) {\n    dxArraySum = dxArraySum.plus(dxArray[i]);\n  }\n  let tempAllocationsArray = [];\n  for (var i = 0; i < dxArray.length; i++) {\n    let ndx = new Big(dxArray[i])\n      .times(inputAmount)\n      .div(dxArraySum)\n      .round();\n    tempAllocationsArray.push(ndx);\n  }\n  let allocationsArray = checkIntegerSumOfAllocations(\n    tempAllocationsArray,\n    inputAmount\n  );\n  let normalizedDxArray = [];\n  for (var i = 0; i < allocationsArray.length; i++) {\n    let ndx = allocationsArray[i];\n    normalizedDxArray.push(BigInt(ndx));\n    pools[i]['partialAmountIn'] = ndx.toString();\n  }\n  return normalizedDxArray;\n}\n\n/** reducePools\n * This function is used to implement part of the non-linear slack variables in the lagrange - multiplier\n * solution for parallel swap. Part of what comes out of the math is that sometimes, the optimal allocation for a pool\n * can be negative, which makes no physical sense. When this occurs, that particular pool needs to be flagged and the\n * lagrange constraint applied to force the allocation to be zero.\n * This function takes an already-solved set of pools, input allocation per pool, the total input amount, and the\n * inputToken name and outputToken name, and determines which, if any, allocations need to be set to zero.\n * However, when this occurs, and a pool is essentially ignored from the list, then the calculation for mu must be re-done.\n * So the calculateOptimalOutput function is then called on the reduced set of pools, and if no negative allocation values remain,\n * then the allocations on the reduced set is determined, and values of zero are put in for the 'failed' pools.\n * @param pools  list of pools that contain inputToken and outputToken\n * @param dxArray  list of input allocation per pool\n * @param inputAmount   total amount of inputToken to be traded among the pools\n * @param inputToken    the name of the inputToken\n * @param outputToken   the name of the outputToken\n * @returns newFullDxVec  the new full list of input allocations the same length as dxArray, containing zeros for failed pools.\n */\nexport function reducePools(\n  pools: Pool[],\n  dxArray: Big[],\n  inputAmount: string,\n  inputToken: string,\n  outputToken: string\n) {\n  let goodIndices = [];\n  for (var i = 0; i < dxArray.length; i++) {\n    let dx = dxArray[i];\n    if (dx.gte(0)) {\n      goodIndices.push(i);\n    }\n  }\n  if (goodIndices.length < 1) {\n    // console.log(\"ERROR OCCURRED -- ALL DX VALUES WERE NEGATIVE\")\n    return dxArray;\n  }\n  let newPools = [];\n  for (var j = 0; j < dxArray.length; j++) {\n    if (goodIndices.includes(j)) {\n      newPools.push(pools[j]);\n    }\n  }\n  let newDxVec = calculateOptimalOutput(\n    newPools,\n    inputAmount,\n    inputToken,\n    outputToken\n  );\n  let goodInd2newdx = {};\n  for (var k = 0; k < newDxVec.length; k++) {\n    goodInd2newdx[goodIndices[k]] = newDxVec[k];\n  }\n  let newFullDxVec = [];\n  for (var ii = 0; ii < pools.length; ii++) {\n    if (goodIndices.includes(ii)) {\n      newFullDxVec.push(goodInd2newdx[ii]);\n    } else {\n      newFullDxVec.push(0);\n    }\n  }\n  return newFullDxVec;\n}\n\nexport function checkIntegerSumOfAllocations(\n  allocations: Big[] | string[] | BigInt[],\n  totalInput: Big | string | BigInt\n) {\n  var totalInput = new Big(totalInput);\n  var allocations:\n    | Big[]\n    | string[]\n    | BigInt[] = allocations.map((item: Big | string | BigInt) =>\n    new Big(item).round()\n  );\n  let alloSum = allocations\n    .map(item => new Big(item))\n    .reduce((a, b) => a.plus(b), new Big(0));\n  let offset = totalInput.minus(alloSum);\n  //get largest allocation.\n  let currMax = new Big(0);\n  let currMaxInd = 0;\n  for (var i = 0; i < allocations.length; i++) {\n    if (allocations[i].gt(currMax)) {\n      currMaxInd = i;\n      currMax = allocations[i];\n    }\n  }\n  let newAllocations = [];\n  for (var j = 0; j < allocations.length; j++) {\n    if (j === currMaxInd) {\n      newAllocations.push(allocations[j].plus(offset).toString());\n    } else {\n      newAllocations.push(allocations[j].toString());\n    }\n  }\n  return newAllocations;\n}\n","/* eslint-disable no-undef */\n////////////////////////////////////////////////////////////////////////////\n// SMART ROUTE SWAP LOGIC\n////////////////////////////////////////////////////////////////////////////\nimport Big from 'big.js';\nimport { checkIntegerSumOfAllocations } from './parallelSwapLogic';\n\nimport { TokenMetadata } from './types';\n\nimport { ftGetTokenMetadata } from './ref';\n\nimport { percentLess, toNonDivisibleNumber } from './utils';\n\nBig.RM = 0;\nBig.DP = 40;\nBig.NE = -40;\nBig.PE = 40;\n\nfunction bisqrt(value) {\n  // For some ridiculous reason, the .sqrt() method for Big decimals is extremely slow (~10-20ms),\n  // which isn't so bad until you need to use it a bunch of times.\n  // Since we're dealing with super large numbers anyway, we can convert the Big decimal number into a BigInt,\n  // then run this BigInt Newton iteration square root function instead, and then convert back into a\n  // Big number. And it speeds up the operation by a crazy factor, ~10x faster.\n  if (value < BigInt(0)) {\n    throw 'square root of negative numbers is not supported';\n  }\n\n  if (value < BigInt(2)) {\n    return value;\n  }\n\n  function newtonIteration(n, x0) {\n    const x1 = (n / x0 + x0) >> BigInt(1);\n    if (x0 === x1 || x0 === x1 - BigInt(1)) {\n      return x0;\n    }\n    return newtonIteration(n, x1);\n  }\n\n  return newtonIteration(value, BigInt(1));\n}\n\nfunction getBetaForRoute(route, path) {\n  if (!route.length) {\n    route = [route];\n  }\n  if (route.length == 1) {\n    let p = route[0];\n    var beta = new Big(p.reserves[path[0]]);\n  } else if (route.length == 2) {\n    let p1 = route[0];\n    let p2 = route[1];\n    var beta = new Big(p1.reserves[path[0]]).times(\n      new Big(p2.reserves[path[1]])\n    );\n  }\n  return beta;\n}\n\nfunction getEpsilonForRoute(route, path) {\n  if (!route.length) {\n    route = [route];\n  }\n  if (route.length == 1) {\n    // Single Hop case\n    let p = route[0];\n    let gamma = new Big(10000).minus(new Big(p.fee)).div(new Big(10000));\n    var epsilon = Big(gamma);\n  } else if (route.length == 2) {\n    //Double Hop Case\n    let p1 = route[0];\n    let p2 = route[1];\n    let gamma1 = new Big(10000).minus(new Big(p1.fee)).div(new Big(10000));\n    let gamma2 = new Big(10000).minus(new Big(p2.fee)).div(Big(10000));\n    var epsilon = new Big(p2.reserves[path[1]])\n      .times(new Big(gamma1))\n      .plus(new Big(p1.reserves[path[1]]).times(gamma1).times(gamma2));\n  }\n  return epsilon;\n}\n\nfunction getAlphaForRoute(route, path) {\n  if (!route.length) {\n    route = [route];\n  }\n  if (route.length == 1) {\n    //console.log('single hop')\n    let p = route[0];\n    let inputToken = path[0];\n    let outputToken = path[1];\n    let gamma = new Big(10000).minus(new Big(p.fee)).div(new Big(10000));\n    let key1 = p.token1Id;\n    let key2 = p.token2Id;\n    let val1 = p.token1Supply;\n    let val2 = p.token2Supply;\n    p['reserves'] = { [key1]: val1, [key2]: val2 };\n    var alpha = new Big(p.reserves[inputToken]).times(\n      new Big(p.reserves[outputToken]).times(new Big(gamma))\n    );\n  } else if (route.length == 2) {\n    //console.log('double hop')\n    let p1 = route[0];\n    let p2 = route[1];\n    let key11 = p1.token1Id;\n    let key12 = p1.token2Id;\n    let val11 = p1.token1Supply;\n    let val12 = p1.token2Supply;\n    p1['reserves'] = { [key11]: val11, [key12]: val12 };\n    let key21 = p2.token1Id;\n    let key22 = p2.token2Id;\n    let val21 = p2.token1Supply;\n    let val22 = p2.token2Supply;\n    p2['reserves'] = { [key21]: val21, [key22]: val22 };\n    let inputToken = path[0];\n    let middleToken = path[1];\n    let outputToken = path[2];\n    let gamma1 = new Big(10000).minus(Big(p1.fee)).div(new Big(10000));\n    let gamma2 = new Big(10000).minus(new Big(p2.fee)).div(new Big(10000));\n    let alpha1 = new Big(p1.reserves[inputToken])\n      .times(new Big(p1.reserves[middleToken]))\n      .times(gamma1);\n    let alpha2 = new Big(p2.reserves[middleToken])\n      .times(new Big(p2.reserves[outputToken]))\n      .times(gamma2);\n    var alpha = alpha1.times(alpha2);\n  }\n  return alpha;\n}\n\nfunction getAlphaSumFromRoutes(routes, nodeRoutes) {\n  let alphaSum = new Big(0);\n  for (var i in routes) {\n    let route = routes[i];\n    let nodeRoute = nodeRoutes[i];\n    let alpha = getAlphaForRoute(route, nodeRoute);\n    // console.log('alpha is...');\n    // console.log(alpha.toString());\n    // below, we are replacing the built-in Big sqrt() method with a\n    // newton-iteration BigInt sqrt function, to speed it up by 10x.\n    let radical = new Big(bisqrt(BigInt(new Big(alpha).round().toFixed())));\n    // let radical = new Big(alpha).sqrt();\n    let epsilon = getEpsilonForRoute(route, nodeRoute);\n    let denom = new Big(epsilon);\n    alphaSum = alphaSum.plus(radical.div(denom));\n  }\n  return alphaSum;\n}\n\nfunction getBetaSumFromRoutes(routes, nodeRoutes) {\n  let betaSum = new Big(0);\n  for (var i in routes) {\n    let route = routes[i];\n    let nodeRoute = nodeRoutes[i];\n    let num = new Big(getBetaForRoute(route, nodeRoute));\n    let denom = new Big(getEpsilonForRoute(route, nodeRoute));\n    betaSum = betaSum.plus(num.div(denom));\n  }\n  return betaSum;\n}\n\nfunction getPhiFromRoutes(routes, nodeRoutes, totalInput) {\n  let alphaSum = getAlphaSumFromRoutes(routes, nodeRoutes);\n  let betaSum = getBetaSumFromRoutes(routes, nodeRoutes);\n  let phi = new Big(totalInput).plus(betaSum).div(alphaSum);\n  return phi;\n}\n\nfunction getAllocationForRoute(phi, route, path) {\n  let alpha = getAlphaForRoute(route, path);\n  let beta = getBetaForRoute(route, path);\n  let epsilon = getEpsilonForRoute(route, path);\n  // below, we are replacing the built-in Big sqrt() method with a\n  // newton-iteration BigInt sqrt function, to speed it up by 10x.\n  let allocation = new Big(phi)\n    .abs()\n    .times(new Big(bisqrt(BigInt(new Big(alpha).round().toFixed()))))\n    .minus(beta)\n    .div(epsilon);\n  return allocation;\n}\n\nfunction getAllocationVectorForRoutes(phi, routes, nodeRoutes) {\n  let allocationVec = [];\n  for (var i in routes) {\n    allocationVec.push(getAllocationForRoute(phi, routes[i], nodeRoutes[i]));\n  }\n  return allocationVec;\n}\n\nfunction getOptimalAllocationForRoutes(routes, nodeRoutes, totalInput) {\n  // console.log(\"CALLING GET OPTIMAL ALLOCATION FOR ROUTES:\")\n  // console.log(routes)\n  var totalInput = new Big(totalInput);\n  let phi = getPhiFromRoutes(routes, nodeRoutes, totalInput);\n  // console.log('PHI CALCULATED TO BE...')\n  // console.log(phi.toString())\n  let allocations = getAllocationVectorForRoutes(phi, routes, nodeRoutes);\n  if (allocations.every(item => item.lt(new Big(0)))) {\n    allocations = allocations.map(item => item.times(new Big(-1.0)));\n  }\n  if (allocations.some(item => item.lt(new Big(0)))) {\n    allocations = reduceRoutes(routes, nodeRoutes, allocations, totalInput);\n  }\n  let sumAllocations = allocations.reduce((a, b) => a.plus(b), new Big(0));\n  let normalizedAllocations = allocations.map(a =>\n    a.div(sumAllocations).times(new Big(totalInput))\n  );\n  return normalizedAllocations;\n}\n\nfunction reduceRoutes(routes, nodeRoutes, allocationVec, totalInput) {\n  // console.log(\"RUNNING REDUCE ROUTES\")\n  var totalInput = new Big(totalInput);\n  let goodIndices = [];\n  for (var i in allocationVec) {\n    let dx = allocationVec[i];\n    // console.log('DX IS...')\n    // console.log(dx.toString())\n    if (dx.gt(new Big(0))) {\n      goodIndices.push(i);\n    }\n  }\n  // console.log('GOOD INDICES ARE...');\n  // console.log(goodIndices);\n  let newRoutes = [];\n  let newNodeRoutes = [];\n  for (var i in goodIndices) {\n    let goodIndex = goodIndices[i];\n    newRoutes.push(routes[goodIndex]);\n    newNodeRoutes.push(nodeRoutes[goodIndex]);\n  }\n  allocationVec = getOptimalAllocationForRoutes(\n    newRoutes,\n    newNodeRoutes,\n    totalInput\n  );\n  let allocationDict = {};\n  for (var i in goodIndices) {\n    allocationDict[goodIndices[i]] = allocationVec[i];\n  }\n  var allocationVecNew = [];\n  for (var i in routes) {\n    if (goodIndices.includes(i)) {\n      allocationVecNew.push(allocationDict[i]);\n    } else {\n      let zeroAllocation = new Big(0);\n      allocationVecNew.push(zeroAllocation);\n    }\n  }\n  return allocationVecNew;\n}\n\nfunction getNodeRoutesFromPathsAndPoolChains(paths, poolChains) {\n  let multiplicity = [];\n  for (var i in poolChains) {\n    let pc = poolChains[i];\n    let mul = pc\n      .map(item => item.length)\n      .reduce((elem1, elem2) => elem1 * elem2, 1);\n    multiplicity.push(mul);\n  }\n  let nodeRoutes = [];\n  for (var j in paths) {\n    let path = paths[j];\n    let m = multiplicity[j];\n    for (var k = 0; k < m; k++) {\n      nodeRoutes.push(path);\n    }\n  }\n  return nodeRoutes;\n}\n\nfunction getPoolChainFromPaths(paths, pools, threshold = 0.001) {\n  let poolChains = [];\n  for (var pathInd in paths) {\n    let path = paths[pathInd];\n    let chain = [];\n    let pairs = [];\n    for (var i = 0; i < path.length - 1; i++) {\n      pairs.push([path[i], path[i + 1]]);\n    }\n    for (var pairInd in pairs) {\n      let pair = pairs[pairInd];\n      // console.log(pair);\n      let tokenPools = getPoolsByToken1ANDToken2(pools, pair[0], pair[1]);\n      chain.push(tokenPools);\n    }\n    poolChains.push(chain);\n  }\n  // return poolChains;\n  let culledPoolChains = getCulledPoolChains(poolChains, threshold);\n\n  return culledPoolChains;\n}\n\nfunction getCulledPoolChains(poolChains, threshold = 0.001) {\n  let newChains = [];\n  for (var pathInd in poolChains) {\n    let path = poolChains[pathInd];\n    let newPath = [];\n    for (var legInd in path) {\n      let leg = path[legInd];\n      let culledPath = cullPoolsWithInsufficientLiquidity(leg, threshold);\n      newPath.push(culledPath);\n    }\n    newChains.push(newPath);\n  }\n  return newChains;\n}\n\nfunction getRoutesFromPoolChain(poolChains) {\n  let routes = [];\n  for (var pci in poolChains) {\n    let poolChain = poolChains[pci];\n    //get cartesian product of each pool chain to get the list of routes.\n    let newRoutes = cartesianProduct(poolChain);\n    routes.push(...newRoutes);\n  }\n  for (var i in routes) {\n    if (!routes[i].length) {\n      routes[i] = [routes[i]];\n    }\n  }\n  return routes;\n}\n\nfunction getOutputSingleHop(pool, inputToken, outputToken, totalInput) {\n  var totalInput = new Big(totalInput);\n  // check if pool is forward or backward for inputToken/outputToken cf. token1Id/token2Id\n  if (inputToken === pool.token1Id && outputToken === pool.token2Id) {\n    // forward Pool\n    var reserves = {\n      [inputToken]: new Big(pool.token1Supply),\n      [outputToken]: new Big(pool.token2Supply),\n    };\n  } else if (inputToken === pool.token2Id && outputToken === pool.token1Id) {\n    // reverse pool\n    var reserves = {\n      [outputToken]: new Big(pool.token1Supply),\n      [inputToken]: new Big(pool.token2Supply),\n    };\n  } else {\n    return new Big(0);\n  }\n  let gamma = new Big(10000).minus(new Big(pool.fee)).div(new Big(10000));\n  // console.log(totalInput)\n  // console.log(gamma)\n  // console.log(reserves)\n  let num = totalInput.times(gamma).times(reserves[outputToken]);\n  let denom = reserves[inputToken].plus(gamma.times(totalInput));\n  return num.div(denom);\n}\n\nfunction getOutputDoubleHop(\n  pools,\n  inputToken,\n  middleToken,\n  outputToken,\n  totalInput\n) {\n  var totalInput = new Big(totalInput);\n  for (var poolIndex in pools) {\n    let p = pools[poolIndex];\n    p['gamma'] = new Big(10000).minus(new Big(p.fee)).div(new Big(10000));\n  }\n  let p1 = pools[0];\n  let p2 = pools[1];\n\n  if (inputToken === p1.token1Id && middleToken === p1.token2Id) {\n    // forward Pool\n    p1['reserves'] = {\n      [inputToken]: new Big(p1.token1Supply),\n      [middleToken]: new Big(p1.token2Supply),\n    };\n  } else if (middleToken === p1.token1Id && inputToken === p1.token2Id) {\n    //reverse pool\n    p1['reserves'] = {\n      [middleToken]: new Big(p1.token1Supply),\n      [inputToken]: new Big(p1.token2Supply),\n    };\n  }\n\n  if (middleToken === p2.token1Id && outputToken === p2.token2Id) {\n    // forward Pool\n    p2['reserves'] = {\n      [middleToken]: new Big(p2.token1Supply),\n      [outputToken]: new Big(p2.token2Supply),\n    };\n  } else if (outputToken === p2.token1Id && middleToken === p2.token2Id) {\n    //reverse pool\n    p2['reserves'] = {\n      [outputToken]: new Big(p2.token1Supply),\n      [middleToken]: new Big(p2.token2Supply),\n    };\n  }\n\n  let c1 = new Big(p1.reserves[middleToken]);\n  let a1 = new Big(p1.reserves[inputToken]);\n  let c2 = new Big(p2.reserves[middleToken]);\n  let b2 = new Big(p2.reserves[outputToken]);\n  let gamma1 = p1.gamma;\n  let gamma2 = p2.gamma;\n  let num = totalInput\n    .times(c1)\n    .times(b2)\n    .times(gamma1)\n    .times(gamma2);\n  let denom = c2\n    .times(a1)\n    .plus(\n      totalInput.times(c2.times(gamma1).plus(c1.times(gamma1).times(gamma2)))\n    );\n  // denom = c2*a1 + totalInput * (c2*gamma1 + c1*gamma1*gamma2)\n\n  return num.div(denom);\n}\n\nfunction getOutputFromRoute(route, nodeRoute, allocation) {\n  if (new Big(allocation).eq(new Big(0))) {\n    return new Big(0);\n  } else {\n    var allocation = new Big(allocation);\n  }\n  if (!route.length) {\n    route = [route];\n  }\n  if (route.length == 1) {\n    // single hop\n    let inputToken = nodeRoute[0];\n    let outputToken = nodeRoute[1];\n    let pool = route[0];\n    var output = getOutputSingleHop(pool, inputToken, outputToken, allocation);\n  } else if (route.length == 2) {\n    // DOUBLE HOP\n    let inputToken = nodeRoute[0];\n    let middleToken = nodeRoute[1];\n    let outputToken = nodeRoute[2];\n    let pools = route;\n    var output = getOutputDoubleHop(\n      pools,\n      inputToken,\n      middleToken,\n      outputToken,\n      allocation\n    );\n  }\n  return output;\n}\n\nfunction getOptOutputVec(routes, nodeRoutes, totalInput) {\n  let allocations = getOptimalAllocationForRoutes(\n    routes,\n    nodeRoutes,\n    totalInput\n  );\n  let result = [];\n  for (var i in routes) {\n    let route = routes[i];\n    let nodeRoute = nodeRoutes[i];\n    let allocation = allocations[i];\n    let output = getOutputFromRoute(route, nodeRoute, allocation);\n    result.push(output);\n  }\n  return {\n    result: result,\n    allocations: allocations,\n  };\n  //NOTE -- I made this return an object instead of the tuple returned in python. need to check the places it is called, and specify\n  // result field instead of tuple 0 position, and allocations field instead of tuple 1 position.\n}\n\nfunction getBestOptInputAndOutputSlower(routes, nodeRoutes, totalInput) {\n  let refDict = getOptOutputVecRefined(routes, nodeRoutes, totalInput);\n  let outputRefined = refDict.result;\n  let inputRefined = refDict.allocations;\n  inputRefined = checkIntegerSumOfAllocations(inputRefined, totalInput);\n  let rawDict = getOptOutputVec(routes, nodeRoutes, totalInput);\n  let outputRaw = rawDict.result;\n  let inputRaw = rawDict.allocations;\n  inputRaw = checkIntegerSumOfAllocations(inputRaw, totalInput);\n  let res1 = new Big(0);\n  let res2 = new Big(0);\n\n  for (var n in outputRefined) {\n    res1 = res1.plus(outputRefined[n]);\n  }\n  for (var nn in outputRaw) {\n    res2 = res2.plus(outputRaw[nn]);\n  }\n  // console.log('COMPARING SINGLE HOPS VS DOUBLE')\n  // console.log(res1.toString())\n  // console.log(res2.toString())\n  if (res1.gt(res2)) {\n    return { input: inputRefined, output: res1 };\n  } else {\n    return { input: inputRaw, output: res2 };\n  }\n}\n\nfunction getBestOptInputAndOutput(routes, nodeRoutes, totalInput) {\n  // let refDict = getOptOutputVecRefined(routes, nodeRoutes, totalInput);\n  // let outputRefined = refDict.result;\n  // let inputRefined = refDict.allocations;\n  // inputRefined = checkIntegerSumOfAllocations(inputRefined, totalInput);\n  let rawDict = getOptOutputVec(routes, nodeRoutes, totalInput);\n  let outputRaw = rawDict.result;\n  let inputRaw = rawDict.allocations;\n  inputRaw = checkIntegerSumOfAllocations(inputRaw, totalInput);\n  let res1 = new Big(0);\n  let res2 = new Big(0);\n\n  let res = outputRaw\n    .map(v => new Big(v))\n    .reduce((bv1, bv2) => bv1.plus(bv2), new Big(0));\n\n  return {\n    input: inputRaw,\n    output: res,\n  };\n}\n\nfunction getBestOptOutput(routes, nodeRoutes, totalInput) {\n  let outputRefined = getOptOutputVecRefined(routes, nodeRoutes, totalInput)\n    .result;\n  let outputRaw = getOptOutputVec(routes, nodeRoutes, totalInput).result;\n  let res1 = new Big(0);\n  let res2 = new Big(0);\n\n  for (var n in outputRefined) {\n    res1 = res1.plus(outputRefined[n]);\n  }\n  for (var nn in outputRaw) {\n    res2 = res2.plus(outputRaw[nn]);\n  }\n  if (res1.gt(res2)) {\n    return res1;\n  } else {\n    return res2;\n  }\n}\n\nfunction getBestOptInput(routes, nodeRoutes, totalInput) {\n  let refDict = getOptOutputVecRefined(routes, nodeRoutes, totalInput);\n  let outputRefined = refDict.result;\n  let inputRefined = refDict.allocations;\n  inputRefined = checkIntegerSumOfAllocations(inputRefined, totalInput);\n  let rawDict = getOptOutputVec(routes, nodeRoutes, totalInput);\n  let outputRaw = rawDict.result;\n  let inputRaw = rawDict.allocations;\n  inputRaw = checkIntegerSumOfAllocations(inputRaw, totalInput);\n  let res1 = new Big(0);\n  let res2 = new Big(0);\n\n  for (var n in outputRefined) {\n    res1 = res1.plus(outputRefined[n]);\n  }\n  for (var nn in outputRaw) {\n    res2 = res2.plus(outputRaw[nn]);\n  }\n  // console.log('COMPARING SINGLE HOPS VS DOUBLE')\n  // console.log(res1.toString())\n  // console.log(res2.toString())\n  if (res1.gt(res2)) {\n    return inputRefined;\n  } else {\n    return inputRaw;\n  }\n}\n\nfunction getOptOutputVecRefined(routes, nodeRoutes, totalInput) {\n  // need to calculate full result.\n  // if direct pools exist, need to calculate parallel result. if not, this portion is set to zero output.\n\n  // need to compare between outputs of the two results above.\n\n  let initLengthRoutes = routes.length;\n  let directRouteInds = [];\n  for (var routeInd in routes) {\n    let route = routes[routeInd];\n    if (!route.length) {\n      route = [route];\n    }\n    if (route.length == 1) {\n      directRouteInds.push(routeInd);\n    }\n  }\n  // console.log('DIRECT ROUTE INDS ARE')\n  // console.log(directRouteInds)\n  // if (directRouteInds.length < 1) {\n  var fullResultAllocations = getOptimalAllocationForRoutes(\n    routes,\n    nodeRoutes,\n    totalInput\n  );\n  var fullResult = [];\n  for (var i in routes) {\n    let r = routes[i];\n    let nr = nodeRoutes[i];\n    let a = fullResultAllocations[i];\n    let output = getOutputFromRoute(r, nr, a);\n    fullResult.push(output);\n  }\n  var fullResultTotal = fullResult.reduce((a, b) => a.plus(b), new Big(0));\n\n  // } else {\n  if (directRouteInds.length > 0) {\n    // console.log('DOING SINGLE HOP ONLY')\n    let droutes = [];\n    let dnodeRoutes = [];\n    for (var dri in directRouteInds) {\n      let ind = directRouteInds[dri];\n      droutes.push(routes[ind]);\n      dnodeRoutes.push(nodeRoutes[ind]);\n    }\n    let dallocations = getOptimalAllocationForRoutes(\n      droutes,\n      dnodeRoutes,\n      totalInput\n    );\n    let dallocDict = {};\n    for (var dd in dallocations) {\n      dallocDict[directRouteInds[dd]] = dallocations[dd];\n    }\n    var pallocations = [];\n\n    for (var ii = 0; ii < initLengthRoutes; ii++) {\n      if (directRouteInds.includes(ii.toString())) {\n        //console.log('ADDING ALLOCATION FOR SINGLE ROUTE')\n        pallocations.push(dallocDict[ii]);\n      } else {\n        pallocations.push(new Big(0));\n      }\n    }\n    var presult = [];\n    for (var j in routes) {\n      let route = routes[j];\n      let nodeRoute = nodeRoutes[j];\n      let allocation = pallocations[j];\n      let output = getOutputFromRoute(route, nodeRoute, allocation);\n      presult.push(output);\n    }\n    var presultTotal = presult.reduce((a, b) => a.plus(b), new Big(0));\n  } else {\n    var presultTotal = new Big(0);\n  }\n  if (presultTotal.gt(fullResultTotal)) {\n    var result = presult;\n    var allocations = pallocations;\n  } else {\n    var result = fullResult;\n    var allocations = fullResultAllocations;\n  }\n  // NEED TO COMPARE BETWEEEN DIRECT AND MULTI HOP TO GET BEST OUTPUT\n  return {\n    result: result,\n    allocations: allocations,\n  };\n}\n\nasync function getBestOptimalAllocationsAndOutputs(\n  pools,\n  inputToken,\n  outputToken,\n  totalInput,\n  maxPathLength = 3,\n  threshold = 0.001\n) {\n  var totalInput = new Big(totalInput);\n  let paths = await getPathsFromPools(\n    pools,\n    inputToken,\n    outputToken,\n    maxPathLength\n  );\n  if (!paths.length) {\n    return {\n      allocations: [],\n      outputs: new Big(0),\n      routes: [],\n      nodeRoutes: [],\n    };\n  }\n  let poolChains = await getPoolChainFromPaths(paths, pools, threshold);\n\n  let routes = await getRoutesFromPoolChain(poolChains);\n  let nodeRoutes = await getNodeRoutesFromPathsAndPoolChains(paths, poolChains);\n  // let allocations = await getBestOptInput(routes, nodeRoutes, totalInput);\n  // // fix integer rounding for allocations:\n  // allocations = checkIntegerSumOfAllocations(allocations, totalInput);\n  // let outputs = getBestOptOutput(routes, nodeRoutes, totalInput);\n  let inputOutput = await getBestOptInputAndOutput(\n    routes,\n    nodeRoutes,\n    totalInput\n  );\n  let allocations = inputOutput.input;\n  let outputs = inputOutput.output;\n\n  return {\n    allocations: allocations,\n    outputs: outputs,\n    routes: routes,\n    nodeRoutes: nodeRoutes,\n  };\n}\n\nfunction getHopsFromRoutes(routes, nodeRoutes, allocations) {\n  let hops = [];\n  for (var i in routes) {\n    var route = routes[i];\n    var nodeRoute = nodeRoutes[i];\n    var allocation = allocations[i];\n    if (!route.length) {\n      route = [route];\n    }\n    if (!route[0]) {\n      continue;\n    }\n    let hop = {\n      pool: route[0],\n      allocation: allocation,\n      inputToken: nodeRoute[0],\n      outputToken: nodeRoute[1],\n    };\n    hops.push(hop);\n  }\n  return hops;\n}\n\nfunction distillHopsByPool(hops) {\n  // console.log('some HOPS =');\n  // console.log(hops);\n  let distilledHops = [];\n  let poolIds = [];\n  let poolId2allocation = {};\n  for (var i in hops) {\n    let hop = hops[i];\n    if (hop.allocation === '0') {\n      continue;\n    }\n    // console.log(`HOP ${i} IS...`);\n    // console.log(hop);\n    let poolId = hop.pool['id'];\n    if (poolIds.includes(poolId)) {\n      poolId2allocation[poolId] = new Big(poolId2allocation[poolId])\n        .plus(new Big(hop.allocation))\n        .toString();\n    } else {\n      poolId2allocation[poolId] = new Big(hop.allocation).toString();\n      poolIds.push(poolId);\n    }\n  }\n  // let poolsWithOrder = [...new Set(...hops.map((item) => item.pool))]\n  let keys = Object.keys(poolId2allocation);\n  for (var j in keys) {\n    var poolId = keys[j];\n    let hop = hops.filter(\n      item => item.pool.id.toString() === poolId.toString()\n    )[0];\n    let distilledHop = {\n      pool: hop.pool,\n      allocation: poolId2allocation[poolId],\n      inputToken: hop.inputToken,\n      outputToken: hop.outputToken,\n    };\n    distilledHops.push(distilledHop);\n  }\n  return distilledHops;\n}\n\nfunction getDistilledHopActions(distilledHops, slippageTolerance) {\n  let actions = [];\n  for (var i in distilledHops) {\n    let hop = distilledHops[i];\n    let expectedAmountOut = getOutputSingleHop(\n      hop.pool,\n      hop.inputToken,\n      hop.outputToken,\n      hop.allocation\n    );\n    let minimumAmountOut = new Big(expectedAmountOut)\n      .times(new Big(1).minus(new Big(slippageTolerance).div(100)))\n      .round()\n      .toString(); //Here, assume slippage tolerance is a percentage. So 1% would be 1.0\n    let action = {\n      pool_id: hop.pool.id,\n      token_in: hop.inputToken,\n      token_out: hop.outputToken,\n      amount_in: hop.allocation,\n      min_amount_out: minimumAmountOut,\n    };\n    actions.push(action);\n  }\n  return actions;\n}\nfunction getMiddleTokenTotalsFromFirstHopActions(firstHopActions) {\n  let middleTokens = [...new Set(firstHopActions.map(item => item.token_out))];\n  let middleTokenTotals = {};\n  for (var i in middleTokens) {\n    let middleToken = middleTokens[i];\n    let mtActions = firstHopActions.filter(\n      item => item.token_out === middleToken\n    );\n    let mtTotal = mtActions\n      .map(item => new Big(item.min_amount_out))\n      .reduce((a, b) => a.plus(b), new Big(0))\n      .toString();\n    middleTokenTotals[middleToken] = mtTotal;\n  }\n  return middleTokenTotals;\n}\nfunction getRoutesAndAllocationsForMiddleToken(\n  routes,\n  nodeRoutes,\n  allocations,\n  middleToken,\n  middleTokenTotal\n) {\n  // get routes that use middle token.\n  // (input route alloction) /sum(input allocations of routes with middle token) * (total_middleToken)\n  let mask = [];\n  for (var i in nodeRoutes) {\n    if (nodeRoutes[i][1] === middleToken) {\n      mask.push(true);\n    } else {\n      mask.push(false);\n    }\n  }\n  let froutes = [];\n  let fallocations = [];\n  let fnoderoutes = [];\n  for (var i in routes) {\n    if (mask[i]) {\n      froutes.push(routes[i]);\n      fallocations.push(allocations[i]);\n      fnoderoutes.push(nodeRoutes[i]);\n    }\n  }\n  let sumfallocations = fallocations.reduce(\n    (a, b) => new Big(a).plus(new Big(b)),\n    new Big(0)\n  );\n  let middleAllocations = fallocations.map(item =>\n    new Big(item).div(sumfallocations).times(new Big(middleTokenTotal))\n  );\n  let secondHopRoutes = froutes.map(item => [item[1]]);\n  let secondHopNodeRoutes = fnoderoutes.map(item => [item[1], item[2]]);\n  middleAllocations = checkIntegerSumOfAllocations(\n    middleAllocations,\n    middleTokenTotal\n  );\n  return {\n    routes: secondHopRoutes,\n    nodeRoutes: secondHopNodeRoutes,\n    allocations: middleAllocations,\n  };\n}\n\nfunction getHopActionsFromRoutes(routes, nodeRoutes, allocations) {\n  // console.log('INSIDE GET HOP ACTIONS FROM ROUTES');\n  // console.log('ROUTES ARE...');\n  // console.log(routes);\n  // console.log('NODE ROUTES ARE...');\n  // console.log(nodeRoutes);\n  // console.log('ALLOCATIONS ARE...');\n  // console.log(allocations);\n  let totalInput = allocations\n    .map(a => new Big(a))\n    .reduce((a, b) => a.plus(b), new Big(0))\n    .toString();\n  let hops = [];\n  for (var i in routes) {\n    var route = routes[i];\n    var nodeRoute = nodeRoutes[i];\n    var allocation = allocations[i];\n    if (new Big(allocation).eq(new Big(0))) {\n      continue;\n    }\n    if (!route.length) {\n      route = [route];\n    }\n    if (!route[0]) {\n      continue;\n    }\n    for (var j in route) {\n      let pool = route[j];\n      // console.log('J IS...');\n      // console.log(j);\n      // console.log('NODE ROUTE IS...');\n      // console.log(nodeRoute);\n      if (j == 0) {\n        //first hop.\n        // console.log(nodeRoute[0]);\n        // console.log(nodeRoute[1]);\n        var hop = {\n          pool: pool,\n          allocation: allocation.toString(),\n          inputToken: nodeRoute[0],\n          outputToken: nodeRoute[1],\n          nodeRoute: nodeRoute,\n          route: route,\n          allRoutes: routes,\n          allNodeRoutes: nodeRoutes,\n          totalInputAmount: totalInput,\n          allAllocations: allocations,\n        };\n        // console.log('FIRST HOP IS...');\n        // console.log(hop);\n        hops.push(hop);\n        if (nodeRoute.length > 2) {\n          var middleTokenAllocation = getOutputSingleHop(\n            pool,\n            nodeRoute[0],\n            nodeRoute[1],\n            allocation\n          );\n        }\n      } else {\n        // second hop\n        var hop = {\n          pool: pool,\n          allocation: middleTokenAllocation.toString(),\n          inputToken: nodeRoute[1],\n          outputToken: nodeRoute[2],\n          nodeRoute: nodeRoute,\n          route: route,\n          allRoutes: routes,\n          allNodeRoutes: nodeRoutes,\n          totalInputAmount: totalInput,\n          allAllocations: allocations,\n        };\n        // console.log('SECOND HOP IS...');\n        // console.log(hop);\n        hops.push(hop);\n      }\n    }\n  }\n  // console.log('HOP ACTIONS FOUND TO BE');\n  // console.log(hops);\n  return hops;\n}\n\n// TODO: Clean this function. I don't need all the \"actions\" just the hops.\n// TODO: re-order actions to ensure each route is complete with zero input for second hop before starting next route.\nfunction getActionListFromRoutesAndAllocations(\n  routes,\n  nodeRoutes,\n  allocations\n) {\n  // REPLACE THE CODE BELOW WITH THE FUNCTION HERE.\n  return getHopActionsFromRoutes(routes, nodeRoutes, allocations);\n  var actions = [];\n  var all_hops = [];\n  let firstHops = getHopsFromRoutes(routes, nodeRoutes, allocations);\n\n  firstHops = firstHops.filter(hop => new Big(hop.allocation).gt(new Big(0)));\n  all_hops.push(...firstHops);\n  let distilledFirstHops = distillHopsByPool(firstHops);\n  let firstHopActions = getDistilledHopActions(\n    distilledFirstHops,\n    slippageTolerance\n  );\n  actions.push(...firstHopActions);\n  let middleTokenTotals = getMiddleTokenTotalsFromFirstHopActions(\n    firstHopActions\n  );\n  // console.log('first hop actions are...');\n  // console.log(firstHopActions);\n  let middleTokens = Object.keys(middleTokenTotals);\n  // console.log('middle token totals are...');\n  // console.log(middleTokenTotals);\n  // console.log('middle tokens are...');\n  // console.log(middleTokens);\n  for (var tokenIndex in middleTokens) {\n    var secondHops = [];\n    let middleToken = middleTokens[tokenIndex];\n    // console.log('current middle token is ');\n    // console.log(middleToken);\n    let middleTokenTotal = middleTokenTotals[middleToken];\n    // console.log('current middle token total is...');\n    // console.log(middleTokenTotal);\n    let middleTokenRoutesWithAllocations = getRoutesAndAllocationsForMiddleToken(\n      routes,\n      nodeRoutes,\n      allocations,\n      middleToken,\n      middleTokenTotal\n    );\n    // console.log('current middle tokens routes with allocations are...');\n    // console.log(middleTokenRoutesWithAllocations);\n    let middleTokenRoutes = middleTokenRoutesWithAllocations.routes;\n    let middleTokenAllocations = middleTokenRoutesWithAllocations.allocations;\n    let middleTokenNodeRoutes = middleTokenRoutesWithAllocations.nodeRoutes;\n    // console.log('middle token routes are...');\n    // console.log(middleTokenRoutes);\n    // console.log('middle token allocations are...');\n    // console.log(middleTokenAllocations);\n    // console.log('middle token node routes are...');\n    // console.log(middleTokenNodeRoutes);\n    secondHops.push(\n      ...getHopsFromRoutes(\n        middleTokenRoutes,\n        middleTokenNodeRoutes,\n        middleTokenAllocations\n      )\n    );\n    // console.log('CURRENT SECOND HOPS', secondHops);\n    // console.log(secondHops.length);\n    // console.log(secondHops.map((hop) => hop.allocation));\n    // console.log('filter out zero allocation 2nd hops:');\n    secondHops = secondHops.filter(hop =>\n      new Big(hop.allocation).gt(new Big(0))\n    );\n    // console.log(secondHops);\n    all_hops.push(...secondHops);\n    // console.log('second hops are currently...');\n    // console.log(secondHops);\n    let distilledSecondHopsForToken = distillHopsByPool(secondHops);\n    // console.log('distilled second hops are...');\n    let secondHopActionsForToken = getDistilledHopActions(\n      distilledSecondHopsForToken,\n      slippageTolerance\n    );\n    // console.log(secondHopActionsForToken);\n    actions.push(...secondHopActionsForToken);\n  }\n\n  //TODO: NEED TO RUN INTEGER ROUNDING FUNCTION ON MIDDLE TOKEN ALLOCATIONS\n\n  // TODO: check the node routes. for double-hop cases, find the hop action for each hop.\n  // For now, we are assuming no parallel swaps if there is a double-hop.\n\n  // Possible cases:\n  //  (1) 1 single-hop.\n  //  (2) Parallel single-hop ?\n  //  (3) 1 double-hop\n  //  (4) 2 double-hops\n\n  // We only have to worry about re-ordering the actions for cases (3) and (4).\n\n  let orderedHops = orderHops(all_hops, routes, nodeRoutes, allocations);\n\n  // console.log('ALL HOPS', all_hops);\n  return orderedHops;\n  // return actions;\n}\n\nfunction orderHops(hops, routes, nodeRoutes, allocations) {\n  // first get rid of zero allocation routes\n  // console.log('NODE ROUTES ARE...');\n  // console.log(nodeRoutes);\n  let filteredRoutes = [];\n  let filteredNodeRoutes = [];\n  let filteredAllocations = [];\n  for (var i in routes) {\n    // remove zero-allocation routes.\n    let allocation = new Big(allocations[i]);\n    if (allocation.gt(new Big(0))) {\n      filteredAllocations.push(allocation);\n      filteredRoutes.push(routes[i]);\n      filteredNodeRoutes.push(nodeRoutes[i]);\n    }\n    // console.log('FILTERED NODE ROUTES ARE...');\n    // console.log(filteredNodeRoutes);\n  }\n  // next check node routes to see if it is case 1, 2, 3, or 4.\n  // Possible cases:\n  //  (1) 1 single-hop.\n  //  (2) Parallel single-hop ?\n  //  (3) 1 double-hop\n  //  (4) 2 double-hops\n\n  if (filteredNodeRoutes.length === 1) {\n    // only one route.\n    let currentNodeRoute = filteredNodeRoutes[0];\n    if (currentNodeRoute.length === 2) {\n      // case 1.\n      return hops;\n    } else {\n      // case 3. assume there are only 3 nodes (double-hop)\n      //make sure order of hops is such that input token precedes output token.\n      //make sure the amount_in for second hop is zero (which will grab all of output of first hop to use.)\n      let firstHop = hops.filter(\n        hop => hop.inputToken === currentNodeRoute[0]\n      )[0];\n      let secondHop = hops.filter(\n        hop => hop.inputToken === currentNodeRoute[1]\n      )[0];\n      // set second hop amount in to 0 so that it will use whatever was generated by hop 1.\n      secondHop.pool.partialAmountIn = '0';\n\n      let orderedHops = [firstHop, secondHop];\n      return orderedHops;\n    }\n  } else if (filteredNodeRoutes.length === 2) {\n    // two routes.\n    let lengthNodeRoutes = filteredNodeRoutes.map(nr => nr.length);\n    // sub cases:\n    // [2,2] -- parallel swap. (direct) -- case 2\n    // [2,3] -- direct swap in parallel with double hop.\n    // [3,2] -- double hop in parallel with direct swap.\n    // [3,3] -- double hop in parallel with double hop. -- case 4\n    let orderedHops = [];\n    if (arrayEquals(lengthNodeRoutes, [2, 2])) {\n      return hops;\n    } else if (arrayEquals(lengthNodeRoutes, [2, 3])) {\n      directNodeRoute = filteredNodeRoutes[0];\n      doubleNodeRoute = filteredNodeRoutes[1];\n      let firstHop = hops.filter(\n        hop =>\n          hop.inputToken === directNodeRoute[0] &&\n          hop.outputToken === directNodeRoute[1]\n      )[0];\n      let secondHop = hops.filter(\n        hop => hop.inputToken === doubleNodeRoute[0]\n      )[0];\n      let thirdHop = hops.filter(\n        hop => hop.outputToken === doubleNodeRoute[2]\n      )[0];\n      // set third hop amount in to 0 so that it will use whatever was generated by hop 2.\n      thirdHop.pool.partialAmountIn = '0';\n      orderedHops = [firstHop, secondHop, thirdHop];\n      return orderedHops;\n    } else if (arrayEquals(lengthNodeRoutes, [3, 2])) {\n      directNodeRoute = filteredNodeRoutes[1];\n      doubleNodeRoute = filteredNodeRoutes[0];\n      let firstHop = hops.filter(\n        hop =>\n          hop.inputToken === directNodeRoute[0] &&\n          hop.outputToken === directNodeRoute[1]\n      )[0];\n      let secondHop = hops.filter(\n        hop => hop.inputToken === doubleNodeRoute[0]\n      )[0];\n      let thirdHop = hops.filter(\n        hop => hop.outputToken === doubleNodeRoute[2]\n      )[0];\n      // set third hop amount in to 0 so that it will use whatever was generated by hop 2.\n      thirdHop.pool.partialAmountIn = '0';\n      orderedHops = [firstHop, secondHop, thirdHop];\n      return orderedHops;\n    } else if (arrayEquals(lengthNodeRoutes, [3, 3])) {\n      orderedHops = [];\n\n      for (var i in filteredNodeRoutes) {\n        let doubleNodeRoute = filteredNodeRoutes[i];\n        let doubleHopMiddleToken = doubleNodeRoute[1];\n        let firstHop = hops.filter(\n          hop =>\n            hop.inputToken === doubleNodeRoute[0] &&\n            hop.outputToken === doubleHopMiddleToken\n        )[0];\n        let secondHop = hops.filter(\n          hop =>\n            hop.inputToken === doubleHopMiddleToken &&\n            hop.outputToken === doubleNodeRoute[2]\n        )[0];\n        // set second hop amount in to 0 so that it will use whatever was generated by hop 1.\n        secondHop.pool.partialAmountIn = '0';\n        orderedHops.push(firstHop);\n        orderedHops.push(secondHop);\n      }\n      return orderedHops;\n    } else {\n      return hops;\n    }\n    for (var i in filteredNodeRoutes) {\n      let currentNodeRoute = filteredNodeRoutes[i];\n      if (currentNodeRoute.length === 2) {\n      }\n    }\n  }\n\n  return hops;\n}\n\n// function getActionListFromRoutesAndAllocationsORIG(\n//   routes,\n//   nodeRoutes,\n//   allocations,\n//   slippageTolerance\n// ) {\n//   let actions = [];\n//   for (var i in routes) {\n//     let route = routes[i];\n//     let nodeRoute = nodeRoutes[i];\n//     let allocation = new Big(allocations[i]);\n//     if (allocation.eq(new Big(0))) {\n//       continue;\n//     }\n//     if (!route.length) {\n//       route = [route];\n//     }\n//     if (route.length === 1) {\n//       //single hop. only one action.\n//       let pool = route[0];\n//       let poolId = pool.id;\n//       let inputToken = nodeRoute[0];\n//       let outputToken = nodeRoute[1];\n//       let expectedAmountOut = getOutputSingleHop(\n//         pool,\n//         inputToken,\n//         outputToken,\n//         allocation\n//       );\n//       let minimumAmountOut = expectedAmountOut\n//         .times(new Big(1).minus(new Big(slippageTolerance).div(100)))\n//         .round()\n//         .toString(); //Here, assume slippage tolerance is a percentage. So 1% would be 1.0\n//       let action = {\n//         pool_id: poolId,\n//         token_in: inputToken,\n//         token_out: outputToken,\n//         amount_in: allocation.round().toString(),\n//         min_amount_out: minimumAmountOut.toString(),\n//       };\n//       actions.push(action);\n//     } else if (route.length === 2) {\n//       // double hop. two actions.\n//       let pool1 = route[0];\n//       let pool2 = route[1];\n//       let pool1Id = pool1.id;\n//       let pool2Id = pool2.id;\n//       let inputToken = nodeRoute[0];\n//       let middleToken = nodeRoute[1];\n//       let outputToken = nodeRoute[2];\n//       let expectedAmountOutFirstHop = getOutputSingleHop(\n//         pool1,\n//         inputToken,\n//         middleToken,\n//         allocation\n//       );\n//       let minimumAmountOutFirstHop = expectedAmountOutFirstHop\n//         .times(new Big(1).minus(new Big(slippageTolerance).div(100)))\n//         .round()\n//         .toString(); //Here, assume slippage tolerance is a percentage. So 1% would be 1.0\n\n//       let action1 = {\n//         pool_id: pool1Id,\n//         token_in: inputToken,\n//         token_out: middleToken,\n//         amount_in: allocation.round().toString(),\n//         min_amount_out: minimumAmountOutFirstHop,\n//       };\n//       let expectedFinalAmountOut = getOutputSingleHop(\n//         pool2,\n//         middleToken,\n//         outputToken,\n//         minimumAmountOutFirstHop\n//       );\n//       let minimumAMountOutSecondHop = expectedFinalAmountOut\n//         .times(new Big(1).minus(new Big(slippageTolerance).div(100)))\n//         .round()\n//         .toString();\n//       let action2 = {\n//         pool_id: pool2Id,\n//         token_in: middleToken,\n//         token_out: outputToken,\n//         amount_in: minimumAmountOutFirstHop,\n//         min_amount_out: minimumAMountOutSecondHop,\n//       };\n//       actions.push(action1);\n//       actions.push(action2);\n//     }\n//   }\n//   return actions;\n// }\n\nfunction* range(start, end) {\n  for (; start <= end; ++start) {\n    yield start;\n  }\n}\n\nfunction last(arr) {\n  return arr[arr.length - 1];\n}\n\nfunction* numericCombinations(n, r, loc = []) {\n  var idx = loc.length;\n  if (idx === r) {\n    yield loc;\n    return;\n  }\n  for (let next of range(idx ? last(loc) + 1 : 0, n - r + idx)) {\n    yield* numericCombinations(n, r, loc.concat(next));\n  }\n}\n\nfunction* combinations(arr, r) {\n  for (let idxs of numericCombinations(arr.length, r)) {\n    yield idxs.map(i => arr[i]);\n  }\n}\n\n//     #middleTokenTotals = getMiddleTokenTotals(routes,nodeRoutes,allocations)\n//     #TODO: complete this function with middle token checks.\n\n//     #consider all routes of length 2 with non-zero allocation. (double-hops)\n//     # among these, check for parallel swaps. That is, check for common node routes\n//     # for first hop. Then check for common node routes on second hop.\n//     # when common node routes occur for the first hop:\n//     # 1. Calculate the total expected output of intermediate token.\n//     # 2.\n//     # when common node routes occur for the second hop:\n//     # 1. get a ratio of the input allocations of the full routes associated with\n//     # these common node routes. allocate the total intermediate token output\n//     # toward these 2nd hop routes in the same ratio as their route input allocations.\n\nexport async function getSmartRouteSwapActions(\n  pools,\n  inputToken,\n  outputToken,\n  totalInput,\n  maxPathLength = 3,\n  threshold = 0.001,\n  numberOfRoutesLimit = 2,\n  MAX_NUMBER_PARALLEL_POOLS = 4,\n  decimalsCulledPoolIds = []\n) {\n  if (!totalInput) {\n    return [];\n  }\n  var totalInput = new Big(totalInput);\n\n  // remove pools that have an id from the decimalCulledPoolIds\n  pools = pools.filter(p => !decimalsCulledPoolIds.includes(p.id));\n\n  let resDict = await getBestOptimalAllocationsAndOutputs(\n    pools,\n    inputToken,\n    outputToken,\n    totalInput,\n    maxPathLength,\n    threshold\n  );\n\n  let allocations = resDict.allocations;\n\n  // let outputs = resDict.outputs;\n  let routes = resDict.routes;\n  let nodeRoutes = resDict.nodeRoutes;\n\n  let sortedIndexValues = argsort(allocations);\n  let topIndices = sortedIndexValues.slice(0, 10);\n  var reducedRoutes = [];\n  var reducedNodeRoutes = [];\n  for (var ind of topIndices) {\n    reducedRoutes.push(routes[ind]);\n    reducedNodeRoutes.push(nodeRoutes[ind]);\n  }\n  routes = reducedRoutes;\n  nodeRoutes = reducedNodeRoutes;\n\n  // TODO: compare pairs of routes to get the best allocation pair-wise.\n  var currentBestOutput = new Big(0);\n  var bestResDict = { routes: [] };\n  var bestAllocations = resDict.allocations;\n  var bestNodeRoutes = resDict.nodeRoutes;\n  var bestRoutes = resDict.routes;\n  // first check parallel swap with 4 actions. store result.\n  var parallelNodeRoutes = [];\n  var parallelRoutes = [];\n  for (var n in bestRoutes) {\n    let currentNodeRoute = bestNodeRoutes[n];\n    if (currentNodeRoute.length == 2) {\n      parallelNodeRoutes.push(currentNodeRoute);\n      parallelRoutes.push(bestRoutes[n]);\n    }\n  }\n  // console.log(`${parallelNodeRoutes.length} parallel routes found...`);\n  var bestRoutesAreParallel = false;\n  if (parallelNodeRoutes.length > 0) {\n    // first calculate the expected result using only parallel routes.\n    // let filteredAllocationsAndOutputs = getOptOutputVecRefined(parallelRoutes, parallelNodeRoutes, totalInput);\n    let filteredAllocationsAndOutputs = getOptOutputVec(\n      parallelRoutes,\n      parallelNodeRoutes,\n      totalInput\n    );\n    let parallellAllocations = filteredAllocationsAndOutputs.allocations;\n    let parallelOutputs = filteredAllocationsAndOutputs.result;\n\n    if (parallellAllocations.length > MAX_NUMBER_PARALLEL_POOLS) {\n      // now sort by allocation value to the top 4 parallel swaps:\n      let sortIndices = argsort(parallellAllocations);\n\n      sortIndices = sortIndices.slice(0, MAX_NUMBER_PARALLEL_POOLS);\n      var filteredParallelRoutes = [];\n      var filteredParallelNodeRoutes = [];\n      for (var i in sortIndices) {\n        filteredParallelRoutes.push(parallelRoutes[sortIndices[i]]);\n        filteredParallelNodeRoutes.push(parallelNodeRoutes[sortIndices[i]]);\n      }\n      filteredAllocationsAndOutputs = getOptOutputVec(\n        filteredParallelRoutes,\n        filteredParallelNodeRoutes,\n        totalInput\n      );\n      parallellAllocations = filteredAllocationsAndOutputs.allocations;\n      parallelOutputs = filteredAllocationsAndOutputs.result;\n    }\n\n    let parallelOutput = parallelOutputs.reduce(\n      (a, b) => a.plus(b),\n      new Big(0)\n    );\n    if (new Big(parallelOutput).gt(currentBestOutput)) {\n      bestAllocations = parallellAllocations;\n      currentBestOutput = parallelOutput;\n      // console.log(\n      //   'BEST OUTPUT FROM PARALLEL SWAPS IS NOW... ',\n      //   currentBestOutput.toString()\n      // );\n      bestRoutes = parallelRoutes;\n      bestNodeRoutes = parallelNodeRoutes;\n      bestRoutesAreParallel = true;\n    }\n  }\n  var canHaveTwoRoutes = false;\n  // initialize this variable to check if we can have two routes, or if all routes share a pool for an edge case.\n  // console.log('THE NUMBER OF ROUTES IS...', routes.length);\n\n  for (var i in routes) {\n    for (var j in routes) {\n      if (j > i) {\n        var route1 = routes[i];\n        var route2 = routes[j];\n        var nodeRoute1 = nodeRoutes[i];\n        var nodeRoute2 = nodeRoutes[j];\n        // check if they share a pool.\n        let route1PoolIds = new Set(route1.map(r => r.id));\n        let route2PoolIds = new Set(route2.map(r => r.id));\n        var sharePool = false;\n        for (var route1PoolId of route1PoolIds) {\n          if (route2PoolIds.has(route1PoolId)) {\n            sharePool = true;\n          }\n        }\n        if (sharePool) {\n          // routes are not independent. skip this pair.\n          // console.log('skipping this pair because pool was shared.');\n          continue;\n        } else {\n          canHaveTwoRoutes = true;\n          let currentRoutes = [route1, route2];\n          let currentNodeRoutes = [nodeRoute1, nodeRoute2];\n\n          let filteredAllocationsAndOutputs = getOptOutputVec(\n            currentRoutes,\n            currentNodeRoutes,\n            totalInput\n          );\n\n          let filteredAllocations = filteredAllocationsAndOutputs.allocations;\n          let filteredOutputs = filteredAllocationsAndOutputs.result;\n          // console.log('FILTERED ALLOCATIONS:');\n          // console.log(filteredAllocations.map((i) => i.toString()));\n          // console.log(filteredOutputs);\n          let totalOutput = filteredOutputs.reduce(\n            (a, b) => a.plus(b),\n            new Big(0)\n          );\n          if (new Big(totalOutput).gt(currentBestOutput)) {\n            bestAllocations = filteredAllocations;\n            currentBestOutput = totalOutput;\n            // console.log('BEST OUTPUT IS NOW... ', currentBestOutput.toString());\n            bestRoutes = currentRoutes;\n            bestNodeRoutes = currentNodeRoutes;\n            bestRoutesAreParallel = false;\n            // bestResDict = currentResDict\n          }\n\n          // if (currentResDict.outputs.gt(currentBestOutput)) {\n          // console.log('DIFF IS...', currentResDict.outputs.minus(currentBestOutput).toString());\n          // bestResDict = currentResDict;\n          // currentBestOutput = bestResDict.outputs;\n          // console.log('BEST OUTPUT IS NOW... ', currentBestOutput.toString());\n          // console.log(bestResDict.routes);\n          // console.log(bestResDict.allocations.map((i) => i.toString()));\n          // console.log(bestResDict.outputs.toString());\n        }\n      }\n    }\n  }\n\n  if (!canHaveTwoRoutes) {\n    // now we need to check through the routes in single manner to find the best one:\n    for (var i in routes) {\n      let currentRoutes = [routes[i]];\n      let currentNodeRoutes = [nodeRoutes[i]];\n      // let filteredAllocationsAndOutputs = getOptOutputVecRefined(currentRoutes, currentNodeRoutes, totalInput);\n      let filteredAllocationsAndOutputs = getOptOutputVec(\n        currentRoutes,\n        currentNodeRoutes,\n        totalInput\n      );\n\n      let filteredAllocations = filteredAllocationsAndOutputs.allocations;\n      let filteredOutputs = filteredAllocationsAndOutputs.result;\n      // console.log('FILTERED ALLOCATIONS:');\n      // console.log(filteredAllocations.map((i) => i.toString()));\n      // console.log(filteredOutputs);\n      let totalOutput = filteredOutputs.reduce((a, b) => a.plus(b), new Big(0));\n      if (new Big(totalOutput).gt(currentBestOutput)) {\n        bestAllocations = filteredAllocations;\n        currentBestOutput = totalOutput;\n        // console.log('BEST OUTPUT IS NOW... ', currentBestOutput.toString());\n        bestRoutes = currentRoutes;\n        bestNodeRoutes = currentNodeRoutes;\n        bestRoutesAreParallel = false;\n        // bestResDict = currentResDict\n      }\n    }\n  }\n\n  // resDict = bestResDict;\n\n  allocations = bestAllocations;\n\n  // let outputs = resDict.outputs;\n  routes = bestRoutes;\n  nodeRoutes = bestNodeRoutes;\n\n  if (routes.length < 1) {\n    return [];\n  }\n\n  // check the top numberOfRoutesLimit\n  // console.log('initial allocations are...');\n  // console.log(allocations.map((a) => a.toString()));\n  // console.log('fixed allocations are...');\n  // console.log(allocations.map((a) => new Big(a).toFixed()));\n  //SORT BY ALLOCATIONS\n  let allSortedIndices = argsort(allocations.map(a => new Big(a)));\n  if (bestRoutesAreParallel) {\n    numberOfRoutesLimit = 4;\n  }\n  let sortedIndices = allSortedIndices.slice(0, numberOfRoutesLimit);\n\n  // console.log('sorted Indices are');\n  // console.log(sortedIndices);\n  var filteredRoutes = [];\n  var filteredNodeRoutes = [];\n  for (var i in sortedIndices) {\n    let index = sortedIndices[i];\n    filteredRoutes.push(routes[index]);\n    filteredNodeRoutes.push(nodeRoutes[index]);\n  }\n\n  // console.log('filteredRoutes are ...');\n  // console.log(filteredRoutes);\n  for (var i in filteredRoutes) {\n    if (!filteredRoutes[i].length) {\n      filteredRoutes[i] = [filteredRoutes[i]];\n    }\n  }\n  // console.log('filtered Node routes are...');\n  // console.log(filteredNodeRoutes);\n\n  // THE BELOW CODE WILL ENSURE THAT ROUTES ARE INDEPENDENT (e.g. THE ROUTES WILL NOT SHARE A POOL)\n\n  let route1PoolIds = filteredRoutes[0].map(pool => pool.id);\n  // console.log('route 1 pool ids:');\n  // console.log(route1PoolIds);\n  if (filteredRoutes.length > 1) {\n    let route2PoolIds = filteredRoutes[1].map(pool => pool.id);\n    // console.log('route 2 pool ids:');\n    // console.log(route2PoolIds);\n    var sharedRoute = false;\n    for (var i in route2PoolIds) {\n      if (route1PoolIds.includes(route2PoolIds[i])) {\n        // a pool was shared between routes. need to calculate a new second route.\n        // console.log(\n        //   'a pool was shared between routes. going to calculate a new second route'\n        // );\n        sharedRoute = true;\n        break;\n      }\n    }\n  }\n\n  // NOTE -- this is a much simpler solution than that below. Instead of choosing the next best second route that doesn't share a\n  // pool with the first route, we could just use the first route and allocate all inputs to it.\n  // but, for larger transactions, it would be better to have option of two independent routes to spread out slippage.\n\n  // if (sharedRoute) {\n  //   filteredRoutes = [filteredRoutes[0]];\n  //   filteredNodeRoutes = [filteredNodeRoutes[0]];\n  //   // TODO -- later can add in a second route that doesn't share a pool with first.\n  // }\n\n  // We're going to find the next-highest allocation route that doesn't share a pool with the first route.\n  if (sharedRoute) {\n    let allFilteredRoutes = [];\n    let allFilteredNodeRoutes = [];\n    for (var i in allSortedIndices) {\n      allFilteredRoutes.push(routes[allSortedIndices[i]]);\n      allFilteredNodeRoutes.push(nodeRoutes[allSortedIndices[i]]);\n    }\n    let firstRoute = allFilteredRoutes[0];\n    // console.log('first route is...');\n    // console.log(firstRoute);\n    let firstRoutePoolIds = firstRoute.map(pool => pool.id);\n    for (var i in allFilteredRoutes) {\n      if (!allFilteredRoutes[i].length) {\n        allFilteredRoutes[i] = [allFilteredRoutes[i]];\n      }\n    }\n    // console.log('FIRST ROUTE POOL IDS ARE');\n    // console.log(firstRoutePoolIds);\n    let allFilteredRouteIds = allFilteredRoutes.map(route =>\n      route.map(pool => pool.id)\n    );\n    // console.log('allFilteredRouteIds are ...');\n    // console.log(allFilteredRouteIds);\n    for (var i in allFilteredRouteIds) {\n      // console.log('i is', i);\n      // console.log('ALL FILTERED ROUTES [i] IS...');\n      // console.log(allFilteredRouteIds[i]);\n      for (var j in allFilteredRouteIds[i]) {\n        // console.log('j is', j);\n        // console.log('ALL FILTERED ROUTES [i][j] IS...');\n        // console.log(allFilteredRouteIds[i][j]);\n        if (firstRoutePoolIds.includes(allFilteredRouteIds[i][j])) {\n          break;\n        }\n\n        var secondRoute = allFilteredRoutes[i];\n        if (!secondRoute.length) {\n          secondRoute = [secondRoute];\n        }\n        filteredRoutes = [allFilteredRoutes[0], secondRoute];\n        filteredNodeRoutes = [\n          allFilteredNodeRoutes[0],\n          allFilteredNodeRoutes[i],\n        ];\n        break;\n      }\n    }\n    // console.log('new filteredRoutes are ...');\n    // console.log(filteredRoutes);\n    // console.log('new filtered Node routes are...');\n    // console.log(filteredNodeRoutes);\n  }\n\n  // let filteredAllocations_check = getBestOptInput(\n  //   filteredRoutes,\n  //   filteredNodeRoutes,\n  //   totalInput\n  // );\n  // let filteredAllocationsAndOutputs = getOptOutputVecRefined(filteredRoutes, filteredNodeRoutes, totalInput);\n  let filteredAllocationsAndOutputs = getOptOutputVec(\n    filteredRoutes,\n    filteredNodeRoutes,\n    totalInput\n  );\n\n  let filteredAllocations = filteredAllocationsAndOutputs.allocations;\n  let filteredOutputs = filteredAllocationsAndOutputs.result;\n\n  filteredAllocations = checkIntegerSumOfAllocations(\n    filteredAllocations,\n    totalInput\n  ).map(stringAllo => new Big(stringAllo));\n\n  let hops = getActionListFromRoutesAndAllocations(\n    filteredRoutes,\n    filteredNodeRoutes,\n    filteredAllocations\n  );\n\n  var actions = [];\n  // console.log('hops are...');\n  // console.log(hops);\n\n  for (var i in hops) {\n    let hopInputTokenMeta = await ftGetTokenMetadata(hops[i].inputToken);\n    let hopOutputTokenMeta = await ftGetTokenMetadata(hops[i].outputToken);\n    let hopOutputTokenDecimals = hopOutputTokenMeta.decimals;\n\n    let expectedHopOutput = getOutputSingleHop(\n      hops[i].pool,\n      hops[i].inputToken,\n      hops[i].outputToken,\n      hops[i].allocation\n    );\n    let decimalEstimate = new Big(expectedHopOutput)\n      .div(new Big(10).pow(hopOutputTokenDecimals))\n      .toString();\n\n    // Need to check if expected Hop Output is > 1. If not, then cull the corresponding pool and re-calculate.\n    if (new Big(expectedHopOutput).lt(new Big(1))) {\n      // purge the pool and recalculate.\n\n      decimalsCulledPoolIds.push(hops[i].pool.id);\n      return getSmartRouteSwapActions(\n        pools,\n        inputToken,\n        outputToken,\n        totalInput,\n        (maxPathLength = maxPathLength),\n        (threshold = threshold),\n        (numberOfRoutesLimit = numberOfRoutesLimit),\n        (MAX_NUMBER_PARALLEL_POOLS = MAX_NUMBER_PARALLEL_POOLS),\n        (decimalsCulledPoolIds = decimalsCulledPoolIds)\n      );\n    }\n\n    if (\n      hops[i].inputToken == inputToken &&\n      hops[i].outputToken == outputToken\n    ) {\n      var status = 'parallel swap';\n    } else {\n      var status = 'stableSmart';\n    }\n\n    let tokens = await Promise.all(\n      hops[i].nodeRoute.map(async t => await ftGetTokenMetadata(t))\n    );\n\n    actions[i] = {\n      estimate: decimalEstimate,\n      pool: {\n        fee: hops[i].pool.fee,\n        gamma_bps: new Big(10000).minus(new Big(hops[i].pool.fee)), //.div(new Big(10000)), //hops[i].pool.gamma, //new Big(10000).minus(new Big(hops[i].pool.fee)).div(new Big(10000));\n        id: hops[i].pool.id,\n        partialAmountIn: new Big(hops[i].allocation).round().toString(),\n        supplies: {\n          [hops[i].pool.token1Id]: hops[i].pool.token1Supply,\n          [hops[i].pool.token2Id]: hops[i].pool.token2Supply,\n        },\n        token0_ref_price: hops[i].pool.token0_price,\n        tokenIds: [hops[i].pool.token1Id, hops[i].pool.token2Id],\n        Dex: hops[i].pool.Dex,\n      },\n      status: status,\n      token: hopInputTokenMeta,\n      outputToken: hops[i].outputToken,\n      inputToken: hops[i].inputToken,\n      nodeRoute: hops[i].nodeRoute,\n      route: hops[i].route,\n      allRoutes: hops[i].allRoutes,\n      allNodeRoutes: hops[i].allNodeRoutes,\n      totalInputAmount: hops[i].totalInputAmount,\n      allAllocations: hops[i].allAllocations,\n      tokens: tokens,\n      routeInputToken: inputToken,\n      routeOutputToken: outputToken,\n      overallPriceImpact: '0',\n    };\n    // console.log('INPUT TOKEN IS...');\n    // console.log(hops[i].inputToken);\n    actions[i].pool.x = actions[i].pool.supplies[hops[i].inputToken];\n    actions[i].pool.y = actions[i].pool.supplies[hops[i].outputToken];\n  }\n  // now set partial amount in for second hops equal to zero:\n  // also, set the total price impact value.\n  let overallPriceImpact = await calculateSmartRouteV2PriceImpact(actions);\n  for (var i in actions) {\n    let action = actions[i];\n    action.overallPriceImpact = overallPriceImpact;\n    if (action.outputToken === outputToken && action.inputToken != inputToken) {\n      // only want to set second hop partial amount in to zero\n      action.pool.partialAmountIn = '0';\n    }\n  }\n\n  return actions;\n}\n\nasync function calculateSmartRouteV2PriceImpact(actions) {\n  // the goal is to take a weighted average of the price impact per route, treating each one at a time.\n  // for single hop (parallel swaps), the price impact is calculated as before.\n  // for double-hop, the market price, P, is determined using reserves of tokens in each pool in the route.\n  // in both cases, we compare the 'market price', P , determined solely by reserves in pools, and the actual\n  // average price, R,  expected to be paid in the transaction.\n  // the price impact is then defined as (P-R)/R * 100 and is a percentage number, returned as a string.\n\n  let deltaY = actions\n    .filter(a => a.outputToken == a.routeOutputToken)\n    .map(a => new Big(a.estimate))\n    .reduce((a, b) => a.plus(b), new Big(0));\n  // console.log('DELTA Y IS...');\n  // console.log(deltaY.toString());\n\n  let inputTokenMeta = actions[0].tokens[0];\n  let deltaX = new Big(actions[0].totalInputAmount).div(\n    new Big(10).pow(inputTokenMeta.decimals)\n  );\n  let R = deltaY.div(deltaX);\n  var P = new Big(0);\n  let routes = actions[0].allRoutes;\n  let nodeRoutes = actions[0].allNodeRoutes;\n  let allocations = actions[0].allAllocations.map(a => new Big(a));\n  let totalAllocations = allocations\n    .map(a => new Big(a))\n    .reduce((a, b) => a.plus(b), new Big(0));\n\n  let weights = allocations.map(a => a.div(totalAllocations));\n\n  for (var i in routes) {\n    let route = routes[i];\n    let nodeRoute = nodeRoutes[i];\n    let tokens = await Promise.all(\n      nodeRoute.map(async t => await ftGetTokenMetadata(t))\n    );\n    let weight = weights[i];\n    if (route.length == 1) {\n      let num = new Big(route[0].reserves[nodeRoute[0]]).div(\n        new Big(10).pow(tokens[0].decimals)\n      );\n      let denom = new Big(route[0].reserves[nodeRoute[1]]).div(\n        new Big(10).pow(tokens[1].decimals)\n      );\n      var routeMarketPrice = num.div(denom);\n    } else {\n      let num1 = new Big(route[0].reserves[nodeRoute[0]]).div(\n        new Big(10).pow(tokens[0].decimals)\n      );\n\n      let denom1 = new Big(route[0].reserves[nodeRoute[1]]).div(\n        new Big(10).pow(tokens[1].decimals)\n      );\n\n      let num2 = new Big(route[1].reserves[nodeRoute[1]]).div(\n        new Big(10).pow(tokens[1].decimals)\n      );\n\n      let denom2 = new Big(route[1].reserves[nodeRoute[2]]).div(\n        new Big(10).pow(tokens[2].decimals)\n      );\n\n      var routeMarketPrice = num1\n        .div(denom1)\n        .times(num2)\n        .div(denom2);\n    }\n    P = P.plus(weight.times(new Big(1).div(routeMarketPrice)));\n  }\n\n  let priceImpact = P.minus(R)\n    .div(R)\n    .times(new Big(100))\n    .toString();\n  return priceImpact;\n}\n\nfunction decor(arr) {\n  var res = [];\n  for (var i in arr) {\n    res.push([arr[i], i]);\n  }\n  return res;\n}\nfunction argsort(arr) {\n  let undecor = a => a[1]; // leave only index\n  let decorated = decor(arr);\n\n  return decorated\n    .sort((a, b) => new Big(b[0]).minus(new Big(a[0])))\n    .map(undecor);\n}\n\nfunction getPoolsByToken1ORToken2(pools, token1, token2) {\n  let filteredPools = pools.filter(\n    item =>\n      item.token1Id === token1 ||\n      item.token2Id === token1 ||\n      item.token1Id === token2 ||\n      item.token2Id === token2\n  );\n  return filteredPools;\n}\n\nfunction getPoolsByToken1ANDToken2(\n  pools,\n  token1,\n  token2,\n  cullZeroLiquidityPools = true\n) {\n  let filteredPools = pools.filter(\n    item =>\n      (item.token1Id === token1 && item.token2Id === token2) ||\n      (item.token1Id === token2 && item.token2Id === token1)\n  );\n  if (cullZeroLiquidityPools) {\n    filteredPools = filteredPools.filter(\n      item => item.token1Supply != '0' && item.token2Supply != '0'\n    );\n  }\n  return filteredPools;\n}\n\nfunction getLiqudityOfPoolsFromList(pools) {\n  let liquidities = [];\n  for (var poolInd in pools) {\n    let pool = pools[poolInd];\n    pool.amounts = [pool.token1Supply, pool.token2Supply];\n    let poolBigAmounts = pool.amounts.map(item => new Big(item));\n    let liquidity = poolBigAmounts[0].times(poolBigAmounts[1]);\n    liquidities.push(liquidity);\n  }\n  return liquidities;\n}\n\nfunction getNormalizedLiquiditiesFromList(pools) {\n  let liquidities = getLiqudityOfPoolsFromList(pools);\n  let maxLiq = bigMax(liquidities);\n  let normalizedLiquidities = liquidities.map(item => item.div(maxLiq));\n  return normalizedLiquidities;\n}\n\nfunction bigMax(arrayOfBigs) {\n  if (arrayOfBigs.length < 1) {\n    return null;\n  }\n  let maxElem = arrayOfBigs[0];\n  for (var ind in arrayOfBigs) {\n    let val = arrayOfBigs[ind];\n    if (val.gt(maxElem)) {\n      maxElem = val;\n    }\n  }\n  return maxElem;\n}\n\nfunction cullPoolsWithInsufficientLiquidity(pools, threshold = 0.0001) {\n  var thresh = new Big(threshold);\n  let normLiq = getNormalizedLiquiditiesFromList(pools);\n  let filteredPools = [];\n  for (var i = 0; i < normLiq.length; i++) {\n    if (normLiq[i] > thresh) {\n      filteredPools.push(pools[i]);\n    }\n  }\n  return filteredPools;\n}\n\nfunction cartesianProduct(a) {\n  let result = a.reduce((a, b) => a.flatMap(d => b.map(e => [d, e].flat())));\n  return result;\n}\n\nfunction addEdge(g, edge) {\n  let src = edge[0];\n  let dst = edge[1];\n  if (Object.keys(g).includes(src)) {\n    if (!Object.keys(g[src]).includes(dst)) {\n      g[src][dst] = 1;\n    }\n  } else {\n    g[src] = {};\n    g[src][dst] = 1;\n  }\n  if (Object.keys(g).includes(dst)) {\n    if (!Object.keys(g[dst]).includes(src)) {\n      g[dst][src] = 1;\n    }\n  } else {\n    g[dst] = {};\n    g[dst][src] = 1;\n  }\n}\n\nfunction addEdges(g, edgeList) {\n  for (var n in edgeList) {\n    let edge = edgeList[n];\n    addEdge(g, edge);\n  }\n}\n\nfunction deleteEdge(g, edge) {\n  let gNew = JSON.parse(JSON.stringify(g)); // using this to deep clone graph structure\n  let e1 = edge[0];\n  let e2 = edge[1];\n  if (Object.keys(gNew).includes(e1)) {\n    if (Object.keys(gNew[e1]).includes(e2)) {\n      delete gNew[e1][e2];\n    }\n  }\n  if (Object.keys(gNew).includes(e2)) {\n    if (Object.keys(gNew[e2]).includes(e1)) {\n      delete gNew[e2][e1];\n    }\n  }\n  return gNew;\n}\n\nfunction deleteNode(g, node) {\n  let gNew = JSON.parse(JSON.stringify(g)); // using this to deep clone graph structure\n  if (Object.keys(gNew).includes(node)) {\n    delete gNew[node];\n  }\n  let keys = Object.keys(gNew);\n  for (var nodeInd in keys) {\n    let nodeNow = keys[nodeInd];\n    if (Object.keys(gNew[nodeNow]).includes(node)) {\n      delete gNew[nodeNow][node];\n    }\n  }\n  return gNew;\n}\n\nfunction dijkstra(graph, s) {\n  var solutions = {};\n  solutions[s] = {};\n  solutions[s].path = [];\n  solutions[s].dist = 0;\n\n  while (true) {\n    var parent = null;\n    var nearest = null;\n    var dist = Infinity;\n\n    //for each existing solution\n    for (var n in solutions) {\n      if (!solutions[n]) {\n        solutions[n] = {};\n      }\n      if (!solutions[n].path) continue;\n      var ndist = solutions[n].dist;\n      var adj = graph[n];\n      //for each of its adjacent nodes...\n      for (var a in adj) {\n        //without a solution already...\n        if (!solutions[a]) {\n          solutions[a] = {};\n        }\n        if (solutions[a].path) continue;\n        //choose nearest node with lowest *total* cost\n        var d = adj[a] + ndist;\n        if (d < dist) {\n          //reference parent\n          parent = solutions[n].path;\n          nearest = a;\n          dist = d;\n        }\n      }\n    }\n\n    //no more solutions\n    if (dist === Infinity) {\n      break;\n    }\n\n    //extend parent's solution path\n    solutions[nearest].path = parent.concat(nearest);\n    //extend parent's cost\n    solutions[nearest].dist = dist;\n  }\n\n  return solutions;\n}\n\nfunction shortestPath(g, src, dst, ignore_nodes = [], ignore_edges = []) {\n  let gTemp = JSON.parse(JSON.stringify(g)); // using this to deep clone graph structure. If we can use lodash, could use  _.cloneDeep(obj)\n  // remove nodes\n  for (var nodeInd in ignore_nodes) {\n    let nodeNow = ignore_nodes[nodeInd];\n    gTemp = deleteNode(gTemp, nodeNow);\n  }\n  // remove edges\n  for (var edgeInd in ignore_edges) {\n    let edgeNow = ignore_edges[edgeInd];\n    gTemp = deleteEdge(gTemp, edgeNow);\n  }\n  let solution = dijkstra(gTemp, src)[dst];\n  solution.path.unshift(src); // original algorithm doesn't include source node in path\n  return solution;\n}\n\nfunction* count(firstval = 0, step = 1) {\n  let x = firstval;\n  while (true) {\n    yield x;\n    x = x + 1;\n  }\n}\n\nclass PathBuffer {\n  constructor() {\n    this.paths = [];\n    this.sortedpaths = [];\n    //this.counter = count();\n  }\n  len() {\n    return this.sortedpaths.length;\n  }\n\n  push(cost, path) {\n    if (path && !arrayContains(this.paths, path)) {\n      this.sortedpaths.push([cost, path]);\n      this.sortedpaths.sort(function(a, b) {\n        return a[0] - b[0];\n      });\n      //heappush(this.sortedpaths, (cost, this.counter.next().value,path));\n      this.paths.push(path);\n    }\n  }\n\n  pop() {\n    //let val = heappop(this.sortedpaths);\n    let val = this.sortedpaths.shift();\n    let cost = val[0];\n    let path = val[1];\n    this.paths.splice(this.paths.indexOf(path), 1);\n    return path;\n  }\n}\n\nfunction arrayEquals(a, b) {\n  return (\n    Array.isArray(a) &&\n    Array.isArray(b) &&\n    a.length === b.length &&\n    a.every((val, index) => val === b[index])\n  );\n}\n\nfunction arrayContains(arr, obj) {\n  // checks to see if the input array contains a reference object, obj, using\n  // JSON.stringify() .\n  let obj_json = JSON.stringify(obj);\n  for (var itemInd in arr) {\n    if (JSON.stringify(arr[itemInd]) == obj_json) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction* yenFromPy(g, source, target) {\n  //adapted from the python implementation in networkx.algorithms.simple_paths.shortest_simple_paths()\n  let listA = [];\n  let listB = new PathBuffer();\n  let prev_path = null;\n\n  while (true) {\n    if (!prev_path) {\n      let sol = shortestPath(g, source, target);\n      let length = sol.dist;\n      let path = sol.path;\n      listB.push(length, path);\n    } else {\n      let ignore_nodes = [];\n      let ignore_edges = [];\n      for (var i = 1; i < prev_path.length; i++) {\n        let root = prev_path.slice(0, i);\n        let root_length = root.length;\n        for (var pathInd in listA) {\n          let path = listA[pathInd];\n\n          if (arrayEquals(path.slice(0, i), root)) {\n            let edgeToIgnore = [path[i - 1], path[i]];\n            ignore_edges.push(edgeToIgnore);\n          }\n        }\n        try {\n          let sol = shortestPath(\n            g,\n            root[root.length - 1],\n            target,\n            (ignore_nodes = ignore_nodes),\n            (ignore_edges = ignore_edges)\n          );\n          let length = sol.dist;\n          let spur = sol.path;\n          let path = root.slice(0, root.length - 1).concat(spur);\n          listB.push(root_length + length, path);\n        } catch (e) {\n          //console.log(`yenFromPy error was... ${e}`)\n          //dont do anything.\n        }\n        ignore_nodes.push(root[root.length - 1]);\n      }\n    }\n    if (listB.sortedpaths) {\n      try {\n        let path = listB.pop();\n        yield path;\n        listA.push(path);\n        prev_path = path;\n      } catch (e) {\n        break;\n      }\n    } else {\n      break;\n    }\n  }\n}\n\nfunction getKShortestPaths(g, source, target, k, maxPathLength = 3) {\n  let paths = [];\n  if (maxPathLength < 2) {\n    var maxPathLength = 2;\n  }\n  let gen = yenFromPy(g, source, target);\n  for (var n = 1; n <= k; n++) {\n    try {\n      let res = gen.next().value;\n      if (res && !arrayContains(paths, res)) {\n        if (res.length > maxPathLength) {\n          // console.log(\n          //   `found all hops of length ${\n          //     maxPathLength - 1\n          //   } or less... breaking out of generator`\n          // );\n          break;\n        }\n        paths.push(res);\n      }\n    } catch (e) {\n      break;\n    }\n  }\n  return paths;\n}\n\nasync function getPathsFromPools(\n  pools,\n  inputToken,\n  outputToken,\n  maxPathLength = 3\n) {\n  let graph = getGraphFromPoolList(pools);\n  return getKShortestPaths(graph, inputToken, outputToken, 100, maxPathLength);\n}\n\nasync function getAllPathsBelowLengthN(g, source, target, N, limit = 100) {\n  // use Yen's algorithm to find the paths of length N or below between source and target nodes in graph g.\n\n  let paths = [];\n\n  let gen = await yenFromPy(g, source, target);\n  let currentPathLength = 0;\n  let count = 1;\n  while (currentPathLength <= N) {\n    //   console.log(`CURRENT PATH LENGTH IS ${currentPathLength}`)\n    try {\n      let res = await gen.next().value;\n      //   console.log(`RES IS ${res}`)\n      if (res && !arrayContains(paths, res)) {\n        if (res.length > currentPathLength) {\n          currentPathLength = res.length;\n          if (currentPathLength > N) {\n            break;\n          }\n        }\n        paths.push(res);\n      }\n      count = count + 1;\n      if (count > limit) {\n        break;\n      }\n    } catch (e) {\n      //   console.log(e)\n      break;\n    }\n  }\n  return paths;\n}\n\nfunction getGraphFromPoolList(poolList) {\n  let pools = poolList.filter(\n    item => item.token1Supply != '0' && item.token2Supply != '0'\n  );\n  let transitions = pools.map(item => [item.token1Id, item.token2Id]);\n  let g = {};\n  addEdges(g, transitions);\n  return g;\n}\n\n////////////////////////////////////\n\n// MAIN FUNCTION\n\n////////////////////////////////////\n\n// TODO -- incorporate the following integrated function, which tries to\n// account for stablecoins within the context of smart routing.\n\n//TODO -- need the right API / hooks for GETSTABLESWAPACTION function and GETPARALLELSWAPACTIONS functions.\n\n//TODO -- transform the actions generated in this function into tranaction to execute.\n\n//TRYING: GETSTABLESWAPACTION <==> instantSwapGetTransactions\n\nexport async function stableSmart(\n  pools,\n  inputToken,\n  outputToken,\n  totalInput,\n  slippageTolerance\n) {\n  let smartRouteActions = await getSmartRouteSwapActions(\n    pools,\n    inputToken,\n    outputToken,\n    totalInput,\n    slippageTolerance\n  );\n  return smartRouteActions;\n}\n\nexport function getExpectedOutputFromActionsORIG(actions, outputToken) {\n  return actions\n    .filter(item => item.outputToken === outputToken)\n    .map(item => new Big(item.estimate))\n    .reduce((a, b) => a.plus(b), new Big(0));\n}\n\nfunction getFeeForRoute(route) {\n  if (!route.length) {\n    route = [route];\n  }\n  if (route.length == 1) {\n    // Single Hop case\n    let p = route[0];\n    return p.fee;\n  } else if (route.length == 2) {\n    //Double Hop Case\n    let p1 = route[0];\n    let p2 = route[1];\n    let fee1 = p1.fee;\n    let fee2 = p2.fee;\n    return fee1 + fee2;\n  }\n}\n\nexport function getAverageFeeForRoutes(routes, nodeRoutes, totalInput) {\n  let normalizedAllocations = getOptimalAllocationForRoutes(\n    routes,\n    nodeRoutes,\n    totalInput\n  ).map(a => a.div(new Big(totalInput)));\n  let averageFee = 0;\n  for (var i in routes) {\n    averageFee += normalizedAllocations[i] * getFeeForRoute(routes[i]);\n  }\n  return averageFee;\n}\n","import { TokenMetadata, Pool, StablePool, EstimateSwapView } from './types';\nimport {\n  toReadableNumber,\n  toNonDivisibleNumber,\n  scientificNotationToString,\n} from './utils';\nimport Big from 'big.js';\nimport { SameInputTokenError, ZeroInputError, NoPoolError } from './error';\nimport { ONLY_ZEROS, toPrecision } from './utils';\nimport _ from 'lodash';\nimport { FEE_DIVISOR } from './constant';\nimport { getSwappedAmount } from './stable-swap';\nimport { ftGetTokenMetadata, ftGetTokensMetadata } from './ref';\nimport { isStablePool } from './utils';\nimport {\n  getStablePoolDecimal,\n  isStablePoolToken,\n  poolFormatter,\n} from './utils';\nimport {\n  stableSmart,\n  getExpectedOutputFromActionsORIG,\n  //@ts-ignore\n} from './smartRoutingLogic.js';\n\nexport interface SwapParams {\n  tokenIn: TokenMetadata;\n  tokenOut: TokenMetadata;\n  amountIn: string;\n  simplePools: Pool[];\n  options?: SwapOptions;\n}\n\nexport interface SwapOptions {\n  enableSmartRouting?: boolean;\n  stablePools?: Pool[];\n  stablePoolsDetail?: StablePool[];\n}\n\nexport const getSimplePoolEstimate = ({\n  tokenIn,\n  tokenOut,\n  pool,\n  amountIn,\n}: {\n  tokenIn: TokenMetadata;\n  tokenOut: TokenMetadata;\n  pool: Pool;\n  amountIn: string;\n}) => {\n  const amount_with_fee = Number(amountIn) * (FEE_DIVISOR - pool.fee);\n  const in_balance = toReadableNumber(\n    tokenIn.decimals,\n    pool.supplies[tokenIn.id]\n  );\n  const out_balance = toReadableNumber(\n    tokenOut.decimals,\n    pool.supplies[tokenOut.id]\n  );\n  const estimate = new Big(\n    (\n      (amount_with_fee * Number(out_balance)) /\n      (FEE_DIVISOR * Number(in_balance) + amount_with_fee)\n    ).toString()\n  ).toFixed();\n\n  return {\n    estimate,\n    pool,\n    outputToken: tokenOut.id,\n    inputToken: tokenIn.id,\n  };\n};\n\nexport const getStablePoolEstimate = ({\n  tokenIn,\n  tokenOut,\n  amountIn,\n  stablePool,\n}: {\n  tokenIn: TokenMetadata;\n  tokenOut: TokenMetadata;\n  amountIn: string;\n  stablePool: StablePool;\n}) => {\n  const STABLE_LP_TOKEN_DECIMALS = getStablePoolDecimal(stablePool);\n\n  const [amount_swapped, _, dy] = getSwappedAmount(\n    tokenIn.id,\n    tokenOut.id,\n    amountIn,\n    stablePool,\n    STABLE_LP_TOKEN_DECIMALS\n  );\n\n  const amountOut =\n    amount_swapped < 0 || isNaN(amount_swapped)\n      ? '0'\n      : toPrecision(scientificNotationToString(amount_swapped.toString()), 0);\n\n  const dyOut =\n    amount_swapped < 0 || isNaN(amount_swapped) || isNaN(dy)\n      ? '0'\n      : toPrecision(scientificNotationToString(dy.toString()), 0);\n\n  return {\n    estimate: toReadableNumber(STABLE_LP_TOKEN_DECIMALS, amountOut),\n    noFeeAmountOut: toReadableNumber(STABLE_LP_TOKEN_DECIMALS, dyOut),\n    pool: stablePool,\n    outputToken: tokenOut.id,\n    inputToken: tokenIn.id,\n  };\n};\n\n/**\n * @description Get the estimate of the amount of tokenOut that can be received\n *\n */\nexport const singlePoolSwap = ({\n  tokenIn,\n  tokenOut,\n  simplePools,\n  amountIn,\n  stablePools,\n}: {\n  tokenIn: TokenMetadata;\n  tokenOut: TokenMetadata;\n  simplePools: Pool[];\n  amountIn: string;\n  stablePools?: StablePool[];\n}) => {\n  if (!simplePools || simplePools.length === 0) {\n    throw NoPoolError;\n  }\n\n  // const pools = simplePools.concat(stablePools);\n\n  const simplePoolsThisPair = simplePools.filter(\n    p => p.tokenIds.includes(tokenIn.id) && p.tokenIds.includes(tokenOut.id)\n  );\n\n  const estimatesSimplePool = simplePoolsThisPair.map(pool =>\n    getSimplePoolEstimate({\n      tokenIn,\n      tokenOut,\n      pool,\n      amountIn,\n    })\n  );\n\n  const stablePoolThisPair = stablePools?.filter(\n    sp =>\n      sp.token_account_ids.includes(tokenIn.id) &&\n      sp.token_account_ids.includes(tokenOut.id)\n  );\n\n  // different stable lp token decimal for different type of pools\n  const estimatesStablePool = stablePoolThisPair?.map(stablePool =>\n    getStablePoolEstimate({\n      tokenIn,\n      tokenOut,\n      amountIn,\n      stablePool,\n    })\n  );\n\n  const maxSimplePoolEstimate =\n    estimatesSimplePool === undefined || estimatesSimplePool.length === 0\n      ? undefined\n      : estimatesSimplePool.length === 1\n      ? estimatesSimplePool[0]\n      : _.maxBy(estimatesSimplePool, estimate => Number(estimate.estimate));\n\n  const maxStablePoolEstimate =\n    estimatesStablePool === undefined || estimatesStablePool.length === 0\n      ? undefined\n      : estimatesStablePool.length === 1\n      ? estimatesStablePool[0]\n      : _.maxBy(estimatesStablePool, estimate => Number(estimate.estimate));\n\n  if (!maxStablePoolEstimate && !maxSimplePoolEstimate) throw NoPoolError;\n\n  if (!maxStablePoolEstimate) {\n    return maxSimplePoolEstimate;\n  } else if (!maxSimplePoolEstimate) return maxStablePoolEstimate;\n  else {\n    return Number(maxSimplePoolEstimate?.estimate) >\n      Number(maxStablePoolEstimate?.estimate)\n      ? maxSimplePoolEstimate\n      : maxStablePoolEstimate;\n  }\n};\n\nexport const getStablePoolsThisPair = ({\n  tokenInId,\n  tokenOutId,\n  stablePools,\n}: {\n  tokenInId: string;\n  tokenOutId: string;\n  stablePools: Pool[];\n}) => {\n  return stablePools.filter(\n    p =>\n      p.tokenIds.includes(tokenInId) &&\n      p.tokenIds.includes(tokenOutId) &&\n      tokenInId !== tokenOutId\n  );\n};\n\nexport const getPoolsByTokens = ({\n  pools,\n  tokenInId,\n  tokenOutId,\n}: {\n  pools: Pool[];\n  tokenInId: string;\n  tokenOutId: string;\n}) => {\n  if (tokenInId === tokenOutId) return [];\n\n  return pools.filter(\n    p => p.tokenIds.includes(tokenInId) && p.tokenIds.includes(tokenOutId)\n  );\n};\n\nexport const getPoolEstimate = async ({\n  tokenIn,\n  tokenOut,\n  amountIn,\n  stablePoolDetail,\n  pool,\n}: {\n  tokenIn: TokenMetadata;\n  tokenOut: TokenMetadata;\n  amountIn: string;\n  pool: Pool;\n  stablePoolDetail?: StablePool;\n}) => {\n  if (!!stablePoolDetail) {\n    return getStablePoolEstimate({\n      tokenIn,\n      tokenOut,\n      stablePool: stablePoolDetail,\n      amountIn,\n    });\n  } else {\n    return getSimplePoolEstimate({\n      tokenIn,\n      tokenOut,\n      pool,\n      amountIn,\n    });\n  }\n};\n\nexport async function getHybridStableSmart(\n  tokenIn: TokenMetadata,\n  tokenOut: TokenMetadata,\n  amountIn: string,\n  stablePools: Pool[],\n  stablePoolsDetail: StablePool[],\n  simplePools: Pool[]\n) {\n  if (\n    !isStablePoolToken(stablePoolsDetail, tokenIn.id) &&\n    !isStablePoolToken(stablePoolsDetail, tokenOut.id)\n  ) {\n    return { actions: [], estimate: '0' };\n  }\n\n  const stablePoolsDetailById = stablePoolsDetail.reduce((acc, cur) => {\n    return {\n      ...acc,\n      [cur.id]: cur,\n    };\n  }, {} as Record<string, StablePool>);\n\n  const parsedAmountIn = toNonDivisibleNumber(tokenIn.decimals, amountIn);\n\n  let pool1: Pool, pool2: Pool;\n\n  let pools1: Pool[] = [];\n  let pools2: Pool[] = [];\n\n  let pools1Right: Pool[] = [];\n  let pools2Right: Pool[] = [];\n\n  let candidatePools: Pool[][] = [];\n\n  /**\n   * find possible routes for this pair\n   *\n   *\n   */\n\n  if (isStablePoolToken(stablePoolsDetail, tokenIn.id)) {\n    // first hop will be through stable pool.\n    pools1 = stablePools.filter(pool => pool.tokenIds.includes(tokenIn.id));\n\n    const otherStables = pools1\n      .map(pool => pool.tokenIds.filter(id => id !== tokenIn.id))\n      .flat();\n\n    for (var otherStable of otherStables) {\n      let stablePoolsThisPair = getStablePoolsThisPair({\n        tokenInId: otherStable,\n        tokenOutId: tokenOut.id,\n        stablePools,\n      });\n\n      let tmpPools = getPoolsByTokens({\n        tokenInId: otherStable,\n        tokenOutId: tokenOut.id,\n        pools: simplePools,\n      });\n      const tobeAddedPools = tmpPools.concat(stablePoolsThisPair);\n      pools2.push(\n        ...tobeAddedPools.filter(p => {\n          const supplies = Object.values(p.supplies);\n          return new Big(supplies[0]).times(new Big(supplies[1])).gt(0);\n        })\n      );\n    }\n  }\n\n  if (isStablePoolToken(stablePoolsDetail, tokenOut.id)) {\n    // second hop will be through stable pool.\n    pools2Right = stablePools.filter(pool =>\n      pool.tokenIds.includes(tokenOut.id)\n    );\n\n    const otherStables = pools2Right\n      .map(pool => pool.tokenIds.filter(id => id !== tokenOut.id))\n      .flat();\n    for (let otherStable of otherStables) {\n      let stablePoolsThisPair = getStablePoolsThisPair({\n        tokenInId: tokenIn.id,\n        tokenOutId: otherStable,\n        stablePools,\n      });\n\n      let tmpPools = getPoolsByTokens({\n        tokenInId: tokenIn.id,\n        tokenOutId: otherStable,\n        pools: simplePools,\n      });\n\n      const tobeAddedPools = tmpPools.concat(stablePoolsThisPair);\n\n      pools1Right.push(\n        ...tobeAddedPools.filter(p => {\n          const supplies = Object.values(p.supplies);\n          return new Big(supplies[0]).times(new Big(supplies[1])).gt(0);\n        })\n      );\n    }\n  }\n\n  // find candidate pools\n\n  for (let p1 of pools1) {\n    let middleTokens = p1.tokenIds.filter((id: string) => id !== tokenIn.id);\n    for (let middleToken of middleTokens) {\n      let p2s = pools2.filter(\n        p =>\n          p.tokenIds.includes(middleToken) &&\n          p.tokenIds.includes(tokenOut.id) &&\n          middleToken !== tokenOut.id\n      );\n      let p2 = _.maxBy(p2s, p =>\n        Number(\n          new Big(toReadableNumber(tokenOut.decimals, p.supplies[tokenOut.id]))\n        )\n      );\n\n      if (middleToken === tokenOut.id) {\n        p2 = p1;\n      }\n\n      if (p1 && p2) {\n        if (p1.id === p2.id) candidatePools.push([p1]);\n        else candidatePools.push([p1, p2]);\n      }\n    }\n  }\n  for (let p1 of pools1Right) {\n    let middleTokens = p1.tokenIds.filter((id: string) => id !== tokenIn.id);\n    for (let middleToken of middleTokens) {\n      let p2s = pools2Right.filter(\n        p =>\n          p.tokenIds.includes(middleToken) &&\n          p.tokenIds.includes(tokenOut.id) &&\n          middleToken !== tokenOut.id\n      );\n      let p2 = _.maxBy(p2s, p =>\n        Number(\n          new Big(toReadableNumber(tokenOut.decimals, p.supplies[tokenOut.id]))\n        )\n      );\n\n      if (middleToken === tokenOut.id) {\n        p2 = p1;\n      }\n\n      if (p1 && p2) {\n        if (p1.id === p2.id) candidatePools.push([p1]);\n        else candidatePools.push([p1, p2]);\n      }\n    }\n  }\n\n  if (candidatePools.length > 0) {\n    const tokensMedata = await ftGetTokensMetadata(\n      candidatePools.map(cp => cp.map(p => p.tokenIds).flat()).flat()\n    );\n\n    const BestPoolPair =\n      candidatePools.length === 1\n        ? candidatePools[0]\n        : _.maxBy(candidatePools, poolPair => {\n            // only one pool case, only for stable tokens\n            if (poolPair.length === 1) {\n              if (isStablePool(stablePoolsDetail, poolPair[0].id)) {\n                const stablePoolThisPair = getStablePoolsThisPair({\n                  tokenInId: tokenIn.id,\n                  tokenOutId: tokenOut.id,\n                  stablePools,\n                })[0];\n\n                const stablePoolDetailThisPair = stablePoolsDetail.find(\n                  spd => spd.id === stablePoolThisPair.id\n                );\n\n                return Number(\n                  getStablePoolEstimate({\n                    tokenIn,\n                    tokenOut,\n                    stablePool: stablePoolDetailThisPair as StablePool,\n                    amountIn,\n                  }).estimate\n                );\n              } else {\n                return Number(\n                  getSimplePoolEstimate({\n                    tokenIn,\n                    tokenOut,\n                    amountIn,\n                    pool: poolPair[0],\n                  }).estimate\n                );\n              }\n            }\n\n            const [tmpPool1, tmpPool2] = poolPair;\n            const tokenMidId = poolPair[0].tokenIds.find((t: string) =>\n              poolPair[1].tokenIds.includes(t)\n            ) as string;\n\n            const tokenMidMeta = tokensMedata[tokenMidId];\n\n            const estimate1 = {\n              ...(isStablePool(stablePoolsDetail, tmpPool1.id)\n                ? getStablePoolEstimate({\n                    tokenIn,\n                    tokenOut: tokenMidMeta,\n                    amountIn,\n                    stablePool: stablePoolsDetailById[tmpPool1.id],\n                  })\n                : getSimplePoolEstimate({\n                    tokenIn,\n                    tokenOut: tokenMidMeta,\n                    amountIn,\n                    pool: tmpPool1,\n                  })),\n            };\n\n            const estimate2 = {\n              ...(isStablePool(stablePoolsDetail, tmpPool2.id)\n                ? getStablePoolEstimate({\n                    tokenIn: tokenMidMeta,\n                    tokenOut,\n                    amountIn: estimate1.estimate,\n                    stablePool: stablePoolsDetailById[tmpPool2.id],\n                  })\n                : getSimplePoolEstimate({\n                    tokenIn: tokenMidMeta,\n                    tokenOut,\n                    pool: tmpPool2,\n                    amountIn: estimate1.estimate,\n                  })),\n            };\n\n            return Number(estimate2.estimate);\n          });\n\n    // one pool case only get best price\n\n    if (!BestPoolPair) return { actions: [], estimate: '0' };\n\n    if (BestPoolPair.length === 1) {\n      const bestPool = BestPoolPair[0];\n      const estimate = await getPoolEstimate({\n        tokenIn,\n        tokenOut,\n        amountIn,\n        pool: bestPool,\n        stablePoolDetail: stablePoolsDetailById[bestPool.id],\n      });\n\n      return {\n        actions: [\n          {\n            ...estimate,\n            pool: { ...bestPool, parsedAmountIn: parsedAmountIn },\n            tokens: [tokenIn, tokenOut],\n            inputToken: tokenIn.id,\n            outputToken: tokenOut.id,\n            totalInputAmount: toNonDivisibleNumber(tokenIn.decimals, amountIn),\n          },\n        ],\n        estimate: estimate.estimate,\n      };\n    }\n\n    // two pool case get best price\n    [pool1, pool2] = BestPoolPair;\n\n    const tokenMidId = BestPoolPair[0].tokenIds.find((t: string) =>\n      BestPoolPair[1].tokenIds.includes(t)\n    ) as string;\n\n    const tokenMidMeta = await ftGetTokenMetadata(tokenMidId);\n\n    const estimate1 = {\n      ...(isStablePool(stablePoolsDetail, pool1.id)\n        ? getStablePoolEstimate({\n            tokenIn,\n            tokenOut: tokenMidMeta,\n            amountIn,\n            stablePool: stablePoolsDetailById[pool1.id],\n          })\n        : getSimplePoolEstimate({\n            tokenIn,\n            tokenOut: tokenMidMeta,\n            amountIn,\n            pool: pool1,\n          })),\n      tokens: [tokenIn, tokenMidMeta, tokenOut],\n      inputToken: tokenIn.id,\n      outputToken: tokenMidMeta.id,\n    };\n\n    estimate1.pool.partialAmountIn = parsedAmountIn;\n\n    const estimate2 = {\n      ...(isStablePool(stablePoolsDetail, pool2.id)\n        ? getStablePoolEstimate({\n            tokenIn: tokenMidMeta,\n            tokenOut,\n            amountIn: estimate1.estimate,\n            stablePool: stablePoolsDetailById[pool2.id],\n          })\n        : getSimplePoolEstimate({\n            tokenIn: tokenMidMeta,\n            tokenOut,\n            amountIn: estimate1.estimate,\n            pool: pool2,\n          })),\n\n      tokens: [tokenIn, tokenMidMeta, tokenOut],\n      inputToken: tokenMidMeta.id,\n      outputToken: tokenOut.id,\n    };\n\n    return { actions: [estimate1, estimate2], estimate: estimate2.estimate };\n  }\n\n  return { actions: [], estimate: '0' };\n}\n\n// simple pools and stable pools for this pair\nexport const estimateSwap = async ({\n  tokenIn,\n  tokenOut,\n  amountIn,\n  simplePools,\n  options,\n}: SwapParams) => {\n  if (tokenIn.id === tokenOut.id) throw SameInputTokenError;\n\n  if (ONLY_ZEROS.test(amountIn)) throw ZeroInputError;\n\n  const { enableSmartRouting, stablePools, stablePoolsDetail } = options || {};\n\n  const parsedAmountIn = toNonDivisibleNumber(tokenIn.decimals, amountIn);\n\n  if (!enableSmartRouting) {\n    const estimate = singlePoolSwap({\n      tokenIn,\n      tokenOut,\n      simplePools,\n      amountIn,\n      stablePools: stablePoolsDetail,\n    });\n\n    console.log(estimate, 'estimate');\n\n    return [\n      {\n        ...estimate,\n        pool: { ...estimate?.pool, partialAmountIn: parsedAmountIn },\n      },\n    ] as EstimateSwapView[];\n  } else {\n    const inputPools = simplePools.map(p => poolFormatter(p));\n\n    const simplePoolSmartRoutingActions = await stableSmart(\n      inputPools,\n      tokenIn.id,\n      tokenOut.id,\n      parsedAmountIn\n    );\n\n    const simplePoolSmartRoutingEstimate = getExpectedOutputFromActionsORIG(\n      simplePoolSmartRoutingActions,\n      tokenOut.id\n    ).toString();\n\n    const hybridSmartRoutingRes = await getHybridStableSmart(\n      tokenIn,\n      tokenOut,\n      amountIn,\n      stablePools || [],\n      stablePoolsDetail || [],\n      simplePools\n    );\n\n    const hybridSmartRoutingEstimate = hybridSmartRoutingRes.estimate.toString();\n\n    if (\n      new Big(simplePoolSmartRoutingEstimate || '0').gte(\n        hybridSmartRoutingEstimate || '0'\n      )\n    ) {\n      if (!simplePoolSmartRoutingActions?.length) throw NoPoolError;\n      return simplePoolSmartRoutingActions as EstimateSwapView[];\n    } else {\n      return hybridSmartRoutingRes.actions as EstimateSwapView[];\n    }\n  }\n};\n"],"names":["FEE_DIVISOR","STABLE_LP_TOKEN_DECIMALS","RATED_POOL_LP_TOKEN_DECIMALS","getConfig","env","process","NEAR_ENV","networkId","nodeUrl","walletUrl","WRAP_NEAR_CONTRACT_ID","REF_FI_CONTRACT_ID","config","STORAGE_TO_REGISTER_WITH_MFT","ONE_YOCTO_NEAR","formatError","msg","Error","unNamedError","SameInputTokenError","ZeroInputError","NoPoolError","NotLoginError","SwapRouteError","TokenNotExistError","NoPuiblicKeyError","NoLocalSignerError","InValidAccessKeyError","AccountIdMisMatch","NoCredential","parsePool","pool","id","Number","tokenIds","token_account_ids","supplies","amounts","reduce","acc","amount","i","fee","total_fee","shareSupply","shares_total_supply","tvl","token0_ref_price","pool_kind","poolFormatter","token1Id","token2Id","token1Supply","token2Supply","shares","token0_price","isStablePoolToken","stablePools","tokenId","map","p","flat","includes","toString","isStablePool","poolId","getStablePoolDecimal","stablePool","round","decimals","minAmountOut","isInteger","Math","ceil","pow","convertToPercentDecimal","percent","math","percentOf","num","percentLess","notation","getGas","gas","BN","getAmount","utils","format","parseNearAmount","ONLY_ZEROS","toReadableNumber","number","wholeStr","substring","length","fractionStr","padStart","replace","toNonDivisibleNumber","undefined","split","wholePart","fracPart","padEnd","slice","scientificNotationToString","strParam","flag","test","sysbol","negative","index","match","basis","ifFraction","formatWithCommas","value","pattern","toPrecision","precision","withCommas","atLeastOne","whole","decimal","str","n","lastIndexOf","transformTransactions","transactions","AccountId","t","signerId","receiverId","actions","functionCalls","fc","type","params","methodName","args","toNumber","toFixed","deposit","getKeyStore","window","keyStores","InMemoryKeyStore","BrowserLocalStorageKeyStore","provider","providers","JsonRpcProvider","url","getMemorySigner","keyPath","homedir","os","credentials","JSON","parse","fs","readFileSync","credentialAccountId","account_id","myKeyStore","setKey","KeyPair","fromString","private_key","signer","InMemorySigner","validateAccessKey","transaction","accessKey","permission","FunctionCall","receiver_id","method_names","every","action","parseFloat","getSignedTransactionsByMemoryKey","transactionsRef","block","finality","signedTransactions","getPublicKey","publicKey","query","request_type","public_key","tx","nearTransactions","createTransaction","PublicKey","from","nonce","functionCall","serialize","base_decode","header","hash","signTransaction","signedTx","push","sendTransactionsByMemoryKey","results","sendTransaction","near","Near","keyStore","headers","refFiViewFunction","account","nearConnection","viewFunction","ftViewFunction","ftGetStorageBalance","getTotalPools","ftGetTokenMetadata","metadata","ftGetTokensMetadata","Promise","all","tokensMetadata","pre","cur","instantSwap","tokenIn","tokenOut","amountIn","slippageTolerance","swapTodos","at","outputToken","registerToken","token","tokenRegistered","registration_only","actionsList","allSwapsTokens","s","inputToken","swapTokens","pool_id","token_in","token_out","amount_in","partialAmountIn","min_amount_out","estimate","stringify","force","registered","DEFAULT_PAGE_LIMIT","getRatedPoolDetail","then","pool_info","getUnRatedPoolDetail","rates","c_amounts","_","getStablePools","getRefPools","page","perPage","from_index","limit","poolData","rawPool","fetchAllPools","totalPools","pages","Array","fill","pools","simplePools","filter","unRatedPools","ratedPools","tradeFee","trade_fee","calc_d","amp","token_num","sum_amounts","sum","d_prev","d","d_prod","c_amount","ann","numerator","denominator","abs","calc_y","x_c_amount","current_c_amounts","index_x","index_y","c","b","y_prev","y","y_numerator","y_denominator","calc_swap","in_token_idx","in_c_amount","out_token_idx","old_c_amounts","dy","amount_swapped","getSwappedAmount","tokenInId","tokenOutId","findIndex","r","base_old_c_amounts","Big","times","RM","DP","NE","PE","checkIntegerSumOfAllocations","allocations","totalInput","item","alloSum","a","plus","offset","minus","currMax","currMaxInd","gt","newAllocations","j","yenFromPy","bisqrt","BigInt","newtonIteration","x0","x1","getBetaForRoute","route","path","beta","reserves","p1","p2","getEpsilonForRoute","gamma","div","epsilon","gamma1","gamma2","getAlphaForRoute","key1","key2","val1","val2","alpha","key11","key12","val11","val12","key21","key22","val21","val22","middleToken","alpha1","alpha2","getAlphaSumFromRoutes","routes","nodeRoutes","alphaSum","nodeRoute","radical","denom","getBetaSumFromRoutes","betaSum","getPhiFromRoutes","phi","getAllocationForRoute","allocation","getAllocationVectorForRoutes","allocationVec","getOptimalAllocationForRoutes","lt","some","reduceRoutes","sumAllocations","normalizedAllocations","goodIndices","dx","newRoutes","newNodeRoutes","goodIndex","allocationDict","allocationVecNew","zeroAllocation","getNodeRoutesFromPathsAndPoolChains","paths","poolChains","multiplicity","pc","mul","elem1","elem2","m","k","getPoolChainFromPaths","threshold","pathInd","chain","pairs","pairInd","pair","tokenPools","getPoolsByToken1ANDToken2","culledPoolChains","getCulledPoolChains","newChains","newPath","legInd","leg","culledPath","cullPoolsWithInsufficientLiquidity","getRoutesFromPoolChain","pci","poolChain","cartesianProduct","getOutputSingleHop","getOutputDoubleHop","poolIndex","c1","a1","c2","b2","getOutputFromRoute","eq","output","getOptOutputVec","result","getBestOptInputAndOutput","rawDict","outputRaw","inputRaw","res1","res2","res","v","bv1","bv2","input","getBestOptimalAllocationsAndOutputs","maxPathLength","getPathsFromPools","outputs","inputOutput","getHopActionsFromRoutes","hops","hop","allRoutes","allNodeRoutes","totalInputAmount","allAllocations","middleTokenAllocation","getActionListFromRoutesAndAllocations","getSmartRouteSwapActions","numberOfRoutesLimit","MAX_NUMBER_PARALLEL_POOLS","decimalsCulledPoolIds","resDict","sortedIndexValues","argsort","topIndices","reducedRoutes","reducedNodeRoutes","ind","currentBestOutput","bestAllocations","bestNodeRoutes","bestRoutes","parallelNodeRoutes","parallelRoutes","currentNodeRoute","bestRoutesAreParallel","filteredAllocationsAndOutputs","parallellAllocations","parallelOutputs","sortIndices","filteredParallelRoutes","filteredParallelNodeRoutes","parallelOutput","canHaveTwoRoutes","route1","route2","nodeRoute1","nodeRoute2","route1PoolIds","Set","route2PoolIds","sharePool","route1PoolId","has","currentRoutes","currentNodeRoutes","filteredAllocations","filteredOutputs","totalOutput","allSortedIndices","sortedIndices","filteredRoutes","filteredNodeRoutes","sharedRoute","allFilteredRoutes","allFilteredNodeRoutes","firstRoute","firstRoutePoolIds","allFilteredRouteIds","secondRoute","stringAllo","hopInputTokenMeta","hopOutputTokenMeta","hopOutputTokenDecimals","expectedHopOutput","decimalEstimate","status","tokens","gamma_bps","Dex","routeInputToken","routeOutputToken","overallPriceImpact","x","calculateSmartRouteV2PriceImpact","deltaY","inputTokenMeta","deltaX","R","P","totalAllocations","weights","weight","routeMarketPrice","num1","denom1","num2","denom2","priceImpact","decor","arr","undecor","decorated","sort","token1","token2","cullZeroLiquidityPools","filteredPools","getLiqudityOfPoolsFromList","liquidities","poolInd","poolBigAmounts","liquidity","getNormalizedLiquiditiesFromList","maxLiq","bigMax","normalizedLiquidities","arrayOfBigs","maxElem","val","thresh","normLiq","flatMap","e","addEdge","g","edge","src","dst","Object","keys","addEdges","edgeList","deleteEdge","gNew","e1","e2","deleteNode","node","nodeInd","nodeNow","dijkstra","graph","solutions","dist","parent","nearest","Infinity","ndist","adj","concat","shortestPath","ignore_nodes","ignore_edges","gTemp","edgeInd","edgeNow","solution","unshift","PathBuffer","sortedpaths","len","cost","arrayContains","pop","shift","splice","indexOf","arrayEquals","isArray","obj","obj_json","itemInd","source","target","listA","listB","prev_path","sol","root","root_length","edgeToIgnore","spur","getKShortestPaths","gen","next","getGraphFromPoolList","poolList","transitions","stableSmart","smartRouteActions","getExpectedOutputFromActionsORIG","getSimplePoolEstimate","amount_with_fee","in_balance","out_balance","getStablePoolEstimate","amountOut","isNaN","dyOut","noFeeAmountOut","singlePoolSwap","simplePoolsThisPair","estimatesSimplePool","stablePoolThisPair","sp","estimatesStablePool","maxSimplePoolEstimate","maxBy","maxStablePoolEstimate","getStablePoolsThisPair","getPoolsByTokens","getPoolEstimate","stablePoolDetail","getHybridStableSmart","stablePoolsDetail","stablePoolsDetailById","parsedAmountIn","pools1","pools2","pools1Right","pools2Right","candidatePools","otherStables","otherStable","stablePoolsThisPair","tmpPools","tobeAddedPools","values","middleTokens","p2s","cp","tokensMedata","BestPoolPair","poolPair","stablePoolDetailThisPair","find","spd","tmpPool1","tmpPool2","tokenMidId","tokenMidMeta","estimate1","estimate2","bestPool","pool1","pool2","estimateSwap","options","enableSmartRouting","console","log","inputPools","simplePoolSmartRoutingActions","simplePoolSmartRoutingEstimate","hybridSmartRoutingRes","hybridSmartRoutingEstimate","gte"],"mappings":"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"}