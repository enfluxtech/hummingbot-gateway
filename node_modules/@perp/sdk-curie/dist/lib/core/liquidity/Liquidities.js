"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("big.js");require("../../constants/envVariables.js");var t=require("../../constants/numbers.js"),i=require("../../contracts/Contracts.js"),r=require("../../internal/Channel.js"),a=require("../../internal/ChannelEventSource.js"),s=require("../../internal/createMemoizedFetcher.js"),c=require("../../internal/config.js"),n=require("../../utils/formatters.js");require("../../utils/tick.js");var o=require("../../utils/poll.js"),u=require("../../utils/logger.js");require("ethers"),require("../../errors/errors.js");var d=require("../contractReader/MulticallReader.js"),l=require("./Liquidity.js");function p(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var h=p(e);class m extends r.Channel{constructor(e){super(e.channelRegistry),this._perp=e,this._cache=new Map,this._fetchAndEmitUpdated=s.createMemoizedFetcher((()=>this._fetchUpdateData()),(()=>{this.emit("updated",this)}),((e,t)=>!e||!t||this._compareUpdatedData(e,t)))}_compareUpdatedData(e,t){const i=Object.values(e.totalPendingFees),r=Object.values(t.totalPendingFees),a=Object.values(e.openLiquiditiesFromMarkets),s=Object.values(t.openLiquiditiesFromMarkets);return!!a.some(((e,t)=>e.length!==s[t].length))||(a.some(((e,t)=>e.some(((e,i)=>!l.Liquidity.same(e,s[t][i])))))||i.some(((e,t)=>!r[t].eq(e))))}_getEventSourceMap(){const e=new a.ChannelEventSource({eventSourceStarter:()=>{var e,t;return o.poll(this._fetchAndEmitUpdated,(null===(t=null===(e=this._perp.moduleConfigs)||void 0===e?void 0:e.orders)||void 0===t?void 0:t.period)||c.DEFAULT_PERIOD).cancel},initEventEmitter:()=>this._fetchAndEmitUpdated(!1,!0)}),t=this.getLiquidityDataAll.bind(this);return{updated:e,updatedLiquidityDataAll:new a.ChannelEventSource({eventSourceStarter:()=>{var e,i;return o.poll(t,(null===(i=null===(e=this._perp.moduleConfigs)||void 0===e?void 0:e.orders)||void 0===i?void 0:i.period)||c.DEFAULT_PERIOD).cancel},initEventEmitter:()=>t()})}}async _fetchUpdateData(){try{const e=await Promise.all([this.getOpenLiquiditiesFromMarkets({cache:!1}),this.getTotalPendingFees({cache:!1})]);return{openLiquiditiesFromMarkets:e[0],totalPendingFees:e[1]}}catch(e){this.emit("updateError")}}async getTotalLiquidities({cache:e=!0}={}){const i=await this.getOpenLiquiditiesFromMarkets({cache:e}),r=Object.values(i),a=Object.keys(i),s={};for(let e=0;e<r.length;e++){const i=r[e],c=a[e],n=await Promise.all(i.map((e=>e.getLiquidityValue())));s[c]=n.reduce(((e,t)=>e.add(t)),t.BIG_ZERO)}return s}async getTotalLiquidityByMarket(e,{cache:i=!0}={}){const r=await this.getOpenLiquiditiesByMarket(e,{cache:i});return(await Promise.all(r.map((e=>e.getLiquidityValue())))).reduce(((e,t)=>e.add(t)),t.BIG_ZERO)}async getTotalPendingFees({cache:e=!0}={}){const t=await this._fetch("totalTokenAmountInPoolAndPendingFeeOfAllMarkets",{cache:e});return Object.values(this._perp.markets.marketMap).reduce(((e,i)=>(e[i.baseAddress]=t[i.baseAddress].totalPendingFee,e)),{})}async getTotalPendingFeeByMarket(e,{cache:t=!0}={}){const i=await this.getTotalPendingFees({cache:t});return null==i?void 0:i[e]}async getOpenLiquiditiesFromMarkets({cache:e=!0}={}){const t=await this._fetch("openLiquidities",{cache:e});return Object.values(this._perp.markets.marketMap).reduce(((e,i,r)=>(e[i.baseAddress]=t[r].map((({liquidity:e,baseDebt:t,quoteDebt:r,lowerTick:a,upperTick:s})=>new l.Liquidity({perp:this._perp,id:`${i.baseAddress}-${a}-${s}`,liquidity:e,upperTick:s,lowerTick:a,baseDebt:t,quoteDebt:r,market:i},this._perp.channelRegistry))),e)),{})}async getOpenLiquiditiesByMarket(e,{cache:t=!0}={}){const i=await this._fetch("openLiquidities",{cache:t}),r=Object.values(this._perp.markets.marketMap).findIndex((t=>t.baseAddress===e));return-1===r?[]:i[r].map((({liquidity:t,baseDebt:i,quoteDebt:r,lowerTick:a,upperTick:s})=>new l.Liquidity({perp:this._perp,id:`${e}-${a}-${s}`,liquidity:t,upperTick:s,lowerTick:a,baseDebt:i,quoteDebt:r,market:this._perp.markets.getMarket({baseAddress:e})},this._perp.channelRegistry)))}async _fetch(e,{cache:t=!0}={}){if(this._cache.has(e)&&t)return this._cache.get(e);const i=[this._perp.markets.marketMap,this._perp.wallet.account];let r;switch(e){case"openLiquidities":r=await this._perp.contractReader.getOpenLiquidities(...i);break;case"totalTokenAmountInPoolAndPendingFeeOfAllMarkets":r=await this._perp.contractReader.getTotalTokenAmountInPoolAndPendingFeeOfAllMarkets(...i)}return this._cache.set(e,r),r}async getLiquidityDataAll(){try{u.logger("getLiquidityDataAll");const e=this._perp.wallet.account,t=this._perp.markets.marketMap,r=this._perp.contracts,a=new d.MulticallReader({contract:this._perp.contracts.multicall2}),s={};Object.entries(t).forEach((([t,a])=>{const c=a.baseAddress,n=[{contract:r.orderBook,contractName:i.ContractName.ORDERBOOK,funcName:"getTotalTokenAmountInPoolAndPendingFee",funcParams:[e,c,!1]},{contract:r.orderBook,contractName:i.ContractName.ORDERBOOK,funcName:"getOpenOrderIds",funcParams:[e,c]},{contract:r.pool.attach(a.poolAddress),contractName:i.ContractName.POOL,funcName:"slot0",funcParams:[]}];s[t]=n}));const c=await a.execute(Object.values(s).flat(),{failFirstByContract:!1,failFirstByClient:!1}),o={};Object.entries(s).forEach((([e,t])=>{const i=c.splice(0,t.length),[r,a]=i[0],s=i[1],u=n.fromSqrtX96(i[2].sqrtPriceX96);o[e]={totalPendingFee:n.bigNumber2BigAndScaleDown(a),openOrderIds:s,markPrice:u}}));const p=[];Object.values(o).forEach((e=>{e.openOrderIds.forEach((e=>{p.push({contract:r.orderBook,contractName:i.ContractName.ORDERBOOK,funcName:"getOpenOrderById",funcParams:[e]})}))}));const m=await a.execute(p,{failFirstByContract:!1,failFirstByClient:!1}),q={};Object.entries(o).forEach((([e,i])=>{const r=t[e],a=m.splice(0,i.openOrderIds.length),s=[];let c=h.default(0);a.forEach((({liquidity:e,baseDebt:t,quoteDebt:a,lowerTick:o,upperTick:u})=>{const d=new l.Liquidity({perp:this._perp,id:`${r.baseAddress}-${o}-${u}`,liquidity:new h.default(e),upperTick:u,lowerTick:o,baseDebt:n.bigNumber2BigAndScaleDown(t),quoteDebt:n.bigNumber2BigAndScaleDown(a),market:r},this._perp.channelRegistry),p=l.Liquidity.getRangeTypeByMarkPrice(i.markPrice,d.lowerTickPrice,d.upperTickPrice),{amountQuote:m,amountBase:q}=l.Liquidity.getLiquidityAmounts({markPrice:i.markPrice,lowerTickPrice:d.lowerTickPrice,upperTickPrice:d.upperTickPrice,liquidity:d.liquidity,rangeType:p}),g=q.mul(i.markPrice);c=c.add(g.add(m)),s.push(d)})),q[e]={...i,totalLiquidityValue:c,openLiquidities:s}})),this.emit("updatedLiquidityDataAll",q)}catch(e){this.emit("updateError",{error:e})}}}exports.Liquidities=m;
//# sourceMappingURL=Liquidities.js.map
