// package: injective.exchange.v1beta1
// file: injective/exchange/v1beta1/tx.proto

import * as jspb from "google-protobuf";
import * as gogoproto_gogo_pb from "../../../gogoproto/gogo_pb";
import * as injective_oracle_v1beta1_oracle_pb from "../../../injective/oracle/v1beta1/oracle_pb";
import * as injective_exchange_v1beta1_exchange_pb from "../../../injective/exchange/v1beta1/exchange_pb";
import * as cosmos_base_v1beta1_coin_pb from "../../../cosmos/base/v1beta1/coin_pb";
import * as cosmos_distribution_v1beta1_distribution_pb from "../../../cosmos/distribution/v1beta1/distribution_pb";
import * as google_protobuf_any_pb from "google-protobuf/google/protobuf/any_pb";
import * as cosmos_proto_cosmos_pb from "../../../cosmos_proto/cosmos_pb";

export class MsgTransferAndExecute extends jspb.Message {
  getSender(): string;
  setSender(value: string): void;

  clearFundsList(): void;
  getFundsList(): Array<cosmos_base_v1beta1_coin_pb.Coin>;
  setFundsList(value: Array<cosmos_base_v1beta1_coin_pb.Coin>): void;
  addFunds(value?: cosmos_base_v1beta1_coin_pb.Coin, index?: number): cosmos_base_v1beta1_coin_pb.Coin;

  getFundsDirection(): FundsDirectionMap[keyof FundsDirectionMap];
  setFundsDirection(value: FundsDirectionMap[keyof FundsDirectionMap]): void;

  hasMsg(): boolean;
  clearMsg(): void;
  getMsg(): google_protobuf_any_pb.Any | undefined;
  setMsg(value?: google_protobuf_any_pb.Any): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgTransferAndExecute.AsObject;
  static toObject(includeInstance: boolean, msg: MsgTransferAndExecute): MsgTransferAndExecute.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgTransferAndExecute, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgTransferAndExecute;
  static deserializeBinaryFromReader(message: MsgTransferAndExecute, reader: jspb.BinaryReader): MsgTransferAndExecute;
}

export namespace MsgTransferAndExecute {
  export type AsObject = {
    sender: string,
    fundsList: Array<cosmos_base_v1beta1_coin_pb.Coin.AsObject>,
    fundsDirection: FundsDirectionMap[keyof FundsDirectionMap],
    msg?: google_protobuf_any_pb.Any.AsObject,
  }
}

export class MsgTransferAndExecuteResponse extends jspb.Message {
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgTransferAndExecuteResponse.AsObject;
  static toObject(includeInstance: boolean, msg: MsgTransferAndExecuteResponse): MsgTransferAndExecuteResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgTransferAndExecuteResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgTransferAndExecuteResponse;
  static deserializeBinaryFromReader(message: MsgTransferAndExecuteResponse, reader: jspb.BinaryReader): MsgTransferAndExecuteResponse;
}

export namespace MsgTransferAndExecuteResponse {
  export type AsObject = {
  }
}

export class MsgMultiExecute extends jspb.Message {
  getSender(): string;
  setSender(value: string): void;

  clearMsgsList(): void;
  getMsgsList(): Array<google_protobuf_any_pb.Any>;
  setMsgsList(value: Array<google_protobuf_any_pb.Any>): void;
  addMsgs(value?: google_protobuf_any_pb.Any, index?: number): google_protobuf_any_pb.Any;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgMultiExecute.AsObject;
  static toObject(includeInstance: boolean, msg: MsgMultiExecute): MsgMultiExecute.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgMultiExecute, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgMultiExecute;
  static deserializeBinaryFromReader(message: MsgMultiExecute, reader: jspb.BinaryReader): MsgMultiExecute;
}

export namespace MsgMultiExecute {
  export type AsObject = {
    sender: string,
    msgsList: Array<google_protobuf_any_pb.Any.AsObject>,
  }
}

export class MsgMultiExecuteResponse extends jspb.Message {
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgMultiExecuteResponse.AsObject;
  static toObject(includeInstance: boolean, msg: MsgMultiExecuteResponse): MsgMultiExecuteResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgMultiExecuteResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgMultiExecuteResponse;
  static deserializeBinaryFromReader(message: MsgMultiExecuteResponse, reader: jspb.BinaryReader): MsgMultiExecuteResponse;
}

export namespace MsgMultiExecuteResponse {
  export type AsObject = {
  }
}

export class MsgDeposit extends jspb.Message {
  getSender(): string;
  setSender(value: string): void;

  getSubaccountId(): string;
  setSubaccountId(value: string): void;

  hasAmount(): boolean;
  clearAmount(): void;
  getAmount(): cosmos_base_v1beta1_coin_pb.Coin | undefined;
  setAmount(value?: cosmos_base_v1beta1_coin_pb.Coin): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgDeposit.AsObject;
  static toObject(includeInstance: boolean, msg: MsgDeposit): MsgDeposit.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgDeposit, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgDeposit;
  static deserializeBinaryFromReader(message: MsgDeposit, reader: jspb.BinaryReader): MsgDeposit;
}

export namespace MsgDeposit {
  export type AsObject = {
    sender: string,
    subaccountId: string,
    amount?: cosmos_base_v1beta1_coin_pb.Coin.AsObject,
  }
}

export class MsgDepositResponse extends jspb.Message {
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgDepositResponse.AsObject;
  static toObject(includeInstance: boolean, msg: MsgDepositResponse): MsgDepositResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgDepositResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgDepositResponse;
  static deserializeBinaryFromReader(message: MsgDepositResponse, reader: jspb.BinaryReader): MsgDepositResponse;
}

export namespace MsgDepositResponse {
  export type AsObject = {
  }
}

export class MsgWithdraw extends jspb.Message {
  getSender(): string;
  setSender(value: string): void;

  getSubaccountId(): string;
  setSubaccountId(value: string): void;

  hasAmount(): boolean;
  clearAmount(): void;
  getAmount(): cosmos_base_v1beta1_coin_pb.Coin | undefined;
  setAmount(value?: cosmos_base_v1beta1_coin_pb.Coin): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgWithdraw.AsObject;
  static toObject(includeInstance: boolean, msg: MsgWithdraw): MsgWithdraw.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgWithdraw, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgWithdraw;
  static deserializeBinaryFromReader(message: MsgWithdraw, reader: jspb.BinaryReader): MsgWithdraw;
}

export namespace MsgWithdraw {
  export type AsObject = {
    sender: string,
    subaccountId: string,
    amount?: cosmos_base_v1beta1_coin_pb.Coin.AsObject,
  }
}

export class MsgWithdrawResponse extends jspb.Message {
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgWithdrawResponse.AsObject;
  static toObject(includeInstance: boolean, msg: MsgWithdrawResponse): MsgWithdrawResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgWithdrawResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgWithdrawResponse;
  static deserializeBinaryFromReader(message: MsgWithdrawResponse, reader: jspb.BinaryReader): MsgWithdrawResponse;
}

export namespace MsgWithdrawResponse {
  export type AsObject = {
  }
}

export class MsgCreateSpotLimitOrder extends jspb.Message {
  getSender(): string;
  setSender(value: string): void;

  hasOrder(): boolean;
  clearOrder(): void;
  getOrder(): injective_exchange_v1beta1_exchange_pb.SpotOrder | undefined;
  setOrder(value?: injective_exchange_v1beta1_exchange_pb.SpotOrder): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgCreateSpotLimitOrder.AsObject;
  static toObject(includeInstance: boolean, msg: MsgCreateSpotLimitOrder): MsgCreateSpotLimitOrder.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgCreateSpotLimitOrder, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgCreateSpotLimitOrder;
  static deserializeBinaryFromReader(message: MsgCreateSpotLimitOrder, reader: jspb.BinaryReader): MsgCreateSpotLimitOrder;
}

export namespace MsgCreateSpotLimitOrder {
  export type AsObject = {
    sender: string,
    order?: injective_exchange_v1beta1_exchange_pb.SpotOrder.AsObject,
  }
}

export class MsgCreateSpotLimitOrderResponse extends jspb.Message {
  getOrderHash(): string;
  setOrderHash(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgCreateSpotLimitOrderResponse.AsObject;
  static toObject(includeInstance: boolean, msg: MsgCreateSpotLimitOrderResponse): MsgCreateSpotLimitOrderResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgCreateSpotLimitOrderResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgCreateSpotLimitOrderResponse;
  static deserializeBinaryFromReader(message: MsgCreateSpotLimitOrderResponse, reader: jspb.BinaryReader): MsgCreateSpotLimitOrderResponse;
}

export namespace MsgCreateSpotLimitOrderResponse {
  export type AsObject = {
    orderHash: string,
  }
}

export class MsgBatchCreateSpotLimitOrders extends jspb.Message {
  getSender(): string;
  setSender(value: string): void;

  clearOrdersList(): void;
  getOrdersList(): Array<injective_exchange_v1beta1_exchange_pb.SpotOrder>;
  setOrdersList(value: Array<injective_exchange_v1beta1_exchange_pb.SpotOrder>): void;
  addOrders(value?: injective_exchange_v1beta1_exchange_pb.SpotOrder, index?: number): injective_exchange_v1beta1_exchange_pb.SpotOrder;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgBatchCreateSpotLimitOrders.AsObject;
  static toObject(includeInstance: boolean, msg: MsgBatchCreateSpotLimitOrders): MsgBatchCreateSpotLimitOrders.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgBatchCreateSpotLimitOrders, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgBatchCreateSpotLimitOrders;
  static deserializeBinaryFromReader(message: MsgBatchCreateSpotLimitOrders, reader: jspb.BinaryReader): MsgBatchCreateSpotLimitOrders;
}

export namespace MsgBatchCreateSpotLimitOrders {
  export type AsObject = {
    sender: string,
    ordersList: Array<injective_exchange_v1beta1_exchange_pb.SpotOrder.AsObject>,
  }
}

export class MsgBatchCreateSpotLimitOrdersResponse extends jspb.Message {
  clearOrderHashesList(): void;
  getOrderHashesList(): Array<string>;
  setOrderHashesList(value: Array<string>): void;
  addOrderHashes(value: string, index?: number): string;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgBatchCreateSpotLimitOrdersResponse.AsObject;
  static toObject(includeInstance: boolean, msg: MsgBatchCreateSpotLimitOrdersResponse): MsgBatchCreateSpotLimitOrdersResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgBatchCreateSpotLimitOrdersResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgBatchCreateSpotLimitOrdersResponse;
  static deserializeBinaryFromReader(message: MsgBatchCreateSpotLimitOrdersResponse, reader: jspb.BinaryReader): MsgBatchCreateSpotLimitOrdersResponse;
}

export namespace MsgBatchCreateSpotLimitOrdersResponse {
  export type AsObject = {
    orderHashesList: Array<string>,
  }
}

export class MsgInstantSpotMarketLaunch extends jspb.Message {
  getSender(): string;
  setSender(value: string): void;

  getTicker(): string;
  setTicker(value: string): void;

  getBaseDenom(): string;
  setBaseDenom(value: string): void;

  getQuoteDenom(): string;
  setQuoteDenom(value: string): void;

  getMinPriceTickSize(): string;
  setMinPriceTickSize(value: string): void;

  getMinQuantityTickSize(): string;
  setMinQuantityTickSize(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgInstantSpotMarketLaunch.AsObject;
  static toObject(includeInstance: boolean, msg: MsgInstantSpotMarketLaunch): MsgInstantSpotMarketLaunch.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgInstantSpotMarketLaunch, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgInstantSpotMarketLaunch;
  static deserializeBinaryFromReader(message: MsgInstantSpotMarketLaunch, reader: jspb.BinaryReader): MsgInstantSpotMarketLaunch;
}

export namespace MsgInstantSpotMarketLaunch {
  export type AsObject = {
    sender: string,
    ticker: string,
    baseDenom: string,
    quoteDenom: string,
    minPriceTickSize: string,
    minQuantityTickSize: string,
  }
}

export class MsgInstantSpotMarketLaunchResponse extends jspb.Message {
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgInstantSpotMarketLaunchResponse.AsObject;
  static toObject(includeInstance: boolean, msg: MsgInstantSpotMarketLaunchResponse): MsgInstantSpotMarketLaunchResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgInstantSpotMarketLaunchResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgInstantSpotMarketLaunchResponse;
  static deserializeBinaryFromReader(message: MsgInstantSpotMarketLaunchResponse, reader: jspb.BinaryReader): MsgInstantSpotMarketLaunchResponse;
}

export namespace MsgInstantSpotMarketLaunchResponse {
  export type AsObject = {
  }
}

export class MsgInstantPerpetualMarketLaunch extends jspb.Message {
  getSender(): string;
  setSender(value: string): void;

  getTicker(): string;
  setTicker(value: string): void;

  getQuoteDenom(): string;
  setQuoteDenom(value: string): void;

  getOracleBase(): string;
  setOracleBase(value: string): void;

  getOracleQuote(): string;
  setOracleQuote(value: string): void;

  getOracleScaleFactor(): number;
  setOracleScaleFactor(value: number): void;

  getOracleType(): injective_oracle_v1beta1_oracle_pb.OracleTypeMap[keyof injective_oracle_v1beta1_oracle_pb.OracleTypeMap];
  setOracleType(value: injective_oracle_v1beta1_oracle_pb.OracleTypeMap[keyof injective_oracle_v1beta1_oracle_pb.OracleTypeMap]): void;

  getMakerFeeRate(): string;
  setMakerFeeRate(value: string): void;

  getTakerFeeRate(): string;
  setTakerFeeRate(value: string): void;

  getInitialMarginRatio(): string;
  setInitialMarginRatio(value: string): void;

  getMaintenanceMarginRatio(): string;
  setMaintenanceMarginRatio(value: string): void;

  getMinPriceTickSize(): string;
  setMinPriceTickSize(value: string): void;

  getMinQuantityTickSize(): string;
  setMinQuantityTickSize(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgInstantPerpetualMarketLaunch.AsObject;
  static toObject(includeInstance: boolean, msg: MsgInstantPerpetualMarketLaunch): MsgInstantPerpetualMarketLaunch.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgInstantPerpetualMarketLaunch, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgInstantPerpetualMarketLaunch;
  static deserializeBinaryFromReader(message: MsgInstantPerpetualMarketLaunch, reader: jspb.BinaryReader): MsgInstantPerpetualMarketLaunch;
}

export namespace MsgInstantPerpetualMarketLaunch {
  export type AsObject = {
    sender: string,
    ticker: string,
    quoteDenom: string,
    oracleBase: string,
    oracleQuote: string,
    oracleScaleFactor: number,
    oracleType: injective_oracle_v1beta1_oracle_pb.OracleTypeMap[keyof injective_oracle_v1beta1_oracle_pb.OracleTypeMap],
    makerFeeRate: string,
    takerFeeRate: string,
    initialMarginRatio: string,
    maintenanceMarginRatio: string,
    minPriceTickSize: string,
    minQuantityTickSize: string,
  }
}

export class MsgInstantPerpetualMarketLaunchResponse extends jspb.Message {
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgInstantPerpetualMarketLaunchResponse.AsObject;
  static toObject(includeInstance: boolean, msg: MsgInstantPerpetualMarketLaunchResponse): MsgInstantPerpetualMarketLaunchResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgInstantPerpetualMarketLaunchResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgInstantPerpetualMarketLaunchResponse;
  static deserializeBinaryFromReader(message: MsgInstantPerpetualMarketLaunchResponse, reader: jspb.BinaryReader): MsgInstantPerpetualMarketLaunchResponse;
}

export namespace MsgInstantPerpetualMarketLaunchResponse {
  export type AsObject = {
  }
}

export class MsgInstantBinaryOptionsMarketLaunch extends jspb.Message {
  getSender(): string;
  setSender(value: string): void;

  getTicker(): string;
  setTicker(value: string): void;

  getOracleSymbol(): string;
  setOracleSymbol(value: string): void;

  getOracleProvider(): string;
  setOracleProvider(value: string): void;

  getOracleType(): injective_oracle_v1beta1_oracle_pb.OracleTypeMap[keyof injective_oracle_v1beta1_oracle_pb.OracleTypeMap];
  setOracleType(value: injective_oracle_v1beta1_oracle_pb.OracleTypeMap[keyof injective_oracle_v1beta1_oracle_pb.OracleTypeMap]): void;

  getOracleScaleFactor(): number;
  setOracleScaleFactor(value: number): void;

  getMakerFeeRate(): string;
  setMakerFeeRate(value: string): void;

  getTakerFeeRate(): string;
  setTakerFeeRate(value: string): void;

  getExpirationTimestamp(): number;
  setExpirationTimestamp(value: number): void;

  getSettlementTimestamp(): number;
  setSettlementTimestamp(value: number): void;

  getAdmin(): string;
  setAdmin(value: string): void;

  getQuoteDenom(): string;
  setQuoteDenom(value: string): void;

  getMinPriceTickSize(): string;
  setMinPriceTickSize(value: string): void;

  getMinQuantityTickSize(): string;
  setMinQuantityTickSize(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgInstantBinaryOptionsMarketLaunch.AsObject;
  static toObject(includeInstance: boolean, msg: MsgInstantBinaryOptionsMarketLaunch): MsgInstantBinaryOptionsMarketLaunch.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgInstantBinaryOptionsMarketLaunch, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgInstantBinaryOptionsMarketLaunch;
  static deserializeBinaryFromReader(message: MsgInstantBinaryOptionsMarketLaunch, reader: jspb.BinaryReader): MsgInstantBinaryOptionsMarketLaunch;
}

export namespace MsgInstantBinaryOptionsMarketLaunch {
  export type AsObject = {
    sender: string,
    ticker: string,
    oracleSymbol: string,
    oracleProvider: string,
    oracleType: injective_oracle_v1beta1_oracle_pb.OracleTypeMap[keyof injective_oracle_v1beta1_oracle_pb.OracleTypeMap],
    oracleScaleFactor: number,
    makerFeeRate: string,
    takerFeeRate: string,
    expirationTimestamp: number,
    settlementTimestamp: number,
    admin: string,
    quoteDenom: string,
    minPriceTickSize: string,
    minQuantityTickSize: string,
  }
}

export class MsgInstantBinaryOptionsMarketLaunchResponse extends jspb.Message {
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgInstantBinaryOptionsMarketLaunchResponse.AsObject;
  static toObject(includeInstance: boolean, msg: MsgInstantBinaryOptionsMarketLaunchResponse): MsgInstantBinaryOptionsMarketLaunchResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgInstantBinaryOptionsMarketLaunchResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgInstantBinaryOptionsMarketLaunchResponse;
  static deserializeBinaryFromReader(message: MsgInstantBinaryOptionsMarketLaunchResponse, reader: jspb.BinaryReader): MsgInstantBinaryOptionsMarketLaunchResponse;
}

export namespace MsgInstantBinaryOptionsMarketLaunchResponse {
  export type AsObject = {
  }
}

export class MsgInstantExpiryFuturesMarketLaunch extends jspb.Message {
  getSender(): string;
  setSender(value: string): void;

  getTicker(): string;
  setTicker(value: string): void;

  getQuoteDenom(): string;
  setQuoteDenom(value: string): void;

  getOracleBase(): string;
  setOracleBase(value: string): void;

  getOracleQuote(): string;
  setOracleQuote(value: string): void;

  getOracleType(): injective_oracle_v1beta1_oracle_pb.OracleTypeMap[keyof injective_oracle_v1beta1_oracle_pb.OracleTypeMap];
  setOracleType(value: injective_oracle_v1beta1_oracle_pb.OracleTypeMap[keyof injective_oracle_v1beta1_oracle_pb.OracleTypeMap]): void;

  getOracleScaleFactor(): number;
  setOracleScaleFactor(value: number): void;

  getExpiry(): number;
  setExpiry(value: number): void;

  getMakerFeeRate(): string;
  setMakerFeeRate(value: string): void;

  getTakerFeeRate(): string;
  setTakerFeeRate(value: string): void;

  getInitialMarginRatio(): string;
  setInitialMarginRatio(value: string): void;

  getMaintenanceMarginRatio(): string;
  setMaintenanceMarginRatio(value: string): void;

  getMinPriceTickSize(): string;
  setMinPriceTickSize(value: string): void;

  getMinQuantityTickSize(): string;
  setMinQuantityTickSize(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgInstantExpiryFuturesMarketLaunch.AsObject;
  static toObject(includeInstance: boolean, msg: MsgInstantExpiryFuturesMarketLaunch): MsgInstantExpiryFuturesMarketLaunch.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgInstantExpiryFuturesMarketLaunch, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgInstantExpiryFuturesMarketLaunch;
  static deserializeBinaryFromReader(message: MsgInstantExpiryFuturesMarketLaunch, reader: jspb.BinaryReader): MsgInstantExpiryFuturesMarketLaunch;
}

export namespace MsgInstantExpiryFuturesMarketLaunch {
  export type AsObject = {
    sender: string,
    ticker: string,
    quoteDenom: string,
    oracleBase: string,
    oracleQuote: string,
    oracleType: injective_oracle_v1beta1_oracle_pb.OracleTypeMap[keyof injective_oracle_v1beta1_oracle_pb.OracleTypeMap],
    oracleScaleFactor: number,
    expiry: number,
    makerFeeRate: string,
    takerFeeRate: string,
    initialMarginRatio: string,
    maintenanceMarginRatio: string,
    minPriceTickSize: string,
    minQuantityTickSize: string,
  }
}

export class MsgInstantExpiryFuturesMarketLaunchResponse extends jspb.Message {
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgInstantExpiryFuturesMarketLaunchResponse.AsObject;
  static toObject(includeInstance: boolean, msg: MsgInstantExpiryFuturesMarketLaunchResponse): MsgInstantExpiryFuturesMarketLaunchResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgInstantExpiryFuturesMarketLaunchResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgInstantExpiryFuturesMarketLaunchResponse;
  static deserializeBinaryFromReader(message: MsgInstantExpiryFuturesMarketLaunchResponse, reader: jspb.BinaryReader): MsgInstantExpiryFuturesMarketLaunchResponse;
}

export namespace MsgInstantExpiryFuturesMarketLaunchResponse {
  export type AsObject = {
  }
}

export class MsgCreateSpotMarketOrder extends jspb.Message {
  getSender(): string;
  setSender(value: string): void;

  hasOrder(): boolean;
  clearOrder(): void;
  getOrder(): injective_exchange_v1beta1_exchange_pb.SpotOrder | undefined;
  setOrder(value?: injective_exchange_v1beta1_exchange_pb.SpotOrder): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgCreateSpotMarketOrder.AsObject;
  static toObject(includeInstance: boolean, msg: MsgCreateSpotMarketOrder): MsgCreateSpotMarketOrder.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgCreateSpotMarketOrder, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgCreateSpotMarketOrder;
  static deserializeBinaryFromReader(message: MsgCreateSpotMarketOrder, reader: jspb.BinaryReader): MsgCreateSpotMarketOrder;
}

export namespace MsgCreateSpotMarketOrder {
  export type AsObject = {
    sender: string,
    order?: injective_exchange_v1beta1_exchange_pb.SpotOrder.AsObject,
  }
}

export class MsgCreateSpotMarketOrderResponse extends jspb.Message {
  getOrderHash(): string;
  setOrderHash(value: string): void;

  hasResults(): boolean;
  clearResults(): void;
  getResults(): SpotMarketOrderResults | undefined;
  setResults(value?: SpotMarketOrderResults): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgCreateSpotMarketOrderResponse.AsObject;
  static toObject(includeInstance: boolean, msg: MsgCreateSpotMarketOrderResponse): MsgCreateSpotMarketOrderResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgCreateSpotMarketOrderResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgCreateSpotMarketOrderResponse;
  static deserializeBinaryFromReader(message: MsgCreateSpotMarketOrderResponse, reader: jspb.BinaryReader): MsgCreateSpotMarketOrderResponse;
}

export namespace MsgCreateSpotMarketOrderResponse {
  export type AsObject = {
    orderHash: string,
    results?: SpotMarketOrderResults.AsObject,
  }
}

export class SpotMarketOrderResults extends jspb.Message {
  getQuantity(): string;
  setQuantity(value: string): void;

  getPrice(): string;
  setPrice(value: string): void;

  getFee(): string;
  setFee(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): SpotMarketOrderResults.AsObject;
  static toObject(includeInstance: boolean, msg: SpotMarketOrderResults): SpotMarketOrderResults.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: SpotMarketOrderResults, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): SpotMarketOrderResults;
  static deserializeBinaryFromReader(message: SpotMarketOrderResults, reader: jspb.BinaryReader): SpotMarketOrderResults;
}

export namespace SpotMarketOrderResults {
  export type AsObject = {
    quantity: string,
    price: string,
    fee: string,
  }
}

export class MsgCreateDerivativeLimitOrder extends jspb.Message {
  getSender(): string;
  setSender(value: string): void;

  hasOrder(): boolean;
  clearOrder(): void;
  getOrder(): injective_exchange_v1beta1_exchange_pb.DerivativeOrder | undefined;
  setOrder(value?: injective_exchange_v1beta1_exchange_pb.DerivativeOrder): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgCreateDerivativeLimitOrder.AsObject;
  static toObject(includeInstance: boolean, msg: MsgCreateDerivativeLimitOrder): MsgCreateDerivativeLimitOrder.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgCreateDerivativeLimitOrder, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgCreateDerivativeLimitOrder;
  static deserializeBinaryFromReader(message: MsgCreateDerivativeLimitOrder, reader: jspb.BinaryReader): MsgCreateDerivativeLimitOrder;
}

export namespace MsgCreateDerivativeLimitOrder {
  export type AsObject = {
    sender: string,
    order?: injective_exchange_v1beta1_exchange_pb.DerivativeOrder.AsObject,
  }
}

export class MsgCreateDerivativeLimitOrderResponse extends jspb.Message {
  getOrderHash(): string;
  setOrderHash(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgCreateDerivativeLimitOrderResponse.AsObject;
  static toObject(includeInstance: boolean, msg: MsgCreateDerivativeLimitOrderResponse): MsgCreateDerivativeLimitOrderResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgCreateDerivativeLimitOrderResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgCreateDerivativeLimitOrderResponse;
  static deserializeBinaryFromReader(message: MsgCreateDerivativeLimitOrderResponse, reader: jspb.BinaryReader): MsgCreateDerivativeLimitOrderResponse;
}

export namespace MsgCreateDerivativeLimitOrderResponse {
  export type AsObject = {
    orderHash: string,
  }
}

export class MsgCreateBinaryOptionsLimitOrder extends jspb.Message {
  getSender(): string;
  setSender(value: string): void;

  hasOrder(): boolean;
  clearOrder(): void;
  getOrder(): injective_exchange_v1beta1_exchange_pb.DerivativeOrder | undefined;
  setOrder(value?: injective_exchange_v1beta1_exchange_pb.DerivativeOrder): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgCreateBinaryOptionsLimitOrder.AsObject;
  static toObject(includeInstance: boolean, msg: MsgCreateBinaryOptionsLimitOrder): MsgCreateBinaryOptionsLimitOrder.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgCreateBinaryOptionsLimitOrder, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgCreateBinaryOptionsLimitOrder;
  static deserializeBinaryFromReader(message: MsgCreateBinaryOptionsLimitOrder, reader: jspb.BinaryReader): MsgCreateBinaryOptionsLimitOrder;
}

export namespace MsgCreateBinaryOptionsLimitOrder {
  export type AsObject = {
    sender: string,
    order?: injective_exchange_v1beta1_exchange_pb.DerivativeOrder.AsObject,
  }
}

export class MsgCreateBinaryOptionsLimitOrderResponse extends jspb.Message {
  getOrderHash(): string;
  setOrderHash(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgCreateBinaryOptionsLimitOrderResponse.AsObject;
  static toObject(includeInstance: boolean, msg: MsgCreateBinaryOptionsLimitOrderResponse): MsgCreateBinaryOptionsLimitOrderResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgCreateBinaryOptionsLimitOrderResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgCreateBinaryOptionsLimitOrderResponse;
  static deserializeBinaryFromReader(message: MsgCreateBinaryOptionsLimitOrderResponse, reader: jspb.BinaryReader): MsgCreateBinaryOptionsLimitOrderResponse;
}

export namespace MsgCreateBinaryOptionsLimitOrderResponse {
  export type AsObject = {
    orderHash: string,
  }
}

export class MsgBatchCreateDerivativeLimitOrders extends jspb.Message {
  getSender(): string;
  setSender(value: string): void;

  clearOrdersList(): void;
  getOrdersList(): Array<injective_exchange_v1beta1_exchange_pb.DerivativeOrder>;
  setOrdersList(value: Array<injective_exchange_v1beta1_exchange_pb.DerivativeOrder>): void;
  addOrders(value?: injective_exchange_v1beta1_exchange_pb.DerivativeOrder, index?: number): injective_exchange_v1beta1_exchange_pb.DerivativeOrder;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgBatchCreateDerivativeLimitOrders.AsObject;
  static toObject(includeInstance: boolean, msg: MsgBatchCreateDerivativeLimitOrders): MsgBatchCreateDerivativeLimitOrders.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgBatchCreateDerivativeLimitOrders, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgBatchCreateDerivativeLimitOrders;
  static deserializeBinaryFromReader(message: MsgBatchCreateDerivativeLimitOrders, reader: jspb.BinaryReader): MsgBatchCreateDerivativeLimitOrders;
}

export namespace MsgBatchCreateDerivativeLimitOrders {
  export type AsObject = {
    sender: string,
    ordersList: Array<injective_exchange_v1beta1_exchange_pb.DerivativeOrder.AsObject>,
  }
}

export class MsgBatchCreateDerivativeLimitOrdersResponse extends jspb.Message {
  clearOrderHashesList(): void;
  getOrderHashesList(): Array<string>;
  setOrderHashesList(value: Array<string>): void;
  addOrderHashes(value: string, index?: number): string;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgBatchCreateDerivativeLimitOrdersResponse.AsObject;
  static toObject(includeInstance: boolean, msg: MsgBatchCreateDerivativeLimitOrdersResponse): MsgBatchCreateDerivativeLimitOrdersResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgBatchCreateDerivativeLimitOrdersResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgBatchCreateDerivativeLimitOrdersResponse;
  static deserializeBinaryFromReader(message: MsgBatchCreateDerivativeLimitOrdersResponse, reader: jspb.BinaryReader): MsgBatchCreateDerivativeLimitOrdersResponse;
}

export namespace MsgBatchCreateDerivativeLimitOrdersResponse {
  export type AsObject = {
    orderHashesList: Array<string>,
  }
}

export class MsgCancelSpotOrder extends jspb.Message {
  getSender(): string;
  setSender(value: string): void;

  getMarketId(): string;
  setMarketId(value: string): void;

  getSubaccountId(): string;
  setSubaccountId(value: string): void;

  getOrderHash(): string;
  setOrderHash(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgCancelSpotOrder.AsObject;
  static toObject(includeInstance: boolean, msg: MsgCancelSpotOrder): MsgCancelSpotOrder.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgCancelSpotOrder, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgCancelSpotOrder;
  static deserializeBinaryFromReader(message: MsgCancelSpotOrder, reader: jspb.BinaryReader): MsgCancelSpotOrder;
}

export namespace MsgCancelSpotOrder {
  export type AsObject = {
    sender: string,
    marketId: string,
    subaccountId: string,
    orderHash: string,
  }
}

export class MsgCancelSpotOrderResponse extends jspb.Message {
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgCancelSpotOrderResponse.AsObject;
  static toObject(includeInstance: boolean, msg: MsgCancelSpotOrderResponse): MsgCancelSpotOrderResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgCancelSpotOrderResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgCancelSpotOrderResponse;
  static deserializeBinaryFromReader(message: MsgCancelSpotOrderResponse, reader: jspb.BinaryReader): MsgCancelSpotOrderResponse;
}

export namespace MsgCancelSpotOrderResponse {
  export type AsObject = {
  }
}

export class MsgBatchCancelSpotOrders extends jspb.Message {
  getSender(): string;
  setSender(value: string): void;

  clearDataList(): void;
  getDataList(): Array<OrderData>;
  setDataList(value: Array<OrderData>): void;
  addData(value?: OrderData, index?: number): OrderData;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgBatchCancelSpotOrders.AsObject;
  static toObject(includeInstance: boolean, msg: MsgBatchCancelSpotOrders): MsgBatchCancelSpotOrders.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgBatchCancelSpotOrders, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgBatchCancelSpotOrders;
  static deserializeBinaryFromReader(message: MsgBatchCancelSpotOrders, reader: jspb.BinaryReader): MsgBatchCancelSpotOrders;
}

export namespace MsgBatchCancelSpotOrders {
  export type AsObject = {
    sender: string,
    dataList: Array<OrderData.AsObject>,
  }
}

export class MsgBatchCancelSpotOrdersResponse extends jspb.Message {
  clearSuccessList(): void;
  getSuccessList(): Array<boolean>;
  setSuccessList(value: Array<boolean>): void;
  addSuccess(value: boolean, index?: number): boolean;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgBatchCancelSpotOrdersResponse.AsObject;
  static toObject(includeInstance: boolean, msg: MsgBatchCancelSpotOrdersResponse): MsgBatchCancelSpotOrdersResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgBatchCancelSpotOrdersResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgBatchCancelSpotOrdersResponse;
  static deserializeBinaryFromReader(message: MsgBatchCancelSpotOrdersResponse, reader: jspb.BinaryReader): MsgBatchCancelSpotOrdersResponse;
}

export namespace MsgBatchCancelSpotOrdersResponse {
  export type AsObject = {
    successList: Array<boolean>,
  }
}

export class MsgBatchCancelBinaryOptionsOrders extends jspb.Message {
  getSender(): string;
  setSender(value: string): void;

  clearDataList(): void;
  getDataList(): Array<OrderData>;
  setDataList(value: Array<OrderData>): void;
  addData(value?: OrderData, index?: number): OrderData;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgBatchCancelBinaryOptionsOrders.AsObject;
  static toObject(includeInstance: boolean, msg: MsgBatchCancelBinaryOptionsOrders): MsgBatchCancelBinaryOptionsOrders.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgBatchCancelBinaryOptionsOrders, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgBatchCancelBinaryOptionsOrders;
  static deserializeBinaryFromReader(message: MsgBatchCancelBinaryOptionsOrders, reader: jspb.BinaryReader): MsgBatchCancelBinaryOptionsOrders;
}

export namespace MsgBatchCancelBinaryOptionsOrders {
  export type AsObject = {
    sender: string,
    dataList: Array<OrderData.AsObject>,
  }
}

export class MsgBatchCancelBinaryOptionsOrdersResponse extends jspb.Message {
  clearSuccessList(): void;
  getSuccessList(): Array<boolean>;
  setSuccessList(value: Array<boolean>): void;
  addSuccess(value: boolean, index?: number): boolean;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgBatchCancelBinaryOptionsOrdersResponse.AsObject;
  static toObject(includeInstance: boolean, msg: MsgBatchCancelBinaryOptionsOrdersResponse): MsgBatchCancelBinaryOptionsOrdersResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgBatchCancelBinaryOptionsOrdersResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgBatchCancelBinaryOptionsOrdersResponse;
  static deserializeBinaryFromReader(message: MsgBatchCancelBinaryOptionsOrdersResponse, reader: jspb.BinaryReader): MsgBatchCancelBinaryOptionsOrdersResponse;
}

export namespace MsgBatchCancelBinaryOptionsOrdersResponse {
  export type AsObject = {
    successList: Array<boolean>,
  }
}

export class MsgBatchUpdateOrders extends jspb.Message {
  getSender(): string;
  setSender(value: string): void;

  getSubaccountId(): string;
  setSubaccountId(value: string): void;

  clearSpotMarketIdsToCancelAllList(): void;
  getSpotMarketIdsToCancelAllList(): Array<string>;
  setSpotMarketIdsToCancelAllList(value: Array<string>): void;
  addSpotMarketIdsToCancelAll(value: string, index?: number): string;

  clearDerivativeMarketIdsToCancelAllList(): void;
  getDerivativeMarketIdsToCancelAllList(): Array<string>;
  setDerivativeMarketIdsToCancelAllList(value: Array<string>): void;
  addDerivativeMarketIdsToCancelAll(value: string, index?: number): string;

  clearSpotOrdersToCancelList(): void;
  getSpotOrdersToCancelList(): Array<OrderData>;
  setSpotOrdersToCancelList(value: Array<OrderData>): void;
  addSpotOrdersToCancel(value?: OrderData, index?: number): OrderData;

  clearDerivativeOrdersToCancelList(): void;
  getDerivativeOrdersToCancelList(): Array<OrderData>;
  setDerivativeOrdersToCancelList(value: Array<OrderData>): void;
  addDerivativeOrdersToCancel(value?: OrderData, index?: number): OrderData;

  clearSpotOrdersToCreateList(): void;
  getSpotOrdersToCreateList(): Array<injective_exchange_v1beta1_exchange_pb.SpotOrder>;
  setSpotOrdersToCreateList(value: Array<injective_exchange_v1beta1_exchange_pb.SpotOrder>): void;
  addSpotOrdersToCreate(value?: injective_exchange_v1beta1_exchange_pb.SpotOrder, index?: number): injective_exchange_v1beta1_exchange_pb.SpotOrder;

  clearDerivativeOrdersToCreateList(): void;
  getDerivativeOrdersToCreateList(): Array<injective_exchange_v1beta1_exchange_pb.DerivativeOrder>;
  setDerivativeOrdersToCreateList(value: Array<injective_exchange_v1beta1_exchange_pb.DerivativeOrder>): void;
  addDerivativeOrdersToCreate(value?: injective_exchange_v1beta1_exchange_pb.DerivativeOrder, index?: number): injective_exchange_v1beta1_exchange_pb.DerivativeOrder;

  clearBinaryOptionsOrdersToCancelList(): void;
  getBinaryOptionsOrdersToCancelList(): Array<OrderData>;
  setBinaryOptionsOrdersToCancelList(value: Array<OrderData>): void;
  addBinaryOptionsOrdersToCancel(value?: OrderData, index?: number): OrderData;

  clearBinaryOptionsMarketIdsToCancelAllList(): void;
  getBinaryOptionsMarketIdsToCancelAllList(): Array<string>;
  setBinaryOptionsMarketIdsToCancelAllList(value: Array<string>): void;
  addBinaryOptionsMarketIdsToCancelAll(value: string, index?: number): string;

  clearBinaryOptionsOrdersToCreateList(): void;
  getBinaryOptionsOrdersToCreateList(): Array<injective_exchange_v1beta1_exchange_pb.DerivativeOrder>;
  setBinaryOptionsOrdersToCreateList(value: Array<injective_exchange_v1beta1_exchange_pb.DerivativeOrder>): void;
  addBinaryOptionsOrdersToCreate(value?: injective_exchange_v1beta1_exchange_pb.DerivativeOrder, index?: number): injective_exchange_v1beta1_exchange_pb.DerivativeOrder;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgBatchUpdateOrders.AsObject;
  static toObject(includeInstance: boolean, msg: MsgBatchUpdateOrders): MsgBatchUpdateOrders.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgBatchUpdateOrders, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgBatchUpdateOrders;
  static deserializeBinaryFromReader(message: MsgBatchUpdateOrders, reader: jspb.BinaryReader): MsgBatchUpdateOrders;
}

export namespace MsgBatchUpdateOrders {
  export type AsObject = {
    sender: string,
    subaccountId: string,
    spotMarketIdsToCancelAllList: Array<string>,
    derivativeMarketIdsToCancelAllList: Array<string>,
    spotOrdersToCancelList: Array<OrderData.AsObject>,
    derivativeOrdersToCancelList: Array<OrderData.AsObject>,
    spotOrdersToCreateList: Array<injective_exchange_v1beta1_exchange_pb.SpotOrder.AsObject>,
    derivativeOrdersToCreateList: Array<injective_exchange_v1beta1_exchange_pb.DerivativeOrder.AsObject>,
    binaryOptionsOrdersToCancelList: Array<OrderData.AsObject>,
    binaryOptionsMarketIdsToCancelAllList: Array<string>,
    binaryOptionsOrdersToCreateList: Array<injective_exchange_v1beta1_exchange_pb.DerivativeOrder.AsObject>,
  }
}

export class MsgBatchUpdateOrdersResponse extends jspb.Message {
  clearSpotCancelSuccessList(): void;
  getSpotCancelSuccessList(): Array<boolean>;
  setSpotCancelSuccessList(value: Array<boolean>): void;
  addSpotCancelSuccess(value: boolean, index?: number): boolean;

  clearDerivativeCancelSuccessList(): void;
  getDerivativeCancelSuccessList(): Array<boolean>;
  setDerivativeCancelSuccessList(value: Array<boolean>): void;
  addDerivativeCancelSuccess(value: boolean, index?: number): boolean;

  clearSpotOrderHashesList(): void;
  getSpotOrderHashesList(): Array<string>;
  setSpotOrderHashesList(value: Array<string>): void;
  addSpotOrderHashes(value: string, index?: number): string;

  clearDerivativeOrderHashesList(): void;
  getDerivativeOrderHashesList(): Array<string>;
  setDerivativeOrderHashesList(value: Array<string>): void;
  addDerivativeOrderHashes(value: string, index?: number): string;

  clearBinaryOptionsCancelSuccessList(): void;
  getBinaryOptionsCancelSuccessList(): Array<boolean>;
  setBinaryOptionsCancelSuccessList(value: Array<boolean>): void;
  addBinaryOptionsCancelSuccess(value: boolean, index?: number): boolean;

  clearBinaryOptionsOrderHashesList(): void;
  getBinaryOptionsOrderHashesList(): Array<string>;
  setBinaryOptionsOrderHashesList(value: Array<string>): void;
  addBinaryOptionsOrderHashes(value: string, index?: number): string;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgBatchUpdateOrdersResponse.AsObject;
  static toObject(includeInstance: boolean, msg: MsgBatchUpdateOrdersResponse): MsgBatchUpdateOrdersResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgBatchUpdateOrdersResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgBatchUpdateOrdersResponse;
  static deserializeBinaryFromReader(message: MsgBatchUpdateOrdersResponse, reader: jspb.BinaryReader): MsgBatchUpdateOrdersResponse;
}

export namespace MsgBatchUpdateOrdersResponse {
  export type AsObject = {
    spotCancelSuccessList: Array<boolean>,
    derivativeCancelSuccessList: Array<boolean>,
    spotOrderHashesList: Array<string>,
    derivativeOrderHashesList: Array<string>,
    binaryOptionsCancelSuccessList: Array<boolean>,
    binaryOptionsOrderHashesList: Array<string>,
  }
}

export class MsgCreateDerivativeMarketOrder extends jspb.Message {
  getSender(): string;
  setSender(value: string): void;

  hasOrder(): boolean;
  clearOrder(): void;
  getOrder(): injective_exchange_v1beta1_exchange_pb.DerivativeOrder | undefined;
  setOrder(value?: injective_exchange_v1beta1_exchange_pb.DerivativeOrder): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgCreateDerivativeMarketOrder.AsObject;
  static toObject(includeInstance: boolean, msg: MsgCreateDerivativeMarketOrder): MsgCreateDerivativeMarketOrder.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgCreateDerivativeMarketOrder, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgCreateDerivativeMarketOrder;
  static deserializeBinaryFromReader(message: MsgCreateDerivativeMarketOrder, reader: jspb.BinaryReader): MsgCreateDerivativeMarketOrder;
}

export namespace MsgCreateDerivativeMarketOrder {
  export type AsObject = {
    sender: string,
    order?: injective_exchange_v1beta1_exchange_pb.DerivativeOrder.AsObject,
  }
}

export class MsgCreateDerivativeMarketOrderResponse extends jspb.Message {
  getOrderHash(): string;
  setOrderHash(value: string): void;

  hasResults(): boolean;
  clearResults(): void;
  getResults(): DerivativeMarketOrderResults | undefined;
  setResults(value?: DerivativeMarketOrderResults): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgCreateDerivativeMarketOrderResponse.AsObject;
  static toObject(includeInstance: boolean, msg: MsgCreateDerivativeMarketOrderResponse): MsgCreateDerivativeMarketOrderResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgCreateDerivativeMarketOrderResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgCreateDerivativeMarketOrderResponse;
  static deserializeBinaryFromReader(message: MsgCreateDerivativeMarketOrderResponse, reader: jspb.BinaryReader): MsgCreateDerivativeMarketOrderResponse;
}

export namespace MsgCreateDerivativeMarketOrderResponse {
  export type AsObject = {
    orderHash: string,
    results?: DerivativeMarketOrderResults.AsObject,
  }
}

export class DerivativeMarketOrderResults extends jspb.Message {
  getQuantity(): string;
  setQuantity(value: string): void;

  getPrice(): string;
  setPrice(value: string): void;

  getFee(): string;
  setFee(value: string): void;

  hasPositionDelta(): boolean;
  clearPositionDelta(): void;
  getPositionDelta(): injective_exchange_v1beta1_exchange_pb.PositionDelta | undefined;
  setPositionDelta(value?: injective_exchange_v1beta1_exchange_pb.PositionDelta): void;

  getPayout(): string;
  setPayout(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): DerivativeMarketOrderResults.AsObject;
  static toObject(includeInstance: boolean, msg: DerivativeMarketOrderResults): DerivativeMarketOrderResults.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: DerivativeMarketOrderResults, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): DerivativeMarketOrderResults;
  static deserializeBinaryFromReader(message: DerivativeMarketOrderResults, reader: jspb.BinaryReader): DerivativeMarketOrderResults;
}

export namespace DerivativeMarketOrderResults {
  export type AsObject = {
    quantity: string,
    price: string,
    fee: string,
    positionDelta?: injective_exchange_v1beta1_exchange_pb.PositionDelta.AsObject,
    payout: string,
  }
}

export class MsgCreateBinaryOptionsMarketOrder extends jspb.Message {
  getSender(): string;
  setSender(value: string): void;

  hasOrder(): boolean;
  clearOrder(): void;
  getOrder(): injective_exchange_v1beta1_exchange_pb.DerivativeOrder | undefined;
  setOrder(value?: injective_exchange_v1beta1_exchange_pb.DerivativeOrder): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgCreateBinaryOptionsMarketOrder.AsObject;
  static toObject(includeInstance: boolean, msg: MsgCreateBinaryOptionsMarketOrder): MsgCreateBinaryOptionsMarketOrder.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgCreateBinaryOptionsMarketOrder, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgCreateBinaryOptionsMarketOrder;
  static deserializeBinaryFromReader(message: MsgCreateBinaryOptionsMarketOrder, reader: jspb.BinaryReader): MsgCreateBinaryOptionsMarketOrder;
}

export namespace MsgCreateBinaryOptionsMarketOrder {
  export type AsObject = {
    sender: string,
    order?: injective_exchange_v1beta1_exchange_pb.DerivativeOrder.AsObject,
  }
}

export class MsgCreateBinaryOptionsMarketOrderResponse extends jspb.Message {
  getOrderHash(): string;
  setOrderHash(value: string): void;

  hasResults(): boolean;
  clearResults(): void;
  getResults(): DerivativeMarketOrderResults | undefined;
  setResults(value?: DerivativeMarketOrderResults): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgCreateBinaryOptionsMarketOrderResponse.AsObject;
  static toObject(includeInstance: boolean, msg: MsgCreateBinaryOptionsMarketOrderResponse): MsgCreateBinaryOptionsMarketOrderResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgCreateBinaryOptionsMarketOrderResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgCreateBinaryOptionsMarketOrderResponse;
  static deserializeBinaryFromReader(message: MsgCreateBinaryOptionsMarketOrderResponse, reader: jspb.BinaryReader): MsgCreateBinaryOptionsMarketOrderResponse;
}

export namespace MsgCreateBinaryOptionsMarketOrderResponse {
  export type AsObject = {
    orderHash: string,
    results?: DerivativeMarketOrderResults.AsObject,
  }
}

export class MsgCancelDerivativeOrder extends jspb.Message {
  getSender(): string;
  setSender(value: string): void;

  getMarketId(): string;
  setMarketId(value: string): void;

  getSubaccountId(): string;
  setSubaccountId(value: string): void;

  getOrderHash(): string;
  setOrderHash(value: string): void;

  getOrderMask(): number;
  setOrderMask(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgCancelDerivativeOrder.AsObject;
  static toObject(includeInstance: boolean, msg: MsgCancelDerivativeOrder): MsgCancelDerivativeOrder.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgCancelDerivativeOrder, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgCancelDerivativeOrder;
  static deserializeBinaryFromReader(message: MsgCancelDerivativeOrder, reader: jspb.BinaryReader): MsgCancelDerivativeOrder;
}

export namespace MsgCancelDerivativeOrder {
  export type AsObject = {
    sender: string,
    marketId: string,
    subaccountId: string,
    orderHash: string,
    orderMask: number,
  }
}

export class MsgCancelDerivativeOrderResponse extends jspb.Message {
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgCancelDerivativeOrderResponse.AsObject;
  static toObject(includeInstance: boolean, msg: MsgCancelDerivativeOrderResponse): MsgCancelDerivativeOrderResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgCancelDerivativeOrderResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgCancelDerivativeOrderResponse;
  static deserializeBinaryFromReader(message: MsgCancelDerivativeOrderResponse, reader: jspb.BinaryReader): MsgCancelDerivativeOrderResponse;
}

export namespace MsgCancelDerivativeOrderResponse {
  export type AsObject = {
  }
}

export class MsgCancelBinaryOptionsOrder extends jspb.Message {
  getSender(): string;
  setSender(value: string): void;

  getMarketId(): string;
  setMarketId(value: string): void;

  getSubaccountId(): string;
  setSubaccountId(value: string): void;

  getOrderHash(): string;
  setOrderHash(value: string): void;

  getOrderMask(): number;
  setOrderMask(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgCancelBinaryOptionsOrder.AsObject;
  static toObject(includeInstance: boolean, msg: MsgCancelBinaryOptionsOrder): MsgCancelBinaryOptionsOrder.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgCancelBinaryOptionsOrder, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgCancelBinaryOptionsOrder;
  static deserializeBinaryFromReader(message: MsgCancelBinaryOptionsOrder, reader: jspb.BinaryReader): MsgCancelBinaryOptionsOrder;
}

export namespace MsgCancelBinaryOptionsOrder {
  export type AsObject = {
    sender: string,
    marketId: string,
    subaccountId: string,
    orderHash: string,
    orderMask: number,
  }
}

export class MsgCancelBinaryOptionsOrderResponse extends jspb.Message {
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgCancelBinaryOptionsOrderResponse.AsObject;
  static toObject(includeInstance: boolean, msg: MsgCancelBinaryOptionsOrderResponse): MsgCancelBinaryOptionsOrderResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgCancelBinaryOptionsOrderResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgCancelBinaryOptionsOrderResponse;
  static deserializeBinaryFromReader(message: MsgCancelBinaryOptionsOrderResponse, reader: jspb.BinaryReader): MsgCancelBinaryOptionsOrderResponse;
}

export namespace MsgCancelBinaryOptionsOrderResponse {
  export type AsObject = {
  }
}

export class OrderData extends jspb.Message {
  getMarketId(): string;
  setMarketId(value: string): void;

  getSubaccountId(): string;
  setSubaccountId(value: string): void;

  getOrderHash(): string;
  setOrderHash(value: string): void;

  getOrderMask(): number;
  setOrderMask(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): OrderData.AsObject;
  static toObject(includeInstance: boolean, msg: OrderData): OrderData.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: OrderData, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): OrderData;
  static deserializeBinaryFromReader(message: OrderData, reader: jspb.BinaryReader): OrderData;
}

export namespace OrderData {
  export type AsObject = {
    marketId: string,
    subaccountId: string,
    orderHash: string,
    orderMask: number,
  }
}

export class MsgBatchCancelDerivativeOrders extends jspb.Message {
  getSender(): string;
  setSender(value: string): void;

  clearDataList(): void;
  getDataList(): Array<OrderData>;
  setDataList(value: Array<OrderData>): void;
  addData(value?: OrderData, index?: number): OrderData;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgBatchCancelDerivativeOrders.AsObject;
  static toObject(includeInstance: boolean, msg: MsgBatchCancelDerivativeOrders): MsgBatchCancelDerivativeOrders.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgBatchCancelDerivativeOrders, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgBatchCancelDerivativeOrders;
  static deserializeBinaryFromReader(message: MsgBatchCancelDerivativeOrders, reader: jspb.BinaryReader): MsgBatchCancelDerivativeOrders;
}

export namespace MsgBatchCancelDerivativeOrders {
  export type AsObject = {
    sender: string,
    dataList: Array<OrderData.AsObject>,
  }
}

export class MsgBatchCancelDerivativeOrdersResponse extends jspb.Message {
  clearSuccessList(): void;
  getSuccessList(): Array<boolean>;
  setSuccessList(value: Array<boolean>): void;
  addSuccess(value: boolean, index?: number): boolean;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgBatchCancelDerivativeOrdersResponse.AsObject;
  static toObject(includeInstance: boolean, msg: MsgBatchCancelDerivativeOrdersResponse): MsgBatchCancelDerivativeOrdersResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgBatchCancelDerivativeOrdersResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgBatchCancelDerivativeOrdersResponse;
  static deserializeBinaryFromReader(message: MsgBatchCancelDerivativeOrdersResponse, reader: jspb.BinaryReader): MsgBatchCancelDerivativeOrdersResponse;
}

export namespace MsgBatchCancelDerivativeOrdersResponse {
  export type AsObject = {
    successList: Array<boolean>,
  }
}

export class MsgSubaccountTransfer extends jspb.Message {
  getSender(): string;
  setSender(value: string): void;

  getSourceSubaccountId(): string;
  setSourceSubaccountId(value: string): void;

  getDestinationSubaccountId(): string;
  setDestinationSubaccountId(value: string): void;

  hasAmount(): boolean;
  clearAmount(): void;
  getAmount(): cosmos_base_v1beta1_coin_pb.Coin | undefined;
  setAmount(value?: cosmos_base_v1beta1_coin_pb.Coin): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgSubaccountTransfer.AsObject;
  static toObject(includeInstance: boolean, msg: MsgSubaccountTransfer): MsgSubaccountTransfer.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgSubaccountTransfer, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgSubaccountTransfer;
  static deserializeBinaryFromReader(message: MsgSubaccountTransfer, reader: jspb.BinaryReader): MsgSubaccountTransfer;
}

export namespace MsgSubaccountTransfer {
  export type AsObject = {
    sender: string,
    sourceSubaccountId: string,
    destinationSubaccountId: string,
    amount?: cosmos_base_v1beta1_coin_pb.Coin.AsObject,
  }
}

export class MsgSubaccountTransferResponse extends jspb.Message {
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgSubaccountTransferResponse.AsObject;
  static toObject(includeInstance: boolean, msg: MsgSubaccountTransferResponse): MsgSubaccountTransferResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgSubaccountTransferResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgSubaccountTransferResponse;
  static deserializeBinaryFromReader(message: MsgSubaccountTransferResponse, reader: jspb.BinaryReader): MsgSubaccountTransferResponse;
}

export namespace MsgSubaccountTransferResponse {
  export type AsObject = {
  }
}

export class MsgExternalTransfer extends jspb.Message {
  getSender(): string;
  setSender(value: string): void;

  getSourceSubaccountId(): string;
  setSourceSubaccountId(value: string): void;

  getDestinationSubaccountId(): string;
  setDestinationSubaccountId(value: string): void;

  hasAmount(): boolean;
  clearAmount(): void;
  getAmount(): cosmos_base_v1beta1_coin_pb.Coin | undefined;
  setAmount(value?: cosmos_base_v1beta1_coin_pb.Coin): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgExternalTransfer.AsObject;
  static toObject(includeInstance: boolean, msg: MsgExternalTransfer): MsgExternalTransfer.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgExternalTransfer, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgExternalTransfer;
  static deserializeBinaryFromReader(message: MsgExternalTransfer, reader: jspb.BinaryReader): MsgExternalTransfer;
}

export namespace MsgExternalTransfer {
  export type AsObject = {
    sender: string,
    sourceSubaccountId: string,
    destinationSubaccountId: string,
    amount?: cosmos_base_v1beta1_coin_pb.Coin.AsObject,
  }
}

export class MsgExternalTransferResponse extends jspb.Message {
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgExternalTransferResponse.AsObject;
  static toObject(includeInstance: boolean, msg: MsgExternalTransferResponse): MsgExternalTransferResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgExternalTransferResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgExternalTransferResponse;
  static deserializeBinaryFromReader(message: MsgExternalTransferResponse, reader: jspb.BinaryReader): MsgExternalTransferResponse;
}

export namespace MsgExternalTransferResponse {
  export type AsObject = {
  }
}

export class MsgLiquidatePosition extends jspb.Message {
  getSender(): string;
  setSender(value: string): void;

  getSubaccountId(): string;
  setSubaccountId(value: string): void;

  getMarketId(): string;
  setMarketId(value: string): void;

  hasOrder(): boolean;
  clearOrder(): void;
  getOrder(): injective_exchange_v1beta1_exchange_pb.DerivativeOrder | undefined;
  setOrder(value?: injective_exchange_v1beta1_exchange_pb.DerivativeOrder): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgLiquidatePosition.AsObject;
  static toObject(includeInstance: boolean, msg: MsgLiquidatePosition): MsgLiquidatePosition.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgLiquidatePosition, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgLiquidatePosition;
  static deserializeBinaryFromReader(message: MsgLiquidatePosition, reader: jspb.BinaryReader): MsgLiquidatePosition;
}

export namespace MsgLiquidatePosition {
  export type AsObject = {
    sender: string,
    subaccountId: string,
    marketId: string,
    order?: injective_exchange_v1beta1_exchange_pb.DerivativeOrder.AsObject,
  }
}

export class MsgLiquidatePositionResponse extends jspb.Message {
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgLiquidatePositionResponse.AsObject;
  static toObject(includeInstance: boolean, msg: MsgLiquidatePositionResponse): MsgLiquidatePositionResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgLiquidatePositionResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgLiquidatePositionResponse;
  static deserializeBinaryFromReader(message: MsgLiquidatePositionResponse, reader: jspb.BinaryReader): MsgLiquidatePositionResponse;
}

export namespace MsgLiquidatePositionResponse {
  export type AsObject = {
  }
}

export class MsgIncreasePositionMargin extends jspb.Message {
  getSender(): string;
  setSender(value: string): void;

  getSourceSubaccountId(): string;
  setSourceSubaccountId(value: string): void;

  getDestinationSubaccountId(): string;
  setDestinationSubaccountId(value: string): void;

  getMarketId(): string;
  setMarketId(value: string): void;

  getAmount(): string;
  setAmount(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgIncreasePositionMargin.AsObject;
  static toObject(includeInstance: boolean, msg: MsgIncreasePositionMargin): MsgIncreasePositionMargin.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgIncreasePositionMargin, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgIncreasePositionMargin;
  static deserializeBinaryFromReader(message: MsgIncreasePositionMargin, reader: jspb.BinaryReader): MsgIncreasePositionMargin;
}

export namespace MsgIncreasePositionMargin {
  export type AsObject = {
    sender: string,
    sourceSubaccountId: string,
    destinationSubaccountId: string,
    marketId: string,
    amount: string,
  }
}

export class MsgIncreasePositionMarginResponse extends jspb.Message {
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgIncreasePositionMarginResponse.AsObject;
  static toObject(includeInstance: boolean, msg: MsgIncreasePositionMarginResponse): MsgIncreasePositionMarginResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgIncreasePositionMarginResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgIncreasePositionMarginResponse;
  static deserializeBinaryFromReader(message: MsgIncreasePositionMarginResponse, reader: jspb.BinaryReader): MsgIncreasePositionMarginResponse;
}

export namespace MsgIncreasePositionMarginResponse {
  export type AsObject = {
  }
}

export class MsgPrivilegedExecuteContract extends jspb.Message {
  getSender(): string;
  setSender(value: string): void;

  getFunds(): string;
  setFunds(value: string): void;

  getContractAddress(): string;
  setContractAddress(value: string): void;

  getData(): string;
  setData(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgPrivilegedExecuteContract.AsObject;
  static toObject(includeInstance: boolean, msg: MsgPrivilegedExecuteContract): MsgPrivilegedExecuteContract.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgPrivilegedExecuteContract, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgPrivilegedExecuteContract;
  static deserializeBinaryFromReader(message: MsgPrivilegedExecuteContract, reader: jspb.BinaryReader): MsgPrivilegedExecuteContract;
}

export namespace MsgPrivilegedExecuteContract {
  export type AsObject = {
    sender: string,
    funds: string,
    contractAddress: string,
    data: string,
  }
}

export class MsgPrivilegedExecuteContractResponse extends jspb.Message {
  clearFundsDiffList(): void;
  getFundsDiffList(): Array<cosmos_base_v1beta1_coin_pb.Coin>;
  setFundsDiffList(value: Array<cosmos_base_v1beta1_coin_pb.Coin>): void;
  addFundsDiff(value?: cosmos_base_v1beta1_coin_pb.Coin, index?: number): cosmos_base_v1beta1_coin_pb.Coin;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgPrivilegedExecuteContractResponse.AsObject;
  static toObject(includeInstance: boolean, msg: MsgPrivilegedExecuteContractResponse): MsgPrivilegedExecuteContractResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgPrivilegedExecuteContractResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgPrivilegedExecuteContractResponse;
  static deserializeBinaryFromReader(message: MsgPrivilegedExecuteContractResponse, reader: jspb.BinaryReader): MsgPrivilegedExecuteContractResponse;
}

export namespace MsgPrivilegedExecuteContractResponse {
  export type AsObject = {
    fundsDiffList: Array<cosmos_base_v1beta1_coin_pb.Coin.AsObject>,
  }
}

export class SpotMarketParamUpdateProposal extends jspb.Message {
  getTitle(): string;
  setTitle(value: string): void;

  getDescription(): string;
  setDescription(value: string): void;

  getMarketId(): string;
  setMarketId(value: string): void;

  getMakerFeeRate(): string;
  setMakerFeeRate(value: string): void;

  getTakerFeeRate(): string;
  setTakerFeeRate(value: string): void;

  getRelayerFeeShareRate(): string;
  setRelayerFeeShareRate(value: string): void;

  getMinPriceTickSize(): string;
  setMinPriceTickSize(value: string): void;

  getMinQuantityTickSize(): string;
  setMinQuantityTickSize(value: string): void;

  getStatus(): injective_exchange_v1beta1_exchange_pb.MarketStatusMap[keyof injective_exchange_v1beta1_exchange_pb.MarketStatusMap];
  setStatus(value: injective_exchange_v1beta1_exchange_pb.MarketStatusMap[keyof injective_exchange_v1beta1_exchange_pb.MarketStatusMap]): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): SpotMarketParamUpdateProposal.AsObject;
  static toObject(includeInstance: boolean, msg: SpotMarketParamUpdateProposal): SpotMarketParamUpdateProposal.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: SpotMarketParamUpdateProposal, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): SpotMarketParamUpdateProposal;
  static deserializeBinaryFromReader(message: SpotMarketParamUpdateProposal, reader: jspb.BinaryReader): SpotMarketParamUpdateProposal;
}

export namespace SpotMarketParamUpdateProposal {
  export type AsObject = {
    title: string,
    description: string,
    marketId: string,
    makerFeeRate: string,
    takerFeeRate: string,
    relayerFeeShareRate: string,
    minPriceTickSize: string,
    minQuantityTickSize: string,
    status: injective_exchange_v1beta1_exchange_pb.MarketStatusMap[keyof injective_exchange_v1beta1_exchange_pb.MarketStatusMap],
  }
}

export class ExchangeEnableProposal extends jspb.Message {
  getTitle(): string;
  setTitle(value: string): void;

  getDescription(): string;
  setDescription(value: string): void;

  getExchangetype(): ExchangeTypeMap[keyof ExchangeTypeMap];
  setExchangetype(value: ExchangeTypeMap[keyof ExchangeTypeMap]): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ExchangeEnableProposal.AsObject;
  static toObject(includeInstance: boolean, msg: ExchangeEnableProposal): ExchangeEnableProposal.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ExchangeEnableProposal, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ExchangeEnableProposal;
  static deserializeBinaryFromReader(message: ExchangeEnableProposal, reader: jspb.BinaryReader): ExchangeEnableProposal;
}

export namespace ExchangeEnableProposal {
  export type AsObject = {
    title: string,
    description: string,
    exchangetype: ExchangeTypeMap[keyof ExchangeTypeMap],
  }
}

export class BatchExchangeModificationProposal extends jspb.Message {
  getTitle(): string;
  setTitle(value: string): void;

  getDescription(): string;
  setDescription(value: string): void;

  clearSpotMarketParamUpdateProposalsList(): void;
  getSpotMarketParamUpdateProposalsList(): Array<SpotMarketParamUpdateProposal>;
  setSpotMarketParamUpdateProposalsList(value: Array<SpotMarketParamUpdateProposal>): void;
  addSpotMarketParamUpdateProposals(value?: SpotMarketParamUpdateProposal, index?: number): SpotMarketParamUpdateProposal;

  clearDerivativeMarketParamUpdateProposalsList(): void;
  getDerivativeMarketParamUpdateProposalsList(): Array<DerivativeMarketParamUpdateProposal>;
  setDerivativeMarketParamUpdateProposalsList(value: Array<DerivativeMarketParamUpdateProposal>): void;
  addDerivativeMarketParamUpdateProposals(value?: DerivativeMarketParamUpdateProposal, index?: number): DerivativeMarketParamUpdateProposal;

  clearSpotMarketLaunchProposalsList(): void;
  getSpotMarketLaunchProposalsList(): Array<SpotMarketLaunchProposal>;
  setSpotMarketLaunchProposalsList(value: Array<SpotMarketLaunchProposal>): void;
  addSpotMarketLaunchProposals(value?: SpotMarketLaunchProposal, index?: number): SpotMarketLaunchProposal;

  clearPerpetualMarketLaunchProposalsList(): void;
  getPerpetualMarketLaunchProposalsList(): Array<PerpetualMarketLaunchProposal>;
  setPerpetualMarketLaunchProposalsList(value: Array<PerpetualMarketLaunchProposal>): void;
  addPerpetualMarketLaunchProposals(value?: PerpetualMarketLaunchProposal, index?: number): PerpetualMarketLaunchProposal;

  clearExpiryFuturesMarketLaunchProposalsList(): void;
  getExpiryFuturesMarketLaunchProposalsList(): Array<ExpiryFuturesMarketLaunchProposal>;
  setExpiryFuturesMarketLaunchProposalsList(value: Array<ExpiryFuturesMarketLaunchProposal>): void;
  addExpiryFuturesMarketLaunchProposals(value?: ExpiryFuturesMarketLaunchProposal, index?: number): ExpiryFuturesMarketLaunchProposal;

  hasTradingRewardCampaignUpdateProposal(): boolean;
  clearTradingRewardCampaignUpdateProposal(): void;
  getTradingRewardCampaignUpdateProposal(): TradingRewardCampaignUpdateProposal | undefined;
  setTradingRewardCampaignUpdateProposal(value?: TradingRewardCampaignUpdateProposal): void;

  clearBinaryOptionsMarketLaunchProposalsList(): void;
  getBinaryOptionsMarketLaunchProposalsList(): Array<BinaryOptionsMarketLaunchProposal>;
  setBinaryOptionsMarketLaunchProposalsList(value: Array<BinaryOptionsMarketLaunchProposal>): void;
  addBinaryOptionsMarketLaunchProposals(value?: BinaryOptionsMarketLaunchProposal, index?: number): BinaryOptionsMarketLaunchProposal;

  clearBinaryOptionsParamUpdateProposalsList(): void;
  getBinaryOptionsParamUpdateProposalsList(): Array<BinaryOptionsMarketParamUpdateProposal>;
  setBinaryOptionsParamUpdateProposalsList(value: Array<BinaryOptionsMarketParamUpdateProposal>): void;
  addBinaryOptionsParamUpdateProposals(value?: BinaryOptionsMarketParamUpdateProposal, index?: number): BinaryOptionsMarketParamUpdateProposal;

  hasDenomDecimalsUpdateProposal(): boolean;
  clearDenomDecimalsUpdateProposal(): void;
  getDenomDecimalsUpdateProposal(): UpdateDenomDecimalsProposal | undefined;
  setDenomDecimalsUpdateProposal(value?: UpdateDenomDecimalsProposal): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): BatchExchangeModificationProposal.AsObject;
  static toObject(includeInstance: boolean, msg: BatchExchangeModificationProposal): BatchExchangeModificationProposal.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: BatchExchangeModificationProposal, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): BatchExchangeModificationProposal;
  static deserializeBinaryFromReader(message: BatchExchangeModificationProposal, reader: jspb.BinaryReader): BatchExchangeModificationProposal;
}

export namespace BatchExchangeModificationProposal {
  export type AsObject = {
    title: string,
    description: string,
    spotMarketParamUpdateProposalsList: Array<SpotMarketParamUpdateProposal.AsObject>,
    derivativeMarketParamUpdateProposalsList: Array<DerivativeMarketParamUpdateProposal.AsObject>,
    spotMarketLaunchProposalsList: Array<SpotMarketLaunchProposal.AsObject>,
    perpetualMarketLaunchProposalsList: Array<PerpetualMarketLaunchProposal.AsObject>,
    expiryFuturesMarketLaunchProposalsList: Array<ExpiryFuturesMarketLaunchProposal.AsObject>,
    tradingRewardCampaignUpdateProposal?: TradingRewardCampaignUpdateProposal.AsObject,
    binaryOptionsMarketLaunchProposalsList: Array<BinaryOptionsMarketLaunchProposal.AsObject>,
    binaryOptionsParamUpdateProposalsList: Array<BinaryOptionsMarketParamUpdateProposal.AsObject>,
    denomDecimalsUpdateProposal?: UpdateDenomDecimalsProposal.AsObject,
  }
}

export class SpotMarketLaunchProposal extends jspb.Message {
  getTitle(): string;
  setTitle(value: string): void;

  getDescription(): string;
  setDescription(value: string): void;

  getTicker(): string;
  setTicker(value: string): void;

  getBaseDenom(): string;
  setBaseDenom(value: string): void;

  getQuoteDenom(): string;
  setQuoteDenom(value: string): void;

  getMinPriceTickSize(): string;
  setMinPriceTickSize(value: string): void;

  getMinQuantityTickSize(): string;
  setMinQuantityTickSize(value: string): void;

  getMakerFeeRate(): string;
  setMakerFeeRate(value: string): void;

  getTakerFeeRate(): string;
  setTakerFeeRate(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): SpotMarketLaunchProposal.AsObject;
  static toObject(includeInstance: boolean, msg: SpotMarketLaunchProposal): SpotMarketLaunchProposal.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: SpotMarketLaunchProposal, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): SpotMarketLaunchProposal;
  static deserializeBinaryFromReader(message: SpotMarketLaunchProposal, reader: jspb.BinaryReader): SpotMarketLaunchProposal;
}

export namespace SpotMarketLaunchProposal {
  export type AsObject = {
    title: string,
    description: string,
    ticker: string,
    baseDenom: string,
    quoteDenom: string,
    minPriceTickSize: string,
    minQuantityTickSize: string,
    makerFeeRate: string,
    takerFeeRate: string,
  }
}

export class PerpetualMarketLaunchProposal extends jspb.Message {
  getTitle(): string;
  setTitle(value: string): void;

  getDescription(): string;
  setDescription(value: string): void;

  getTicker(): string;
  setTicker(value: string): void;

  getQuoteDenom(): string;
  setQuoteDenom(value: string): void;

  getOracleBase(): string;
  setOracleBase(value: string): void;

  getOracleQuote(): string;
  setOracleQuote(value: string): void;

  getOracleScaleFactor(): number;
  setOracleScaleFactor(value: number): void;

  getOracleType(): injective_oracle_v1beta1_oracle_pb.OracleTypeMap[keyof injective_oracle_v1beta1_oracle_pb.OracleTypeMap];
  setOracleType(value: injective_oracle_v1beta1_oracle_pb.OracleTypeMap[keyof injective_oracle_v1beta1_oracle_pb.OracleTypeMap]): void;

  getInitialMarginRatio(): string;
  setInitialMarginRatio(value: string): void;

  getMaintenanceMarginRatio(): string;
  setMaintenanceMarginRatio(value: string): void;

  getMakerFeeRate(): string;
  setMakerFeeRate(value: string): void;

  getTakerFeeRate(): string;
  setTakerFeeRate(value: string): void;

  getMinPriceTickSize(): string;
  setMinPriceTickSize(value: string): void;

  getMinQuantityTickSize(): string;
  setMinQuantityTickSize(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): PerpetualMarketLaunchProposal.AsObject;
  static toObject(includeInstance: boolean, msg: PerpetualMarketLaunchProposal): PerpetualMarketLaunchProposal.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: PerpetualMarketLaunchProposal, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): PerpetualMarketLaunchProposal;
  static deserializeBinaryFromReader(message: PerpetualMarketLaunchProposal, reader: jspb.BinaryReader): PerpetualMarketLaunchProposal;
}

export namespace PerpetualMarketLaunchProposal {
  export type AsObject = {
    title: string,
    description: string,
    ticker: string,
    quoteDenom: string,
    oracleBase: string,
    oracleQuote: string,
    oracleScaleFactor: number,
    oracleType: injective_oracle_v1beta1_oracle_pb.OracleTypeMap[keyof injective_oracle_v1beta1_oracle_pb.OracleTypeMap],
    initialMarginRatio: string,
    maintenanceMarginRatio: string,
    makerFeeRate: string,
    takerFeeRate: string,
    minPriceTickSize: string,
    minQuantityTickSize: string,
  }
}

export class BinaryOptionsMarketLaunchProposal extends jspb.Message {
  getTitle(): string;
  setTitle(value: string): void;

  getDescription(): string;
  setDescription(value: string): void;

  getTicker(): string;
  setTicker(value: string): void;

  getOracleSymbol(): string;
  setOracleSymbol(value: string): void;

  getOracleProvider(): string;
  setOracleProvider(value: string): void;

  getOracleType(): injective_oracle_v1beta1_oracle_pb.OracleTypeMap[keyof injective_oracle_v1beta1_oracle_pb.OracleTypeMap];
  setOracleType(value: injective_oracle_v1beta1_oracle_pb.OracleTypeMap[keyof injective_oracle_v1beta1_oracle_pb.OracleTypeMap]): void;

  getOracleScaleFactor(): number;
  setOracleScaleFactor(value: number): void;

  getExpirationTimestamp(): number;
  setExpirationTimestamp(value: number): void;

  getSettlementTimestamp(): number;
  setSettlementTimestamp(value: number): void;

  getAdmin(): string;
  setAdmin(value: string): void;

  getQuoteDenom(): string;
  setQuoteDenom(value: string): void;

  getMakerFeeRate(): string;
  setMakerFeeRate(value: string): void;

  getTakerFeeRate(): string;
  setTakerFeeRate(value: string): void;

  getMinPriceTickSize(): string;
  setMinPriceTickSize(value: string): void;

  getMinQuantityTickSize(): string;
  setMinQuantityTickSize(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): BinaryOptionsMarketLaunchProposal.AsObject;
  static toObject(includeInstance: boolean, msg: BinaryOptionsMarketLaunchProposal): BinaryOptionsMarketLaunchProposal.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: BinaryOptionsMarketLaunchProposal, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): BinaryOptionsMarketLaunchProposal;
  static deserializeBinaryFromReader(message: BinaryOptionsMarketLaunchProposal, reader: jspb.BinaryReader): BinaryOptionsMarketLaunchProposal;
}

export namespace BinaryOptionsMarketLaunchProposal {
  export type AsObject = {
    title: string,
    description: string,
    ticker: string,
    oracleSymbol: string,
    oracleProvider: string,
    oracleType: injective_oracle_v1beta1_oracle_pb.OracleTypeMap[keyof injective_oracle_v1beta1_oracle_pb.OracleTypeMap],
    oracleScaleFactor: number,
    expirationTimestamp: number,
    settlementTimestamp: number,
    admin: string,
    quoteDenom: string,
    makerFeeRate: string,
    takerFeeRate: string,
    minPriceTickSize: string,
    minQuantityTickSize: string,
  }
}

export class ExpiryFuturesMarketLaunchProposal extends jspb.Message {
  getTitle(): string;
  setTitle(value: string): void;

  getDescription(): string;
  setDescription(value: string): void;

  getTicker(): string;
  setTicker(value: string): void;

  getQuoteDenom(): string;
  setQuoteDenom(value: string): void;

  getOracleBase(): string;
  setOracleBase(value: string): void;

  getOracleQuote(): string;
  setOracleQuote(value: string): void;

  getOracleScaleFactor(): number;
  setOracleScaleFactor(value: number): void;

  getOracleType(): injective_oracle_v1beta1_oracle_pb.OracleTypeMap[keyof injective_oracle_v1beta1_oracle_pb.OracleTypeMap];
  setOracleType(value: injective_oracle_v1beta1_oracle_pb.OracleTypeMap[keyof injective_oracle_v1beta1_oracle_pb.OracleTypeMap]): void;

  getExpiry(): number;
  setExpiry(value: number): void;

  getInitialMarginRatio(): string;
  setInitialMarginRatio(value: string): void;

  getMaintenanceMarginRatio(): string;
  setMaintenanceMarginRatio(value: string): void;

  getMakerFeeRate(): string;
  setMakerFeeRate(value: string): void;

  getTakerFeeRate(): string;
  setTakerFeeRate(value: string): void;

  getMinPriceTickSize(): string;
  setMinPriceTickSize(value: string): void;

  getMinQuantityTickSize(): string;
  setMinQuantityTickSize(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ExpiryFuturesMarketLaunchProposal.AsObject;
  static toObject(includeInstance: boolean, msg: ExpiryFuturesMarketLaunchProposal): ExpiryFuturesMarketLaunchProposal.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ExpiryFuturesMarketLaunchProposal, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ExpiryFuturesMarketLaunchProposal;
  static deserializeBinaryFromReader(message: ExpiryFuturesMarketLaunchProposal, reader: jspb.BinaryReader): ExpiryFuturesMarketLaunchProposal;
}

export namespace ExpiryFuturesMarketLaunchProposal {
  export type AsObject = {
    title: string,
    description: string,
    ticker: string,
    quoteDenom: string,
    oracleBase: string,
    oracleQuote: string,
    oracleScaleFactor: number,
    oracleType: injective_oracle_v1beta1_oracle_pb.OracleTypeMap[keyof injective_oracle_v1beta1_oracle_pb.OracleTypeMap],
    expiry: number,
    initialMarginRatio: string,
    maintenanceMarginRatio: string,
    makerFeeRate: string,
    takerFeeRate: string,
    minPriceTickSize: string,
    minQuantityTickSize: string,
  }
}

export class DerivativeMarketParamUpdateProposal extends jspb.Message {
  getTitle(): string;
  setTitle(value: string): void;

  getDescription(): string;
  setDescription(value: string): void;

  getMarketId(): string;
  setMarketId(value: string): void;

  getInitialMarginRatio(): string;
  setInitialMarginRatio(value: string): void;

  getMaintenanceMarginRatio(): string;
  setMaintenanceMarginRatio(value: string): void;

  getMakerFeeRate(): string;
  setMakerFeeRate(value: string): void;

  getTakerFeeRate(): string;
  setTakerFeeRate(value: string): void;

  getRelayerFeeShareRate(): string;
  setRelayerFeeShareRate(value: string): void;

  getMinPriceTickSize(): string;
  setMinPriceTickSize(value: string): void;

  getMinQuantityTickSize(): string;
  setMinQuantityTickSize(value: string): void;

  getHourlyinterestrate(): string;
  setHourlyinterestrate(value: string): void;

  getHourlyfundingratecap(): string;
  setHourlyfundingratecap(value: string): void;

  getStatus(): injective_exchange_v1beta1_exchange_pb.MarketStatusMap[keyof injective_exchange_v1beta1_exchange_pb.MarketStatusMap];
  setStatus(value: injective_exchange_v1beta1_exchange_pb.MarketStatusMap[keyof injective_exchange_v1beta1_exchange_pb.MarketStatusMap]): void;

  hasOracleParams(): boolean;
  clearOracleParams(): void;
  getOracleParams(): OracleParams | undefined;
  setOracleParams(value?: OracleParams): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): DerivativeMarketParamUpdateProposal.AsObject;
  static toObject(includeInstance: boolean, msg: DerivativeMarketParamUpdateProposal): DerivativeMarketParamUpdateProposal.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: DerivativeMarketParamUpdateProposal, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): DerivativeMarketParamUpdateProposal;
  static deserializeBinaryFromReader(message: DerivativeMarketParamUpdateProposal, reader: jspb.BinaryReader): DerivativeMarketParamUpdateProposal;
}

export namespace DerivativeMarketParamUpdateProposal {
  export type AsObject = {
    title: string,
    description: string,
    marketId: string,
    initialMarginRatio: string,
    maintenanceMarginRatio: string,
    makerFeeRate: string,
    takerFeeRate: string,
    relayerFeeShareRate: string,
    minPriceTickSize: string,
    minQuantityTickSize: string,
    hourlyinterestrate: string,
    hourlyfundingratecap: string,
    status: injective_exchange_v1beta1_exchange_pb.MarketStatusMap[keyof injective_exchange_v1beta1_exchange_pb.MarketStatusMap],
    oracleParams?: OracleParams.AsObject,
  }
}

export class MarketForcedSettlementProposal extends jspb.Message {
  getTitle(): string;
  setTitle(value: string): void;

  getDescription(): string;
  setDescription(value: string): void;

  getMarketId(): string;
  setMarketId(value: string): void;

  getSettlementPrice(): string;
  setSettlementPrice(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MarketForcedSettlementProposal.AsObject;
  static toObject(includeInstance: boolean, msg: MarketForcedSettlementProposal): MarketForcedSettlementProposal.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MarketForcedSettlementProposal, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MarketForcedSettlementProposal;
  static deserializeBinaryFromReader(message: MarketForcedSettlementProposal, reader: jspb.BinaryReader): MarketForcedSettlementProposal;
}

export namespace MarketForcedSettlementProposal {
  export type AsObject = {
    title: string,
    description: string,
    marketId: string,
    settlementPrice: string,
  }
}

export class UpdateDenomDecimalsProposal extends jspb.Message {
  getTitle(): string;
  setTitle(value: string): void;

  getDescription(): string;
  setDescription(value: string): void;

  clearDenomDecimalsList(): void;
  getDenomDecimalsList(): Array<DenomDecimals>;
  setDenomDecimalsList(value: Array<DenomDecimals>): void;
  addDenomDecimals(value?: DenomDecimals, index?: number): DenomDecimals;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): UpdateDenomDecimalsProposal.AsObject;
  static toObject(includeInstance: boolean, msg: UpdateDenomDecimalsProposal): UpdateDenomDecimalsProposal.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: UpdateDenomDecimalsProposal, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): UpdateDenomDecimalsProposal;
  static deserializeBinaryFromReader(message: UpdateDenomDecimalsProposal, reader: jspb.BinaryReader): UpdateDenomDecimalsProposal;
}

export namespace UpdateDenomDecimalsProposal {
  export type AsObject = {
    title: string,
    description: string,
    denomDecimalsList: Array<DenomDecimals.AsObject>,
  }
}

export class DenomDecimals extends jspb.Message {
  getDenom(): string;
  setDenom(value: string): void;

  getDecimals(): number;
  setDecimals(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): DenomDecimals.AsObject;
  static toObject(includeInstance: boolean, msg: DenomDecimals): DenomDecimals.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: DenomDecimals, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): DenomDecimals;
  static deserializeBinaryFromReader(message: DenomDecimals, reader: jspb.BinaryReader): DenomDecimals;
}

export namespace DenomDecimals {
  export type AsObject = {
    denom: string,
    decimals: number,
  }
}

export class BinaryOptionsMarketParamUpdateProposal extends jspb.Message {
  getTitle(): string;
  setTitle(value: string): void;

  getDescription(): string;
  setDescription(value: string): void;

  getMarketId(): string;
  setMarketId(value: string): void;

  getMakerFeeRate(): string;
  setMakerFeeRate(value: string): void;

  getTakerFeeRate(): string;
  setTakerFeeRate(value: string): void;

  getRelayerFeeShareRate(): string;
  setRelayerFeeShareRate(value: string): void;

  getMinPriceTickSize(): string;
  setMinPriceTickSize(value: string): void;

  getMinQuantityTickSize(): string;
  setMinQuantityTickSize(value: string): void;

  getExpirationTimestamp(): number;
  setExpirationTimestamp(value: number): void;

  getSettlementTimestamp(): number;
  setSettlementTimestamp(value: number): void;

  getSettlementPrice(): string;
  setSettlementPrice(value: string): void;

  getAdmin(): string;
  setAdmin(value: string): void;

  getStatus(): injective_exchange_v1beta1_exchange_pb.MarketStatusMap[keyof injective_exchange_v1beta1_exchange_pb.MarketStatusMap];
  setStatus(value: injective_exchange_v1beta1_exchange_pb.MarketStatusMap[keyof injective_exchange_v1beta1_exchange_pb.MarketStatusMap]): void;

  hasOracleParams(): boolean;
  clearOracleParams(): void;
  getOracleParams(): ProviderOracleParams | undefined;
  setOracleParams(value?: ProviderOracleParams): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): BinaryOptionsMarketParamUpdateProposal.AsObject;
  static toObject(includeInstance: boolean, msg: BinaryOptionsMarketParamUpdateProposal): BinaryOptionsMarketParamUpdateProposal.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: BinaryOptionsMarketParamUpdateProposal, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): BinaryOptionsMarketParamUpdateProposal;
  static deserializeBinaryFromReader(message: BinaryOptionsMarketParamUpdateProposal, reader: jspb.BinaryReader): BinaryOptionsMarketParamUpdateProposal;
}

export namespace BinaryOptionsMarketParamUpdateProposal {
  export type AsObject = {
    title: string,
    description: string,
    marketId: string,
    makerFeeRate: string,
    takerFeeRate: string,
    relayerFeeShareRate: string,
    minPriceTickSize: string,
    minQuantityTickSize: string,
    expirationTimestamp: number,
    settlementTimestamp: number,
    settlementPrice: string,
    admin: string,
    status: injective_exchange_v1beta1_exchange_pb.MarketStatusMap[keyof injective_exchange_v1beta1_exchange_pb.MarketStatusMap],
    oracleParams?: ProviderOracleParams.AsObject,
  }
}

export class ProviderOracleParams extends jspb.Message {
  getSymbol(): string;
  setSymbol(value: string): void;

  getProvider(): string;
  setProvider(value: string): void;

  getOracleScaleFactor(): number;
  setOracleScaleFactor(value: number): void;

  getOracleType(): injective_oracle_v1beta1_oracle_pb.OracleTypeMap[keyof injective_oracle_v1beta1_oracle_pb.OracleTypeMap];
  setOracleType(value: injective_oracle_v1beta1_oracle_pb.OracleTypeMap[keyof injective_oracle_v1beta1_oracle_pb.OracleTypeMap]): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ProviderOracleParams.AsObject;
  static toObject(includeInstance: boolean, msg: ProviderOracleParams): ProviderOracleParams.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ProviderOracleParams, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ProviderOracleParams;
  static deserializeBinaryFromReader(message: ProviderOracleParams, reader: jspb.BinaryReader): ProviderOracleParams;
}

export namespace ProviderOracleParams {
  export type AsObject = {
    symbol: string,
    provider: string,
    oracleScaleFactor: number,
    oracleType: injective_oracle_v1beta1_oracle_pb.OracleTypeMap[keyof injective_oracle_v1beta1_oracle_pb.OracleTypeMap],
  }
}

export class OracleParams extends jspb.Message {
  getOracleBase(): string;
  setOracleBase(value: string): void;

  getOracleQuote(): string;
  setOracleQuote(value: string): void;

  getOracleScaleFactor(): number;
  setOracleScaleFactor(value: number): void;

  getOracleType(): injective_oracle_v1beta1_oracle_pb.OracleTypeMap[keyof injective_oracle_v1beta1_oracle_pb.OracleTypeMap];
  setOracleType(value: injective_oracle_v1beta1_oracle_pb.OracleTypeMap[keyof injective_oracle_v1beta1_oracle_pb.OracleTypeMap]): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): OracleParams.AsObject;
  static toObject(includeInstance: boolean, msg: OracleParams): OracleParams.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: OracleParams, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): OracleParams;
  static deserializeBinaryFromReader(message: OracleParams, reader: jspb.BinaryReader): OracleParams;
}

export namespace OracleParams {
  export type AsObject = {
    oracleBase: string,
    oracleQuote: string,
    oracleScaleFactor: number,
    oracleType: injective_oracle_v1beta1_oracle_pb.OracleTypeMap[keyof injective_oracle_v1beta1_oracle_pb.OracleTypeMap],
  }
}

export class TradingRewardCampaignLaunchProposal extends jspb.Message {
  getTitle(): string;
  setTitle(value: string): void;

  getDescription(): string;
  setDescription(value: string): void;

  hasCampaignInfo(): boolean;
  clearCampaignInfo(): void;
  getCampaignInfo(): injective_exchange_v1beta1_exchange_pb.TradingRewardCampaignInfo | undefined;
  setCampaignInfo(value?: injective_exchange_v1beta1_exchange_pb.TradingRewardCampaignInfo): void;

  clearCampaignRewardPoolsList(): void;
  getCampaignRewardPoolsList(): Array<injective_exchange_v1beta1_exchange_pb.CampaignRewardPool>;
  setCampaignRewardPoolsList(value: Array<injective_exchange_v1beta1_exchange_pb.CampaignRewardPool>): void;
  addCampaignRewardPools(value?: injective_exchange_v1beta1_exchange_pb.CampaignRewardPool, index?: number): injective_exchange_v1beta1_exchange_pb.CampaignRewardPool;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TradingRewardCampaignLaunchProposal.AsObject;
  static toObject(includeInstance: boolean, msg: TradingRewardCampaignLaunchProposal): TradingRewardCampaignLaunchProposal.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: TradingRewardCampaignLaunchProposal, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): TradingRewardCampaignLaunchProposal;
  static deserializeBinaryFromReader(message: TradingRewardCampaignLaunchProposal, reader: jspb.BinaryReader): TradingRewardCampaignLaunchProposal;
}

export namespace TradingRewardCampaignLaunchProposal {
  export type AsObject = {
    title: string,
    description: string,
    campaignInfo?: injective_exchange_v1beta1_exchange_pb.TradingRewardCampaignInfo.AsObject,
    campaignRewardPoolsList: Array<injective_exchange_v1beta1_exchange_pb.CampaignRewardPool.AsObject>,
  }
}

export class TradingRewardCampaignUpdateProposal extends jspb.Message {
  getTitle(): string;
  setTitle(value: string): void;

  getDescription(): string;
  setDescription(value: string): void;

  hasCampaignInfo(): boolean;
  clearCampaignInfo(): void;
  getCampaignInfo(): injective_exchange_v1beta1_exchange_pb.TradingRewardCampaignInfo | undefined;
  setCampaignInfo(value?: injective_exchange_v1beta1_exchange_pb.TradingRewardCampaignInfo): void;

  clearCampaignRewardPoolsAdditionsList(): void;
  getCampaignRewardPoolsAdditionsList(): Array<injective_exchange_v1beta1_exchange_pb.CampaignRewardPool>;
  setCampaignRewardPoolsAdditionsList(value: Array<injective_exchange_v1beta1_exchange_pb.CampaignRewardPool>): void;
  addCampaignRewardPoolsAdditions(value?: injective_exchange_v1beta1_exchange_pb.CampaignRewardPool, index?: number): injective_exchange_v1beta1_exchange_pb.CampaignRewardPool;

  clearCampaignRewardPoolsUpdatesList(): void;
  getCampaignRewardPoolsUpdatesList(): Array<injective_exchange_v1beta1_exchange_pb.CampaignRewardPool>;
  setCampaignRewardPoolsUpdatesList(value: Array<injective_exchange_v1beta1_exchange_pb.CampaignRewardPool>): void;
  addCampaignRewardPoolsUpdates(value?: injective_exchange_v1beta1_exchange_pb.CampaignRewardPool, index?: number): injective_exchange_v1beta1_exchange_pb.CampaignRewardPool;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TradingRewardCampaignUpdateProposal.AsObject;
  static toObject(includeInstance: boolean, msg: TradingRewardCampaignUpdateProposal): TradingRewardCampaignUpdateProposal.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: TradingRewardCampaignUpdateProposal, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): TradingRewardCampaignUpdateProposal;
  static deserializeBinaryFromReader(message: TradingRewardCampaignUpdateProposal, reader: jspb.BinaryReader): TradingRewardCampaignUpdateProposal;
}

export namespace TradingRewardCampaignUpdateProposal {
  export type AsObject = {
    title: string,
    description: string,
    campaignInfo?: injective_exchange_v1beta1_exchange_pb.TradingRewardCampaignInfo.AsObject,
    campaignRewardPoolsAdditionsList: Array<injective_exchange_v1beta1_exchange_pb.CampaignRewardPool.AsObject>,
    campaignRewardPoolsUpdatesList: Array<injective_exchange_v1beta1_exchange_pb.CampaignRewardPool.AsObject>,
  }
}

export class RewardPointUpdate extends jspb.Message {
  getAccountAddress(): string;
  setAccountAddress(value: string): void;

  getNewPoints(): string;
  setNewPoints(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): RewardPointUpdate.AsObject;
  static toObject(includeInstance: boolean, msg: RewardPointUpdate): RewardPointUpdate.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: RewardPointUpdate, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): RewardPointUpdate;
  static deserializeBinaryFromReader(message: RewardPointUpdate, reader: jspb.BinaryReader): RewardPointUpdate;
}

export namespace RewardPointUpdate {
  export type AsObject = {
    accountAddress: string,
    newPoints: string,
  }
}

export class TradingRewardPendingPointsUpdateProposal extends jspb.Message {
  getTitle(): string;
  setTitle(value: string): void;

  getDescription(): string;
  setDescription(value: string): void;

  getPendingPoolTimestamp(): number;
  setPendingPoolTimestamp(value: number): void;

  clearRewardPointUpdatesList(): void;
  getRewardPointUpdatesList(): Array<RewardPointUpdate>;
  setRewardPointUpdatesList(value: Array<RewardPointUpdate>): void;
  addRewardPointUpdates(value?: RewardPointUpdate, index?: number): RewardPointUpdate;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TradingRewardPendingPointsUpdateProposal.AsObject;
  static toObject(includeInstance: boolean, msg: TradingRewardPendingPointsUpdateProposal): TradingRewardPendingPointsUpdateProposal.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: TradingRewardPendingPointsUpdateProposal, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): TradingRewardPendingPointsUpdateProposal;
  static deserializeBinaryFromReader(message: TradingRewardPendingPointsUpdateProposal, reader: jspb.BinaryReader): TradingRewardPendingPointsUpdateProposal;
}

export namespace TradingRewardPendingPointsUpdateProposal {
  export type AsObject = {
    title: string,
    description: string,
    pendingPoolTimestamp: number,
    rewardPointUpdatesList: Array<RewardPointUpdate.AsObject>,
  }
}

export class FeeDiscountProposal extends jspb.Message {
  getTitle(): string;
  setTitle(value: string): void;

  getDescription(): string;
  setDescription(value: string): void;

  hasSchedule(): boolean;
  clearSchedule(): void;
  getSchedule(): injective_exchange_v1beta1_exchange_pb.FeeDiscountSchedule | undefined;
  setSchedule(value?: injective_exchange_v1beta1_exchange_pb.FeeDiscountSchedule): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): FeeDiscountProposal.AsObject;
  static toObject(includeInstance: boolean, msg: FeeDiscountProposal): FeeDiscountProposal.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: FeeDiscountProposal, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): FeeDiscountProposal;
  static deserializeBinaryFromReader(message: FeeDiscountProposal, reader: jspb.BinaryReader): FeeDiscountProposal;
}

export namespace FeeDiscountProposal {
  export type AsObject = {
    title: string,
    description: string,
    schedule?: injective_exchange_v1beta1_exchange_pb.FeeDiscountSchedule.AsObject,
  }
}

export class BatchCommunityPoolSpendProposal extends jspb.Message {
  getTitle(): string;
  setTitle(value: string): void;

  getDescription(): string;
  setDescription(value: string): void;

  clearProposalsList(): void;
  getProposalsList(): Array<cosmos_distribution_v1beta1_distribution_pb.CommunityPoolSpendProposal>;
  setProposalsList(value: Array<cosmos_distribution_v1beta1_distribution_pb.CommunityPoolSpendProposal>): void;
  addProposals(value?: cosmos_distribution_v1beta1_distribution_pb.CommunityPoolSpendProposal, index?: number): cosmos_distribution_v1beta1_distribution_pb.CommunityPoolSpendProposal;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): BatchCommunityPoolSpendProposal.AsObject;
  static toObject(includeInstance: boolean, msg: BatchCommunityPoolSpendProposal): BatchCommunityPoolSpendProposal.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: BatchCommunityPoolSpendProposal, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): BatchCommunityPoolSpendProposal;
  static deserializeBinaryFromReader(message: BatchCommunityPoolSpendProposal, reader: jspb.BinaryReader): BatchCommunityPoolSpendProposal;
}

export namespace BatchCommunityPoolSpendProposal {
  export type AsObject = {
    title: string,
    description: string,
    proposalsList: Array<cosmos_distribution_v1beta1_distribution_pb.CommunityPoolSpendProposal.AsObject>,
  }
}

export class MsgRewardsOptOut extends jspb.Message {
  getSender(): string;
  setSender(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgRewardsOptOut.AsObject;
  static toObject(includeInstance: boolean, msg: MsgRewardsOptOut): MsgRewardsOptOut.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgRewardsOptOut, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgRewardsOptOut;
  static deserializeBinaryFromReader(message: MsgRewardsOptOut, reader: jspb.BinaryReader): MsgRewardsOptOut;
}

export namespace MsgRewardsOptOut {
  export type AsObject = {
    sender: string,
  }
}

export class MsgRewardsOptOutResponse extends jspb.Message {
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgRewardsOptOutResponse.AsObject;
  static toObject(includeInstance: boolean, msg: MsgRewardsOptOutResponse): MsgRewardsOptOutResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgRewardsOptOutResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgRewardsOptOutResponse;
  static deserializeBinaryFromReader(message: MsgRewardsOptOutResponse, reader: jspb.BinaryReader): MsgRewardsOptOutResponse;
}

export namespace MsgRewardsOptOutResponse {
  export type AsObject = {
  }
}

export class MsgReclaimLockedFunds extends jspb.Message {
  getSender(): string;
  setSender(value: string): void;

  getLockedaccountpubkey(): Uint8Array | string;
  getLockedaccountpubkey_asU8(): Uint8Array;
  getLockedaccountpubkey_asB64(): string;
  setLockedaccountpubkey(value: Uint8Array | string): void;

  getSignature(): Uint8Array | string;
  getSignature_asU8(): Uint8Array;
  getSignature_asB64(): string;
  setSignature(value: Uint8Array | string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgReclaimLockedFunds.AsObject;
  static toObject(includeInstance: boolean, msg: MsgReclaimLockedFunds): MsgReclaimLockedFunds.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgReclaimLockedFunds, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgReclaimLockedFunds;
  static deserializeBinaryFromReader(message: MsgReclaimLockedFunds, reader: jspb.BinaryReader): MsgReclaimLockedFunds;
}

export namespace MsgReclaimLockedFunds {
  export type AsObject = {
    sender: string,
    lockedaccountpubkey: Uint8Array | string,
    signature: Uint8Array | string,
  }
}

export class MsgReclaimLockedFundsResponse extends jspb.Message {
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgReclaimLockedFundsResponse.AsObject;
  static toObject(includeInstance: boolean, msg: MsgReclaimLockedFundsResponse): MsgReclaimLockedFundsResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgReclaimLockedFundsResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgReclaimLockedFundsResponse;
  static deserializeBinaryFromReader(message: MsgReclaimLockedFundsResponse, reader: jspb.BinaryReader): MsgReclaimLockedFundsResponse;
}

export namespace MsgReclaimLockedFundsResponse {
  export type AsObject = {
  }
}

export class MsgSignData extends jspb.Message {
  getSigner(): Uint8Array | string;
  getSigner_asU8(): Uint8Array;
  getSigner_asB64(): string;
  setSigner(value: Uint8Array | string): void;

  getData(): Uint8Array | string;
  getData_asU8(): Uint8Array;
  getData_asB64(): string;
  setData(value: Uint8Array | string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgSignData.AsObject;
  static toObject(includeInstance: boolean, msg: MsgSignData): MsgSignData.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgSignData, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgSignData;
  static deserializeBinaryFromReader(message: MsgSignData, reader: jspb.BinaryReader): MsgSignData;
}

export namespace MsgSignData {
  export type AsObject = {
    signer: Uint8Array | string,
    data: Uint8Array | string,
  }
}

export class MsgSignDoc extends jspb.Message {
  getSignType(): string;
  setSignType(value: string): void;

  hasValue(): boolean;
  clearValue(): void;
  getValue(): MsgSignData | undefined;
  setValue(value?: MsgSignData): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgSignDoc.AsObject;
  static toObject(includeInstance: boolean, msg: MsgSignDoc): MsgSignDoc.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgSignDoc, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgSignDoc;
  static deserializeBinaryFromReader(message: MsgSignDoc, reader: jspb.BinaryReader): MsgSignDoc;
}

export namespace MsgSignDoc {
  export type AsObject = {
    signType: string,
    value?: MsgSignData.AsObject,
  }
}

export class MsgAdminUpdateBinaryOptionsMarket extends jspb.Message {
  getSender(): string;
  setSender(value: string): void;

  getMarketId(): string;
  setMarketId(value: string): void;

  getSettlementPrice(): string;
  setSettlementPrice(value: string): void;

  getExpirationTimestamp(): number;
  setExpirationTimestamp(value: number): void;

  getSettlementTimestamp(): number;
  setSettlementTimestamp(value: number): void;

  getStatus(): injective_exchange_v1beta1_exchange_pb.MarketStatusMap[keyof injective_exchange_v1beta1_exchange_pb.MarketStatusMap];
  setStatus(value: injective_exchange_v1beta1_exchange_pb.MarketStatusMap[keyof injective_exchange_v1beta1_exchange_pb.MarketStatusMap]): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgAdminUpdateBinaryOptionsMarket.AsObject;
  static toObject(includeInstance: boolean, msg: MsgAdminUpdateBinaryOptionsMarket): MsgAdminUpdateBinaryOptionsMarket.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgAdminUpdateBinaryOptionsMarket, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgAdminUpdateBinaryOptionsMarket;
  static deserializeBinaryFromReader(message: MsgAdminUpdateBinaryOptionsMarket, reader: jspb.BinaryReader): MsgAdminUpdateBinaryOptionsMarket;
}

export namespace MsgAdminUpdateBinaryOptionsMarket {
  export type AsObject = {
    sender: string,
    marketId: string,
    settlementPrice: string,
    expirationTimestamp: number,
    settlementTimestamp: number,
    status: injective_exchange_v1beta1_exchange_pb.MarketStatusMap[keyof injective_exchange_v1beta1_exchange_pb.MarketStatusMap],
  }
}

export class MsgAdminUpdateBinaryOptionsMarketResponse extends jspb.Message {
  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MsgAdminUpdateBinaryOptionsMarketResponse.AsObject;
  static toObject(includeInstance: boolean, msg: MsgAdminUpdateBinaryOptionsMarketResponse): MsgAdminUpdateBinaryOptionsMarketResponse.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MsgAdminUpdateBinaryOptionsMarketResponse, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MsgAdminUpdateBinaryOptionsMarketResponse;
  static deserializeBinaryFromReader(message: MsgAdminUpdateBinaryOptionsMarketResponse, reader: jspb.BinaryReader): MsgAdminUpdateBinaryOptionsMarketResponse;
}

export namespace MsgAdminUpdateBinaryOptionsMarketResponse {
  export type AsObject = {
  }
}

export class AtomicMarketOrderFeeMultiplierScheduleProposal extends jspb.Message {
  getTitle(): string;
  setTitle(value: string): void;

  getDescription(): string;
  setDescription(value: string): void;

  clearMarketFeeMultipliersList(): void;
  getMarketFeeMultipliersList(): Array<injective_exchange_v1beta1_exchange_pb.MarketFeeMultiplier>;
  setMarketFeeMultipliersList(value: Array<injective_exchange_v1beta1_exchange_pb.MarketFeeMultiplier>): void;
  addMarketFeeMultipliers(value?: injective_exchange_v1beta1_exchange_pb.MarketFeeMultiplier, index?: number): injective_exchange_v1beta1_exchange_pb.MarketFeeMultiplier;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): AtomicMarketOrderFeeMultiplierScheduleProposal.AsObject;
  static toObject(includeInstance: boolean, msg: AtomicMarketOrderFeeMultiplierScheduleProposal): AtomicMarketOrderFeeMultiplierScheduleProposal.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: AtomicMarketOrderFeeMultiplierScheduleProposal, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): AtomicMarketOrderFeeMultiplierScheduleProposal;
  static deserializeBinaryFromReader(message: AtomicMarketOrderFeeMultiplierScheduleProposal, reader: jspb.BinaryReader): AtomicMarketOrderFeeMultiplierScheduleProposal;
}

export namespace AtomicMarketOrderFeeMultiplierScheduleProposal {
  export type AsObject = {
    title: string,
    description: string,
    marketFeeMultipliersList: Array<injective_exchange_v1beta1_exchange_pb.MarketFeeMultiplier.AsObject>,
  }
}

export interface FundsDirectionMap {
  UNDEFINED: 0;
  BANK_TO_SUBACCOUNT: 1;
  SUBACCOUNT_TO_BANK: 2;
}

export const FundsDirection: FundsDirectionMap;

export interface ExchangeTypeMap {
  EXCHANGE_UNSPECIFIED: 0;
  SPOT: 1;
  DERIVATIVES: 2;
}

export const ExchangeType: ExchangeTypeMap;

