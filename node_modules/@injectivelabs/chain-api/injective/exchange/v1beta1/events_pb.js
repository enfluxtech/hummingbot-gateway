// source: injective/exchange/v1beta1/events.proto
/**
 * @fileoverview
 * @enhanceable
 * @suppress {missingRequire} reports error on implicit type usages.
 * @suppress {messageConventions} JS Compiler reports an error if a variable or
 *     field starts with 'MSG_' and isn't a translatable message.
 * @public
 */
// GENERATED CODE -- DO NOT EDIT!
/* eslint-disable */
// @ts-nocheck

var jspb = require('google-protobuf');
var goog = jspb;
var global = (function() {
  if (this) { return this; }
  if (typeof window !== 'undefined') { return window; }
  if (typeof global !== 'undefined') { return global; }
  if (typeof self !== 'undefined') { return self; }
  return Function('return this')();
}.call(null));

var gogoproto_gogo_pb = require('../../../gogoproto/gogo_pb.js');
goog.object.extend(proto, gogoproto_gogo_pb);
var cosmos_base_v1beta1_coin_pb = require('../../../cosmos/base/v1beta1/coin_pb.js');
goog.object.extend(proto, cosmos_base_v1beta1_coin_pb);
var injective_oracle_v1beta1_oracle_pb = require('../../../injective/oracle/v1beta1/oracle_pb.js');
goog.object.extend(proto, injective_oracle_v1beta1_oracle_pb);
var injective_exchange_v1beta1_exchange_pb = require('../../../injective/exchange/v1beta1/exchange_pb.js');
goog.object.extend(proto, injective_exchange_v1beta1_exchange_pb);
goog.exportSymbol('proto.injective.exchange.v1beta1.DerivativeMarketOrderCancel', null, global);
goog.exportSymbol('proto.injective.exchange.v1beta1.EventAtomicMarketOrderFeeMultipliersUpdated', null, global);
goog.exportSymbol('proto.injective.exchange.v1beta1.EventBatchDepositUpdate', null, global);
goog.exportSymbol('proto.injective.exchange.v1beta1.EventBatchDerivativeExecution', null, global);
goog.exportSymbol('proto.injective.exchange.v1beta1.EventBatchDerivativePosition', null, global);
goog.exportSymbol('proto.injective.exchange.v1beta1.EventBatchSpotExecution', null, global);
goog.exportSymbol('proto.injective.exchange.v1beta1.EventBinaryOptionsMarketUpdate', null, global);
goog.exportSymbol('proto.injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder', null, global);
goog.exportSymbol('proto.injective.exchange.v1beta1.EventCancelDerivativeOrder', null, global);
goog.exportSymbol('proto.injective.exchange.v1beta1.EventCancelSpotOrder', null, global);
goog.exportSymbol('proto.injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger', null, global);
goog.exportSymbol('proto.injective.exchange.v1beta1.EventDerivativeMarketPaused', null, global);
goog.exportSymbol('proto.injective.exchange.v1beta1.EventExpiryFuturesMarketUpdate', null, global);
goog.exportSymbol('proto.injective.exchange.v1beta1.EventFeeDiscountSchedule', null, global);
goog.exportSymbol('proto.injective.exchange.v1beta1.EventLostFundsFromLiquidation', null, global);
goog.exportSymbol('proto.injective.exchange.v1beta1.EventNewConditionalDerivativeOrder', null, global);
goog.exportSymbol('proto.injective.exchange.v1beta1.EventNewDerivativeOrders', null, global);
goog.exportSymbol('proto.injective.exchange.v1beta1.EventNewSpotOrders', null, global);
goog.exportSymbol('proto.injective.exchange.v1beta1.EventOrderFail', null, global);
goog.exportSymbol('proto.injective.exchange.v1beta1.EventOrderbookUpdate', null, global);
goog.exportSymbol('proto.injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate', null, global);
goog.exportSymbol('proto.injective.exchange.v1beta1.EventPerpetualMarketUpdate', null, global);
goog.exportSymbol('proto.injective.exchange.v1beta1.EventSpotMarketUpdate', null, global);
goog.exportSymbol('proto.injective.exchange.v1beta1.EventSubaccountBalanceTransfer', null, global);
goog.exportSymbol('proto.injective.exchange.v1beta1.EventSubaccountDeposit', null, global);
goog.exportSymbol('proto.injective.exchange.v1beta1.EventSubaccountWithdraw', null, global);
goog.exportSymbol('proto.injective.exchange.v1beta1.EventTradingRewardCampaignUpdate', null, global);
goog.exportSymbol('proto.injective.exchange.v1beta1.EventTradingRewardDistribution', null, global);
goog.exportSymbol('proto.injective.exchange.v1beta1.Orderbook', null, global);
goog.exportSymbol('proto.injective.exchange.v1beta1.OrderbookUpdate', null, global);
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.injective.exchange.v1beta1.EventBatchSpotExecution = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.injective.exchange.v1beta1.EventBatchSpotExecution.repeatedFields_, null);
};
goog.inherits(proto.injective.exchange.v1beta1.EventBatchSpotExecution, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.injective.exchange.v1beta1.EventBatchSpotExecution.displayName = 'proto.injective.exchange.v1beta1.EventBatchSpotExecution';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.injective.exchange.v1beta1.EventBatchDerivativeExecution = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.injective.exchange.v1beta1.EventBatchDerivativeExecution.repeatedFields_, null);
};
goog.inherits(proto.injective.exchange.v1beta1.EventBatchDerivativeExecution, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.injective.exchange.v1beta1.EventBatchDerivativeExecution.displayName = 'proto.injective.exchange.v1beta1.EventBatchDerivativeExecution';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.injective.exchange.v1beta1.EventLostFundsFromLiquidation = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.injective.exchange.v1beta1.EventLostFundsFromLiquidation, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.injective.exchange.v1beta1.EventLostFundsFromLiquidation.displayName = 'proto.injective.exchange.v1beta1.EventLostFundsFromLiquidation';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.injective.exchange.v1beta1.EventBatchDerivativePosition = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.injective.exchange.v1beta1.EventBatchDerivativePosition.repeatedFields_, null);
};
goog.inherits(proto.injective.exchange.v1beta1.EventBatchDerivativePosition, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.injective.exchange.v1beta1.EventBatchDerivativePosition.displayName = 'proto.injective.exchange.v1beta1.EventBatchDerivativePosition';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.injective.exchange.v1beta1.EventDerivativeMarketPaused = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.injective.exchange.v1beta1.EventDerivativeMarketPaused, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.injective.exchange.v1beta1.EventDerivativeMarketPaused.displayName = 'proto.injective.exchange.v1beta1.EventDerivativeMarketPaused';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.injective.exchange.v1beta1.EventBinaryOptionsMarketUpdate = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.injective.exchange.v1beta1.EventBinaryOptionsMarketUpdate, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.injective.exchange.v1beta1.EventBinaryOptionsMarketUpdate.displayName = 'proto.injective.exchange.v1beta1.EventBinaryOptionsMarketUpdate';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.injective.exchange.v1beta1.EventNewSpotOrders = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.injective.exchange.v1beta1.EventNewSpotOrders.repeatedFields_, null);
};
goog.inherits(proto.injective.exchange.v1beta1.EventNewSpotOrders, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.injective.exchange.v1beta1.EventNewSpotOrders.displayName = 'proto.injective.exchange.v1beta1.EventNewSpotOrders';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.injective.exchange.v1beta1.EventNewDerivativeOrders = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.injective.exchange.v1beta1.EventNewDerivativeOrders.repeatedFields_, null);
};
goog.inherits(proto.injective.exchange.v1beta1.EventNewDerivativeOrders, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.injective.exchange.v1beta1.EventNewDerivativeOrders.displayName = 'proto.injective.exchange.v1beta1.EventNewDerivativeOrders';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.injective.exchange.v1beta1.EventCancelSpotOrder = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.injective.exchange.v1beta1.EventCancelSpotOrder, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.injective.exchange.v1beta1.EventCancelSpotOrder.displayName = 'proto.injective.exchange.v1beta1.EventCancelSpotOrder';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.injective.exchange.v1beta1.EventSpotMarketUpdate = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.injective.exchange.v1beta1.EventSpotMarketUpdate, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.injective.exchange.v1beta1.EventSpotMarketUpdate.displayName = 'proto.injective.exchange.v1beta1.EventSpotMarketUpdate';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.injective.exchange.v1beta1.EventPerpetualMarketUpdate = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.injective.exchange.v1beta1.EventPerpetualMarketUpdate, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.injective.exchange.v1beta1.EventPerpetualMarketUpdate.displayName = 'proto.injective.exchange.v1beta1.EventPerpetualMarketUpdate';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.injective.exchange.v1beta1.EventExpiryFuturesMarketUpdate = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.injective.exchange.v1beta1.EventExpiryFuturesMarketUpdate, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.injective.exchange.v1beta1.EventExpiryFuturesMarketUpdate.displayName = 'proto.injective.exchange.v1beta1.EventExpiryFuturesMarketUpdate';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate.displayName = 'proto.injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.injective.exchange.v1beta1.EventSubaccountDeposit = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.injective.exchange.v1beta1.EventSubaccountDeposit, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.injective.exchange.v1beta1.EventSubaccountDeposit.displayName = 'proto.injective.exchange.v1beta1.EventSubaccountDeposit';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.injective.exchange.v1beta1.EventSubaccountWithdraw = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.injective.exchange.v1beta1.EventSubaccountWithdraw, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.injective.exchange.v1beta1.EventSubaccountWithdraw.displayName = 'proto.injective.exchange.v1beta1.EventSubaccountWithdraw';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.injective.exchange.v1beta1.EventSubaccountBalanceTransfer = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.injective.exchange.v1beta1.EventSubaccountBalanceTransfer, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.injective.exchange.v1beta1.EventSubaccountBalanceTransfer.displayName = 'proto.injective.exchange.v1beta1.EventSubaccountBalanceTransfer';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.injective.exchange.v1beta1.EventBatchDepositUpdate = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.injective.exchange.v1beta1.EventBatchDepositUpdate.repeatedFields_, null);
};
goog.inherits(proto.injective.exchange.v1beta1.EventBatchDepositUpdate, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.injective.exchange.v1beta1.EventBatchDepositUpdate.displayName = 'proto.injective.exchange.v1beta1.EventBatchDepositUpdate';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.injective.exchange.v1beta1.DerivativeMarketOrderCancel = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.injective.exchange.v1beta1.DerivativeMarketOrderCancel, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.injective.exchange.v1beta1.DerivativeMarketOrderCancel.displayName = 'proto.injective.exchange.v1beta1.DerivativeMarketOrderCancel';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.injective.exchange.v1beta1.EventCancelDerivativeOrder = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.injective.exchange.v1beta1.EventCancelDerivativeOrder, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.injective.exchange.v1beta1.EventCancelDerivativeOrder.displayName = 'proto.injective.exchange.v1beta1.EventCancelDerivativeOrder';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.injective.exchange.v1beta1.EventFeeDiscountSchedule = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.injective.exchange.v1beta1.EventFeeDiscountSchedule, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.injective.exchange.v1beta1.EventFeeDiscountSchedule.displayName = 'proto.injective.exchange.v1beta1.EventFeeDiscountSchedule';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.injective.exchange.v1beta1.EventTradingRewardCampaignUpdate = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.injective.exchange.v1beta1.EventTradingRewardCampaignUpdate.repeatedFields_, null);
};
goog.inherits(proto.injective.exchange.v1beta1.EventTradingRewardCampaignUpdate, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.injective.exchange.v1beta1.EventTradingRewardCampaignUpdate.displayName = 'proto.injective.exchange.v1beta1.EventTradingRewardCampaignUpdate';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.injective.exchange.v1beta1.EventTradingRewardDistribution = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.injective.exchange.v1beta1.EventTradingRewardDistribution.repeatedFields_, null);
};
goog.inherits(proto.injective.exchange.v1beta1.EventTradingRewardDistribution, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.injective.exchange.v1beta1.EventTradingRewardDistribution.displayName = 'proto.injective.exchange.v1beta1.EventTradingRewardDistribution';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.injective.exchange.v1beta1.EventNewConditionalDerivativeOrder = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.injective.exchange.v1beta1.EventNewConditionalDerivativeOrder, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.injective.exchange.v1beta1.EventNewConditionalDerivativeOrder.displayName = 'proto.injective.exchange.v1beta1.EventNewConditionalDerivativeOrder';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder.displayName = 'proto.injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger.displayName = 'proto.injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.injective.exchange.v1beta1.EventOrderFail = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.injective.exchange.v1beta1.EventOrderFail.repeatedFields_, null);
};
goog.inherits(proto.injective.exchange.v1beta1.EventOrderFail, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.injective.exchange.v1beta1.EventOrderFail.displayName = 'proto.injective.exchange.v1beta1.EventOrderFail';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.injective.exchange.v1beta1.EventAtomicMarketOrderFeeMultipliersUpdated = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.injective.exchange.v1beta1.EventAtomicMarketOrderFeeMultipliersUpdated.repeatedFields_, null);
};
goog.inherits(proto.injective.exchange.v1beta1.EventAtomicMarketOrderFeeMultipliersUpdated, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.injective.exchange.v1beta1.EventAtomicMarketOrderFeeMultipliersUpdated.displayName = 'proto.injective.exchange.v1beta1.EventAtomicMarketOrderFeeMultipliersUpdated';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.injective.exchange.v1beta1.EventOrderbookUpdate = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.injective.exchange.v1beta1.EventOrderbookUpdate.repeatedFields_, null);
};
goog.inherits(proto.injective.exchange.v1beta1.EventOrderbookUpdate, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.injective.exchange.v1beta1.EventOrderbookUpdate.displayName = 'proto.injective.exchange.v1beta1.EventOrderbookUpdate';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.injective.exchange.v1beta1.OrderbookUpdate = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.injective.exchange.v1beta1.OrderbookUpdate, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.injective.exchange.v1beta1.OrderbookUpdate.displayName = 'proto.injective.exchange.v1beta1.OrderbookUpdate';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.injective.exchange.v1beta1.Orderbook = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.injective.exchange.v1beta1.Orderbook.repeatedFields_, null);
};
goog.inherits(proto.injective.exchange.v1beta1.Orderbook, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.injective.exchange.v1beta1.Orderbook.displayName = 'proto.injective.exchange.v1beta1.Orderbook';
}

/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.injective.exchange.v1beta1.EventBatchSpotExecution.repeatedFields_ = [4];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.injective.exchange.v1beta1.EventBatchSpotExecution.prototype.toObject = function(opt_includeInstance) {
  return proto.injective.exchange.v1beta1.EventBatchSpotExecution.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.injective.exchange.v1beta1.EventBatchSpotExecution} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.injective.exchange.v1beta1.EventBatchSpotExecution.toObject = function(includeInstance, msg) {
  var f, obj = {
    marketId: jspb.Message.getFieldWithDefault(msg, 1, ""),
    isBuy: jspb.Message.getBooleanFieldWithDefault(msg, 2, false),
    executiontype: jspb.Message.getFieldWithDefault(msg, 3, 0),
    tradesList: jspb.Message.toObjectList(msg.getTradesList(),
    injective_exchange_v1beta1_exchange_pb.TradeLog.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.injective.exchange.v1beta1.EventBatchSpotExecution}
 */
proto.injective.exchange.v1beta1.EventBatchSpotExecution.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.injective.exchange.v1beta1.EventBatchSpotExecution;
  return proto.injective.exchange.v1beta1.EventBatchSpotExecution.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.injective.exchange.v1beta1.EventBatchSpotExecution} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.injective.exchange.v1beta1.EventBatchSpotExecution}
 */
proto.injective.exchange.v1beta1.EventBatchSpotExecution.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setMarketId(value);
      break;
    case 2:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setIsBuy(value);
      break;
    case 3:
      var value = /** @type {!proto.injective.exchange.v1beta1.ExecutionType} */ (reader.readEnum());
      msg.setExecutiontype(value);
      break;
    case 4:
      var value = new injective_exchange_v1beta1_exchange_pb.TradeLog;
      reader.readMessage(value,injective_exchange_v1beta1_exchange_pb.TradeLog.deserializeBinaryFromReader);
      msg.addTrades(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.injective.exchange.v1beta1.EventBatchSpotExecution.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.injective.exchange.v1beta1.EventBatchSpotExecution.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.injective.exchange.v1beta1.EventBatchSpotExecution} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.injective.exchange.v1beta1.EventBatchSpotExecution.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getMarketId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getIsBuy();
  if (f) {
    writer.writeBool(
      2,
      f
    );
  }
  f = message.getExecutiontype();
  if (f !== 0.0) {
    writer.writeEnum(
      3,
      f
    );
  }
  f = message.getTradesList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      4,
      f,
      injective_exchange_v1beta1_exchange_pb.TradeLog.serializeBinaryToWriter
    );
  }
};


/**
 * optional string market_id = 1;
 * @return {string}
 */
proto.injective.exchange.v1beta1.EventBatchSpotExecution.prototype.getMarketId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.injective.exchange.v1beta1.EventBatchSpotExecution} returns this
 */
proto.injective.exchange.v1beta1.EventBatchSpotExecution.prototype.setMarketId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional bool is_buy = 2;
 * @return {boolean}
 */
proto.injective.exchange.v1beta1.EventBatchSpotExecution.prototype.getIsBuy = function() {
  return /** @type {boolean} */ (jspb.Message.getBooleanFieldWithDefault(this, 2, false));
};


/**
 * @param {boolean} value
 * @return {!proto.injective.exchange.v1beta1.EventBatchSpotExecution} returns this
 */
proto.injective.exchange.v1beta1.EventBatchSpotExecution.prototype.setIsBuy = function(value) {
  return jspb.Message.setProto3BooleanField(this, 2, value);
};


/**
 * optional ExecutionType executionType = 3;
 * @return {!proto.injective.exchange.v1beta1.ExecutionType}
 */
proto.injective.exchange.v1beta1.EventBatchSpotExecution.prototype.getExecutiontype = function() {
  return /** @type {!proto.injective.exchange.v1beta1.ExecutionType} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/**
 * @param {!proto.injective.exchange.v1beta1.ExecutionType} value
 * @return {!proto.injective.exchange.v1beta1.EventBatchSpotExecution} returns this
 */
proto.injective.exchange.v1beta1.EventBatchSpotExecution.prototype.setExecutiontype = function(value) {
  return jspb.Message.setProto3EnumField(this, 3, value);
};


/**
 * repeated TradeLog trades = 4;
 * @return {!Array<!proto.injective.exchange.v1beta1.TradeLog>}
 */
proto.injective.exchange.v1beta1.EventBatchSpotExecution.prototype.getTradesList = function() {
  return /** @type{!Array<!proto.injective.exchange.v1beta1.TradeLog>} */ (
    jspb.Message.getRepeatedWrapperField(this, injective_exchange_v1beta1_exchange_pb.TradeLog, 4));
};


/**
 * @param {!Array<!proto.injective.exchange.v1beta1.TradeLog>} value
 * @return {!proto.injective.exchange.v1beta1.EventBatchSpotExecution} returns this
*/
proto.injective.exchange.v1beta1.EventBatchSpotExecution.prototype.setTradesList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 4, value);
};


/**
 * @param {!proto.injective.exchange.v1beta1.TradeLog=} opt_value
 * @param {number=} opt_index
 * @return {!proto.injective.exchange.v1beta1.TradeLog}
 */
proto.injective.exchange.v1beta1.EventBatchSpotExecution.prototype.addTrades = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 4, opt_value, proto.injective.exchange.v1beta1.TradeLog, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.injective.exchange.v1beta1.EventBatchSpotExecution} returns this
 */
proto.injective.exchange.v1beta1.EventBatchSpotExecution.prototype.clearTradesList = function() {
  return this.setTradesList([]);
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.injective.exchange.v1beta1.EventBatchDerivativeExecution.repeatedFields_ = [6];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.injective.exchange.v1beta1.EventBatchDerivativeExecution.prototype.toObject = function(opt_includeInstance) {
  return proto.injective.exchange.v1beta1.EventBatchDerivativeExecution.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.injective.exchange.v1beta1.EventBatchDerivativeExecution} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.injective.exchange.v1beta1.EventBatchDerivativeExecution.toObject = function(includeInstance, msg) {
  var f, obj = {
    marketId: jspb.Message.getFieldWithDefault(msg, 1, ""),
    isBuy: jspb.Message.getBooleanFieldWithDefault(msg, 2, false),
    isLiquidation: jspb.Message.getBooleanFieldWithDefault(msg, 3, false),
    cumulativeFunding: jspb.Message.getFieldWithDefault(msg, 4, ""),
    executiontype: jspb.Message.getFieldWithDefault(msg, 5, 0),
    tradesList: jspb.Message.toObjectList(msg.getTradesList(),
    injective_exchange_v1beta1_exchange_pb.DerivativeTradeLog.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.injective.exchange.v1beta1.EventBatchDerivativeExecution}
 */
proto.injective.exchange.v1beta1.EventBatchDerivativeExecution.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.injective.exchange.v1beta1.EventBatchDerivativeExecution;
  return proto.injective.exchange.v1beta1.EventBatchDerivativeExecution.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.injective.exchange.v1beta1.EventBatchDerivativeExecution} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.injective.exchange.v1beta1.EventBatchDerivativeExecution}
 */
proto.injective.exchange.v1beta1.EventBatchDerivativeExecution.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setMarketId(value);
      break;
    case 2:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setIsBuy(value);
      break;
    case 3:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setIsLiquidation(value);
      break;
    case 4:
      var value = /** @type {string} */ (reader.readString());
      msg.setCumulativeFunding(value);
      break;
    case 5:
      var value = /** @type {!proto.injective.exchange.v1beta1.ExecutionType} */ (reader.readEnum());
      msg.setExecutiontype(value);
      break;
    case 6:
      var value = new injective_exchange_v1beta1_exchange_pb.DerivativeTradeLog;
      reader.readMessage(value,injective_exchange_v1beta1_exchange_pb.DerivativeTradeLog.deserializeBinaryFromReader);
      msg.addTrades(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.injective.exchange.v1beta1.EventBatchDerivativeExecution.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.injective.exchange.v1beta1.EventBatchDerivativeExecution.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.injective.exchange.v1beta1.EventBatchDerivativeExecution} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.injective.exchange.v1beta1.EventBatchDerivativeExecution.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getMarketId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getIsBuy();
  if (f) {
    writer.writeBool(
      2,
      f
    );
  }
  f = message.getIsLiquidation();
  if (f) {
    writer.writeBool(
      3,
      f
    );
  }
  f = message.getCumulativeFunding();
  if (f.length > 0) {
    writer.writeString(
      4,
      f
    );
  }
  f = message.getExecutiontype();
  if (f !== 0.0) {
    writer.writeEnum(
      5,
      f
    );
  }
  f = message.getTradesList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      6,
      f,
      injective_exchange_v1beta1_exchange_pb.DerivativeTradeLog.serializeBinaryToWriter
    );
  }
};


/**
 * optional string market_id = 1;
 * @return {string}
 */
proto.injective.exchange.v1beta1.EventBatchDerivativeExecution.prototype.getMarketId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.injective.exchange.v1beta1.EventBatchDerivativeExecution} returns this
 */
proto.injective.exchange.v1beta1.EventBatchDerivativeExecution.prototype.setMarketId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional bool is_buy = 2;
 * @return {boolean}
 */
proto.injective.exchange.v1beta1.EventBatchDerivativeExecution.prototype.getIsBuy = function() {
  return /** @type {boolean} */ (jspb.Message.getBooleanFieldWithDefault(this, 2, false));
};


/**
 * @param {boolean} value
 * @return {!proto.injective.exchange.v1beta1.EventBatchDerivativeExecution} returns this
 */
proto.injective.exchange.v1beta1.EventBatchDerivativeExecution.prototype.setIsBuy = function(value) {
  return jspb.Message.setProto3BooleanField(this, 2, value);
};


/**
 * optional bool is_liquidation = 3;
 * @return {boolean}
 */
proto.injective.exchange.v1beta1.EventBatchDerivativeExecution.prototype.getIsLiquidation = function() {
  return /** @type {boolean} */ (jspb.Message.getBooleanFieldWithDefault(this, 3, false));
};


/**
 * @param {boolean} value
 * @return {!proto.injective.exchange.v1beta1.EventBatchDerivativeExecution} returns this
 */
proto.injective.exchange.v1beta1.EventBatchDerivativeExecution.prototype.setIsLiquidation = function(value) {
  return jspb.Message.setProto3BooleanField(this, 3, value);
};


/**
 * optional string cumulative_funding = 4;
 * @return {string}
 */
proto.injective.exchange.v1beta1.EventBatchDerivativeExecution.prototype.getCumulativeFunding = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * @param {string} value
 * @return {!proto.injective.exchange.v1beta1.EventBatchDerivativeExecution} returns this
 */
proto.injective.exchange.v1beta1.EventBatchDerivativeExecution.prototype.setCumulativeFunding = function(value) {
  return jspb.Message.setProto3StringField(this, 4, value);
};


/**
 * optional ExecutionType executionType = 5;
 * @return {!proto.injective.exchange.v1beta1.ExecutionType}
 */
proto.injective.exchange.v1beta1.EventBatchDerivativeExecution.prototype.getExecutiontype = function() {
  return /** @type {!proto.injective.exchange.v1beta1.ExecutionType} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/**
 * @param {!proto.injective.exchange.v1beta1.ExecutionType} value
 * @return {!proto.injective.exchange.v1beta1.EventBatchDerivativeExecution} returns this
 */
proto.injective.exchange.v1beta1.EventBatchDerivativeExecution.prototype.setExecutiontype = function(value) {
  return jspb.Message.setProto3EnumField(this, 5, value);
};


/**
 * repeated DerivativeTradeLog trades = 6;
 * @return {!Array<!proto.injective.exchange.v1beta1.DerivativeTradeLog>}
 */
proto.injective.exchange.v1beta1.EventBatchDerivativeExecution.prototype.getTradesList = function() {
  return /** @type{!Array<!proto.injective.exchange.v1beta1.DerivativeTradeLog>} */ (
    jspb.Message.getRepeatedWrapperField(this, injective_exchange_v1beta1_exchange_pb.DerivativeTradeLog, 6));
};


/**
 * @param {!Array<!proto.injective.exchange.v1beta1.DerivativeTradeLog>} value
 * @return {!proto.injective.exchange.v1beta1.EventBatchDerivativeExecution} returns this
*/
proto.injective.exchange.v1beta1.EventBatchDerivativeExecution.prototype.setTradesList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 6, value);
};


/**
 * @param {!proto.injective.exchange.v1beta1.DerivativeTradeLog=} opt_value
 * @param {number=} opt_index
 * @return {!proto.injective.exchange.v1beta1.DerivativeTradeLog}
 */
proto.injective.exchange.v1beta1.EventBatchDerivativeExecution.prototype.addTrades = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 6, opt_value, proto.injective.exchange.v1beta1.DerivativeTradeLog, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.injective.exchange.v1beta1.EventBatchDerivativeExecution} returns this
 */
proto.injective.exchange.v1beta1.EventBatchDerivativeExecution.prototype.clearTradesList = function() {
  return this.setTradesList([]);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.injective.exchange.v1beta1.EventLostFundsFromLiquidation.prototype.toObject = function(opt_includeInstance) {
  return proto.injective.exchange.v1beta1.EventLostFundsFromLiquidation.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.injective.exchange.v1beta1.EventLostFundsFromLiquidation} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.injective.exchange.v1beta1.EventLostFundsFromLiquidation.toObject = function(includeInstance, msg) {
  var f, obj = {
    marketId: jspb.Message.getFieldWithDefault(msg, 1, ""),
    subaccountId: msg.getSubaccountId_asB64(),
    lostFundsFromAvailableDuringPayout: jspb.Message.getFieldWithDefault(msg, 3, ""),
    lostFundsFromOrderCancels: jspb.Message.getFieldWithDefault(msg, 4, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.injective.exchange.v1beta1.EventLostFundsFromLiquidation}
 */
proto.injective.exchange.v1beta1.EventLostFundsFromLiquidation.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.injective.exchange.v1beta1.EventLostFundsFromLiquidation;
  return proto.injective.exchange.v1beta1.EventLostFundsFromLiquidation.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.injective.exchange.v1beta1.EventLostFundsFromLiquidation} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.injective.exchange.v1beta1.EventLostFundsFromLiquidation}
 */
proto.injective.exchange.v1beta1.EventLostFundsFromLiquidation.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setMarketId(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSubaccountId(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setLostFundsFromAvailableDuringPayout(value);
      break;
    case 4:
      var value = /** @type {string} */ (reader.readString());
      msg.setLostFundsFromOrderCancels(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.injective.exchange.v1beta1.EventLostFundsFromLiquidation.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.injective.exchange.v1beta1.EventLostFundsFromLiquidation.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.injective.exchange.v1beta1.EventLostFundsFromLiquidation} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.injective.exchange.v1beta1.EventLostFundsFromLiquidation.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getMarketId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getSubaccountId_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = message.getLostFundsFromAvailableDuringPayout();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
  f = message.getLostFundsFromOrderCancels();
  if (f.length > 0) {
    writer.writeString(
      4,
      f
    );
  }
};


/**
 * optional string market_id = 1;
 * @return {string}
 */
proto.injective.exchange.v1beta1.EventLostFundsFromLiquidation.prototype.getMarketId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.injective.exchange.v1beta1.EventLostFundsFromLiquidation} returns this
 */
proto.injective.exchange.v1beta1.EventLostFundsFromLiquidation.prototype.setMarketId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional bytes subaccount_id = 2;
 * @return {!(string|Uint8Array)}
 */
proto.injective.exchange.v1beta1.EventLostFundsFromLiquidation.prototype.getSubaccountId = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes subaccount_id = 2;
 * This is a type-conversion wrapper around `getSubaccountId()`
 * @return {string}
 */
proto.injective.exchange.v1beta1.EventLostFundsFromLiquidation.prototype.getSubaccountId_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSubaccountId()));
};


/**
 * optional bytes subaccount_id = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSubaccountId()`
 * @return {!Uint8Array}
 */
proto.injective.exchange.v1beta1.EventLostFundsFromLiquidation.prototype.getSubaccountId_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSubaccountId()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.injective.exchange.v1beta1.EventLostFundsFromLiquidation} returns this
 */
proto.injective.exchange.v1beta1.EventLostFundsFromLiquidation.prototype.setSubaccountId = function(value) {
  return jspb.Message.setProto3BytesField(this, 2, value);
};


/**
 * optional string lost_funds_from_available_during_payout = 3;
 * @return {string}
 */
proto.injective.exchange.v1beta1.EventLostFundsFromLiquidation.prototype.getLostFundsFromAvailableDuringPayout = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * @param {string} value
 * @return {!proto.injective.exchange.v1beta1.EventLostFundsFromLiquidation} returns this
 */
proto.injective.exchange.v1beta1.EventLostFundsFromLiquidation.prototype.setLostFundsFromAvailableDuringPayout = function(value) {
  return jspb.Message.setProto3StringField(this, 3, value);
};


/**
 * optional string lost_funds_from_order_cancels = 4;
 * @return {string}
 */
proto.injective.exchange.v1beta1.EventLostFundsFromLiquidation.prototype.getLostFundsFromOrderCancels = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * @param {string} value
 * @return {!proto.injective.exchange.v1beta1.EventLostFundsFromLiquidation} returns this
 */
proto.injective.exchange.v1beta1.EventLostFundsFromLiquidation.prototype.setLostFundsFromOrderCancels = function(value) {
  return jspb.Message.setProto3StringField(this, 4, value);
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.injective.exchange.v1beta1.EventBatchDerivativePosition.repeatedFields_ = [2];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.injective.exchange.v1beta1.EventBatchDerivativePosition.prototype.toObject = function(opt_includeInstance) {
  return proto.injective.exchange.v1beta1.EventBatchDerivativePosition.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.injective.exchange.v1beta1.EventBatchDerivativePosition} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.injective.exchange.v1beta1.EventBatchDerivativePosition.toObject = function(includeInstance, msg) {
  var f, obj = {
    marketId: jspb.Message.getFieldWithDefault(msg, 1, ""),
    positionsList: jspb.Message.toObjectList(msg.getPositionsList(),
    injective_exchange_v1beta1_exchange_pb.SubaccountPosition.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.injective.exchange.v1beta1.EventBatchDerivativePosition}
 */
proto.injective.exchange.v1beta1.EventBatchDerivativePosition.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.injective.exchange.v1beta1.EventBatchDerivativePosition;
  return proto.injective.exchange.v1beta1.EventBatchDerivativePosition.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.injective.exchange.v1beta1.EventBatchDerivativePosition} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.injective.exchange.v1beta1.EventBatchDerivativePosition}
 */
proto.injective.exchange.v1beta1.EventBatchDerivativePosition.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setMarketId(value);
      break;
    case 2:
      var value = new injective_exchange_v1beta1_exchange_pb.SubaccountPosition;
      reader.readMessage(value,injective_exchange_v1beta1_exchange_pb.SubaccountPosition.deserializeBinaryFromReader);
      msg.addPositions(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.injective.exchange.v1beta1.EventBatchDerivativePosition.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.injective.exchange.v1beta1.EventBatchDerivativePosition.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.injective.exchange.v1beta1.EventBatchDerivativePosition} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.injective.exchange.v1beta1.EventBatchDerivativePosition.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getMarketId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getPositionsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      2,
      f,
      injective_exchange_v1beta1_exchange_pb.SubaccountPosition.serializeBinaryToWriter
    );
  }
};


/**
 * optional string market_id = 1;
 * @return {string}
 */
proto.injective.exchange.v1beta1.EventBatchDerivativePosition.prototype.getMarketId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.injective.exchange.v1beta1.EventBatchDerivativePosition} returns this
 */
proto.injective.exchange.v1beta1.EventBatchDerivativePosition.prototype.setMarketId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * repeated SubaccountPosition positions = 2;
 * @return {!Array<!proto.injective.exchange.v1beta1.SubaccountPosition>}
 */
proto.injective.exchange.v1beta1.EventBatchDerivativePosition.prototype.getPositionsList = function() {
  return /** @type{!Array<!proto.injective.exchange.v1beta1.SubaccountPosition>} */ (
    jspb.Message.getRepeatedWrapperField(this, injective_exchange_v1beta1_exchange_pb.SubaccountPosition, 2));
};


/**
 * @param {!Array<!proto.injective.exchange.v1beta1.SubaccountPosition>} value
 * @return {!proto.injective.exchange.v1beta1.EventBatchDerivativePosition} returns this
*/
proto.injective.exchange.v1beta1.EventBatchDerivativePosition.prototype.setPositionsList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 2, value);
};


/**
 * @param {!proto.injective.exchange.v1beta1.SubaccountPosition=} opt_value
 * @param {number=} opt_index
 * @return {!proto.injective.exchange.v1beta1.SubaccountPosition}
 */
proto.injective.exchange.v1beta1.EventBatchDerivativePosition.prototype.addPositions = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.injective.exchange.v1beta1.SubaccountPosition, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.injective.exchange.v1beta1.EventBatchDerivativePosition} returns this
 */
proto.injective.exchange.v1beta1.EventBatchDerivativePosition.prototype.clearPositionsList = function() {
  return this.setPositionsList([]);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.injective.exchange.v1beta1.EventDerivativeMarketPaused.prototype.toObject = function(opt_includeInstance) {
  return proto.injective.exchange.v1beta1.EventDerivativeMarketPaused.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.injective.exchange.v1beta1.EventDerivativeMarketPaused} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.injective.exchange.v1beta1.EventDerivativeMarketPaused.toObject = function(includeInstance, msg) {
  var f, obj = {
    marketId: jspb.Message.getFieldWithDefault(msg, 1, ""),
    settlePrice: jspb.Message.getFieldWithDefault(msg, 2, ""),
    totalMissingFunds: jspb.Message.getFieldWithDefault(msg, 3, ""),
    missingFundsRate: jspb.Message.getFieldWithDefault(msg, 4, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.injective.exchange.v1beta1.EventDerivativeMarketPaused}
 */
proto.injective.exchange.v1beta1.EventDerivativeMarketPaused.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.injective.exchange.v1beta1.EventDerivativeMarketPaused;
  return proto.injective.exchange.v1beta1.EventDerivativeMarketPaused.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.injective.exchange.v1beta1.EventDerivativeMarketPaused} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.injective.exchange.v1beta1.EventDerivativeMarketPaused}
 */
proto.injective.exchange.v1beta1.EventDerivativeMarketPaused.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setMarketId(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setSettlePrice(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setTotalMissingFunds(value);
      break;
    case 4:
      var value = /** @type {string} */ (reader.readString());
      msg.setMissingFundsRate(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.injective.exchange.v1beta1.EventDerivativeMarketPaused.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.injective.exchange.v1beta1.EventDerivativeMarketPaused.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.injective.exchange.v1beta1.EventDerivativeMarketPaused} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.injective.exchange.v1beta1.EventDerivativeMarketPaused.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getMarketId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getSettlePrice();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getTotalMissingFunds();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
  f = message.getMissingFundsRate();
  if (f.length > 0) {
    writer.writeString(
      4,
      f
    );
  }
};


/**
 * optional string market_id = 1;
 * @return {string}
 */
proto.injective.exchange.v1beta1.EventDerivativeMarketPaused.prototype.getMarketId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.injective.exchange.v1beta1.EventDerivativeMarketPaused} returns this
 */
proto.injective.exchange.v1beta1.EventDerivativeMarketPaused.prototype.setMarketId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional string settle_price = 2;
 * @return {string}
 */
proto.injective.exchange.v1beta1.EventDerivativeMarketPaused.prototype.getSettlePrice = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.injective.exchange.v1beta1.EventDerivativeMarketPaused} returns this
 */
proto.injective.exchange.v1beta1.EventDerivativeMarketPaused.prototype.setSettlePrice = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * optional string total_missing_funds = 3;
 * @return {string}
 */
proto.injective.exchange.v1beta1.EventDerivativeMarketPaused.prototype.getTotalMissingFunds = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * @param {string} value
 * @return {!proto.injective.exchange.v1beta1.EventDerivativeMarketPaused} returns this
 */
proto.injective.exchange.v1beta1.EventDerivativeMarketPaused.prototype.setTotalMissingFunds = function(value) {
  return jspb.Message.setProto3StringField(this, 3, value);
};


/**
 * optional string missing_funds_rate = 4;
 * @return {string}
 */
proto.injective.exchange.v1beta1.EventDerivativeMarketPaused.prototype.getMissingFundsRate = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * @param {string} value
 * @return {!proto.injective.exchange.v1beta1.EventDerivativeMarketPaused} returns this
 */
proto.injective.exchange.v1beta1.EventDerivativeMarketPaused.prototype.setMissingFundsRate = function(value) {
  return jspb.Message.setProto3StringField(this, 4, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.injective.exchange.v1beta1.EventBinaryOptionsMarketUpdate.prototype.toObject = function(opt_includeInstance) {
  return proto.injective.exchange.v1beta1.EventBinaryOptionsMarketUpdate.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.injective.exchange.v1beta1.EventBinaryOptionsMarketUpdate} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.injective.exchange.v1beta1.EventBinaryOptionsMarketUpdate.toObject = function(includeInstance, msg) {
  var f, obj = {
    market: (f = msg.getMarket()) && injective_exchange_v1beta1_exchange_pb.BinaryOptionsMarket.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.injective.exchange.v1beta1.EventBinaryOptionsMarketUpdate}
 */
proto.injective.exchange.v1beta1.EventBinaryOptionsMarketUpdate.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.injective.exchange.v1beta1.EventBinaryOptionsMarketUpdate;
  return proto.injective.exchange.v1beta1.EventBinaryOptionsMarketUpdate.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.injective.exchange.v1beta1.EventBinaryOptionsMarketUpdate} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.injective.exchange.v1beta1.EventBinaryOptionsMarketUpdate}
 */
proto.injective.exchange.v1beta1.EventBinaryOptionsMarketUpdate.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new injective_exchange_v1beta1_exchange_pb.BinaryOptionsMarket;
      reader.readMessage(value,injective_exchange_v1beta1_exchange_pb.BinaryOptionsMarket.deserializeBinaryFromReader);
      msg.setMarket(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.injective.exchange.v1beta1.EventBinaryOptionsMarketUpdate.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.injective.exchange.v1beta1.EventBinaryOptionsMarketUpdate.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.injective.exchange.v1beta1.EventBinaryOptionsMarketUpdate} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.injective.exchange.v1beta1.EventBinaryOptionsMarketUpdate.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getMarket();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      injective_exchange_v1beta1_exchange_pb.BinaryOptionsMarket.serializeBinaryToWriter
    );
  }
};


/**
 * optional BinaryOptionsMarket market = 1;
 * @return {?proto.injective.exchange.v1beta1.BinaryOptionsMarket}
 */
proto.injective.exchange.v1beta1.EventBinaryOptionsMarketUpdate.prototype.getMarket = function() {
  return /** @type{?proto.injective.exchange.v1beta1.BinaryOptionsMarket} */ (
    jspb.Message.getWrapperField(this, injective_exchange_v1beta1_exchange_pb.BinaryOptionsMarket, 1));
};


/**
 * @param {?proto.injective.exchange.v1beta1.BinaryOptionsMarket|undefined} value
 * @return {!proto.injective.exchange.v1beta1.EventBinaryOptionsMarketUpdate} returns this
*/
proto.injective.exchange.v1beta1.EventBinaryOptionsMarketUpdate.prototype.setMarket = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.injective.exchange.v1beta1.EventBinaryOptionsMarketUpdate} returns this
 */
proto.injective.exchange.v1beta1.EventBinaryOptionsMarketUpdate.prototype.clearMarket = function() {
  return this.setMarket(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.injective.exchange.v1beta1.EventBinaryOptionsMarketUpdate.prototype.hasMarket = function() {
  return jspb.Message.getField(this, 1) != null;
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.injective.exchange.v1beta1.EventNewSpotOrders.repeatedFields_ = [2,3];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.injective.exchange.v1beta1.EventNewSpotOrders.prototype.toObject = function(opt_includeInstance) {
  return proto.injective.exchange.v1beta1.EventNewSpotOrders.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.injective.exchange.v1beta1.EventNewSpotOrders} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.injective.exchange.v1beta1.EventNewSpotOrders.toObject = function(includeInstance, msg) {
  var f, obj = {
    marketId: jspb.Message.getFieldWithDefault(msg, 1, ""),
    buyOrdersList: jspb.Message.toObjectList(msg.getBuyOrdersList(),
    injective_exchange_v1beta1_exchange_pb.SpotLimitOrder.toObject, includeInstance),
    sellOrdersList: jspb.Message.toObjectList(msg.getSellOrdersList(),
    injective_exchange_v1beta1_exchange_pb.SpotLimitOrder.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.injective.exchange.v1beta1.EventNewSpotOrders}
 */
proto.injective.exchange.v1beta1.EventNewSpotOrders.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.injective.exchange.v1beta1.EventNewSpotOrders;
  return proto.injective.exchange.v1beta1.EventNewSpotOrders.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.injective.exchange.v1beta1.EventNewSpotOrders} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.injective.exchange.v1beta1.EventNewSpotOrders}
 */
proto.injective.exchange.v1beta1.EventNewSpotOrders.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setMarketId(value);
      break;
    case 2:
      var value = new injective_exchange_v1beta1_exchange_pb.SpotLimitOrder;
      reader.readMessage(value,injective_exchange_v1beta1_exchange_pb.SpotLimitOrder.deserializeBinaryFromReader);
      msg.addBuyOrders(value);
      break;
    case 3:
      var value = new injective_exchange_v1beta1_exchange_pb.SpotLimitOrder;
      reader.readMessage(value,injective_exchange_v1beta1_exchange_pb.SpotLimitOrder.deserializeBinaryFromReader);
      msg.addSellOrders(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.injective.exchange.v1beta1.EventNewSpotOrders.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.injective.exchange.v1beta1.EventNewSpotOrders.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.injective.exchange.v1beta1.EventNewSpotOrders} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.injective.exchange.v1beta1.EventNewSpotOrders.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getMarketId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getBuyOrdersList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      2,
      f,
      injective_exchange_v1beta1_exchange_pb.SpotLimitOrder.serializeBinaryToWriter
    );
  }
  f = message.getSellOrdersList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      3,
      f,
      injective_exchange_v1beta1_exchange_pb.SpotLimitOrder.serializeBinaryToWriter
    );
  }
};


/**
 * optional string market_id = 1;
 * @return {string}
 */
proto.injective.exchange.v1beta1.EventNewSpotOrders.prototype.getMarketId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.injective.exchange.v1beta1.EventNewSpotOrders} returns this
 */
proto.injective.exchange.v1beta1.EventNewSpotOrders.prototype.setMarketId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * repeated SpotLimitOrder buy_orders = 2;
 * @return {!Array<!proto.injective.exchange.v1beta1.SpotLimitOrder>}
 */
proto.injective.exchange.v1beta1.EventNewSpotOrders.prototype.getBuyOrdersList = function() {
  return /** @type{!Array<!proto.injective.exchange.v1beta1.SpotLimitOrder>} */ (
    jspb.Message.getRepeatedWrapperField(this, injective_exchange_v1beta1_exchange_pb.SpotLimitOrder, 2));
};


/**
 * @param {!Array<!proto.injective.exchange.v1beta1.SpotLimitOrder>} value
 * @return {!proto.injective.exchange.v1beta1.EventNewSpotOrders} returns this
*/
proto.injective.exchange.v1beta1.EventNewSpotOrders.prototype.setBuyOrdersList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 2, value);
};


/**
 * @param {!proto.injective.exchange.v1beta1.SpotLimitOrder=} opt_value
 * @param {number=} opt_index
 * @return {!proto.injective.exchange.v1beta1.SpotLimitOrder}
 */
proto.injective.exchange.v1beta1.EventNewSpotOrders.prototype.addBuyOrders = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.injective.exchange.v1beta1.SpotLimitOrder, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.injective.exchange.v1beta1.EventNewSpotOrders} returns this
 */
proto.injective.exchange.v1beta1.EventNewSpotOrders.prototype.clearBuyOrdersList = function() {
  return this.setBuyOrdersList([]);
};


/**
 * repeated SpotLimitOrder sell_orders = 3;
 * @return {!Array<!proto.injective.exchange.v1beta1.SpotLimitOrder>}
 */
proto.injective.exchange.v1beta1.EventNewSpotOrders.prototype.getSellOrdersList = function() {
  return /** @type{!Array<!proto.injective.exchange.v1beta1.SpotLimitOrder>} */ (
    jspb.Message.getRepeatedWrapperField(this, injective_exchange_v1beta1_exchange_pb.SpotLimitOrder, 3));
};


/**
 * @param {!Array<!proto.injective.exchange.v1beta1.SpotLimitOrder>} value
 * @return {!proto.injective.exchange.v1beta1.EventNewSpotOrders} returns this
*/
proto.injective.exchange.v1beta1.EventNewSpotOrders.prototype.setSellOrdersList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 3, value);
};


/**
 * @param {!proto.injective.exchange.v1beta1.SpotLimitOrder=} opt_value
 * @param {number=} opt_index
 * @return {!proto.injective.exchange.v1beta1.SpotLimitOrder}
 */
proto.injective.exchange.v1beta1.EventNewSpotOrders.prototype.addSellOrders = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 3, opt_value, proto.injective.exchange.v1beta1.SpotLimitOrder, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.injective.exchange.v1beta1.EventNewSpotOrders} returns this
 */
proto.injective.exchange.v1beta1.EventNewSpotOrders.prototype.clearSellOrdersList = function() {
  return this.setSellOrdersList([]);
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.injective.exchange.v1beta1.EventNewDerivativeOrders.repeatedFields_ = [2,3];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.injective.exchange.v1beta1.EventNewDerivativeOrders.prototype.toObject = function(opt_includeInstance) {
  return proto.injective.exchange.v1beta1.EventNewDerivativeOrders.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.injective.exchange.v1beta1.EventNewDerivativeOrders} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.injective.exchange.v1beta1.EventNewDerivativeOrders.toObject = function(includeInstance, msg) {
  var f, obj = {
    marketId: jspb.Message.getFieldWithDefault(msg, 1, ""),
    buyOrdersList: jspb.Message.toObjectList(msg.getBuyOrdersList(),
    injective_exchange_v1beta1_exchange_pb.DerivativeLimitOrder.toObject, includeInstance),
    sellOrdersList: jspb.Message.toObjectList(msg.getSellOrdersList(),
    injective_exchange_v1beta1_exchange_pb.DerivativeLimitOrder.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.injective.exchange.v1beta1.EventNewDerivativeOrders}
 */
proto.injective.exchange.v1beta1.EventNewDerivativeOrders.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.injective.exchange.v1beta1.EventNewDerivativeOrders;
  return proto.injective.exchange.v1beta1.EventNewDerivativeOrders.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.injective.exchange.v1beta1.EventNewDerivativeOrders} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.injective.exchange.v1beta1.EventNewDerivativeOrders}
 */
proto.injective.exchange.v1beta1.EventNewDerivativeOrders.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setMarketId(value);
      break;
    case 2:
      var value = new injective_exchange_v1beta1_exchange_pb.DerivativeLimitOrder;
      reader.readMessage(value,injective_exchange_v1beta1_exchange_pb.DerivativeLimitOrder.deserializeBinaryFromReader);
      msg.addBuyOrders(value);
      break;
    case 3:
      var value = new injective_exchange_v1beta1_exchange_pb.DerivativeLimitOrder;
      reader.readMessage(value,injective_exchange_v1beta1_exchange_pb.DerivativeLimitOrder.deserializeBinaryFromReader);
      msg.addSellOrders(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.injective.exchange.v1beta1.EventNewDerivativeOrders.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.injective.exchange.v1beta1.EventNewDerivativeOrders.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.injective.exchange.v1beta1.EventNewDerivativeOrders} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.injective.exchange.v1beta1.EventNewDerivativeOrders.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getMarketId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getBuyOrdersList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      2,
      f,
      injective_exchange_v1beta1_exchange_pb.DerivativeLimitOrder.serializeBinaryToWriter
    );
  }
  f = message.getSellOrdersList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      3,
      f,
      injective_exchange_v1beta1_exchange_pb.DerivativeLimitOrder.serializeBinaryToWriter
    );
  }
};


/**
 * optional string market_id = 1;
 * @return {string}
 */
proto.injective.exchange.v1beta1.EventNewDerivativeOrders.prototype.getMarketId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.injective.exchange.v1beta1.EventNewDerivativeOrders} returns this
 */
proto.injective.exchange.v1beta1.EventNewDerivativeOrders.prototype.setMarketId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * repeated DerivativeLimitOrder buy_orders = 2;
 * @return {!Array<!proto.injective.exchange.v1beta1.DerivativeLimitOrder>}
 */
proto.injective.exchange.v1beta1.EventNewDerivativeOrders.prototype.getBuyOrdersList = function() {
  return /** @type{!Array<!proto.injective.exchange.v1beta1.DerivativeLimitOrder>} */ (
    jspb.Message.getRepeatedWrapperField(this, injective_exchange_v1beta1_exchange_pb.DerivativeLimitOrder, 2));
};


/**
 * @param {!Array<!proto.injective.exchange.v1beta1.DerivativeLimitOrder>} value
 * @return {!proto.injective.exchange.v1beta1.EventNewDerivativeOrders} returns this
*/
proto.injective.exchange.v1beta1.EventNewDerivativeOrders.prototype.setBuyOrdersList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 2, value);
};


/**
 * @param {!proto.injective.exchange.v1beta1.DerivativeLimitOrder=} opt_value
 * @param {number=} opt_index
 * @return {!proto.injective.exchange.v1beta1.DerivativeLimitOrder}
 */
proto.injective.exchange.v1beta1.EventNewDerivativeOrders.prototype.addBuyOrders = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.injective.exchange.v1beta1.DerivativeLimitOrder, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.injective.exchange.v1beta1.EventNewDerivativeOrders} returns this
 */
proto.injective.exchange.v1beta1.EventNewDerivativeOrders.prototype.clearBuyOrdersList = function() {
  return this.setBuyOrdersList([]);
};


/**
 * repeated DerivativeLimitOrder sell_orders = 3;
 * @return {!Array<!proto.injective.exchange.v1beta1.DerivativeLimitOrder>}
 */
proto.injective.exchange.v1beta1.EventNewDerivativeOrders.prototype.getSellOrdersList = function() {
  return /** @type{!Array<!proto.injective.exchange.v1beta1.DerivativeLimitOrder>} */ (
    jspb.Message.getRepeatedWrapperField(this, injective_exchange_v1beta1_exchange_pb.DerivativeLimitOrder, 3));
};


/**
 * @param {!Array<!proto.injective.exchange.v1beta1.DerivativeLimitOrder>} value
 * @return {!proto.injective.exchange.v1beta1.EventNewDerivativeOrders} returns this
*/
proto.injective.exchange.v1beta1.EventNewDerivativeOrders.prototype.setSellOrdersList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 3, value);
};


/**
 * @param {!proto.injective.exchange.v1beta1.DerivativeLimitOrder=} opt_value
 * @param {number=} opt_index
 * @return {!proto.injective.exchange.v1beta1.DerivativeLimitOrder}
 */
proto.injective.exchange.v1beta1.EventNewDerivativeOrders.prototype.addSellOrders = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 3, opt_value, proto.injective.exchange.v1beta1.DerivativeLimitOrder, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.injective.exchange.v1beta1.EventNewDerivativeOrders} returns this
 */
proto.injective.exchange.v1beta1.EventNewDerivativeOrders.prototype.clearSellOrdersList = function() {
  return this.setSellOrdersList([]);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.injective.exchange.v1beta1.EventCancelSpotOrder.prototype.toObject = function(opt_includeInstance) {
  return proto.injective.exchange.v1beta1.EventCancelSpotOrder.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.injective.exchange.v1beta1.EventCancelSpotOrder} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.injective.exchange.v1beta1.EventCancelSpotOrder.toObject = function(includeInstance, msg) {
  var f, obj = {
    marketId: jspb.Message.getFieldWithDefault(msg, 1, ""),
    order: (f = msg.getOrder()) && injective_exchange_v1beta1_exchange_pb.SpotLimitOrder.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.injective.exchange.v1beta1.EventCancelSpotOrder}
 */
proto.injective.exchange.v1beta1.EventCancelSpotOrder.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.injective.exchange.v1beta1.EventCancelSpotOrder;
  return proto.injective.exchange.v1beta1.EventCancelSpotOrder.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.injective.exchange.v1beta1.EventCancelSpotOrder} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.injective.exchange.v1beta1.EventCancelSpotOrder}
 */
proto.injective.exchange.v1beta1.EventCancelSpotOrder.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setMarketId(value);
      break;
    case 2:
      var value = new injective_exchange_v1beta1_exchange_pb.SpotLimitOrder;
      reader.readMessage(value,injective_exchange_v1beta1_exchange_pb.SpotLimitOrder.deserializeBinaryFromReader);
      msg.setOrder(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.injective.exchange.v1beta1.EventCancelSpotOrder.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.injective.exchange.v1beta1.EventCancelSpotOrder.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.injective.exchange.v1beta1.EventCancelSpotOrder} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.injective.exchange.v1beta1.EventCancelSpotOrder.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getMarketId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getOrder();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      injective_exchange_v1beta1_exchange_pb.SpotLimitOrder.serializeBinaryToWriter
    );
  }
};


/**
 * optional string market_id = 1;
 * @return {string}
 */
proto.injective.exchange.v1beta1.EventCancelSpotOrder.prototype.getMarketId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.injective.exchange.v1beta1.EventCancelSpotOrder} returns this
 */
proto.injective.exchange.v1beta1.EventCancelSpotOrder.prototype.setMarketId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional SpotLimitOrder order = 2;
 * @return {?proto.injective.exchange.v1beta1.SpotLimitOrder}
 */
proto.injective.exchange.v1beta1.EventCancelSpotOrder.prototype.getOrder = function() {
  return /** @type{?proto.injective.exchange.v1beta1.SpotLimitOrder} */ (
    jspb.Message.getWrapperField(this, injective_exchange_v1beta1_exchange_pb.SpotLimitOrder, 2));
};


/**
 * @param {?proto.injective.exchange.v1beta1.SpotLimitOrder|undefined} value
 * @return {!proto.injective.exchange.v1beta1.EventCancelSpotOrder} returns this
*/
proto.injective.exchange.v1beta1.EventCancelSpotOrder.prototype.setOrder = function(value) {
  return jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.injective.exchange.v1beta1.EventCancelSpotOrder} returns this
 */
proto.injective.exchange.v1beta1.EventCancelSpotOrder.prototype.clearOrder = function() {
  return this.setOrder(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.injective.exchange.v1beta1.EventCancelSpotOrder.prototype.hasOrder = function() {
  return jspb.Message.getField(this, 2) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.injective.exchange.v1beta1.EventSpotMarketUpdate.prototype.toObject = function(opt_includeInstance) {
  return proto.injective.exchange.v1beta1.EventSpotMarketUpdate.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.injective.exchange.v1beta1.EventSpotMarketUpdate} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.injective.exchange.v1beta1.EventSpotMarketUpdate.toObject = function(includeInstance, msg) {
  var f, obj = {
    market: (f = msg.getMarket()) && injective_exchange_v1beta1_exchange_pb.SpotMarket.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.injective.exchange.v1beta1.EventSpotMarketUpdate}
 */
proto.injective.exchange.v1beta1.EventSpotMarketUpdate.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.injective.exchange.v1beta1.EventSpotMarketUpdate;
  return proto.injective.exchange.v1beta1.EventSpotMarketUpdate.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.injective.exchange.v1beta1.EventSpotMarketUpdate} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.injective.exchange.v1beta1.EventSpotMarketUpdate}
 */
proto.injective.exchange.v1beta1.EventSpotMarketUpdate.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new injective_exchange_v1beta1_exchange_pb.SpotMarket;
      reader.readMessage(value,injective_exchange_v1beta1_exchange_pb.SpotMarket.deserializeBinaryFromReader);
      msg.setMarket(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.injective.exchange.v1beta1.EventSpotMarketUpdate.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.injective.exchange.v1beta1.EventSpotMarketUpdate.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.injective.exchange.v1beta1.EventSpotMarketUpdate} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.injective.exchange.v1beta1.EventSpotMarketUpdate.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getMarket();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      injective_exchange_v1beta1_exchange_pb.SpotMarket.serializeBinaryToWriter
    );
  }
};


/**
 * optional SpotMarket market = 1;
 * @return {?proto.injective.exchange.v1beta1.SpotMarket}
 */
proto.injective.exchange.v1beta1.EventSpotMarketUpdate.prototype.getMarket = function() {
  return /** @type{?proto.injective.exchange.v1beta1.SpotMarket} */ (
    jspb.Message.getWrapperField(this, injective_exchange_v1beta1_exchange_pb.SpotMarket, 1));
};


/**
 * @param {?proto.injective.exchange.v1beta1.SpotMarket|undefined} value
 * @return {!proto.injective.exchange.v1beta1.EventSpotMarketUpdate} returns this
*/
proto.injective.exchange.v1beta1.EventSpotMarketUpdate.prototype.setMarket = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.injective.exchange.v1beta1.EventSpotMarketUpdate} returns this
 */
proto.injective.exchange.v1beta1.EventSpotMarketUpdate.prototype.clearMarket = function() {
  return this.setMarket(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.injective.exchange.v1beta1.EventSpotMarketUpdate.prototype.hasMarket = function() {
  return jspb.Message.getField(this, 1) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.injective.exchange.v1beta1.EventPerpetualMarketUpdate.prototype.toObject = function(opt_includeInstance) {
  return proto.injective.exchange.v1beta1.EventPerpetualMarketUpdate.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.injective.exchange.v1beta1.EventPerpetualMarketUpdate} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.injective.exchange.v1beta1.EventPerpetualMarketUpdate.toObject = function(includeInstance, msg) {
  var f, obj = {
    market: (f = msg.getMarket()) && injective_exchange_v1beta1_exchange_pb.DerivativeMarket.toObject(includeInstance, f),
    perpetualMarketInfo: (f = msg.getPerpetualMarketInfo()) && injective_exchange_v1beta1_exchange_pb.PerpetualMarketInfo.toObject(includeInstance, f),
    funding: (f = msg.getFunding()) && injective_exchange_v1beta1_exchange_pb.PerpetualMarketFunding.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.injective.exchange.v1beta1.EventPerpetualMarketUpdate}
 */
proto.injective.exchange.v1beta1.EventPerpetualMarketUpdate.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.injective.exchange.v1beta1.EventPerpetualMarketUpdate;
  return proto.injective.exchange.v1beta1.EventPerpetualMarketUpdate.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.injective.exchange.v1beta1.EventPerpetualMarketUpdate} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.injective.exchange.v1beta1.EventPerpetualMarketUpdate}
 */
proto.injective.exchange.v1beta1.EventPerpetualMarketUpdate.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new injective_exchange_v1beta1_exchange_pb.DerivativeMarket;
      reader.readMessage(value,injective_exchange_v1beta1_exchange_pb.DerivativeMarket.deserializeBinaryFromReader);
      msg.setMarket(value);
      break;
    case 2:
      var value = new injective_exchange_v1beta1_exchange_pb.PerpetualMarketInfo;
      reader.readMessage(value,injective_exchange_v1beta1_exchange_pb.PerpetualMarketInfo.deserializeBinaryFromReader);
      msg.setPerpetualMarketInfo(value);
      break;
    case 3:
      var value = new injective_exchange_v1beta1_exchange_pb.PerpetualMarketFunding;
      reader.readMessage(value,injective_exchange_v1beta1_exchange_pb.PerpetualMarketFunding.deserializeBinaryFromReader);
      msg.setFunding(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.injective.exchange.v1beta1.EventPerpetualMarketUpdate.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.injective.exchange.v1beta1.EventPerpetualMarketUpdate.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.injective.exchange.v1beta1.EventPerpetualMarketUpdate} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.injective.exchange.v1beta1.EventPerpetualMarketUpdate.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getMarket();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      injective_exchange_v1beta1_exchange_pb.DerivativeMarket.serializeBinaryToWriter
    );
  }
  f = message.getPerpetualMarketInfo();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      injective_exchange_v1beta1_exchange_pb.PerpetualMarketInfo.serializeBinaryToWriter
    );
  }
  f = message.getFunding();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      injective_exchange_v1beta1_exchange_pb.PerpetualMarketFunding.serializeBinaryToWriter
    );
  }
};


/**
 * optional DerivativeMarket market = 1;
 * @return {?proto.injective.exchange.v1beta1.DerivativeMarket}
 */
proto.injective.exchange.v1beta1.EventPerpetualMarketUpdate.prototype.getMarket = function() {
  return /** @type{?proto.injective.exchange.v1beta1.DerivativeMarket} */ (
    jspb.Message.getWrapperField(this, injective_exchange_v1beta1_exchange_pb.DerivativeMarket, 1));
};


/**
 * @param {?proto.injective.exchange.v1beta1.DerivativeMarket|undefined} value
 * @return {!proto.injective.exchange.v1beta1.EventPerpetualMarketUpdate} returns this
*/
proto.injective.exchange.v1beta1.EventPerpetualMarketUpdate.prototype.setMarket = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.injective.exchange.v1beta1.EventPerpetualMarketUpdate} returns this
 */
proto.injective.exchange.v1beta1.EventPerpetualMarketUpdate.prototype.clearMarket = function() {
  return this.setMarket(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.injective.exchange.v1beta1.EventPerpetualMarketUpdate.prototype.hasMarket = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional PerpetualMarketInfo perpetual_market_info = 2;
 * @return {?proto.injective.exchange.v1beta1.PerpetualMarketInfo}
 */
proto.injective.exchange.v1beta1.EventPerpetualMarketUpdate.prototype.getPerpetualMarketInfo = function() {
  return /** @type{?proto.injective.exchange.v1beta1.PerpetualMarketInfo} */ (
    jspb.Message.getWrapperField(this, injective_exchange_v1beta1_exchange_pb.PerpetualMarketInfo, 2));
};


/**
 * @param {?proto.injective.exchange.v1beta1.PerpetualMarketInfo|undefined} value
 * @return {!proto.injective.exchange.v1beta1.EventPerpetualMarketUpdate} returns this
*/
proto.injective.exchange.v1beta1.EventPerpetualMarketUpdate.prototype.setPerpetualMarketInfo = function(value) {
  return jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.injective.exchange.v1beta1.EventPerpetualMarketUpdate} returns this
 */
proto.injective.exchange.v1beta1.EventPerpetualMarketUpdate.prototype.clearPerpetualMarketInfo = function() {
  return this.setPerpetualMarketInfo(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.injective.exchange.v1beta1.EventPerpetualMarketUpdate.prototype.hasPerpetualMarketInfo = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional PerpetualMarketFunding funding = 3;
 * @return {?proto.injective.exchange.v1beta1.PerpetualMarketFunding}
 */
proto.injective.exchange.v1beta1.EventPerpetualMarketUpdate.prototype.getFunding = function() {
  return /** @type{?proto.injective.exchange.v1beta1.PerpetualMarketFunding} */ (
    jspb.Message.getWrapperField(this, injective_exchange_v1beta1_exchange_pb.PerpetualMarketFunding, 3));
};


/**
 * @param {?proto.injective.exchange.v1beta1.PerpetualMarketFunding|undefined} value
 * @return {!proto.injective.exchange.v1beta1.EventPerpetualMarketUpdate} returns this
*/
proto.injective.exchange.v1beta1.EventPerpetualMarketUpdate.prototype.setFunding = function(value) {
  return jspb.Message.setWrapperField(this, 3, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.injective.exchange.v1beta1.EventPerpetualMarketUpdate} returns this
 */
proto.injective.exchange.v1beta1.EventPerpetualMarketUpdate.prototype.clearFunding = function() {
  return this.setFunding(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.injective.exchange.v1beta1.EventPerpetualMarketUpdate.prototype.hasFunding = function() {
  return jspb.Message.getField(this, 3) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.injective.exchange.v1beta1.EventExpiryFuturesMarketUpdate.prototype.toObject = function(opt_includeInstance) {
  return proto.injective.exchange.v1beta1.EventExpiryFuturesMarketUpdate.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.injective.exchange.v1beta1.EventExpiryFuturesMarketUpdate} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.injective.exchange.v1beta1.EventExpiryFuturesMarketUpdate.toObject = function(includeInstance, msg) {
  var f, obj = {
    market: (f = msg.getMarket()) && injective_exchange_v1beta1_exchange_pb.DerivativeMarket.toObject(includeInstance, f),
    expiryFuturesMarketInfo: (f = msg.getExpiryFuturesMarketInfo()) && injective_exchange_v1beta1_exchange_pb.ExpiryFuturesMarketInfo.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.injective.exchange.v1beta1.EventExpiryFuturesMarketUpdate}
 */
proto.injective.exchange.v1beta1.EventExpiryFuturesMarketUpdate.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.injective.exchange.v1beta1.EventExpiryFuturesMarketUpdate;
  return proto.injective.exchange.v1beta1.EventExpiryFuturesMarketUpdate.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.injective.exchange.v1beta1.EventExpiryFuturesMarketUpdate} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.injective.exchange.v1beta1.EventExpiryFuturesMarketUpdate}
 */
proto.injective.exchange.v1beta1.EventExpiryFuturesMarketUpdate.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new injective_exchange_v1beta1_exchange_pb.DerivativeMarket;
      reader.readMessage(value,injective_exchange_v1beta1_exchange_pb.DerivativeMarket.deserializeBinaryFromReader);
      msg.setMarket(value);
      break;
    case 3:
      var value = new injective_exchange_v1beta1_exchange_pb.ExpiryFuturesMarketInfo;
      reader.readMessage(value,injective_exchange_v1beta1_exchange_pb.ExpiryFuturesMarketInfo.deserializeBinaryFromReader);
      msg.setExpiryFuturesMarketInfo(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.injective.exchange.v1beta1.EventExpiryFuturesMarketUpdate.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.injective.exchange.v1beta1.EventExpiryFuturesMarketUpdate.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.injective.exchange.v1beta1.EventExpiryFuturesMarketUpdate} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.injective.exchange.v1beta1.EventExpiryFuturesMarketUpdate.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getMarket();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      injective_exchange_v1beta1_exchange_pb.DerivativeMarket.serializeBinaryToWriter
    );
  }
  f = message.getExpiryFuturesMarketInfo();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      injective_exchange_v1beta1_exchange_pb.ExpiryFuturesMarketInfo.serializeBinaryToWriter
    );
  }
};


/**
 * optional DerivativeMarket market = 1;
 * @return {?proto.injective.exchange.v1beta1.DerivativeMarket}
 */
proto.injective.exchange.v1beta1.EventExpiryFuturesMarketUpdate.prototype.getMarket = function() {
  return /** @type{?proto.injective.exchange.v1beta1.DerivativeMarket} */ (
    jspb.Message.getWrapperField(this, injective_exchange_v1beta1_exchange_pb.DerivativeMarket, 1));
};


/**
 * @param {?proto.injective.exchange.v1beta1.DerivativeMarket|undefined} value
 * @return {!proto.injective.exchange.v1beta1.EventExpiryFuturesMarketUpdate} returns this
*/
proto.injective.exchange.v1beta1.EventExpiryFuturesMarketUpdate.prototype.setMarket = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.injective.exchange.v1beta1.EventExpiryFuturesMarketUpdate} returns this
 */
proto.injective.exchange.v1beta1.EventExpiryFuturesMarketUpdate.prototype.clearMarket = function() {
  return this.setMarket(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.injective.exchange.v1beta1.EventExpiryFuturesMarketUpdate.prototype.hasMarket = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional ExpiryFuturesMarketInfo expiry_futures_market_info = 3;
 * @return {?proto.injective.exchange.v1beta1.ExpiryFuturesMarketInfo}
 */
proto.injective.exchange.v1beta1.EventExpiryFuturesMarketUpdate.prototype.getExpiryFuturesMarketInfo = function() {
  return /** @type{?proto.injective.exchange.v1beta1.ExpiryFuturesMarketInfo} */ (
    jspb.Message.getWrapperField(this, injective_exchange_v1beta1_exchange_pb.ExpiryFuturesMarketInfo, 3));
};


/**
 * @param {?proto.injective.exchange.v1beta1.ExpiryFuturesMarketInfo|undefined} value
 * @return {!proto.injective.exchange.v1beta1.EventExpiryFuturesMarketUpdate} returns this
*/
proto.injective.exchange.v1beta1.EventExpiryFuturesMarketUpdate.prototype.setExpiryFuturesMarketInfo = function(value) {
  return jspb.Message.setWrapperField(this, 3, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.injective.exchange.v1beta1.EventExpiryFuturesMarketUpdate} returns this
 */
proto.injective.exchange.v1beta1.EventExpiryFuturesMarketUpdate.prototype.clearExpiryFuturesMarketInfo = function() {
  return this.setExpiryFuturesMarketInfo(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.injective.exchange.v1beta1.EventExpiryFuturesMarketUpdate.prototype.hasExpiryFuturesMarketInfo = function() {
  return jspb.Message.getField(this, 3) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate.prototype.toObject = function(opt_includeInstance) {
  return proto.injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate.toObject = function(includeInstance, msg) {
  var f, obj = {
    marketId: jspb.Message.getFieldWithDefault(msg, 1, ""),
    funding: (f = msg.getFunding()) && injective_exchange_v1beta1_exchange_pb.PerpetualMarketFunding.toObject(includeInstance, f),
    isHourlyFunding: jspb.Message.getBooleanFieldWithDefault(msg, 3, false),
    fundingRate: jspb.Message.getFieldWithDefault(msg, 4, ""),
    markPrice: jspb.Message.getFieldWithDefault(msg, 5, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate}
 */
proto.injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate;
  return proto.injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate}
 */
proto.injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setMarketId(value);
      break;
    case 2:
      var value = new injective_exchange_v1beta1_exchange_pb.PerpetualMarketFunding;
      reader.readMessage(value,injective_exchange_v1beta1_exchange_pb.PerpetualMarketFunding.deserializeBinaryFromReader);
      msg.setFunding(value);
      break;
    case 3:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setIsHourlyFunding(value);
      break;
    case 4:
      var value = /** @type {string} */ (reader.readString());
      msg.setFundingRate(value);
      break;
    case 5:
      var value = /** @type {string} */ (reader.readString());
      msg.setMarkPrice(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getMarketId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getFunding();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      injective_exchange_v1beta1_exchange_pb.PerpetualMarketFunding.serializeBinaryToWriter
    );
  }
  f = message.getIsHourlyFunding();
  if (f) {
    writer.writeBool(
      3,
      f
    );
  }
  f = message.getFundingRate();
  if (f.length > 0) {
    writer.writeString(
      4,
      f
    );
  }
  f = message.getMarkPrice();
  if (f.length > 0) {
    writer.writeString(
      5,
      f
    );
  }
};


/**
 * optional string market_id = 1;
 * @return {string}
 */
proto.injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate.prototype.getMarketId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate} returns this
 */
proto.injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate.prototype.setMarketId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional PerpetualMarketFunding funding = 2;
 * @return {?proto.injective.exchange.v1beta1.PerpetualMarketFunding}
 */
proto.injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate.prototype.getFunding = function() {
  return /** @type{?proto.injective.exchange.v1beta1.PerpetualMarketFunding} */ (
    jspb.Message.getWrapperField(this, injective_exchange_v1beta1_exchange_pb.PerpetualMarketFunding, 2));
};


/**
 * @param {?proto.injective.exchange.v1beta1.PerpetualMarketFunding|undefined} value
 * @return {!proto.injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate} returns this
*/
proto.injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate.prototype.setFunding = function(value) {
  return jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate} returns this
 */
proto.injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate.prototype.clearFunding = function() {
  return this.setFunding(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate.prototype.hasFunding = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional bool is_hourly_funding = 3;
 * @return {boolean}
 */
proto.injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate.prototype.getIsHourlyFunding = function() {
  return /** @type {boolean} */ (jspb.Message.getBooleanFieldWithDefault(this, 3, false));
};


/**
 * @param {boolean} value
 * @return {!proto.injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate} returns this
 */
proto.injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate.prototype.setIsHourlyFunding = function(value) {
  return jspb.Message.setProto3BooleanField(this, 3, value);
};


/**
 * optional string funding_rate = 4;
 * @return {string}
 */
proto.injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate.prototype.getFundingRate = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * @param {string} value
 * @return {!proto.injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate} returns this
 */
proto.injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate.prototype.setFundingRate = function(value) {
  return jspb.Message.setProto3StringField(this, 4, value);
};


/**
 * optional string mark_price = 5;
 * @return {string}
 */
proto.injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate.prototype.getMarkPrice = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 5, ""));
};


/**
 * @param {string} value
 * @return {!proto.injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate} returns this
 */
proto.injective.exchange.v1beta1.EventPerpetualMarketFundingUpdate.prototype.setMarkPrice = function(value) {
  return jspb.Message.setProto3StringField(this, 5, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.injective.exchange.v1beta1.EventSubaccountDeposit.prototype.toObject = function(opt_includeInstance) {
  return proto.injective.exchange.v1beta1.EventSubaccountDeposit.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.injective.exchange.v1beta1.EventSubaccountDeposit} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.injective.exchange.v1beta1.EventSubaccountDeposit.toObject = function(includeInstance, msg) {
  var f, obj = {
    srcAddress: jspb.Message.getFieldWithDefault(msg, 1, ""),
    subaccountId: msg.getSubaccountId_asB64(),
    amount: (f = msg.getAmount()) && cosmos_base_v1beta1_coin_pb.Coin.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.injective.exchange.v1beta1.EventSubaccountDeposit}
 */
proto.injective.exchange.v1beta1.EventSubaccountDeposit.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.injective.exchange.v1beta1.EventSubaccountDeposit;
  return proto.injective.exchange.v1beta1.EventSubaccountDeposit.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.injective.exchange.v1beta1.EventSubaccountDeposit} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.injective.exchange.v1beta1.EventSubaccountDeposit}
 */
proto.injective.exchange.v1beta1.EventSubaccountDeposit.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setSrcAddress(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSubaccountId(value);
      break;
    case 3:
      var value = new cosmos_base_v1beta1_coin_pb.Coin;
      reader.readMessage(value,cosmos_base_v1beta1_coin_pb.Coin.deserializeBinaryFromReader);
      msg.setAmount(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.injective.exchange.v1beta1.EventSubaccountDeposit.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.injective.exchange.v1beta1.EventSubaccountDeposit.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.injective.exchange.v1beta1.EventSubaccountDeposit} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.injective.exchange.v1beta1.EventSubaccountDeposit.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getSrcAddress();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getSubaccountId_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = message.getAmount();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      cosmos_base_v1beta1_coin_pb.Coin.serializeBinaryToWriter
    );
  }
};


/**
 * optional string src_address = 1;
 * @return {string}
 */
proto.injective.exchange.v1beta1.EventSubaccountDeposit.prototype.getSrcAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.injective.exchange.v1beta1.EventSubaccountDeposit} returns this
 */
proto.injective.exchange.v1beta1.EventSubaccountDeposit.prototype.setSrcAddress = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional bytes subaccount_id = 2;
 * @return {!(string|Uint8Array)}
 */
proto.injective.exchange.v1beta1.EventSubaccountDeposit.prototype.getSubaccountId = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes subaccount_id = 2;
 * This is a type-conversion wrapper around `getSubaccountId()`
 * @return {string}
 */
proto.injective.exchange.v1beta1.EventSubaccountDeposit.prototype.getSubaccountId_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSubaccountId()));
};


/**
 * optional bytes subaccount_id = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSubaccountId()`
 * @return {!Uint8Array}
 */
proto.injective.exchange.v1beta1.EventSubaccountDeposit.prototype.getSubaccountId_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSubaccountId()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.injective.exchange.v1beta1.EventSubaccountDeposit} returns this
 */
proto.injective.exchange.v1beta1.EventSubaccountDeposit.prototype.setSubaccountId = function(value) {
  return jspb.Message.setProto3BytesField(this, 2, value);
};


/**
 * optional cosmos.base.v1beta1.Coin amount = 3;
 * @return {?proto.cosmos.base.v1beta1.Coin}
 */
proto.injective.exchange.v1beta1.EventSubaccountDeposit.prototype.getAmount = function() {
  return /** @type{?proto.cosmos.base.v1beta1.Coin} */ (
    jspb.Message.getWrapperField(this, cosmos_base_v1beta1_coin_pb.Coin, 3));
};


/**
 * @param {?proto.cosmos.base.v1beta1.Coin|undefined} value
 * @return {!proto.injective.exchange.v1beta1.EventSubaccountDeposit} returns this
*/
proto.injective.exchange.v1beta1.EventSubaccountDeposit.prototype.setAmount = function(value) {
  return jspb.Message.setWrapperField(this, 3, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.injective.exchange.v1beta1.EventSubaccountDeposit} returns this
 */
proto.injective.exchange.v1beta1.EventSubaccountDeposit.prototype.clearAmount = function() {
  return this.setAmount(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.injective.exchange.v1beta1.EventSubaccountDeposit.prototype.hasAmount = function() {
  return jspb.Message.getField(this, 3) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.injective.exchange.v1beta1.EventSubaccountWithdraw.prototype.toObject = function(opt_includeInstance) {
  return proto.injective.exchange.v1beta1.EventSubaccountWithdraw.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.injective.exchange.v1beta1.EventSubaccountWithdraw} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.injective.exchange.v1beta1.EventSubaccountWithdraw.toObject = function(includeInstance, msg) {
  var f, obj = {
    subaccountId: msg.getSubaccountId_asB64(),
    dstAddress: jspb.Message.getFieldWithDefault(msg, 2, ""),
    amount: (f = msg.getAmount()) && cosmos_base_v1beta1_coin_pb.Coin.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.injective.exchange.v1beta1.EventSubaccountWithdraw}
 */
proto.injective.exchange.v1beta1.EventSubaccountWithdraw.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.injective.exchange.v1beta1.EventSubaccountWithdraw;
  return proto.injective.exchange.v1beta1.EventSubaccountWithdraw.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.injective.exchange.v1beta1.EventSubaccountWithdraw} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.injective.exchange.v1beta1.EventSubaccountWithdraw}
 */
proto.injective.exchange.v1beta1.EventSubaccountWithdraw.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSubaccountId(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setDstAddress(value);
      break;
    case 3:
      var value = new cosmos_base_v1beta1_coin_pb.Coin;
      reader.readMessage(value,cosmos_base_v1beta1_coin_pb.Coin.deserializeBinaryFromReader);
      msg.setAmount(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.injective.exchange.v1beta1.EventSubaccountWithdraw.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.injective.exchange.v1beta1.EventSubaccountWithdraw.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.injective.exchange.v1beta1.EventSubaccountWithdraw} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.injective.exchange.v1beta1.EventSubaccountWithdraw.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getSubaccountId_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getDstAddress();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getAmount();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      cosmos_base_v1beta1_coin_pb.Coin.serializeBinaryToWriter
    );
  }
};


/**
 * optional bytes subaccount_id = 1;
 * @return {!(string|Uint8Array)}
 */
proto.injective.exchange.v1beta1.EventSubaccountWithdraw.prototype.getSubaccountId = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes subaccount_id = 1;
 * This is a type-conversion wrapper around `getSubaccountId()`
 * @return {string}
 */
proto.injective.exchange.v1beta1.EventSubaccountWithdraw.prototype.getSubaccountId_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSubaccountId()));
};


/**
 * optional bytes subaccount_id = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSubaccountId()`
 * @return {!Uint8Array}
 */
proto.injective.exchange.v1beta1.EventSubaccountWithdraw.prototype.getSubaccountId_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSubaccountId()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.injective.exchange.v1beta1.EventSubaccountWithdraw} returns this
 */
proto.injective.exchange.v1beta1.EventSubaccountWithdraw.prototype.setSubaccountId = function(value) {
  return jspb.Message.setProto3BytesField(this, 1, value);
};


/**
 * optional string dst_address = 2;
 * @return {string}
 */
proto.injective.exchange.v1beta1.EventSubaccountWithdraw.prototype.getDstAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.injective.exchange.v1beta1.EventSubaccountWithdraw} returns this
 */
proto.injective.exchange.v1beta1.EventSubaccountWithdraw.prototype.setDstAddress = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * optional cosmos.base.v1beta1.Coin amount = 3;
 * @return {?proto.cosmos.base.v1beta1.Coin}
 */
proto.injective.exchange.v1beta1.EventSubaccountWithdraw.prototype.getAmount = function() {
  return /** @type{?proto.cosmos.base.v1beta1.Coin} */ (
    jspb.Message.getWrapperField(this, cosmos_base_v1beta1_coin_pb.Coin, 3));
};


/**
 * @param {?proto.cosmos.base.v1beta1.Coin|undefined} value
 * @return {!proto.injective.exchange.v1beta1.EventSubaccountWithdraw} returns this
*/
proto.injective.exchange.v1beta1.EventSubaccountWithdraw.prototype.setAmount = function(value) {
  return jspb.Message.setWrapperField(this, 3, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.injective.exchange.v1beta1.EventSubaccountWithdraw} returns this
 */
proto.injective.exchange.v1beta1.EventSubaccountWithdraw.prototype.clearAmount = function() {
  return this.setAmount(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.injective.exchange.v1beta1.EventSubaccountWithdraw.prototype.hasAmount = function() {
  return jspb.Message.getField(this, 3) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.injective.exchange.v1beta1.EventSubaccountBalanceTransfer.prototype.toObject = function(opt_includeInstance) {
  return proto.injective.exchange.v1beta1.EventSubaccountBalanceTransfer.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.injective.exchange.v1beta1.EventSubaccountBalanceTransfer} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.injective.exchange.v1beta1.EventSubaccountBalanceTransfer.toObject = function(includeInstance, msg) {
  var f, obj = {
    srcSubaccountId: jspb.Message.getFieldWithDefault(msg, 1, ""),
    dstSubaccountId: jspb.Message.getFieldWithDefault(msg, 2, ""),
    amount: (f = msg.getAmount()) && cosmos_base_v1beta1_coin_pb.Coin.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.injective.exchange.v1beta1.EventSubaccountBalanceTransfer}
 */
proto.injective.exchange.v1beta1.EventSubaccountBalanceTransfer.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.injective.exchange.v1beta1.EventSubaccountBalanceTransfer;
  return proto.injective.exchange.v1beta1.EventSubaccountBalanceTransfer.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.injective.exchange.v1beta1.EventSubaccountBalanceTransfer} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.injective.exchange.v1beta1.EventSubaccountBalanceTransfer}
 */
proto.injective.exchange.v1beta1.EventSubaccountBalanceTransfer.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setSrcSubaccountId(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setDstSubaccountId(value);
      break;
    case 3:
      var value = new cosmos_base_v1beta1_coin_pb.Coin;
      reader.readMessage(value,cosmos_base_v1beta1_coin_pb.Coin.deserializeBinaryFromReader);
      msg.setAmount(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.injective.exchange.v1beta1.EventSubaccountBalanceTransfer.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.injective.exchange.v1beta1.EventSubaccountBalanceTransfer.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.injective.exchange.v1beta1.EventSubaccountBalanceTransfer} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.injective.exchange.v1beta1.EventSubaccountBalanceTransfer.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getSrcSubaccountId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getDstSubaccountId();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getAmount();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      cosmos_base_v1beta1_coin_pb.Coin.serializeBinaryToWriter
    );
  }
};


/**
 * optional string src_subaccount_id = 1;
 * @return {string}
 */
proto.injective.exchange.v1beta1.EventSubaccountBalanceTransfer.prototype.getSrcSubaccountId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.injective.exchange.v1beta1.EventSubaccountBalanceTransfer} returns this
 */
proto.injective.exchange.v1beta1.EventSubaccountBalanceTransfer.prototype.setSrcSubaccountId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional string dst_subaccount_id = 2;
 * @return {string}
 */
proto.injective.exchange.v1beta1.EventSubaccountBalanceTransfer.prototype.getDstSubaccountId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.injective.exchange.v1beta1.EventSubaccountBalanceTransfer} returns this
 */
proto.injective.exchange.v1beta1.EventSubaccountBalanceTransfer.prototype.setDstSubaccountId = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};


/**
 * optional cosmos.base.v1beta1.Coin amount = 3;
 * @return {?proto.cosmos.base.v1beta1.Coin}
 */
proto.injective.exchange.v1beta1.EventSubaccountBalanceTransfer.prototype.getAmount = function() {
  return /** @type{?proto.cosmos.base.v1beta1.Coin} */ (
    jspb.Message.getWrapperField(this, cosmos_base_v1beta1_coin_pb.Coin, 3));
};


/**
 * @param {?proto.cosmos.base.v1beta1.Coin|undefined} value
 * @return {!proto.injective.exchange.v1beta1.EventSubaccountBalanceTransfer} returns this
*/
proto.injective.exchange.v1beta1.EventSubaccountBalanceTransfer.prototype.setAmount = function(value) {
  return jspb.Message.setWrapperField(this, 3, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.injective.exchange.v1beta1.EventSubaccountBalanceTransfer} returns this
 */
proto.injective.exchange.v1beta1.EventSubaccountBalanceTransfer.prototype.clearAmount = function() {
  return this.setAmount(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.injective.exchange.v1beta1.EventSubaccountBalanceTransfer.prototype.hasAmount = function() {
  return jspb.Message.getField(this, 3) != null;
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.injective.exchange.v1beta1.EventBatchDepositUpdate.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.injective.exchange.v1beta1.EventBatchDepositUpdate.prototype.toObject = function(opt_includeInstance) {
  return proto.injective.exchange.v1beta1.EventBatchDepositUpdate.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.injective.exchange.v1beta1.EventBatchDepositUpdate} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.injective.exchange.v1beta1.EventBatchDepositUpdate.toObject = function(includeInstance, msg) {
  var f, obj = {
    depositUpdatesList: jspb.Message.toObjectList(msg.getDepositUpdatesList(),
    injective_exchange_v1beta1_exchange_pb.DepositUpdate.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.injective.exchange.v1beta1.EventBatchDepositUpdate}
 */
proto.injective.exchange.v1beta1.EventBatchDepositUpdate.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.injective.exchange.v1beta1.EventBatchDepositUpdate;
  return proto.injective.exchange.v1beta1.EventBatchDepositUpdate.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.injective.exchange.v1beta1.EventBatchDepositUpdate} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.injective.exchange.v1beta1.EventBatchDepositUpdate}
 */
proto.injective.exchange.v1beta1.EventBatchDepositUpdate.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new injective_exchange_v1beta1_exchange_pb.DepositUpdate;
      reader.readMessage(value,injective_exchange_v1beta1_exchange_pb.DepositUpdate.deserializeBinaryFromReader);
      msg.addDepositUpdates(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.injective.exchange.v1beta1.EventBatchDepositUpdate.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.injective.exchange.v1beta1.EventBatchDepositUpdate.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.injective.exchange.v1beta1.EventBatchDepositUpdate} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.injective.exchange.v1beta1.EventBatchDepositUpdate.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getDepositUpdatesList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      injective_exchange_v1beta1_exchange_pb.DepositUpdate.serializeBinaryToWriter
    );
  }
};


/**
 * repeated DepositUpdate deposit_updates = 1;
 * @return {!Array<!proto.injective.exchange.v1beta1.DepositUpdate>}
 */
proto.injective.exchange.v1beta1.EventBatchDepositUpdate.prototype.getDepositUpdatesList = function() {
  return /** @type{!Array<!proto.injective.exchange.v1beta1.DepositUpdate>} */ (
    jspb.Message.getRepeatedWrapperField(this, injective_exchange_v1beta1_exchange_pb.DepositUpdate, 1));
};


/**
 * @param {!Array<!proto.injective.exchange.v1beta1.DepositUpdate>} value
 * @return {!proto.injective.exchange.v1beta1.EventBatchDepositUpdate} returns this
*/
proto.injective.exchange.v1beta1.EventBatchDepositUpdate.prototype.setDepositUpdatesList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.injective.exchange.v1beta1.DepositUpdate=} opt_value
 * @param {number=} opt_index
 * @return {!proto.injective.exchange.v1beta1.DepositUpdate}
 */
proto.injective.exchange.v1beta1.EventBatchDepositUpdate.prototype.addDepositUpdates = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.injective.exchange.v1beta1.DepositUpdate, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.injective.exchange.v1beta1.EventBatchDepositUpdate} returns this
 */
proto.injective.exchange.v1beta1.EventBatchDepositUpdate.prototype.clearDepositUpdatesList = function() {
  return this.setDepositUpdatesList([]);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.injective.exchange.v1beta1.DerivativeMarketOrderCancel.prototype.toObject = function(opt_includeInstance) {
  return proto.injective.exchange.v1beta1.DerivativeMarketOrderCancel.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.injective.exchange.v1beta1.DerivativeMarketOrderCancel} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.injective.exchange.v1beta1.DerivativeMarketOrderCancel.toObject = function(includeInstance, msg) {
  var f, obj = {
    marketOrder: (f = msg.getMarketOrder()) && injective_exchange_v1beta1_exchange_pb.DerivativeMarketOrder.toObject(includeInstance, f),
    cancelQuantity: jspb.Message.getFieldWithDefault(msg, 2, "")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.injective.exchange.v1beta1.DerivativeMarketOrderCancel}
 */
proto.injective.exchange.v1beta1.DerivativeMarketOrderCancel.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.injective.exchange.v1beta1.DerivativeMarketOrderCancel;
  return proto.injective.exchange.v1beta1.DerivativeMarketOrderCancel.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.injective.exchange.v1beta1.DerivativeMarketOrderCancel} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.injective.exchange.v1beta1.DerivativeMarketOrderCancel}
 */
proto.injective.exchange.v1beta1.DerivativeMarketOrderCancel.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new injective_exchange_v1beta1_exchange_pb.DerivativeMarketOrder;
      reader.readMessage(value,injective_exchange_v1beta1_exchange_pb.DerivativeMarketOrder.deserializeBinaryFromReader);
      msg.setMarketOrder(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setCancelQuantity(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.injective.exchange.v1beta1.DerivativeMarketOrderCancel.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.injective.exchange.v1beta1.DerivativeMarketOrderCancel.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.injective.exchange.v1beta1.DerivativeMarketOrderCancel} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.injective.exchange.v1beta1.DerivativeMarketOrderCancel.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getMarketOrder();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      injective_exchange_v1beta1_exchange_pb.DerivativeMarketOrder.serializeBinaryToWriter
    );
  }
  f = message.getCancelQuantity();
  if (f.length > 0) {
    writer.writeString(
      2,
      f
    );
  }
};


/**
 * optional DerivativeMarketOrder market_order = 1;
 * @return {?proto.injective.exchange.v1beta1.DerivativeMarketOrder}
 */
proto.injective.exchange.v1beta1.DerivativeMarketOrderCancel.prototype.getMarketOrder = function() {
  return /** @type{?proto.injective.exchange.v1beta1.DerivativeMarketOrder} */ (
    jspb.Message.getWrapperField(this, injective_exchange_v1beta1_exchange_pb.DerivativeMarketOrder, 1));
};


/**
 * @param {?proto.injective.exchange.v1beta1.DerivativeMarketOrder|undefined} value
 * @return {!proto.injective.exchange.v1beta1.DerivativeMarketOrderCancel} returns this
*/
proto.injective.exchange.v1beta1.DerivativeMarketOrderCancel.prototype.setMarketOrder = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.injective.exchange.v1beta1.DerivativeMarketOrderCancel} returns this
 */
proto.injective.exchange.v1beta1.DerivativeMarketOrderCancel.prototype.clearMarketOrder = function() {
  return this.setMarketOrder(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.injective.exchange.v1beta1.DerivativeMarketOrderCancel.prototype.hasMarketOrder = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional string cancel_quantity = 2;
 * @return {string}
 */
proto.injective.exchange.v1beta1.DerivativeMarketOrderCancel.prototype.getCancelQuantity = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * @param {string} value
 * @return {!proto.injective.exchange.v1beta1.DerivativeMarketOrderCancel} returns this
 */
proto.injective.exchange.v1beta1.DerivativeMarketOrderCancel.prototype.setCancelQuantity = function(value) {
  return jspb.Message.setProto3StringField(this, 2, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.injective.exchange.v1beta1.EventCancelDerivativeOrder.prototype.toObject = function(opt_includeInstance) {
  return proto.injective.exchange.v1beta1.EventCancelDerivativeOrder.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.injective.exchange.v1beta1.EventCancelDerivativeOrder} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.injective.exchange.v1beta1.EventCancelDerivativeOrder.toObject = function(includeInstance, msg) {
  var f, obj = {
    marketId: jspb.Message.getFieldWithDefault(msg, 1, ""),
    islimitcancel: jspb.Message.getBooleanFieldWithDefault(msg, 2, false),
    limitOrder: (f = msg.getLimitOrder()) && injective_exchange_v1beta1_exchange_pb.DerivativeLimitOrder.toObject(includeInstance, f),
    marketOrderCancel: (f = msg.getMarketOrderCancel()) && proto.injective.exchange.v1beta1.DerivativeMarketOrderCancel.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.injective.exchange.v1beta1.EventCancelDerivativeOrder}
 */
proto.injective.exchange.v1beta1.EventCancelDerivativeOrder.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.injective.exchange.v1beta1.EventCancelDerivativeOrder;
  return proto.injective.exchange.v1beta1.EventCancelDerivativeOrder.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.injective.exchange.v1beta1.EventCancelDerivativeOrder} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.injective.exchange.v1beta1.EventCancelDerivativeOrder}
 */
proto.injective.exchange.v1beta1.EventCancelDerivativeOrder.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setMarketId(value);
      break;
    case 2:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setIslimitcancel(value);
      break;
    case 3:
      var value = new injective_exchange_v1beta1_exchange_pb.DerivativeLimitOrder;
      reader.readMessage(value,injective_exchange_v1beta1_exchange_pb.DerivativeLimitOrder.deserializeBinaryFromReader);
      msg.setLimitOrder(value);
      break;
    case 4:
      var value = new proto.injective.exchange.v1beta1.DerivativeMarketOrderCancel;
      reader.readMessage(value,proto.injective.exchange.v1beta1.DerivativeMarketOrderCancel.deserializeBinaryFromReader);
      msg.setMarketOrderCancel(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.injective.exchange.v1beta1.EventCancelDerivativeOrder.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.injective.exchange.v1beta1.EventCancelDerivativeOrder.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.injective.exchange.v1beta1.EventCancelDerivativeOrder} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.injective.exchange.v1beta1.EventCancelDerivativeOrder.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getMarketId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getIslimitcancel();
  if (f) {
    writer.writeBool(
      2,
      f
    );
  }
  f = message.getLimitOrder();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      injective_exchange_v1beta1_exchange_pb.DerivativeLimitOrder.serializeBinaryToWriter
    );
  }
  f = message.getMarketOrderCancel();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      proto.injective.exchange.v1beta1.DerivativeMarketOrderCancel.serializeBinaryToWriter
    );
  }
};


/**
 * optional string market_id = 1;
 * @return {string}
 */
proto.injective.exchange.v1beta1.EventCancelDerivativeOrder.prototype.getMarketId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.injective.exchange.v1beta1.EventCancelDerivativeOrder} returns this
 */
proto.injective.exchange.v1beta1.EventCancelDerivativeOrder.prototype.setMarketId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional bool isLimitCancel = 2;
 * @return {boolean}
 */
proto.injective.exchange.v1beta1.EventCancelDerivativeOrder.prototype.getIslimitcancel = function() {
  return /** @type {boolean} */ (jspb.Message.getBooleanFieldWithDefault(this, 2, false));
};


/**
 * @param {boolean} value
 * @return {!proto.injective.exchange.v1beta1.EventCancelDerivativeOrder} returns this
 */
proto.injective.exchange.v1beta1.EventCancelDerivativeOrder.prototype.setIslimitcancel = function(value) {
  return jspb.Message.setProto3BooleanField(this, 2, value);
};


/**
 * optional DerivativeLimitOrder limit_order = 3;
 * @return {?proto.injective.exchange.v1beta1.DerivativeLimitOrder}
 */
proto.injective.exchange.v1beta1.EventCancelDerivativeOrder.prototype.getLimitOrder = function() {
  return /** @type{?proto.injective.exchange.v1beta1.DerivativeLimitOrder} */ (
    jspb.Message.getWrapperField(this, injective_exchange_v1beta1_exchange_pb.DerivativeLimitOrder, 3));
};


/**
 * @param {?proto.injective.exchange.v1beta1.DerivativeLimitOrder|undefined} value
 * @return {!proto.injective.exchange.v1beta1.EventCancelDerivativeOrder} returns this
*/
proto.injective.exchange.v1beta1.EventCancelDerivativeOrder.prototype.setLimitOrder = function(value) {
  return jspb.Message.setWrapperField(this, 3, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.injective.exchange.v1beta1.EventCancelDerivativeOrder} returns this
 */
proto.injective.exchange.v1beta1.EventCancelDerivativeOrder.prototype.clearLimitOrder = function() {
  return this.setLimitOrder(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.injective.exchange.v1beta1.EventCancelDerivativeOrder.prototype.hasLimitOrder = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional DerivativeMarketOrderCancel market_order_cancel = 4;
 * @return {?proto.injective.exchange.v1beta1.DerivativeMarketOrderCancel}
 */
proto.injective.exchange.v1beta1.EventCancelDerivativeOrder.prototype.getMarketOrderCancel = function() {
  return /** @type{?proto.injective.exchange.v1beta1.DerivativeMarketOrderCancel} */ (
    jspb.Message.getWrapperField(this, proto.injective.exchange.v1beta1.DerivativeMarketOrderCancel, 4));
};


/**
 * @param {?proto.injective.exchange.v1beta1.DerivativeMarketOrderCancel|undefined} value
 * @return {!proto.injective.exchange.v1beta1.EventCancelDerivativeOrder} returns this
*/
proto.injective.exchange.v1beta1.EventCancelDerivativeOrder.prototype.setMarketOrderCancel = function(value) {
  return jspb.Message.setWrapperField(this, 4, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.injective.exchange.v1beta1.EventCancelDerivativeOrder} returns this
 */
proto.injective.exchange.v1beta1.EventCancelDerivativeOrder.prototype.clearMarketOrderCancel = function() {
  return this.setMarketOrderCancel(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.injective.exchange.v1beta1.EventCancelDerivativeOrder.prototype.hasMarketOrderCancel = function() {
  return jspb.Message.getField(this, 4) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.injective.exchange.v1beta1.EventFeeDiscountSchedule.prototype.toObject = function(opt_includeInstance) {
  return proto.injective.exchange.v1beta1.EventFeeDiscountSchedule.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.injective.exchange.v1beta1.EventFeeDiscountSchedule} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.injective.exchange.v1beta1.EventFeeDiscountSchedule.toObject = function(includeInstance, msg) {
  var f, obj = {
    schedule: (f = msg.getSchedule()) && injective_exchange_v1beta1_exchange_pb.FeeDiscountSchedule.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.injective.exchange.v1beta1.EventFeeDiscountSchedule}
 */
proto.injective.exchange.v1beta1.EventFeeDiscountSchedule.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.injective.exchange.v1beta1.EventFeeDiscountSchedule;
  return proto.injective.exchange.v1beta1.EventFeeDiscountSchedule.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.injective.exchange.v1beta1.EventFeeDiscountSchedule} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.injective.exchange.v1beta1.EventFeeDiscountSchedule}
 */
proto.injective.exchange.v1beta1.EventFeeDiscountSchedule.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new injective_exchange_v1beta1_exchange_pb.FeeDiscountSchedule;
      reader.readMessage(value,injective_exchange_v1beta1_exchange_pb.FeeDiscountSchedule.deserializeBinaryFromReader);
      msg.setSchedule(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.injective.exchange.v1beta1.EventFeeDiscountSchedule.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.injective.exchange.v1beta1.EventFeeDiscountSchedule.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.injective.exchange.v1beta1.EventFeeDiscountSchedule} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.injective.exchange.v1beta1.EventFeeDiscountSchedule.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getSchedule();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      injective_exchange_v1beta1_exchange_pb.FeeDiscountSchedule.serializeBinaryToWriter
    );
  }
};


/**
 * optional FeeDiscountSchedule schedule = 1;
 * @return {?proto.injective.exchange.v1beta1.FeeDiscountSchedule}
 */
proto.injective.exchange.v1beta1.EventFeeDiscountSchedule.prototype.getSchedule = function() {
  return /** @type{?proto.injective.exchange.v1beta1.FeeDiscountSchedule} */ (
    jspb.Message.getWrapperField(this, injective_exchange_v1beta1_exchange_pb.FeeDiscountSchedule, 1));
};


/**
 * @param {?proto.injective.exchange.v1beta1.FeeDiscountSchedule|undefined} value
 * @return {!proto.injective.exchange.v1beta1.EventFeeDiscountSchedule} returns this
*/
proto.injective.exchange.v1beta1.EventFeeDiscountSchedule.prototype.setSchedule = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.injective.exchange.v1beta1.EventFeeDiscountSchedule} returns this
 */
proto.injective.exchange.v1beta1.EventFeeDiscountSchedule.prototype.clearSchedule = function() {
  return this.setSchedule(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.injective.exchange.v1beta1.EventFeeDiscountSchedule.prototype.hasSchedule = function() {
  return jspb.Message.getField(this, 1) != null;
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.injective.exchange.v1beta1.EventTradingRewardCampaignUpdate.repeatedFields_ = [2];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.injective.exchange.v1beta1.EventTradingRewardCampaignUpdate.prototype.toObject = function(opt_includeInstance) {
  return proto.injective.exchange.v1beta1.EventTradingRewardCampaignUpdate.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.injective.exchange.v1beta1.EventTradingRewardCampaignUpdate} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.injective.exchange.v1beta1.EventTradingRewardCampaignUpdate.toObject = function(includeInstance, msg) {
  var f, obj = {
    campaignInfo: (f = msg.getCampaignInfo()) && injective_exchange_v1beta1_exchange_pb.TradingRewardCampaignInfo.toObject(includeInstance, f),
    campaignRewardPoolsList: jspb.Message.toObjectList(msg.getCampaignRewardPoolsList(),
    injective_exchange_v1beta1_exchange_pb.CampaignRewardPool.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.injective.exchange.v1beta1.EventTradingRewardCampaignUpdate}
 */
proto.injective.exchange.v1beta1.EventTradingRewardCampaignUpdate.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.injective.exchange.v1beta1.EventTradingRewardCampaignUpdate;
  return proto.injective.exchange.v1beta1.EventTradingRewardCampaignUpdate.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.injective.exchange.v1beta1.EventTradingRewardCampaignUpdate} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.injective.exchange.v1beta1.EventTradingRewardCampaignUpdate}
 */
proto.injective.exchange.v1beta1.EventTradingRewardCampaignUpdate.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new injective_exchange_v1beta1_exchange_pb.TradingRewardCampaignInfo;
      reader.readMessage(value,injective_exchange_v1beta1_exchange_pb.TradingRewardCampaignInfo.deserializeBinaryFromReader);
      msg.setCampaignInfo(value);
      break;
    case 2:
      var value = new injective_exchange_v1beta1_exchange_pb.CampaignRewardPool;
      reader.readMessage(value,injective_exchange_v1beta1_exchange_pb.CampaignRewardPool.deserializeBinaryFromReader);
      msg.addCampaignRewardPools(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.injective.exchange.v1beta1.EventTradingRewardCampaignUpdate.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.injective.exchange.v1beta1.EventTradingRewardCampaignUpdate.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.injective.exchange.v1beta1.EventTradingRewardCampaignUpdate} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.injective.exchange.v1beta1.EventTradingRewardCampaignUpdate.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getCampaignInfo();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      injective_exchange_v1beta1_exchange_pb.TradingRewardCampaignInfo.serializeBinaryToWriter
    );
  }
  f = message.getCampaignRewardPoolsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      2,
      f,
      injective_exchange_v1beta1_exchange_pb.CampaignRewardPool.serializeBinaryToWriter
    );
  }
};


/**
 * optional TradingRewardCampaignInfo campaign_info = 1;
 * @return {?proto.injective.exchange.v1beta1.TradingRewardCampaignInfo}
 */
proto.injective.exchange.v1beta1.EventTradingRewardCampaignUpdate.prototype.getCampaignInfo = function() {
  return /** @type{?proto.injective.exchange.v1beta1.TradingRewardCampaignInfo} */ (
    jspb.Message.getWrapperField(this, injective_exchange_v1beta1_exchange_pb.TradingRewardCampaignInfo, 1));
};


/**
 * @param {?proto.injective.exchange.v1beta1.TradingRewardCampaignInfo|undefined} value
 * @return {!proto.injective.exchange.v1beta1.EventTradingRewardCampaignUpdate} returns this
*/
proto.injective.exchange.v1beta1.EventTradingRewardCampaignUpdate.prototype.setCampaignInfo = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.injective.exchange.v1beta1.EventTradingRewardCampaignUpdate} returns this
 */
proto.injective.exchange.v1beta1.EventTradingRewardCampaignUpdate.prototype.clearCampaignInfo = function() {
  return this.setCampaignInfo(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.injective.exchange.v1beta1.EventTradingRewardCampaignUpdate.prototype.hasCampaignInfo = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * repeated CampaignRewardPool campaign_reward_pools = 2;
 * @return {!Array<!proto.injective.exchange.v1beta1.CampaignRewardPool>}
 */
proto.injective.exchange.v1beta1.EventTradingRewardCampaignUpdate.prototype.getCampaignRewardPoolsList = function() {
  return /** @type{!Array<!proto.injective.exchange.v1beta1.CampaignRewardPool>} */ (
    jspb.Message.getRepeatedWrapperField(this, injective_exchange_v1beta1_exchange_pb.CampaignRewardPool, 2));
};


/**
 * @param {!Array<!proto.injective.exchange.v1beta1.CampaignRewardPool>} value
 * @return {!proto.injective.exchange.v1beta1.EventTradingRewardCampaignUpdate} returns this
*/
proto.injective.exchange.v1beta1.EventTradingRewardCampaignUpdate.prototype.setCampaignRewardPoolsList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 2, value);
};


/**
 * @param {!proto.injective.exchange.v1beta1.CampaignRewardPool=} opt_value
 * @param {number=} opt_index
 * @return {!proto.injective.exchange.v1beta1.CampaignRewardPool}
 */
proto.injective.exchange.v1beta1.EventTradingRewardCampaignUpdate.prototype.addCampaignRewardPools = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.injective.exchange.v1beta1.CampaignRewardPool, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.injective.exchange.v1beta1.EventTradingRewardCampaignUpdate} returns this
 */
proto.injective.exchange.v1beta1.EventTradingRewardCampaignUpdate.prototype.clearCampaignRewardPoolsList = function() {
  return this.setCampaignRewardPoolsList([]);
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.injective.exchange.v1beta1.EventTradingRewardDistribution.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.injective.exchange.v1beta1.EventTradingRewardDistribution.prototype.toObject = function(opt_includeInstance) {
  return proto.injective.exchange.v1beta1.EventTradingRewardDistribution.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.injective.exchange.v1beta1.EventTradingRewardDistribution} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.injective.exchange.v1beta1.EventTradingRewardDistribution.toObject = function(includeInstance, msg) {
  var f, obj = {
    accountRewardsList: jspb.Message.toObjectList(msg.getAccountRewardsList(),
    injective_exchange_v1beta1_exchange_pb.AccountRewards.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.injective.exchange.v1beta1.EventTradingRewardDistribution}
 */
proto.injective.exchange.v1beta1.EventTradingRewardDistribution.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.injective.exchange.v1beta1.EventTradingRewardDistribution;
  return proto.injective.exchange.v1beta1.EventTradingRewardDistribution.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.injective.exchange.v1beta1.EventTradingRewardDistribution} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.injective.exchange.v1beta1.EventTradingRewardDistribution}
 */
proto.injective.exchange.v1beta1.EventTradingRewardDistribution.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new injective_exchange_v1beta1_exchange_pb.AccountRewards;
      reader.readMessage(value,injective_exchange_v1beta1_exchange_pb.AccountRewards.deserializeBinaryFromReader);
      msg.addAccountRewards(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.injective.exchange.v1beta1.EventTradingRewardDistribution.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.injective.exchange.v1beta1.EventTradingRewardDistribution.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.injective.exchange.v1beta1.EventTradingRewardDistribution} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.injective.exchange.v1beta1.EventTradingRewardDistribution.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAccountRewardsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      injective_exchange_v1beta1_exchange_pb.AccountRewards.serializeBinaryToWriter
    );
  }
};


/**
 * repeated AccountRewards account_rewards = 1;
 * @return {!Array<!proto.injective.exchange.v1beta1.AccountRewards>}
 */
proto.injective.exchange.v1beta1.EventTradingRewardDistribution.prototype.getAccountRewardsList = function() {
  return /** @type{!Array<!proto.injective.exchange.v1beta1.AccountRewards>} */ (
    jspb.Message.getRepeatedWrapperField(this, injective_exchange_v1beta1_exchange_pb.AccountRewards, 1));
};


/**
 * @param {!Array<!proto.injective.exchange.v1beta1.AccountRewards>} value
 * @return {!proto.injective.exchange.v1beta1.EventTradingRewardDistribution} returns this
*/
proto.injective.exchange.v1beta1.EventTradingRewardDistribution.prototype.setAccountRewardsList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.injective.exchange.v1beta1.AccountRewards=} opt_value
 * @param {number=} opt_index
 * @return {!proto.injective.exchange.v1beta1.AccountRewards}
 */
proto.injective.exchange.v1beta1.EventTradingRewardDistribution.prototype.addAccountRewards = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.injective.exchange.v1beta1.AccountRewards, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.injective.exchange.v1beta1.EventTradingRewardDistribution} returns this
 */
proto.injective.exchange.v1beta1.EventTradingRewardDistribution.prototype.clearAccountRewardsList = function() {
  return this.setAccountRewardsList([]);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.injective.exchange.v1beta1.EventNewConditionalDerivativeOrder.prototype.toObject = function(opt_includeInstance) {
  return proto.injective.exchange.v1beta1.EventNewConditionalDerivativeOrder.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.injective.exchange.v1beta1.EventNewConditionalDerivativeOrder} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.injective.exchange.v1beta1.EventNewConditionalDerivativeOrder.toObject = function(includeInstance, msg) {
  var f, obj = {
    marketId: jspb.Message.getFieldWithDefault(msg, 1, ""),
    order: (f = msg.getOrder()) && injective_exchange_v1beta1_exchange_pb.DerivativeOrder.toObject(includeInstance, f),
    hash: msg.getHash_asB64(),
    isMarket: jspb.Message.getBooleanFieldWithDefault(msg, 4, false)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.injective.exchange.v1beta1.EventNewConditionalDerivativeOrder}
 */
proto.injective.exchange.v1beta1.EventNewConditionalDerivativeOrder.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.injective.exchange.v1beta1.EventNewConditionalDerivativeOrder;
  return proto.injective.exchange.v1beta1.EventNewConditionalDerivativeOrder.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.injective.exchange.v1beta1.EventNewConditionalDerivativeOrder} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.injective.exchange.v1beta1.EventNewConditionalDerivativeOrder}
 */
proto.injective.exchange.v1beta1.EventNewConditionalDerivativeOrder.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setMarketId(value);
      break;
    case 2:
      var value = new injective_exchange_v1beta1_exchange_pb.DerivativeOrder;
      reader.readMessage(value,injective_exchange_v1beta1_exchange_pb.DerivativeOrder.deserializeBinaryFromReader);
      msg.setOrder(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setHash(value);
      break;
    case 4:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setIsMarket(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.injective.exchange.v1beta1.EventNewConditionalDerivativeOrder.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.injective.exchange.v1beta1.EventNewConditionalDerivativeOrder.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.injective.exchange.v1beta1.EventNewConditionalDerivativeOrder} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.injective.exchange.v1beta1.EventNewConditionalDerivativeOrder.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getMarketId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getOrder();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      injective_exchange_v1beta1_exchange_pb.DerivativeOrder.serializeBinaryToWriter
    );
  }
  f = message.getHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
  f = message.getIsMarket();
  if (f) {
    writer.writeBool(
      4,
      f
    );
  }
};


/**
 * optional string market_id = 1;
 * @return {string}
 */
proto.injective.exchange.v1beta1.EventNewConditionalDerivativeOrder.prototype.getMarketId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.injective.exchange.v1beta1.EventNewConditionalDerivativeOrder} returns this
 */
proto.injective.exchange.v1beta1.EventNewConditionalDerivativeOrder.prototype.setMarketId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional DerivativeOrder order = 2;
 * @return {?proto.injective.exchange.v1beta1.DerivativeOrder}
 */
proto.injective.exchange.v1beta1.EventNewConditionalDerivativeOrder.prototype.getOrder = function() {
  return /** @type{?proto.injective.exchange.v1beta1.DerivativeOrder} */ (
    jspb.Message.getWrapperField(this, injective_exchange_v1beta1_exchange_pb.DerivativeOrder, 2));
};


/**
 * @param {?proto.injective.exchange.v1beta1.DerivativeOrder|undefined} value
 * @return {!proto.injective.exchange.v1beta1.EventNewConditionalDerivativeOrder} returns this
*/
proto.injective.exchange.v1beta1.EventNewConditionalDerivativeOrder.prototype.setOrder = function(value) {
  return jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.injective.exchange.v1beta1.EventNewConditionalDerivativeOrder} returns this
 */
proto.injective.exchange.v1beta1.EventNewConditionalDerivativeOrder.prototype.clearOrder = function() {
  return this.setOrder(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.injective.exchange.v1beta1.EventNewConditionalDerivativeOrder.prototype.hasOrder = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional bytes hash = 3;
 * @return {!(string|Uint8Array)}
 */
proto.injective.exchange.v1beta1.EventNewConditionalDerivativeOrder.prototype.getHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes hash = 3;
 * This is a type-conversion wrapper around `getHash()`
 * @return {string}
 */
proto.injective.exchange.v1beta1.EventNewConditionalDerivativeOrder.prototype.getHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getHash()));
};


/**
 * optional bytes hash = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getHash()`
 * @return {!Uint8Array}
 */
proto.injective.exchange.v1beta1.EventNewConditionalDerivativeOrder.prototype.getHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getHash()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.injective.exchange.v1beta1.EventNewConditionalDerivativeOrder} returns this
 */
proto.injective.exchange.v1beta1.EventNewConditionalDerivativeOrder.prototype.setHash = function(value) {
  return jspb.Message.setProto3BytesField(this, 3, value);
};


/**
 * optional bool is_market = 4;
 * @return {boolean}
 */
proto.injective.exchange.v1beta1.EventNewConditionalDerivativeOrder.prototype.getIsMarket = function() {
  return /** @type {boolean} */ (jspb.Message.getBooleanFieldWithDefault(this, 4, false));
};


/**
 * @param {boolean} value
 * @return {!proto.injective.exchange.v1beta1.EventNewConditionalDerivativeOrder} returns this
 */
proto.injective.exchange.v1beta1.EventNewConditionalDerivativeOrder.prototype.setIsMarket = function(value) {
  return jspb.Message.setProto3BooleanField(this, 4, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder.prototype.toObject = function(opt_includeInstance) {
  return proto.injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder.toObject = function(includeInstance, msg) {
  var f, obj = {
    marketId: jspb.Message.getFieldWithDefault(msg, 1, ""),
    islimitcancel: jspb.Message.getBooleanFieldWithDefault(msg, 2, false),
    limitOrder: (f = msg.getLimitOrder()) && injective_exchange_v1beta1_exchange_pb.DerivativeLimitOrder.toObject(includeInstance, f),
    marketOrder: (f = msg.getMarketOrder()) && injective_exchange_v1beta1_exchange_pb.DerivativeMarketOrder.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder}
 */
proto.injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder;
  return proto.injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder}
 */
proto.injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setMarketId(value);
      break;
    case 2:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setIslimitcancel(value);
      break;
    case 3:
      var value = new injective_exchange_v1beta1_exchange_pb.DerivativeLimitOrder;
      reader.readMessage(value,injective_exchange_v1beta1_exchange_pb.DerivativeLimitOrder.deserializeBinaryFromReader);
      msg.setLimitOrder(value);
      break;
    case 4:
      var value = new injective_exchange_v1beta1_exchange_pb.DerivativeMarketOrder;
      reader.readMessage(value,injective_exchange_v1beta1_exchange_pb.DerivativeMarketOrder.deserializeBinaryFromReader);
      msg.setMarketOrder(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getMarketId();
  if (f.length > 0) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getIslimitcancel();
  if (f) {
    writer.writeBool(
      2,
      f
    );
  }
  f = message.getLimitOrder();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      injective_exchange_v1beta1_exchange_pb.DerivativeLimitOrder.serializeBinaryToWriter
    );
  }
  f = message.getMarketOrder();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      injective_exchange_v1beta1_exchange_pb.DerivativeMarketOrder.serializeBinaryToWriter
    );
  }
};


/**
 * optional string market_id = 1;
 * @return {string}
 */
proto.injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder.prototype.getMarketId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * @param {string} value
 * @return {!proto.injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder} returns this
 */
proto.injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder.prototype.setMarketId = function(value) {
  return jspb.Message.setProto3StringField(this, 1, value);
};


/**
 * optional bool isLimitCancel = 2;
 * @return {boolean}
 */
proto.injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder.prototype.getIslimitcancel = function() {
  return /** @type {boolean} */ (jspb.Message.getBooleanFieldWithDefault(this, 2, false));
};


/**
 * @param {boolean} value
 * @return {!proto.injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder} returns this
 */
proto.injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder.prototype.setIslimitcancel = function(value) {
  return jspb.Message.setProto3BooleanField(this, 2, value);
};


/**
 * optional DerivativeLimitOrder limit_order = 3;
 * @return {?proto.injective.exchange.v1beta1.DerivativeLimitOrder}
 */
proto.injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder.prototype.getLimitOrder = function() {
  return /** @type{?proto.injective.exchange.v1beta1.DerivativeLimitOrder} */ (
    jspb.Message.getWrapperField(this, injective_exchange_v1beta1_exchange_pb.DerivativeLimitOrder, 3));
};


/**
 * @param {?proto.injective.exchange.v1beta1.DerivativeLimitOrder|undefined} value
 * @return {!proto.injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder} returns this
*/
proto.injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder.prototype.setLimitOrder = function(value) {
  return jspb.Message.setWrapperField(this, 3, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder} returns this
 */
proto.injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder.prototype.clearLimitOrder = function() {
  return this.setLimitOrder(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder.prototype.hasLimitOrder = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional DerivativeMarketOrder market_order = 4;
 * @return {?proto.injective.exchange.v1beta1.DerivativeMarketOrder}
 */
proto.injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder.prototype.getMarketOrder = function() {
  return /** @type{?proto.injective.exchange.v1beta1.DerivativeMarketOrder} */ (
    jspb.Message.getWrapperField(this, injective_exchange_v1beta1_exchange_pb.DerivativeMarketOrder, 4));
};


/**
 * @param {?proto.injective.exchange.v1beta1.DerivativeMarketOrder|undefined} value
 * @return {!proto.injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder} returns this
*/
proto.injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder.prototype.setMarketOrder = function(value) {
  return jspb.Message.setWrapperField(this, 4, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder} returns this
 */
proto.injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder.prototype.clearMarketOrder = function() {
  return this.setMarketOrder(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.injective.exchange.v1beta1.EventCancelConditionalDerivativeOrder.prototype.hasMarketOrder = function() {
  return jspb.Message.getField(this, 4) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger.prototype.toObject = function(opt_includeInstance) {
  return proto.injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger.toObject = function(includeInstance, msg) {
  var f, obj = {
    marketId: msg.getMarketId_asB64(),
    islimittrigger: jspb.Message.getBooleanFieldWithDefault(msg, 2, false),
    triggeredOrderHash: msg.getTriggeredOrderHash_asB64(),
    placedOrderHash: msg.getPlacedOrderHash_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger}
 */
proto.injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger;
  return proto.injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger}
 */
proto.injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setMarketId(value);
      break;
    case 2:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setIslimittrigger(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setTriggeredOrderHash(value);
      break;
    case 4:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPlacedOrderHash(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getMarketId_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getIslimittrigger();
  if (f) {
    writer.writeBool(
      2,
      f
    );
  }
  f = message.getTriggeredOrderHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      3,
      f
    );
  }
  f = message.getPlacedOrderHash_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      4,
      f
    );
  }
};


/**
 * optional bytes market_id = 1;
 * @return {!(string|Uint8Array)}
 */
proto.injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger.prototype.getMarketId = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes market_id = 1;
 * This is a type-conversion wrapper around `getMarketId()`
 * @return {string}
 */
proto.injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger.prototype.getMarketId_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getMarketId()));
};


/**
 * optional bytes market_id = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getMarketId()`
 * @return {!Uint8Array}
 */
proto.injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger.prototype.getMarketId_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getMarketId()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger} returns this
 */
proto.injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger.prototype.setMarketId = function(value) {
  return jspb.Message.setProto3BytesField(this, 1, value);
};


/**
 * optional bool isLimitTrigger = 2;
 * @return {boolean}
 */
proto.injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger.prototype.getIslimittrigger = function() {
  return /** @type {boolean} */ (jspb.Message.getBooleanFieldWithDefault(this, 2, false));
};


/**
 * @param {boolean} value
 * @return {!proto.injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger} returns this
 */
proto.injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger.prototype.setIslimittrigger = function(value) {
  return jspb.Message.setProto3BooleanField(this, 2, value);
};


/**
 * optional bytes triggered_order_hash = 3;
 * @return {!(string|Uint8Array)}
 */
proto.injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger.prototype.getTriggeredOrderHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes triggered_order_hash = 3;
 * This is a type-conversion wrapper around `getTriggeredOrderHash()`
 * @return {string}
 */
proto.injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger.prototype.getTriggeredOrderHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getTriggeredOrderHash()));
};


/**
 * optional bytes triggered_order_hash = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getTriggeredOrderHash()`
 * @return {!Uint8Array}
 */
proto.injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger.prototype.getTriggeredOrderHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getTriggeredOrderHash()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger} returns this
 */
proto.injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger.prototype.setTriggeredOrderHash = function(value) {
  return jspb.Message.setProto3BytesField(this, 3, value);
};


/**
 * optional bytes placed_order_hash = 4;
 * @return {!(string|Uint8Array)}
 */
proto.injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger.prototype.getPlacedOrderHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * optional bytes placed_order_hash = 4;
 * This is a type-conversion wrapper around `getPlacedOrderHash()`
 * @return {string}
 */
proto.injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger.prototype.getPlacedOrderHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPlacedOrderHash()));
};


/**
 * optional bytes placed_order_hash = 4;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPlacedOrderHash()`
 * @return {!Uint8Array}
 */
proto.injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger.prototype.getPlacedOrderHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPlacedOrderHash()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger} returns this
 */
proto.injective.exchange.v1beta1.EventConditionalDerivativeOrderTrigger.prototype.setPlacedOrderHash = function(value) {
  return jspb.Message.setProto3BytesField(this, 4, value);
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.injective.exchange.v1beta1.EventOrderFail.repeatedFields_ = [2,3];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.injective.exchange.v1beta1.EventOrderFail.prototype.toObject = function(opt_includeInstance) {
  return proto.injective.exchange.v1beta1.EventOrderFail.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.injective.exchange.v1beta1.EventOrderFail} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.injective.exchange.v1beta1.EventOrderFail.toObject = function(includeInstance, msg) {
  var f, obj = {
    account: msg.getAccount_asB64(),
    hashesList: msg.getHashesList_asB64(),
    flagsList: (f = jspb.Message.getRepeatedField(msg, 3)) == null ? undefined : f
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.injective.exchange.v1beta1.EventOrderFail}
 */
proto.injective.exchange.v1beta1.EventOrderFail.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.injective.exchange.v1beta1.EventOrderFail;
  return proto.injective.exchange.v1beta1.EventOrderFail.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.injective.exchange.v1beta1.EventOrderFail} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.injective.exchange.v1beta1.EventOrderFail}
 */
proto.injective.exchange.v1beta1.EventOrderFail.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setAccount(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.addHashes(value);
      break;
    case 3:
      var values = /** @type {!Array<number>} */ (reader.isDelimited() ? reader.readPackedUint32() : [reader.readUint32()]);
      for (var i = 0; i < values.length; i++) {
        msg.addFlags(values[i]);
      }
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.injective.exchange.v1beta1.EventOrderFail.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.injective.exchange.v1beta1.EventOrderFail.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.injective.exchange.v1beta1.EventOrderFail} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.injective.exchange.v1beta1.EventOrderFail.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAccount_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getHashesList_asU8();
  if (f.length > 0) {
    writer.writeRepeatedBytes(
      2,
      f
    );
  }
  f = message.getFlagsList();
  if (f.length > 0) {
    writer.writePackedUint32(
      3,
      f
    );
  }
};


/**
 * optional bytes account = 1;
 * @return {!(string|Uint8Array)}
 */
proto.injective.exchange.v1beta1.EventOrderFail.prototype.getAccount = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes account = 1;
 * This is a type-conversion wrapper around `getAccount()`
 * @return {string}
 */
proto.injective.exchange.v1beta1.EventOrderFail.prototype.getAccount_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getAccount()));
};


/**
 * optional bytes account = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getAccount()`
 * @return {!Uint8Array}
 */
proto.injective.exchange.v1beta1.EventOrderFail.prototype.getAccount_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getAccount()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.injective.exchange.v1beta1.EventOrderFail} returns this
 */
proto.injective.exchange.v1beta1.EventOrderFail.prototype.setAccount = function(value) {
  return jspb.Message.setProto3BytesField(this, 1, value);
};


/**
 * repeated bytes hashes = 2;
 * @return {!(Array<!Uint8Array>|Array<string>)}
 */
proto.injective.exchange.v1beta1.EventOrderFail.prototype.getHashesList = function() {
  return /** @type {!(Array<!Uint8Array>|Array<string>)} */ (jspb.Message.getRepeatedField(this, 2));
};


/**
 * repeated bytes hashes = 2;
 * This is a type-conversion wrapper around `getHashesList()`
 * @return {!Array<string>}
 */
proto.injective.exchange.v1beta1.EventOrderFail.prototype.getHashesList_asB64 = function() {
  return /** @type {!Array<string>} */ (jspb.Message.bytesListAsB64(
      this.getHashesList()));
};


/**
 * repeated bytes hashes = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getHashesList()`
 * @return {!Array<!Uint8Array>}
 */
proto.injective.exchange.v1beta1.EventOrderFail.prototype.getHashesList_asU8 = function() {
  return /** @type {!Array<!Uint8Array>} */ (jspb.Message.bytesListAsU8(
      this.getHashesList()));
};


/**
 * @param {!(Array<!Uint8Array>|Array<string>)} value
 * @return {!proto.injective.exchange.v1beta1.EventOrderFail} returns this
 */
proto.injective.exchange.v1beta1.EventOrderFail.prototype.setHashesList = function(value) {
  return jspb.Message.setField(this, 2, value || []);
};


/**
 * @param {!(string|Uint8Array)} value
 * @param {number=} opt_index
 * @return {!proto.injective.exchange.v1beta1.EventOrderFail} returns this
 */
proto.injective.exchange.v1beta1.EventOrderFail.prototype.addHashes = function(value, opt_index) {
  return jspb.Message.addToRepeatedField(this, 2, value, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.injective.exchange.v1beta1.EventOrderFail} returns this
 */
proto.injective.exchange.v1beta1.EventOrderFail.prototype.clearHashesList = function() {
  return this.setHashesList([]);
};


/**
 * repeated uint32 flags = 3;
 * @return {!Array<number>}
 */
proto.injective.exchange.v1beta1.EventOrderFail.prototype.getFlagsList = function() {
  return /** @type {!Array<number>} */ (jspb.Message.getRepeatedField(this, 3));
};


/**
 * @param {!Array<number>} value
 * @return {!proto.injective.exchange.v1beta1.EventOrderFail} returns this
 */
proto.injective.exchange.v1beta1.EventOrderFail.prototype.setFlagsList = function(value) {
  return jspb.Message.setField(this, 3, value || []);
};


/**
 * @param {number} value
 * @param {number=} opt_index
 * @return {!proto.injective.exchange.v1beta1.EventOrderFail} returns this
 */
proto.injective.exchange.v1beta1.EventOrderFail.prototype.addFlags = function(value, opt_index) {
  return jspb.Message.addToRepeatedField(this, 3, value, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.injective.exchange.v1beta1.EventOrderFail} returns this
 */
proto.injective.exchange.v1beta1.EventOrderFail.prototype.clearFlagsList = function() {
  return this.setFlagsList([]);
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.injective.exchange.v1beta1.EventAtomicMarketOrderFeeMultipliersUpdated.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.injective.exchange.v1beta1.EventAtomicMarketOrderFeeMultipliersUpdated.prototype.toObject = function(opt_includeInstance) {
  return proto.injective.exchange.v1beta1.EventAtomicMarketOrderFeeMultipliersUpdated.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.injective.exchange.v1beta1.EventAtomicMarketOrderFeeMultipliersUpdated} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.injective.exchange.v1beta1.EventAtomicMarketOrderFeeMultipliersUpdated.toObject = function(includeInstance, msg) {
  var f, obj = {
    marketFeeMultipliersList: jspb.Message.toObjectList(msg.getMarketFeeMultipliersList(),
    injective_exchange_v1beta1_exchange_pb.MarketFeeMultiplier.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.injective.exchange.v1beta1.EventAtomicMarketOrderFeeMultipliersUpdated}
 */
proto.injective.exchange.v1beta1.EventAtomicMarketOrderFeeMultipliersUpdated.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.injective.exchange.v1beta1.EventAtomicMarketOrderFeeMultipliersUpdated;
  return proto.injective.exchange.v1beta1.EventAtomicMarketOrderFeeMultipliersUpdated.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.injective.exchange.v1beta1.EventAtomicMarketOrderFeeMultipliersUpdated} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.injective.exchange.v1beta1.EventAtomicMarketOrderFeeMultipliersUpdated}
 */
proto.injective.exchange.v1beta1.EventAtomicMarketOrderFeeMultipliersUpdated.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new injective_exchange_v1beta1_exchange_pb.MarketFeeMultiplier;
      reader.readMessage(value,injective_exchange_v1beta1_exchange_pb.MarketFeeMultiplier.deserializeBinaryFromReader);
      msg.addMarketFeeMultipliers(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.injective.exchange.v1beta1.EventAtomicMarketOrderFeeMultipliersUpdated.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.injective.exchange.v1beta1.EventAtomicMarketOrderFeeMultipliersUpdated.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.injective.exchange.v1beta1.EventAtomicMarketOrderFeeMultipliersUpdated} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.injective.exchange.v1beta1.EventAtomicMarketOrderFeeMultipliersUpdated.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getMarketFeeMultipliersList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      injective_exchange_v1beta1_exchange_pb.MarketFeeMultiplier.serializeBinaryToWriter
    );
  }
};


/**
 * repeated MarketFeeMultiplier market_fee_multipliers = 1;
 * @return {!Array<!proto.injective.exchange.v1beta1.MarketFeeMultiplier>}
 */
proto.injective.exchange.v1beta1.EventAtomicMarketOrderFeeMultipliersUpdated.prototype.getMarketFeeMultipliersList = function() {
  return /** @type{!Array<!proto.injective.exchange.v1beta1.MarketFeeMultiplier>} */ (
    jspb.Message.getRepeatedWrapperField(this, injective_exchange_v1beta1_exchange_pb.MarketFeeMultiplier, 1));
};


/**
 * @param {!Array<!proto.injective.exchange.v1beta1.MarketFeeMultiplier>} value
 * @return {!proto.injective.exchange.v1beta1.EventAtomicMarketOrderFeeMultipliersUpdated} returns this
*/
proto.injective.exchange.v1beta1.EventAtomicMarketOrderFeeMultipliersUpdated.prototype.setMarketFeeMultipliersList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.injective.exchange.v1beta1.MarketFeeMultiplier=} opt_value
 * @param {number=} opt_index
 * @return {!proto.injective.exchange.v1beta1.MarketFeeMultiplier}
 */
proto.injective.exchange.v1beta1.EventAtomicMarketOrderFeeMultipliersUpdated.prototype.addMarketFeeMultipliers = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.injective.exchange.v1beta1.MarketFeeMultiplier, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.injective.exchange.v1beta1.EventAtomicMarketOrderFeeMultipliersUpdated} returns this
 */
proto.injective.exchange.v1beta1.EventAtomicMarketOrderFeeMultipliersUpdated.prototype.clearMarketFeeMultipliersList = function() {
  return this.setMarketFeeMultipliersList([]);
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.injective.exchange.v1beta1.EventOrderbookUpdate.repeatedFields_ = [1,2];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.injective.exchange.v1beta1.EventOrderbookUpdate.prototype.toObject = function(opt_includeInstance) {
  return proto.injective.exchange.v1beta1.EventOrderbookUpdate.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.injective.exchange.v1beta1.EventOrderbookUpdate} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.injective.exchange.v1beta1.EventOrderbookUpdate.toObject = function(includeInstance, msg) {
  var f, obj = {
    spotUpdatesList: jspb.Message.toObjectList(msg.getSpotUpdatesList(),
    proto.injective.exchange.v1beta1.OrderbookUpdate.toObject, includeInstance),
    derivativeUpdatesList: jspb.Message.toObjectList(msg.getDerivativeUpdatesList(),
    proto.injective.exchange.v1beta1.OrderbookUpdate.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.injective.exchange.v1beta1.EventOrderbookUpdate}
 */
proto.injective.exchange.v1beta1.EventOrderbookUpdate.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.injective.exchange.v1beta1.EventOrderbookUpdate;
  return proto.injective.exchange.v1beta1.EventOrderbookUpdate.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.injective.exchange.v1beta1.EventOrderbookUpdate} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.injective.exchange.v1beta1.EventOrderbookUpdate}
 */
proto.injective.exchange.v1beta1.EventOrderbookUpdate.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.injective.exchange.v1beta1.OrderbookUpdate;
      reader.readMessage(value,proto.injective.exchange.v1beta1.OrderbookUpdate.deserializeBinaryFromReader);
      msg.addSpotUpdates(value);
      break;
    case 2:
      var value = new proto.injective.exchange.v1beta1.OrderbookUpdate;
      reader.readMessage(value,proto.injective.exchange.v1beta1.OrderbookUpdate.deserializeBinaryFromReader);
      msg.addDerivativeUpdates(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.injective.exchange.v1beta1.EventOrderbookUpdate.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.injective.exchange.v1beta1.EventOrderbookUpdate.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.injective.exchange.v1beta1.EventOrderbookUpdate} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.injective.exchange.v1beta1.EventOrderbookUpdate.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getSpotUpdatesList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.injective.exchange.v1beta1.OrderbookUpdate.serializeBinaryToWriter
    );
  }
  f = message.getDerivativeUpdatesList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      2,
      f,
      proto.injective.exchange.v1beta1.OrderbookUpdate.serializeBinaryToWriter
    );
  }
};


/**
 * repeated OrderbookUpdate spot_updates = 1;
 * @return {!Array<!proto.injective.exchange.v1beta1.OrderbookUpdate>}
 */
proto.injective.exchange.v1beta1.EventOrderbookUpdate.prototype.getSpotUpdatesList = function() {
  return /** @type{!Array<!proto.injective.exchange.v1beta1.OrderbookUpdate>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.injective.exchange.v1beta1.OrderbookUpdate, 1));
};


/**
 * @param {!Array<!proto.injective.exchange.v1beta1.OrderbookUpdate>} value
 * @return {!proto.injective.exchange.v1beta1.EventOrderbookUpdate} returns this
*/
proto.injective.exchange.v1beta1.EventOrderbookUpdate.prototype.setSpotUpdatesList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.injective.exchange.v1beta1.OrderbookUpdate=} opt_value
 * @param {number=} opt_index
 * @return {!proto.injective.exchange.v1beta1.OrderbookUpdate}
 */
proto.injective.exchange.v1beta1.EventOrderbookUpdate.prototype.addSpotUpdates = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.injective.exchange.v1beta1.OrderbookUpdate, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.injective.exchange.v1beta1.EventOrderbookUpdate} returns this
 */
proto.injective.exchange.v1beta1.EventOrderbookUpdate.prototype.clearSpotUpdatesList = function() {
  return this.setSpotUpdatesList([]);
};


/**
 * repeated OrderbookUpdate derivative_updates = 2;
 * @return {!Array<!proto.injective.exchange.v1beta1.OrderbookUpdate>}
 */
proto.injective.exchange.v1beta1.EventOrderbookUpdate.prototype.getDerivativeUpdatesList = function() {
  return /** @type{!Array<!proto.injective.exchange.v1beta1.OrderbookUpdate>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.injective.exchange.v1beta1.OrderbookUpdate, 2));
};


/**
 * @param {!Array<!proto.injective.exchange.v1beta1.OrderbookUpdate>} value
 * @return {!proto.injective.exchange.v1beta1.EventOrderbookUpdate} returns this
*/
proto.injective.exchange.v1beta1.EventOrderbookUpdate.prototype.setDerivativeUpdatesList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 2, value);
};


/**
 * @param {!proto.injective.exchange.v1beta1.OrderbookUpdate=} opt_value
 * @param {number=} opt_index
 * @return {!proto.injective.exchange.v1beta1.OrderbookUpdate}
 */
proto.injective.exchange.v1beta1.EventOrderbookUpdate.prototype.addDerivativeUpdates = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.injective.exchange.v1beta1.OrderbookUpdate, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.injective.exchange.v1beta1.EventOrderbookUpdate} returns this
 */
proto.injective.exchange.v1beta1.EventOrderbookUpdate.prototype.clearDerivativeUpdatesList = function() {
  return this.setDerivativeUpdatesList([]);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.injective.exchange.v1beta1.OrderbookUpdate.prototype.toObject = function(opt_includeInstance) {
  return proto.injective.exchange.v1beta1.OrderbookUpdate.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.injective.exchange.v1beta1.OrderbookUpdate} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.injective.exchange.v1beta1.OrderbookUpdate.toObject = function(includeInstance, msg) {
  var f, obj = {
    seq: jspb.Message.getFieldWithDefault(msg, 1, 0),
    orderbook: (f = msg.getOrderbook()) && proto.injective.exchange.v1beta1.Orderbook.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.injective.exchange.v1beta1.OrderbookUpdate}
 */
proto.injective.exchange.v1beta1.OrderbookUpdate.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.injective.exchange.v1beta1.OrderbookUpdate;
  return proto.injective.exchange.v1beta1.OrderbookUpdate.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.injective.exchange.v1beta1.OrderbookUpdate} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.injective.exchange.v1beta1.OrderbookUpdate}
 */
proto.injective.exchange.v1beta1.OrderbookUpdate.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setSeq(value);
      break;
    case 2:
      var value = new proto.injective.exchange.v1beta1.Orderbook;
      reader.readMessage(value,proto.injective.exchange.v1beta1.Orderbook.deserializeBinaryFromReader);
      msg.setOrderbook(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.injective.exchange.v1beta1.OrderbookUpdate.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.injective.exchange.v1beta1.OrderbookUpdate.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.injective.exchange.v1beta1.OrderbookUpdate} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.injective.exchange.v1beta1.OrderbookUpdate.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getSeq();
  if (f !== 0) {
    writer.writeUint64(
      1,
      f
    );
  }
  f = message.getOrderbook();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.injective.exchange.v1beta1.Orderbook.serializeBinaryToWriter
    );
  }
};


/**
 * optional uint64 seq = 1;
 * @return {number}
 */
proto.injective.exchange.v1beta1.OrderbookUpdate.prototype.getSeq = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.injective.exchange.v1beta1.OrderbookUpdate} returns this
 */
proto.injective.exchange.v1beta1.OrderbookUpdate.prototype.setSeq = function(value) {
  return jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * optional Orderbook orderbook = 2;
 * @return {?proto.injective.exchange.v1beta1.Orderbook}
 */
proto.injective.exchange.v1beta1.OrderbookUpdate.prototype.getOrderbook = function() {
  return /** @type{?proto.injective.exchange.v1beta1.Orderbook} */ (
    jspb.Message.getWrapperField(this, proto.injective.exchange.v1beta1.Orderbook, 2));
};


/**
 * @param {?proto.injective.exchange.v1beta1.Orderbook|undefined} value
 * @return {!proto.injective.exchange.v1beta1.OrderbookUpdate} returns this
*/
proto.injective.exchange.v1beta1.OrderbookUpdate.prototype.setOrderbook = function(value) {
  return jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.injective.exchange.v1beta1.OrderbookUpdate} returns this
 */
proto.injective.exchange.v1beta1.OrderbookUpdate.prototype.clearOrderbook = function() {
  return this.setOrderbook(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.injective.exchange.v1beta1.OrderbookUpdate.prototype.hasOrderbook = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.injective.exchange.v1beta1.Orderbook.repeatedFields_ = [2,3];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.injective.exchange.v1beta1.Orderbook.prototype.toObject = function(opt_includeInstance) {
  return proto.injective.exchange.v1beta1.Orderbook.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.injective.exchange.v1beta1.Orderbook} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.injective.exchange.v1beta1.Orderbook.toObject = function(includeInstance, msg) {
  var f, obj = {
    marketId: msg.getMarketId_asB64(),
    buyLevelsList: jspb.Message.toObjectList(msg.getBuyLevelsList(),
    injective_exchange_v1beta1_exchange_pb.Level.toObject, includeInstance),
    sellLevelsList: jspb.Message.toObjectList(msg.getSellLevelsList(),
    injective_exchange_v1beta1_exchange_pb.Level.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.injective.exchange.v1beta1.Orderbook}
 */
proto.injective.exchange.v1beta1.Orderbook.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.injective.exchange.v1beta1.Orderbook;
  return proto.injective.exchange.v1beta1.Orderbook.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.injective.exchange.v1beta1.Orderbook} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.injective.exchange.v1beta1.Orderbook}
 */
proto.injective.exchange.v1beta1.Orderbook.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setMarketId(value);
      break;
    case 2:
      var value = new injective_exchange_v1beta1_exchange_pb.Level;
      reader.readMessage(value,injective_exchange_v1beta1_exchange_pb.Level.deserializeBinaryFromReader);
      msg.addBuyLevels(value);
      break;
    case 3:
      var value = new injective_exchange_v1beta1_exchange_pb.Level;
      reader.readMessage(value,injective_exchange_v1beta1_exchange_pb.Level.deserializeBinaryFromReader);
      msg.addSellLevels(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.injective.exchange.v1beta1.Orderbook.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.injective.exchange.v1beta1.Orderbook.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.injective.exchange.v1beta1.Orderbook} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.injective.exchange.v1beta1.Orderbook.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getMarketId_asU8();
  if (f.length > 0) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = message.getBuyLevelsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      2,
      f,
      injective_exchange_v1beta1_exchange_pb.Level.serializeBinaryToWriter
    );
  }
  f = message.getSellLevelsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      3,
      f,
      injective_exchange_v1beta1_exchange_pb.Level.serializeBinaryToWriter
    );
  }
};


/**
 * optional bytes market_id = 1;
 * @return {!(string|Uint8Array)}
 */
proto.injective.exchange.v1beta1.Orderbook.prototype.getMarketId = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes market_id = 1;
 * This is a type-conversion wrapper around `getMarketId()`
 * @return {string}
 */
proto.injective.exchange.v1beta1.Orderbook.prototype.getMarketId_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getMarketId()));
};


/**
 * optional bytes market_id = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getMarketId()`
 * @return {!Uint8Array}
 */
proto.injective.exchange.v1beta1.Orderbook.prototype.getMarketId_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getMarketId()));
};


/**
 * @param {!(string|Uint8Array)} value
 * @return {!proto.injective.exchange.v1beta1.Orderbook} returns this
 */
proto.injective.exchange.v1beta1.Orderbook.prototype.setMarketId = function(value) {
  return jspb.Message.setProto3BytesField(this, 1, value);
};


/**
 * repeated Level buy_levels = 2;
 * @return {!Array<!proto.injective.exchange.v1beta1.Level>}
 */
proto.injective.exchange.v1beta1.Orderbook.prototype.getBuyLevelsList = function() {
  return /** @type{!Array<!proto.injective.exchange.v1beta1.Level>} */ (
    jspb.Message.getRepeatedWrapperField(this, injective_exchange_v1beta1_exchange_pb.Level, 2));
};


/**
 * @param {!Array<!proto.injective.exchange.v1beta1.Level>} value
 * @return {!proto.injective.exchange.v1beta1.Orderbook} returns this
*/
proto.injective.exchange.v1beta1.Orderbook.prototype.setBuyLevelsList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 2, value);
};


/**
 * @param {!proto.injective.exchange.v1beta1.Level=} opt_value
 * @param {number=} opt_index
 * @return {!proto.injective.exchange.v1beta1.Level}
 */
proto.injective.exchange.v1beta1.Orderbook.prototype.addBuyLevels = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.injective.exchange.v1beta1.Level, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.injective.exchange.v1beta1.Orderbook} returns this
 */
proto.injective.exchange.v1beta1.Orderbook.prototype.clearBuyLevelsList = function() {
  return this.setBuyLevelsList([]);
};


/**
 * repeated Level sell_levels = 3;
 * @return {!Array<!proto.injective.exchange.v1beta1.Level>}
 */
proto.injective.exchange.v1beta1.Orderbook.prototype.getSellLevelsList = function() {
  return /** @type{!Array<!proto.injective.exchange.v1beta1.Level>} */ (
    jspb.Message.getRepeatedWrapperField(this, injective_exchange_v1beta1_exchange_pb.Level, 3));
};


/**
 * @param {!Array<!proto.injective.exchange.v1beta1.Level>} value
 * @return {!proto.injective.exchange.v1beta1.Orderbook} returns this
*/
proto.injective.exchange.v1beta1.Orderbook.prototype.setSellLevelsList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 3, value);
};


/**
 * @param {!proto.injective.exchange.v1beta1.Level=} opt_value
 * @param {number=} opt_index
 * @return {!proto.injective.exchange.v1beta1.Level}
 */
proto.injective.exchange.v1beta1.Orderbook.prototype.addSellLevels = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 3, opt_value, proto.injective.exchange.v1beta1.Level, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.injective.exchange.v1beta1.Orderbook} returns this
 */
proto.injective.exchange.v1beta1.Orderbook.prototype.clearSellLevelsList = function() {
  return this.setSellLevelsList([]);
};


goog.object.extend(exports, proto.injective.exchange.v1beta1);
