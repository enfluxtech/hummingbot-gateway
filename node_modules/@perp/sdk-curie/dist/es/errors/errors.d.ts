import { AccountBalance, ClearingHouse, Exchange, OrderBook, Quoter, Vault } from "../contracts/type";
import { Contract as EthersContract } from "ethers";
export interface ContractNativeError extends Error {
    code: number;
    message: string;
    data: string;
}
export declare enum ContractErrorCode {
    UNISWAP_BROKER_INSUFFICIENT_LIQUIDITY = "UB_UOA",
    QUOTER_INSUFFICIENT_LIQUIDITY = "Q_UOA",
    NOT_ENOUGH_FREE_COLLATERAL = "CH_NEFCI",
    PRICE_SLIPPAGE_CHECK_FAILS_PSCF = "CH_PSCF",
    PRICE_SLIPPAGE_CHECK_FAILS_TLRS = "CH_TLRS",
    PRICE_SLIPPAGE_CHECK_FAILS_TMRS = "CH_TMRS",
    PRICE_SLIPPAGE_CHECK_FAILS_TLRL = "CH_TLRL",
    PRICE_SLIPPAGE_CHECK_FAILS_TMRL = "CH_TMRL",
    COLLATERAL_DEPOSIT_FAILS_GTDC = "V_GTDC",
    COLLATERAL_DEPOSIT_FAILS_GTSTBC = "V_GTSTBC",
    ALREADY_OVER_PRICE_LIMIT_ONCE = "EX_AOPLO",
    OVER_PRICE_LIMIT_BEFORE_SWAP = "EX_OPLBS",
    OVER_PRICE_LIMIT_AFTER_SWAP = "EX_OPLAS",
    POSITION_SIZE_IS_ZERO = "CH_PSZ",
    NOT_ENOUGH_ACCOUNT_VALUE_BY_IM_RATIO = "CH_NEFCI",
    ORDERS_NUMBER_EXCEEDS = "OB_ONE",
    NOT_ENOUGH_LIQUIDITY = "OB_NEL",
    NON_EXISTENT_OPEN_ORDER = "OB_NEO",
    MARKET_NUMBER_EXCEEDS = "AB_MNE",
    OVER_MAXIMUM_PRICE_SPREAD = "CH_OMPS",
    NOT_ENOUGH_MINIMUM_REQUIRED_MARGIN = "CH_NEMRM",
    LIQUIDITY_MATH_ERROR_LS = "LS",
    LIQUIDITY_MATH_ERROR_LA = "LA"
}
export declare enum ErrorName {
    INIT_SDK_ERROR = "init_sdk_error",
    UNSUPPORTED_CHAIN = "unsupported_chain",
    TYPE_ERROR = "type_error",
    ARGUMENT_ERROR = "argument_error",
    FAILED_PRECONDITION_ERROR = "failed_precondition_error",
    UNAUTHORIZED_ERROR = "unauthorized_error",
    GRAPHQL_QUERY_ERROR = "graphql_query_error",
    RPC_CLOSED_ERROR = "rpc_closed_error",
    RPC_REJECTED_ERROR = "rpc_rejected_error",
    RPC_TIMEOUT_ERROR = "rpc_timeout_error",
    RPC_MAX_RETRY_ERROR = "rpc_max_retry_error",
    RPC_GAS_TOO_LOW_ERROR = "rpc_gas_too_low_error",
    CONTRACT_READ_ERROR = "contract_read_error",
    MULTICALL_READ_ERROR = "multicall_read_error",
    MULTICALL_READ_ENCODE_ERROR = "multicall_read_encode_error",
    MULTICALL_READ_DECODE_ERROR = "multicall_read_decode_error",
    INSUFFICIENT_LIQUIDITY_ERROR = "insufficient_liquidity_error",
    UNISWAP_BROKER_INSUFFICIENT_LIQUIDITY_ERROR = "uniswap_broker_insufficient_liquidity_error",
    NOT_ENOUGH_FREE_COLLATERAL_ERROR = "not_enough_free_collateral_error",
    REDUCE_POSITION_TOO_MUCH_ERROR = "reduce_position_too_much_error",
    CONTRACT_WRITE_ERROR = "contract_write_error",
    PRICE_SLIPPAGE_CHECK_ERROR = "price_slippage_check_error",
    COLLATERAL_DEPOSIT_CAP_ERROR = "collateral_deposit_cap_error",
    ALREADY_OVER_PRICE_LIMIT_ONCE_ERROR = "already_over_price_limit_once_error",
    OVER_PRICE_LIMIT_BEFORE_SWAP_ERROR = "over_price_limit_before_swap_error",
    OVER_PRICE_LIMIT_AFTER_SWAP_ERROR = "over_price_limit_after_swap_error",
    POSITION_SIZE_IS_ZERO_ERROR = "position_size_is_zero_error",
    NOT_ENOUGH_ACCOUNT_VALUE_BY_IM_RATIO_ERROR = "not_enough_account_value_by_im_ratio_error",
    ORDERS_NUMBER_EXCEEDS_ERROR = "orders_number_exceeds_error",
    NOT_ENOUGH_LIQUIDITY_ERROR = "not_enough_liquidity_error",
    NON_EXISTENT_OPEN_ORDER_ERROR = "non_existent_open_order_error",
    MARKET_NUMBER_EXCEEDS_ERROR = "market_number_exceeds_error",
    OVER_MAXIMUM_PRICE_SPREAD_ERROR = "over_maximum_price_spread_error",
    NOT_ENOUGH_MINIMUM_REQUIRED_MARGIN_ERROR = "not_enough_minimum_required_margin_error",
    UNISWAP_ERROR = "uniswap_error"
}
export declare type SDKErrorContractRead = ContractReadError<EthersContract> | InsufficientLiquidityError | UniswapBrokerInsufficientLiquidityError | NotEnoughFreeCollateralError;
export declare type SDKErrorContractWrite = ContractWriteError<EthersContract> | NotEnoughLiquidityError | PriceSlippageCheckError;
export declare type SDKErrorGraph = GraphqlQueryError;
export declare type SDKErrorRpc = RpcClosedError | RpcRejectedError | RpcIntrinsicGasTooLowError;
export declare type SDKErrorGeneral = UnauthorizedError | ArgumentError | FailedPreconditionError | TypeError;
export declare type SDKError = SDKErrorContractRead | SDKErrorContractWrite | SDKErrorGraph | SDKErrorRpc | SDKErrorGeneral;
export declare function isSDKErrorContractRead(error: any): error is SDKErrorContractRead;
export declare function isSDKErrorContractWrite(error: any): error is SDKErrorContractWrite;
export declare function isSDKError(error: any): error is SDKError;
interface SDKBaseErrorParams {
    rawError?: Error;
}
declare abstract class SDKBaseError extends Error {
    readonly rawError?: Error;
    constructor(data?: SDKBaseErrorParams);
}
export declare class InitSDKError extends Error {
    constructor(error: Error);
}
interface TypeErrorParams extends SDKBaseErrorParams {
    functionName: string;
    variableName: string;
    variableValue: any;
    type: string;
}
export declare class TypeError extends SDKBaseError {
    constructor(data: TypeErrorParams);
}
interface ArgumentErrorParams extends SDKBaseErrorParams {
    functionName: string;
    key: string;
    value: any;
}
export declare class ArgumentError extends SDKBaseError {
    constructor(data: ArgumentErrorParams);
}
interface FailedPreconditionErrorParams extends SDKBaseErrorParams {
    functionName: string;
    stateName: string;
    stateValue: any;
}
export declare class FailedPreconditionError extends SDKBaseError {
    constructor(data: FailedPreconditionErrorParams);
}
interface UnauthorizedErrorParams extends SDKBaseErrorParams {
    functionName: string;
}
export declare class UnauthorizedError extends SDKBaseError {
    constructor(data: UnauthorizedErrorParams);
}
export declare class UnsupportedChainError extends Error {
    constructor();
}
export interface ContractErrorParams<ContractFunctionName> extends SDKBaseErrorParams {
    contractName: string;
    contractFunctionName: ContractFunctionName;
    contractErrorCode?: ContractErrorCode;
    args?: {
        [key: string]: any;
    };
    context?: {
        [key: string]: any;
    };
}
export declare class MulticallReadError<ContractType extends EthersContract> extends SDKBaseError {
    readonly contractName: string;
    readonly contractFunctionName: keyof ContractType;
    readonly contractErrorCode?: ContractErrorCode;
    readonly arguments: string;
    readonly context: string;
    constructor(data: ContractErrorParams<keyof ContractType>);
}
export declare class MulticallEncodeError<ContractType extends EthersContract> extends MulticallReadError<ContractType> {
    constructor(data: ContractErrorParams<keyof ContractType>);
}
export declare class MulticallDecodeError<ContractType extends EthersContract> extends MulticallReadError<ContractType> {
    constructor(data: ContractErrorParams<keyof ContractType>);
}
export declare type ContractReadErrorParams<ContractFunctionName> = ContractErrorParams<ContractFunctionName>;
export declare class ContractReadError<ContractType extends EthersContract> extends SDKBaseError {
    readonly contractName: string;
    readonly contractFunctionName: keyof ContractType;
    readonly contractErrorCode?: ContractErrorCode;
    readonly arguments: string;
    readonly context: string;
    constructor(data: ContractReadErrorParams<keyof ContractType>);
}
export declare class InsufficientLiquidityError extends ContractReadError<Quoter> {
    constructor(data: ContractReadErrorParams<keyof Quoter>);
}
export declare class UniswapBrokerInsufficientLiquidityError extends ContractReadError<ClearingHouse> {
    constructor(data: ContractReadErrorParams<keyof ClearingHouse>);
}
export declare class NotEnoughFreeCollateralError extends ContractReadError<ClearingHouse> {
    constructor(data: ContractReadErrorParams<keyof ClearingHouse>);
}
export declare class ReducePositionInvalidError extends ContractReadError<ClearingHouse> {
    constructor(data: ContractReadErrorParams<keyof ClearingHouse>);
}
interface ContractWriteBaseErrorParams<ContractFunctionName> extends ContractErrorParams<ContractFunctionName> {
    txHash?: string;
    gasLimit?: string;
    txPayload?: {
        from?: string;
        to?: string;
        inputData?: string;
    };
}
export declare class ContractWriteError<ContractType extends EthersContract> extends SDKBaseError {
    readonly contractName: string;
    readonly contractFunctionName: keyof ContractType;
    readonly contractErrorCode?: ContractErrorCode;
    readonly arguments: string;
    readonly context: string;
    readonly txHash?: string;
    readonly gasLimit?: string;
    readonly from?: string;
    readonly to?: string;
    readonly inputData?: string;
    constructor(data: ContractWriteBaseErrorParams<keyof ContractType>);
}
export declare type ContractWriteErrorParams<ContractFunctionName> = ContractWriteBaseErrorParams<ContractFunctionName> & Required<Pick<ContractWriteBaseErrorParams<ContractFunctionName>, "contractErrorCode">>;
export declare class CollateralDepositCapError extends ContractWriteError<Vault> {
    constructor(data: ContractWriteErrorParams<keyof Vault>);
}
export declare class PriceSlippageCheckError extends ContractWriteError<ClearingHouse> {
    constructor(data: ContractWriteErrorParams<keyof ClearingHouse>);
}
export declare class AlreadyOverPriceLimitOnceError extends ContractWriteError<Exchange> {
    constructor(data: ContractWriteErrorParams<keyof Exchange>);
}
export declare class OverPriceLimitBeforeSwapError extends ContractWriteError<Exchange> {
    constructor(data: ContractWriteErrorParams<keyof Exchange>);
}
export declare class OverPriceLimitAfterSwapError extends ContractWriteError<Exchange> {
    constructor(data: ContractWriteErrorParams<keyof Exchange>);
}
export declare class PositionSizeIsZeroError extends ContractWriteError<ClearingHouse> {
    constructor(data: ContractWriteErrorParams<keyof ClearingHouse>);
}
export declare class NotEnoughAccountValueByImRatioError extends ContractWriteError<ClearingHouse> {
    constructor(data: ContractWriteErrorParams<keyof ClearingHouse>);
}
export declare class OrdersNumberExceedsError extends ContractWriteError<OrderBook> {
    constructor(data: ContractWriteErrorParams<keyof OrderBook>);
}
export declare class NotEnoughLiquidityError extends ContractWriteError<OrderBook> {
    constructor(data: ContractWriteErrorParams<keyof OrderBook>);
}
export declare class NonExistentOpenOrderError extends ContractWriteError<OrderBook> {
    constructor(data: ContractWriteErrorParams<keyof OrderBook>);
}
export declare class MarketNumberExceedsError extends ContractWriteError<AccountBalance> {
    constructor(data: ContractWriteErrorParams<keyof AccountBalance>);
}
export declare class OverMaximumPriceSpreadError extends ContractWriteError<ClearingHouse> {
    constructor(data: ContractWriteErrorParams<keyof ClearingHouse>);
}
export declare class NotEnoughMinimumRequiredMarginError extends ContractWriteError<ClearingHouse> {
    constructor(data: ContractWriteErrorParams<keyof ClearingHouse>);
}
export declare class UniswapV3Error extends ContractWriteError<ClearingHouse> {
    constructor(data: ContractWriteErrorParams<keyof ClearingHouse>);
}
interface GraphqlQueryErrorParams extends SDKBaseErrorParams {
    functionName: string;
    query: string;
    args?: {
        [key: string]: any;
    };
}
export declare class GraphqlQueryError extends SDKBaseError {
    readonly functionName: string;
    readonly query: string;
    readonly args: string;
    constructor(data: GraphqlQueryErrorParams);
}
export declare enum RpcErrorCode {
    USER_DENIED_TRANSACTION = 4001,
    INTRINSIC_GAS_TOO_LOW = "intrinsic gas too low"
}
export interface RpcNativeError extends Error {
    code: number;
    data?: unknown;
}
export declare function isRpcNativeUserDeniedError(error: Error): error is RpcNativeError;
export declare function isRpcNativeGasTooLowError(error: Error): error is RpcNativeError;
interface RpcErrorParams extends SDKBaseErrorParams {
    contractFunctionName: keyof EthersContract;
}
export declare class RpcIntrinsicGasTooLowError extends SDKBaseError {
    readonly contractFunctionName: keyof EthersContract;
    constructor(data: RpcErrorParams);
}
export declare class RpcRejectedError extends SDKBaseError {
    readonly contractFunctionName: keyof EthersContract;
    constructor(data: RpcErrorParams);
}
export declare class RpcClosedError extends SDKBaseError {
    constructor(data: SDKBaseErrorParams);
}
export declare class RpcTimeoutError extends SDKBaseError {
    constructor(data?: SDKBaseErrorParams);
}
interface RpcMaxRetryErrorParams extends SDKBaseErrorParams {
    rawErrors?: Error[];
}
export declare class RpcMaxRetryError extends SDKBaseError {
    readonly rawErrors?: Error[];
    constructor({ rawErrors, ...error }: RpcMaxRetryErrorParams);
}
export {};
