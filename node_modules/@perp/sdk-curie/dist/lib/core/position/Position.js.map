{"version":3,"file":"Position.js","sources":["../../../../src/core/position/Position.ts"],"sourcesContent":["import { Channel, ChannelEventSource, ChannelRegistry } from \"../../internal\"\nimport { getPriceImpact, getSwapRate, getTransactionFee, getUnrealizedPnl } from \"../clearingHouse/utils\"\n\nimport Big from \"big.js\"\nimport { GetQuoterSwapReturn } from \"../contractReader\"\nimport { Market } from \"../market\"\nimport type { PerpetualProtocol } from \"../PerpetualProtocol\"\nimport { PositionSide } from \"./types\"\n\ntype PositionEventName = \"updated\" | \"updateError\"\n\nexport enum PositionType {\n    TAKER = \"TAKER\",\n    MAKER = \"MAKER\",\n}\n\ninterface PositionConstructorData {\n    perp: PerpetualProtocol\n    type: PositionType\n    market: Market\n    side: PositionSide\n    sizeAbs: Big // NOTE: base asset amount\n    openNotionalAbs: Big // NOTE: quote asset amount\n    entryPrice: Big\n    liquidationPrice?: Big\n}\n\nexport interface PositionDataDerived {\n    markPrice: Big\n    indexPrice: Big\n    indexTwapPrice: Big\n    unrealizedPnl: Big\n    positionNotional: Big\n    positionNotionalTwap: Big\n    exitPrice: Big\n    priceImpact: Big\n    transactionFee: Big\n    liquidationPrice?: Big\n}\n\ntype CacheKey = \"swap\"\ntype CacheValue = GetQuoterSwapReturn\nexport class Position extends Channel<PositionEventName> {\n    readonly market: Market\n    private _cache: Map<CacheKey, CacheValue> = new Map()\n    readonly side: PositionSide\n    readonly sizeAbs: Big\n    readonly openNotionalAbs: Big\n    readonly entryPrice: Big\n    readonly liquidationPrice?: Big\n    readonly type: PositionType\n    private readonly _perp: PerpetualProtocol\n\n    constructor(\n        { perp, market, side, sizeAbs, openNotionalAbs, entryPrice, liquidationPrice, type }: PositionConstructorData,\n        _channelRegistry?: ChannelRegistry,\n    ) {\n        super(_channelRegistry)\n\n        this._perp = perp\n        this.market = market\n        this.side = side\n        this.sizeAbs = sizeAbs\n        this.openNotionalAbs = openNotionalAbs\n        this.entryPrice = entryPrice\n        this.liquidationPrice = liquidationPrice\n        this.type = type\n    }\n    get sizeOriginal() {\n        return this.sizeAbs.mul(this.side === PositionSide.LONG ? 1 : -1)\n    }\n\n    get openNotionalOriginal() {\n        return this.openNotionalAbs.mul(this.side === PositionSide.LONG ? -1 : 1)\n    }\n    /**\n     * When closing position, is trader selling BASE token in exchange for QUOTE token?\n     */\n    get isBaseToQuote() {\n        // NOTE: Closing a LONG is equivalent to SELL BASE token.\n        return this.side === PositionSide.LONG\n    }\n\n    /**\n     * When closing position, is BASE token being SOLD? (Since position size is always measured by BASE)\n     * NOTE: see truth table, https://docs.google.com/spreadsheets/d/1gVLSYVj98e0p2HaxQ7NdHCejd6S25sr9jgXlnzE1jqE/edit#gid=2106034965\n     */\n    get isExactInput() {\n        // NOTE: Closing a LONG is equivalent to SELL BASE token, which IS BASE.\n        // NOTE: Closing a SHORT is equivalent to SELL QUOTE token, which IS NOT BASE.\n        return this.side === PositionSide.LONG\n    }\n\n    async getSwap({ cache = true } = {}) {\n        return this._fetch(\"swap\", { cache })\n    }\n\n    public async getExitPrice({ cache = true } = {}) {\n        const { exchangedPositionSize, exchangedPositionNotional } = await this._fetch(\"swap\", { cache })\n        const exitPrice = getSwapRate({\n            amountBase: exchangedPositionSize,\n            amountQuote: exchangedPositionNotional,\n        })\n        return exitPrice\n    }\n\n    public async getPriceImpact({ cache = true } = {}) {\n        const exitPrice = await this.getExitPrice({ cache })\n        const { markPrice } = await this.market.getPrices({ cache })\n        const priceImpact = getPriceImpact({\n            price: exitPrice,\n            markPrice: markPrice,\n        })\n        return priceImpact\n    }\n\n    public async getUnrealizedPnl({ cache = true } = {}) {\n        const { deltaAvailableQuote } = await this._fetch(\"swap\", { cache })\n        const isLong = this.side === PositionSide.LONG\n        const unrealizedPnl = getUnrealizedPnl({\n            isLong,\n            deltaAvailableQuote,\n            openNotionalAbs: this.openNotionalAbs,\n        })\n        return unrealizedPnl\n    }\n\n    public async getTransactionFee({ cache = true } = {}) {\n        const { deltaAvailableQuote, exchangedPositionNotional } = await this._fetch(\"swap\", { cache })\n        const feeRatio = this._perp.clearingHouseConfig.marketExchangeFeeRatios[this.market.baseAddress]\n\n        const transactionFee = getTransactionFee({\n            isBaseToQuote: this.isBaseToQuote,\n            exchangedPositionNotional,\n            deltaAvailableQuote,\n            feeRatio,\n        })\n        return transactionFee\n    }\n\n    private async _handleMarketUpdate() {\n        try {\n            await this._fetch(\"swap\", { cache: false })\n            this.emit(\"updated\", this)\n        } catch (error) {\n            this.emit(\"updateError\", error)\n        }\n    }\n\n    protected _getEventSourceMap() {\n        const updateDataEventSource = new ChannelEventSource<PositionEventName>({\n            eventSourceStarter: () => {\n                return this.market.on(\"updated\", this._handleMarketUpdate.bind(this))\n            },\n            initEventEmitter: eventName => {\n                if (eventName === \"updated\") {\n                    this.emit(\"updated\", this)\n                }\n            },\n        })\n\n        return {\n            updated: updateDataEventSource,\n        }\n    }\n\n    /**\n     * Calculate the upper/lower bound for slippage protection.\n     * Formula: https://www.notion.so/perp/V2-Formula-for-opening-position-e8f7e481cf144b75977217114cecbdb9#3802018734c2426aa59d9426fe98b097\n     **/\n    async getOppositeAmountBound(slippage: Big) {\n        const { output } = await this._fetch(\"swap\", { cache: false })\n\n        let result\n        if (this.isExactInput) {\n            result = output.mul(new Big(1).sub(slippage))\n        } else {\n            result = output.mul(new Big(1).add(slippage))\n            if (slippage.eq(0) && !this.isBaseToQuote) {\n                // when sliipage = 0, isBaseToQuote = false, and isExactInput = false, contract will have rounding issue.\n                result = result.add(new Big(1).mul(10 ** -18))\n            }\n        }\n        return result\n    }\n\n    static same(positionA: Position, positionB: Position) {\n        return (\n            positionA.market.tickerSymbol === positionB.market.tickerSymbol &&\n            positionA.side === positionB.side &&\n            positionA.sizeAbs.eq(positionB.sizeAbs)\n        )\n    }\n\n    private async _fetch(key: CacheKey, obj?: { cache: boolean }): Promise<CacheValue>\n    private async _fetch(key: CacheKey, { cache = true } = {}) {\n        if (this._cache.has(key) && cache) {\n            return this._cache.get(key) as CacheValue\n        }\n\n        let result\n        switch (key) {\n            case \"swap\": {\n                result = await this._perp.contractReader.getQuoterSwap({\n                    baseTokenAddress: this.market.baseAddress,\n                    amount: this.sizeAbs,\n                    isBaseToQuote: this.isBaseToQuote,\n                    isExactInput: this.isExactInput,\n                })\n                break\n            }\n        }\n        this._cache.set(key, result)\n\n        return result\n    }\n}\n"],"names":["PositionType","Position","Channel","constructor","perp","market","side","sizeAbs","openNotionalAbs","entryPrice","liquidationPrice","type","_channelRegistry","super","this","_cache","Map","_perp","sizeOriginal","mul","PositionSide","LONG","openNotionalOriginal","isBaseToQuote","isExactInput","async","cache","_fetch","exchangedPositionSize","exchangedPositionNotional","getSwapRate","amountBase","amountQuote","exitPrice","getExitPrice","markPrice","getPrices","getPriceImpact","price","deltaAvailableQuote","isLong","getUnrealizedPnl","feeRatio","clearingHouseConfig","marketExchangeFeeRatios","baseAddress","getTransactionFee","emit","error","_getEventSourceMap","updated","ChannelEventSource","eventSourceStarter","on","_handleMarketUpdate","bind","initEventEmitter","eventName","slippage","output","result","Big","sub","add","eq","static","positionA","positionB","tickerSymbol","key","has","get","contractReader","getQuoterSwap","baseTokenAddress","amount","set"],"mappings":"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"}