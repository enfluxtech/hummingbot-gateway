{"version":3,"file":"Market.js","sources":["../../../../src/core/market/Market.ts"],"sourcesContent":["import { Big } from \"big.js\"\n\nimport {\n    Channel,\n    ChannelEventSource,\n    createMemoizedFetcher,\n    DEFAULT_PERIOD,\n    hasNumbersChange,\n    MemoizedFetcher,\n} from \"../../internal\"\nimport {\n    fromSqrtX96,\n    getMaxTickByTickSpacing,\n    getMinTickByTickSpacing,\n    getTickFromPrice,\n    poll,\n    TickPriceMode,\n    tickToPrice,\n} from \"../../utils\"\nimport { ContractReader, GetMarketStatusReturn } from \"../contractReader\"\nimport type { PerpetualProtocol } from \"../PerpetualProtocol\"\n\ntype MarketEventName = \"updateError\" | \"updated\"\n\ntype CacheKey =\n    | \"indexPrice\"\n    | \"markPrice\"\n    | \"indexTwapPrice\"\n    | \"isMarketPaused\"\n    | \"isMarketClosed\"\n    | \"marketStatus\"\n    | \"closedPrice\"\n\ntype CacheValue = Big | boolean | GetMarketStatusReturn\n\nexport enum MarketStatus {\n    ACTIVE = \"ACTIVE\",\n    PAUSED = \"PAUSED\",\n    CLOSED = \"CLOSED\",\n}\n\nclass Market extends Channel<MarketEventName> {\n    private _cache: Map<CacheKey, CacheValue> = new Map()\n    private readonly _contractReader: ContractReader\n\n    constructor(\n        private readonly _perp: PerpetualProtocol,\n        readonly tickerSymbol: string,\n        readonly poolAddress: string,\n        readonly baseSymbol: string,\n        readonly baseAddress: string,\n        readonly quoteSymbol: string,\n        readonly quoteAddress: string,\n    ) {\n        super(_perp.channelRegistry)\n        this._perp = _perp\n        this.poolAddress = poolAddress\n        this.baseAddress = baseAddress\n        this.quoteAddress = quoteAddress\n        this._contractReader = this._perp.contractReader\n    }\n\n    get tickSpacing() {\n        return this._perp.clearingHouseConfig.marketTickSpacings[this.poolAddress]\n    }\n\n    get maxTick() {\n        return getMaxTickByTickSpacing(this.tickSpacing)\n    }\n\n    get minTick() {\n        return getMinTickByTickSpacing(this.tickSpacing)\n    }\n\n    getTickFromPrice(price: Big, mode?: TickPriceMode) {\n        return getTickFromPrice(price, this.tickSpacing, mode)\n    }\n\n    getPriceFromTick(tick: number) {\n        return tickToPrice(tick)\n    }\n\n    getPriceFeedAggregator() {\n        return this._contractReader.getPriceFeedAggregator(this.baseAddress)\n    }\n\n    protected _getEventSourceMap() {\n        const fetchAndEmitUpdated = this._createFetchUpdateData()\n        const updateDataEventSource = new ChannelEventSource<MarketEventName>({\n            eventSourceStarter: () => {\n                const { cancel } = poll(fetchAndEmitUpdated, this._perp.moduleConfigs?.market?.period || DEFAULT_PERIOD)\n                return cancel\n            },\n            initEventEmitter: () => fetchAndEmitUpdated(true, true),\n        })\n\n        // TODO: eventName typing protection, should error when invalid eventName is provided\n        return {\n            updated: updateDataEventSource,\n            updateError: updateDataEventSource,\n        }\n    }\n\n    /**\n     * Get market data and emit \"updated\" event\n     */\n    private _createFetchUpdateData(): MemoizedFetcher {\n        const getMarketData = async () => {\n            try {\n                const twapInterval = this._perp.clearingHouseConfig.twapInterval.toNumber()\n                const result = await this._contractReader.getMarketData({\n                    poolAddress: this.poolAddress,\n                    baseAddress: this.baseAddress,\n                    twapTimeRange: twapInterval,\n                })\n\n                const { markPrice, indexPrice, indexTwapPrice } = result\n\n                this._cache.set(\"markPrice\", markPrice)\n                this._cache.set(\"indexPrice\", indexPrice)\n                this._cache.set(\"indexTwapPrice\", indexTwapPrice)\n\n                return result\n            } catch (error) {\n                this.emit(\"updateError\", { error })\n            }\n        }\n\n        return createMemoizedFetcher(\n            getMarketData.bind(this),\n            () => {\n                this.emit(\"updated\", this)\n            },\n            (a, b) => (a && b ? hasNumbersChange(a, b) : true),\n        )\n    }\n\n    async getStatus() {\n        const { isPaused, isClosed } = await this._fetch(\"marketStatus\", { cache: false })\n        return isClosed ? MarketStatus.CLOSED : isPaused ? MarketStatus.PAUSED : MarketStatus.ACTIVE\n    }\n\n    async getClosedPrice() {\n        return await this._fetch(\"closedPrice\")\n    }\n\n    async getPrices({ cache = true } = {}) {\n        // TODO: replace with multi-call\n        const [markPrice, indexPrice, indexTwapPrice] = await Promise.all([\n            this._fetch(\"markPrice\", { cache }),\n            this._fetch(\"indexPrice\", { cache }),\n            this._fetch(\"indexTwapPrice\", { cache }),\n        ])\n        return {\n            markPrice,\n            indexPrice,\n            indexTwapPrice,\n        }\n    }\n\n    private async _fetch(key: \"closedPrice\", obj?: { cache: boolean }): Promise<Big>\n    private async _fetch(key: \"indexPrice\" | \"markPrice\" | \"indexTwapPrice\", obj?: { cache: boolean }): Promise<Big>\n    private async _fetch(key: \"isMarketPaused\" | \"isMarketClosed\", obj?: { cache: boolean }): Promise<boolean>\n    private async _fetch(key: \"marketStatus\", obj?: { cache: boolean }): Promise<GetMarketStatusReturn>\n    private async _fetch(key: CacheKey, obj?: { cache: boolean }): Promise<CacheValue>\n    private async _fetch(key: CacheKey, { cache = true } = {}) {\n        if (this._cache.has(key) && cache) {\n            return this._cache.get(key)\n        }\n\n        let result\n        switch (key) {\n            case \"indexPrice\": {\n                result = await this._contractReader.getIndexPrice(this.baseAddress)\n                break\n            }\n            case \"markPrice\": {\n                const { sqrtPriceX96 } = await this._contractReader.getSlot0(this.poolAddress)\n                result = fromSqrtX96(sqrtPriceX96)\n                break\n            }\n            case \"indexTwapPrice\": {\n                const twapInterval = this._perp.clearingHouseConfig.twapInterval.toNumber()\n                result = await this._contractReader.getIndexPrice(this.baseAddress, twapInterval)\n                break\n            }\n            case \"isMarketPaused\": {\n                result = await this._contractReader.isMarketPaused(this.baseAddress)\n                break\n            }\n            case \"isMarketClosed\": {\n                result = await this._contractReader.isMarketClosed(this.baseAddress)\n                break\n            }\n            case \"marketStatus\": {\n                result = await this._contractReader.getMarketStatus(this.baseAddress)\n                break\n            }\n            case \"closedPrice\": {\n                result = await this._contractReader.getClosedPrice(this.baseAddress)\n                break\n            }\n        }\n        this._cache.set(key, result)\n\n        return result\n    }\n}\n\nexport { Market }\n"],"names":["MarketStatus","Market","Channel","constructor","_perp","tickerSymbol","poolAddress","baseSymbol","baseAddress","quoteSymbol","quoteAddress","super","channelRegistry","this","_cache","Map","_contractReader","contractReader","tickSpacing","clearingHouseConfig","marketTickSpacings","maxTick","getMaxTickByTickSpacing","minTick","getMinTickByTickSpacing","getTickFromPrice","price","mode","getPriceFromTick","tick","tickToPrice","getPriceFeedAggregator","_getEventSourceMap","fetchAndEmitUpdated","_createFetchUpdateData","updateDataEventSource","ChannelEventSource","eventSourceStarter","cancel","poll","_b","_a","moduleConfigs","market","period","DEFAULT_PERIOD","initEventEmitter","updated","updateError","createMemoizedFetcher","async","twapInterval","toNumber","result","getMarketData","twapTimeRange","markPrice","indexPrice","indexTwapPrice","set","error","emit","bind","a","b","hasNumbersChange","isPaused","isClosed","_fetch","cache","CLOSED","PAUSED","ACTIVE","Promise","all","key","has","get","getIndexPrice","sqrtPriceX96","getSlot0","fromSqrtX96","isMarketPaused","isMarketClosed","getMarketStatus","getClosedPrice"],"mappings":"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"}