{"version":3,"file":"ContractReader.js","sources":["../../../../src/core/contractReader/ContractReader.ts"],"sourcesContent":["import { BigNumber, constants, errors } from \"ethers\"\nimport { COLLATERAL_TOKEN_DECIMAL, RATIO_DECIMAL, SETTLEMENT_TOKEN_DECIMAL } from \"../../constants\"\nimport { ContractName, Contracts } from \"../../contracts\"\nimport {\n    BaseToken,\n    ChainlinkPriceFeed,\n    ClearingHouse,\n    CollateralManager,\n    DelegateApproval,\n    IERC20Metadata,\n    Multicall2,\n    OrderBook,\n    Quoter,\n    UniswapV3Pool,\n    Vault,\n} from \"../../contracts/type\"\nimport {\n    ContractErrorCode,\n    ContractReadError,\n    ContractReadErrorParams,\n    extractContractErrorCode,\n    InsufficientLiquidityError,\n    MarketNumberExceedsError,\n    NotEnoughFreeCollateralError,\n    OverPriceLimitAfterSwapError,\n    UniswapBrokerInsufficientLiquidityError,\n} from \"../../errors\"\nimport {\n    big2BigNumberAndScaleUp,\n    bigNumber2BigAndScaleDown,\n    errorGuardAsync,\n    fromSqrtX96,\n    scaleDownDecimals,\n} from \"../../utils\"\nimport { NonSettlementCollateralToken, SettlementToken } from \"../wallet\"\nimport { ContractCall, MulticallReader } from \"./MulticallReader\"\nimport { contractCallsParserForErrorHandling, genKeyFromContractAndFuncName } from \"./utils\"\n\nimport Big from \"big.js\"\nimport { Metadata } from \"../../metadata\"\nimport { RetryProvider } from \"../../network\"\nimport { logger } from \"../../utils\"\nimport { MarketMap } from \"../market\"\nimport { marketInfo } from \"../market/Markets\"\n\ninterface ContractsReaderConfig {\n    contracts: Contracts\n    provider: RetryProvider\n    metadata: Metadata\n}\n\ninterface GetLiquidityPendingFeeParams {\n    trader: string\n    baseTokenAddress: string\n    lowerTick: number\n    upperTick: number\n}\n\ninterface GetOpenLiquiditiesParams {\n    trader: string\n    baseTokenAddress: string\n}\n\ninterface GetOpenLiquidityParams {\n    trader: string\n    baseTokenAddress: string\n    lowerTick: number\n    upperTick: number\n}\n\nexport type GetTotalTokenAmountInPoolAndPendingFeeOfAllMarketsReturn = Record<\n    string,\n    {\n        totalTokenAmount: Big\n        totalPendingFee: Big\n    }\n>\n\ninterface GetQuoterSwapParams {\n    baseTokenAddress: string\n    isBaseToQuote: boolean\n    isExactInput: boolean\n    amount: Big\n}\n\ninterface SimulateOpenPositionParams {\n    baseTokenAddress: string\n    isBaseToQuote: boolean\n    isExactInput: boolean\n    amount: Big\n    oppositeAmountBound: Big\n}\n\nexport interface GetQuoterSwapReturn {\n    deltaAvailableBase: Big\n    deltaAvailableQuote: Big\n    exchangedPositionNotional: Big\n    exchangedPositionSize: Big\n    output: Big\n}\n\nexport interface SimulateOpenPositionReturn {\n    deltaBase: Big\n    deltaQuote: Big\n}\n\nexport interface GetPositionDraftRelatedDataReturn {\n    swap: {\n        deltaAvailableBase: Big\n        deltaAvailableQuote: Big\n        exchangedPositionNotional: Big\n        exchangedPositionSize: Big\n        output: Big\n    }\n    getPnlAndPendingFee: {\n        owedPNL: Big\n        unrealizedPNL: Big\n        pendingFee: Big\n    }\n    otherBaseDebts: Big[]\n    otherMarketIndexPrices: Big[]\n    quoteDebts: Big[]\n}\n\nexport interface GetPositionDraftRelatedData {\n    trader: string\n    marketBaseAddresses: string[]\n    currentMarketBaseSize: Big\n    currentMarketBaseAddress: string\n}\n\nexport type GetOpenLiquidityReturn = {\n    baseDebt: Big\n    quoteDebt: Big\n    liquidity: Big\n    lowerTick: number\n    upperTick: number\n}[][] // NOTE: [market1: [ liquidity1, liquidity2 ]]\n\nexport interface GetMarketStatusReturn {\n    isPaused: boolean\n    isClosed: boolean\n}\n\nexport type MarketTickSpacings = { [poolAddress: string]: number }\nexport type MarketExchangeFeeRatios = { [baseAddress: string]: Big }\nexport type MarketInsuranceFundFeeRatios = { [baseAddress: string]: Big }\n\ninterface MulticallMarketDataArgs {\n    poolAddress: string\n    baseAddress: string\n    twapTimeRange: number\n}\n\n// TODO: How to better differentiate STATIC(fetch once) / DYNAMIC(fetch on-demand) / REALTIME(steam of updates) data fetch?\nexport class ContractReader {\n    readonly contracts: Contracts\n\n    private _provider: RetryProvider\n    private _metadata: Metadata\n    private _multicallReader: MulticallReader\n\n    constructor({ contracts, provider, metadata }: ContractsReaderConfig) {\n        this.contracts = contracts\n        this._provider = provider\n        this._metadata = metadata\n        this._multicallReader = new MulticallReader({ contract: contracts.multicall2 })\n    }\n\n    async getNativeBalance(account: string) {\n        return errorGuardAsync(\n            async () => {\n                logger(\"getNativeBalance\")\n                const balance = await this._provider.getBalance(account)\n                return bigNumber2BigAndScaleDown(balance)\n            },\n            rawError =>\n                new ContractReadError({\n                    contractName: \"ethers\",\n                    contractFunctionName: \"getNativeBalance\",\n                    args: { account },\n                    rawError,\n                }),\n        )\n    }\n\n    async getAccountValue(account: string) {\n        return errorGuardAsync(\n            async () => {\n                logger(\"getAccountValue\")\n                const accountValue = await this.contracts.vault.getAccountValue(account)\n                return bigNumber2BigAndScaleDown(accountValue, SETTLEMENT_TOKEN_DECIMAL)\n            },\n            rawError =>\n                new ContractReadError<Vault>({\n                    contractName: ContractName.VAULT,\n                    contractFunctionName: \"getAccountValue\",\n                    args: { account },\n                    rawError,\n                }),\n        )\n    }\n\n    async getFreeCollateral(account: string) {\n        return errorGuardAsync(\n            async () => {\n                logger(\"getFreeCollateral\")\n                const freeCollateral = await this.contracts.vault.getFreeCollateral(account)\n                return bigNumber2BigAndScaleDown(freeCollateral, COLLATERAL_TOKEN_DECIMAL)\n            },\n            rawError =>\n                new ContractReadError<Vault>({\n                    contractName: ContractName.VAULT,\n                    contractFunctionName: \"getFreeCollateral\",\n                    args: { account },\n                    rawError,\n                }),\n        )\n    }\n\n    async getFreeCollateralByToken(account: string, token: NonSettlementCollateralToken | SettlementToken) {\n        return errorGuardAsync(\n            async () => {\n                logger(\"getFreeCollateralByToken::token::decimals\")\n                logger(\"getFreeCollateralByToken::vault::GetFreeCollateralByToken\")\n                const tokenAddress = token.address\n                const tokenDecimals = await token.decimals()\n                const freeCollateral = await this.contracts.vault.getFreeCollateralByToken(account, tokenAddress)\n                return bigNumber2BigAndScaleDown(freeCollateral, tokenDecimals)\n            },\n            rawError =>\n                new ContractReadError<Vault>({\n                    contractName: ContractName.VAULT,\n                    contractFunctionName: \"getFreeCollateralByToken\",\n                    args: { account, tokenAddress: token.address },\n                    rawError,\n                }),\n        )\n    }\n\n    async getVaultBalanceOfSettlementToken(account: string) {\n        return errorGuardAsync(\n            async () => {\n                logger(\"getVaultBalanceOfSettlementToken\")\n                const freeCollateral = await this.contracts.vault.getSettlementTokenValue(account)\n                return bigNumber2BigAndScaleDown(freeCollateral, SETTLEMENT_TOKEN_DECIMAL)\n            },\n            rawError =>\n                new ContractReadError<Vault>({\n                    contractName: ContractName.VAULT,\n                    contractFunctionName: \"getSettlementTokenValue\",\n                    args: { account },\n                    rawError,\n                }),\n        )\n    }\n\n    async getVaultBalanceByToken(account: string, token: NonSettlementCollateralToken) {\n        return errorGuardAsync(\n            async () => {\n                logger(\"getVaultBalanceByToken::token::decimals\")\n                logger(\"getVaultBalanceByToken::vault::GetBalanceByToken\")\n                const tokenAddress = token.address\n                const tokenDecimals = await token.decimals()\n                const balance = await this.contracts.vault.getBalanceByToken(account, tokenAddress)\n                return bigNumber2BigAndScaleDown(balance, tokenDecimals)\n            },\n            rawError =>\n                new ContractReadError<Vault>({\n                    contractName: ContractName.VAULT,\n                    contractFunctionName: \"getBalanceByToken\",\n                    args: { account, tokenAddress: token.address },\n                    rawError,\n                }),\n        )\n    }\n\n    async getCollateralConfig(tokenAddress: string) {\n        return errorGuardAsync(\n            async () => {\n                logger(\"getCollateralConfig::collateralManager::getCollateralConfig\")\n                logger(\"getCollateralConfig::collateralToken::decimals\")\n                const collateralManager = this.contracts.collateralManager\n                const collateralConfig = await collateralManager.getCollateralConfig(tokenAddress)\n                const priceFeed = collateralConfig.priceFeed\n\n                // collateralRatio & discountRatio are scaled up by 10^6 in contract, thus using scaleDownDecimals to scale down\n                const collateralRatio = collateralConfig.collateralRatio\n                const discountRatio = collateralConfig.discountRatio\n\n                const depositCap = collateralConfig.depositCap\n                const collateralToken = this.contracts.collateralTokenMap.get(tokenAddress)\n                const decimals = await collateralToken?.contract.decimals()\n                return {\n                    priceFeed: priceFeed,\n                    collateralRatio: scaleDownDecimals(Big(collateralRatio), RATIO_DECIMAL).toNumber(),\n                    discountRatio: scaleDownDecimals(Big(discountRatio), RATIO_DECIMAL).toNumber(),\n                    depositCap: bigNumber2BigAndScaleDown(depositCap, decimals),\n                }\n            },\n            rawError =>\n                new ContractReadError<CollateralManager>({\n                    contractName: ContractName.COLLATERAL_MANAGER,\n                    contractFunctionName: \"getCollateralConfig\",\n                    args: { tokenAddress },\n                    rawError,\n                }),\n        )\n    }\n\n    async getAllowanceByToken(account: string, spender: string, tokenAddress: string) {\n        return errorGuardAsync(\n            async () => {\n                logger(\"getAllowanceByToken:token::allowance\")\n                logger(\"getAllowanceByToken:token::decimals\")\n                const token = this.contracts.collateralTokenMap.get(tokenAddress)?.contract\n                if (!token) throw new Error(`Collateral token ${tokenAddress} not found`)\n                const [allowance, decimals] = await Promise.all([token.allowance(account, spender), token.decimals()])\n                return bigNumber2BigAndScaleDown(allowance, decimals)\n            },\n            rawError =>\n                new ContractReadError<IERC20Metadata>({\n                    contractName: ContractName.COLLATERAL_TOKENS,\n                    contractFunctionName: \"allowance\",\n                    args: { account, spender, tokenAddress },\n                    rawError,\n                }),\n        )\n    }\n\n    async getAllowanceOfSettlementToken(account: string, spender: string) {\n        return errorGuardAsync(\n            async () => {\n                logger(\"getAllowanceOfSettlementToken\")\n                const token = this.contracts.settlementToken\n                const allowance = await token.allowance(account, spender)\n                return bigNumber2BigAndScaleDown(allowance, SETTLEMENT_TOKEN_DECIMAL)\n            },\n            rawError =>\n                new ContractReadError<IERC20Metadata>({\n                    contractName: ContractName.SETTLEMENT_TOKEN,\n                    contractFunctionName: \"allowance\",\n                    args: { account, spender },\n                    rawError,\n                }),\n        )\n    }\n\n    async getBalanceByToken(account: string, tokenAddress: string, decimals: number) {\n        return errorGuardAsync(\n            async () => {\n                logger(\"getBalanceByToken\")\n                const token = this.contracts.collateralTokenMap.get(tokenAddress)?.contract\n                if (!token) throw new Error(`Collateral token ${tokenAddress} not found`)\n                const balance = await token.balanceOf(account)\n                return bigNumber2BigAndScaleDown(balance, decimals)\n            },\n            rawError =>\n                new ContractReadError<IERC20Metadata>({\n                    contractName: ContractName.COLLATERAL_TOKENS,\n                    contractFunctionName: \"balanceOf\",\n                    args: { account, tokenAddress, decimals },\n                    rawError,\n                }),\n        )\n    }\n\n    async getBalanceOfSettlementToken(account: string) {\n        return errorGuardAsync(\n            async () => {\n                logger(\"getBalanceOfSettlementToken\")\n                const token = this.contracts.settlementToken\n                const balance = await token.balanceOf(account)\n                return bigNumber2BigAndScaleDown(balance, SETTLEMENT_TOKEN_DECIMAL)\n            },\n            rawError =>\n                new ContractReadError<IERC20Metadata>({\n                    contractName: ContractName.SETTLEMENT_TOKEN,\n                    contractFunctionName: \"balanceOf\",\n                    args: { account },\n                    rawError,\n                }),\n        )\n    }\n\n    async getPriceFeedAggregator(baseTokenAddress: string) {\n        return errorGuardAsync(\n            async () => {\n                logger(\"getPriceFeedAggregator::contractBaseToken::getPriceFeed\")\n                logger(\"getPriceFeedAggregator::contractPriceFeed::getAggregator\")\n                const contractBaseToken = this.contracts.baseToken.attach(baseTokenAddress)\n                const priceFeedAddress = await contractBaseToken.getPriceFeed()\n                const contractPriceFeed = this.contracts.baseTokenPriceFeed.attach(priceFeedAddress)\n                return errorGuardAsync(\n                    async () => {\n                        // NOTE: contractPriceFeed is created with ChainLink factory but in runtime \"getAggregator\" will not exist when it's not Chainlink.\n                        const aggregatorAddress = await contractPriceFeed.getAggregator()\n                        const contractAggregator = this.contracts.baseTokenPriceFeedAggregator.attach(aggregatorAddress)\n                        return {\n                            address: aggregatorAddress,\n                            contract: contractAggregator,\n                        }\n                    },\n                    rawError =>\n                        new ContractReadError<ChainlinkPriceFeed>({\n                            contractName: ContractName.CHAINLINK_PRICE_FEED,\n                            contractFunctionName: \"getAggregator\",\n                            context: { baseTokenAddress },\n                            rawError,\n                        }),\n                )\n            },\n            rawError =>\n                new ContractReadError<BaseToken>({\n                    contractName: ContractName.BASE_TOKEN,\n                    contractFunctionName: \"getPriceFeed\",\n                    context: { baseTokenAddress },\n                    rawError,\n                }),\n        )\n    }\n\n    /**\n     * Check if the market is paused.\n     * @param baseTokenAddress - token address of baseToken\n     */\n    async isMarketPaused(baseTokenAddress: string): Promise<boolean> {\n        return errorGuardAsync(\n            async () => {\n                logger(\"isMarketPaused\")\n                const contract = this.contracts.baseToken.attach(baseTokenAddress)\n                return await contract.isPaused()\n            },\n            rawError =>\n                new ContractReadError<BaseToken>({\n                    contractName: ContractName.BASE_TOKEN,\n                    contractFunctionName: \"isPaused\",\n                    context: { baseTokenAddress },\n                    rawError,\n                }),\n        )\n    }\n\n    /**\n     * Check if the market is closed.\n     * @param baseTokenAddress - token address of baseToken\n     */\n    async isMarketClosed(baseTokenAddress: string): Promise<boolean> {\n        return errorGuardAsync(\n            async () => {\n                logger(\"isMarketClosed\")\n                const contract = this.contracts.baseToken.attach(baseTokenAddress)\n                return await contract.isClosed()\n            },\n            rawError =>\n                new ContractReadError<BaseToken>({\n                    contractName: ContractName.BASE_TOKEN,\n                    contractFunctionName: \"isClosed\",\n                    context: { baseTokenAddress },\n                    rawError,\n                }),\n        )\n    }\n\n    /**\n     * Check if the market is paused or closed.\n     * @param baseTokenAddress - token address of baseToken\n     */\n    async getMarketStatus(baseTokenAddress: string): Promise<{ isPaused: boolean; isClosed: boolean }> {\n        const contractCalls = [\n            {\n                contract: this.contracts.baseToken.attach(baseTokenAddress),\n                contractName: ContractName.BASE_TOKEN,\n                funcName: \"isPaused\",\n                funcParams: [],\n            },\n            {\n                contract: this.contracts.baseToken.attach(baseTokenAddress),\n                contractName: ContractName.BASE_TOKEN,\n                funcName: \"isClosed\",\n                funcParams: [],\n            },\n        ]\n        return errorGuardAsync(\n            async () => {\n                logger(\"getMarketStatus\")\n                const [isPaused, isClosed] = await this._multicallReader.execute(contractCalls)\n                return { isPaused, isClosed }\n            },\n            rawError =>\n                new ContractReadError<Multicall2>({\n                    contractName: ContractName.MULTICALL2,\n                    contractFunctionName: \"tryAggregate\",\n                    args: contractCallsParserForErrorHandling(contractCalls),\n                    rawError,\n                }),\n        )\n    }\n\n    /**\n     * get closed price.\n     * @constructor\n     * @param {string} baseTokenAddress -  token address of baseToken\n     */\n    async getClosedPrice(baseTokenAddress: string) {\n        return errorGuardAsync(\n            async () => {\n                logger(\"getClosedPrice\")\n                const contract = this.contracts.baseToken.attach(baseTokenAddress)\n                const closedPrice = await contract.getClosedPrice()\n                return bigNumber2BigAndScaleDown(closedPrice)\n            },\n            rawError =>\n                new ContractReadError<BaseToken>({\n                    contractName: ContractName.BASE_TOKEN,\n                    contractFunctionName: \"getClosedPrice\",\n                    context: { baseTokenAddress },\n                    rawError,\n                }),\n        )\n    }\n\n    /**\n     * get index price (twap index price).\n     * @constructor\n     * @param {string} baseTokenAddress -  token address of baseToken\n     * @param {number} interval - interval of twap\n     */\n    async getIndexPrice(baseTokenAddress: string, interval = 0) {\n        return errorGuardAsync(\n            async () => {\n                logger(\"getIndexPrice\")\n                const contract = this.contracts.baseToken.attach(baseTokenAddress)\n                const indexPrice = await contract.getIndexPrice(interval)\n                return bigNumber2BigAndScaleDown(indexPrice)\n            },\n            rawError =>\n                new ContractReadError<BaseToken>({\n                    contractName: ContractName.BASE_TOKEN,\n                    contractFunctionName: \"getIndexPrice\",\n                    args: { interval },\n                    context: { baseTokenAddress },\n                    rawError,\n                }),\n        )\n    }\n\n    async getSlot0(poolAddress: string) {\n        return errorGuardAsync(\n            async () => {\n                logger(\"getSlot0\")\n                return await this.contracts.pool.attach(poolAddress).slot0()\n            },\n            rawError =>\n                new ContractReadError<UniswapV3Pool>({\n                    contractName: ContractName.POOL,\n                    contractFunctionName: \"slot0\",\n                    rawError,\n                }),\n        )\n    }\n\n    async getQuoterSwap({\n        baseTokenAddress,\n        isBaseToQuote,\n        isExactInput,\n        amount,\n    }: GetQuoterSwapParams): Promise<GetQuoterSwapReturn> {\n        return errorGuardAsync(\n            async () => {\n                logger(\"getQuoterSwap\")\n                const { deltaAvailableBase, deltaAvailableQuote, exchangedPositionNotional, exchangedPositionSize } =\n                    await this.contracts.quoter.callStatic.swap({\n                        baseToken: baseTokenAddress,\n                        isBaseToQuote,\n                        isExactInput,\n                        amount: big2BigNumberAndScaleUp(amount),\n                        sqrtPriceLimitX96: 0,\n                    })\n\n                const _deltaAvailableBase = bigNumber2BigAndScaleDown(deltaAvailableBase)\n                const _deltaAvailableQuote = bigNumber2BigAndScaleDown(deltaAvailableQuote)\n                const _exchangedPositionNotional = bigNumber2BigAndScaleDown(exchangedPositionNotional)\n                const _exchangedPositionSize = bigNumber2BigAndScaleDown(exchangedPositionSize)\n                // NOTE:\n                // 1. isBaseToQuote = T, isExactInput = T, => deltaQuote\n                // 2. isBaseToQuote = T, isExactInput = F, => deltaBase\n                // 3. isBaseToQuote = F, isExactInput = F, => deltaQuote\n                // 4. isBaseToQuote = F, isExactInput = T, => deltaBase\n                const output = isBaseToQuote === isExactInput ? _deltaAvailableQuote : _deltaAvailableBase\n\n                return {\n                    deltaAvailableBase: _deltaAvailableBase,\n                    deltaAvailableQuote: _deltaAvailableQuote,\n                    exchangedPositionNotional: _exchangedPositionNotional,\n                    exchangedPositionSize: _exchangedPositionSize,\n                    output,\n                }\n            },\n            (rawError: any) => {\n                const params: ContractReadErrorParams<\"swap\"> = {\n                    contractName: ContractName.QUOTER,\n                    contractFunctionName: \"swap\",\n                    args: {\n                        baseToken: baseTokenAddress,\n                        isBaseToQuote,\n                        isExactInput,\n                        amount: big2BigNumberAndScaleUp(amount),\n                        sqrtPriceLimitX96: 0,\n                    },\n                    rawError,\n                }\n                // NOTE: currently, ethers doesn't provider typing for error\n                // see details in https://github.com/ethers-io/ethers.js/discussions/1556\n                if (\n                    rawError.code === errors.CALL_EXCEPTION &&\n                    rawError.reason === ContractErrorCode.QUOTER_INSUFFICIENT_LIQUIDITY\n                ) {\n                    return new InsufficientLiquidityError(params)\n                }\n                return new ContractReadError<Quoter>(params)\n            },\n        )\n    }\n\n    async getLiquidityPendingFee({ trader, baseTokenAddress, lowerTick, upperTick }: GetLiquidityPendingFeeParams) {\n        return errorGuardAsync(\n            async () => {\n                logger(\"getLiquidityPendingFee\")\n                const fee = await this.contracts.orderBook.getPendingFee(trader, baseTokenAddress, lowerTick, upperTick)\n                return bigNumber2BigAndScaleDown(fee)\n            },\n            rawError =>\n                new ContractReadError<OrderBook>({\n                    contractName: ContractName.ORDERBOOK,\n                    contractFunctionName: \"getPendingFee\",\n                    args: { trader, baseTokenAddress, lowerTick, upperTick },\n                    rawError,\n                }),\n        )\n    }\n\n    async getOpenLiquidityIdsByMarket({ trader, baseTokenAddress }: GetOpenLiquiditiesParams) {\n        return errorGuardAsync(\n            async () => {\n                logger(\"getOpenLiquidityIdsByMarket\")\n                return this.contracts.orderBook.getOpenOrderIds(trader, baseTokenAddress)\n            },\n            rawError =>\n                new ContractReadError<OrderBook>({\n                    contractName: ContractName.ORDERBOOK,\n                    contractFunctionName: \"getOpenOrderIds\",\n                    args: { trader, baseTokenAddress },\n                    rawError,\n                }),\n        )\n    }\n\n    async getOpenLiquidityIds(marketMap: MarketMap, account: string) {\n        const contractCalls = Object.values(marketMap).map(({ baseAddress }) => ({\n            contract: this.contracts.orderBook,\n            contractName: ContractName.ORDERBOOK,\n            funcName: \"getOpenOrderIds\",\n            funcParams: [account, baseAddress],\n        }))\n\n        return errorGuardAsync(\n            async () => {\n                logger(\"getOpenLiquidityIds\")\n                const idsByMarkets = await this._multicallReader.execute([...contractCalls])\n                return idsByMarkets\n            },\n            rawError =>\n                new ContractReadError<Multicall2>({\n                    contractName: ContractName.MULTICALL2,\n                    contractFunctionName: \"tryAggregate\",\n                    args: contractCallsParserForErrorHandling(contractCalls),\n                    rawError,\n                }),\n        )\n    }\n\n    async getOpenLiquidities(marketMap: MarketMap, account: string): Promise<GetOpenLiquidityReturn> {\n        const idsByMarkets = await this.getOpenLiquidityIds(marketMap, account)\n        const contractCalls: ContractCall[] = []\n\n        Object.values(marketMap).forEach(({ baseAddress }, index) => {\n            contractCalls.push(\n                ...idsByMarkets[index].map((id: number) => ({\n                    contract: this.contracts.orderBook,\n                    contractName: ContractName.ORDERBOOK,\n                    funcName: \"getOpenOrderById\",\n                    funcParams: [id],\n                })),\n            )\n        })\n\n        return errorGuardAsync(\n            async () => {\n                logger(\"getOpenLiquidities\")\n                const orders = await this._multicallReader.execute([...contractCalls])\n                let pointer = 0\n                return idsByMarkets.map((ids, index) => {\n                    const len = idsByMarkets[index].length\n                    const result = orders.slice(pointer, pointer + len)\n                    pointer += len\n                    return result.map(({ baseDebt, quoteDebt, liquidity, lowerTick, upperTick }) => ({\n                        baseDebt: bigNumber2BigAndScaleDown(baseDebt),\n                        quoteDebt: bigNumber2BigAndScaleDown(quoteDebt),\n                        liquidity: new Big(liquidity),\n                        lowerTick,\n                        upperTick,\n                    }))\n                })\n            },\n            rawError =>\n                new ContractReadError<Multicall2>({\n                    contractName: ContractName.MULTICALL2,\n                    contractFunctionName: \"tryAggregate\",\n                    args: contractCallsParserForErrorHandling(contractCalls),\n                    rawError,\n                }),\n        )\n    }\n\n    async getOpenLiquiditiesByMarket({ trader, baseTokenAddress }: GetOpenLiquiditiesParams) {\n        const ids = await this.getOpenLiquidityIdsByMarket({ trader, baseTokenAddress })\n        const openLiquidityCalls = ids.map(id => ({\n            contract: this.contracts.orderBook,\n            contractName: ContractName.ORDERBOOK,\n            funcName: \"getOpenOrderById\",\n            funcParams: [id],\n        }))\n\n        return errorGuardAsync(\n            async () => {\n                logger(\"getOpenLiquiditiesByMarket\")\n                const liquidities = await this._multicallReader.execute(openLiquidityCalls)\n                return liquidities.map(({ baseDebt, quoteDebt, liquidity, lowerTick, upperTick }) => ({\n                    baseDebt: bigNumber2BigAndScaleDown(baseDebt),\n                    quoteDebt: bigNumber2BigAndScaleDown(quoteDebt),\n                    liquidity: bigNumber2BigAndScaleDown(liquidity),\n                    lowerTick,\n                    upperTick,\n                }))\n            },\n            rawError =>\n                new ContractReadError<Multicall2>({\n                    contractName: ContractName.MULTICALL2,\n                    contractFunctionName: \"tryAggregate\",\n                    args: contractCallsParserForErrorHandling(openLiquidityCalls),\n                    rawError,\n                }),\n        )\n    }\n\n    async getOpenOrder({ trader, baseTokenAddress, lowerTick, upperTick }: GetOpenLiquidityParams) {\n        return errorGuardAsync(\n            async () => {\n                logger(\"getOpenOrder\")\n                const info = await this.contracts.orderBook.getOpenOrder(trader, baseTokenAddress, lowerTick, upperTick)\n                return {\n                    baseDebt: bigNumber2BigAndScaleDown(info.baseDebt),\n                    quoteDebt: bigNumber2BigAndScaleDown(info.quoteDebt),\n                    liquidity: bigNumber2BigAndScaleDown(info.liquidity),\n                    lowerTick: info.lowerTick,\n                    upperTick: info.upperTick,\n                }\n            },\n            rawError =>\n                new ContractReadError<OrderBook>({\n                    contractName: ContractName.ORDERBOOK,\n                    contractFunctionName: \"getOpenOrder\",\n                    args: { trader, baseTokenAddress, lowerTick, upperTick },\n                    rawError,\n                }),\n        )\n    }\n\n    async getTotalTokenAmountInPoolAndPendingFeeOfAllMarkets(marketMap: MarketMap, trader: string) {\n        const contractCalls = Object.values(marketMap).map(({ baseAddress }) => ({\n            contract: this.contracts.orderBook,\n            contractName: ContractName.ORDERBOOK,\n            funcName: \"getTotalTokenAmountInPoolAndPendingFee\",\n            funcParams: [trader, baseAddress, false],\n        }))\n\n        return errorGuardAsync(\n            async () => {\n                logger(\"getTotalTokenAmountInPoolAndPendingFeeOfAllMarkets\")\n                const result = await this._multicallReader.execute([...contractCalls])\n                return Object.values(marketMap).reduce((acc, market, index) => {\n                    const [_totalTokenAmount, _totalPendingFee] = result[index]\n                    return {\n                        ...acc,\n                        [market.baseAddress]: {\n                            totalTokenAmount: bigNumber2BigAndScaleDown(_totalTokenAmount),\n                            totalPendingFee: bigNumber2BigAndScaleDown(_totalPendingFee),\n                        },\n                    }\n                }, {} as GetTotalTokenAmountInPoolAndPendingFeeOfAllMarketsReturn)\n            },\n            rawError =>\n                new ContractReadError<Multicall2>({\n                    contractName: ContractName.MULTICALL2,\n                    contractFunctionName: \"tryAggregate\",\n                    args: contractCallsParserForErrorHandling(contractCalls),\n                    rawError,\n                }),\n        )\n    }\n\n    async simulateOpenPosition({\n        baseTokenAddress,\n        isBaseToQuote,\n        isExactInput,\n        amount,\n        oppositeAmountBound,\n    }: SimulateOpenPositionParams) {\n        const args = {\n            baseToken: baseTokenAddress,\n            isBaseToQuote,\n            isExactInput,\n            amount: big2BigNumberAndScaleUp(amount),\n            oppositeAmountBound: big2BigNumberAndScaleUp(oppositeAmountBound),\n            sqrtPriceLimitX96: 0, // NOTE: this is for partial filled, disable by giving zero.\n            deadline: constants.MaxUint256, // NOTE: not important yet\n            referralCode: constants.HashZero, // NOTE: not important yet\n        }\n\n        return errorGuardAsync(\n            async () => {\n                logger(\"simulateOpenPosition\")\n                const { base, quote } = await this.contracts.clearingHouse.callStatic.openPosition(args)\n                return { deltaBase: bigNumber2BigAndScaleDown(base), deltaQuote: bigNumber2BigAndScaleDown(quote) }\n            },\n            (rawError: any) => {\n                const params: ContractReadErrorParams<\"openPosition\"> = {\n                    contractName: ContractName.CLEARINGHOUSE,\n                    contractFunctionName: \"openPosition\",\n                    args: args,\n                    rawError,\n                }\n\n                const contractErrorCode = extractContractErrorCode(rawError)\n                if (contractErrorCode === ContractErrorCode.NOT_ENOUGH_FREE_COLLATERAL) {\n                    return new NotEnoughFreeCollateralError({ ...params, contractErrorCode })\n                } else if (contractErrorCode === ContractErrorCode.UNISWAP_BROKER_INSUFFICIENT_LIQUIDITY) {\n                    return new UniswapBrokerInsufficientLiquidityError({ ...params, contractErrorCode })\n                } else if (contractErrorCode === ContractErrorCode.OVER_PRICE_LIMIT_AFTER_SWAP) {\n                    return new OverPriceLimitAfterSwapError({\n                        contractName: ContractName.CLEARINGHOUSE,\n                        contractFunctionName: \"swap\",\n                        contractErrorCode,\n                        rawError,\n                    })\n                } else if (contractErrorCode === ContractErrorCode.MARKET_NUMBER_EXCEEDS) {\n                    return new MarketNumberExceedsError({\n                        contractName: ContractName.ACCOUNT_BALANCE,\n                        contractFunctionName: \"registerBaseToken\",\n                        contractErrorCode,\n                        rawError,\n                    })\n                }\n                return new ContractReadError<ClearingHouse>(params)\n            },\n        )\n    }\n    async getMarketsBaseTokenAndQuoteTokenAmount(marketsInfo: marketInfo[]) {\n        const baseTokens = marketsInfo.map(market => {\n            const { baseToken, pool } = market\n            return {\n                contract: this.contracts.createIERC20Token(baseToken),\n                contractName: ContractName.Token0,\n                funcName: \"balanceOf\",\n                funcParams: [pool],\n            }\n        })\n        const quoteTokens = marketsInfo.map(market => {\n            const { quoteToken, pool } = market\n            return {\n                contract: this.contracts.createIERC20Token(quoteToken),\n                contractName: ContractName.Token1,\n                funcName: \"balanceOf\",\n                funcParams: [pool],\n            }\n        })\n        const contractCall = [...baseTokens, ...quoteTokens]\n        return errorGuardAsync(\n            async () => {\n                logger(\"getMarketsBaseTokenAndQuoteTokenAmount\")\n                const result = await this._multicallReader.execute(contractCall, { returnByContractAndFuncName: true })\n                const quoteAmount = result[genKeyFromContractAndFuncName(quoteTokens[0])]\n                const baseAmount = result[genKeyFromContractAndFuncName(baseTokens[0])]\n\n                return marketsInfo.reduce((curr, market, index) => {\n                    const { pool } = market\n                    return {\n                        ...curr,\n                        [pool]: {\n                            quoteAmount: bigNumber2BigAndScaleDown(quoteAmount[index]).toString(),\n                            baseAmount: bigNumber2BigAndScaleDown(baseAmount[index]).toString(),\n                        },\n                    }\n                }, {})\n            },\n            rawError =>\n                new ContractReadError<Multicall2>({\n                    contractName: ContractName.MULTICALL2,\n                    contractFunctionName: \"tryAggregate\",\n                    args: contractCallsParserForErrorHandling(contractCall),\n                    rawError,\n                }),\n        )\n    }\n    /* ===== Multicall Reader ===== */\n    async getClearingHouseMetadata() {\n        const mmRatioMulticallArgs = {\n            contract: this.contracts.clearingHouseConfig,\n            contractName: ContractName.CLEARINGHOUSE_CONFIG,\n            funcName: \"getMmRatio\",\n            funcParams: [],\n        }\n        const imRatioMulticallArgs = {\n            contract: this.contracts.clearingHouseConfig,\n            contractName: ContractName.CLEARINGHOUSE_CONFIG,\n            funcName: \"getImRatio\",\n            funcParams: [],\n        }\n        const maxFundingRateMulticallArgs = {\n            contract: this.contracts.clearingHouseConfig,\n            contractName: ContractName.CLEARINGHOUSE_CONFIG,\n            funcName: \"getMaxFundingRate\",\n            funcParams: [],\n        }\n        const twapIntervalMulticallArgs = {\n            contract: this.contracts.clearingHouseConfig,\n            contractName: ContractName.CLEARINGHOUSE_CONFIG,\n            funcName: \"getTwapInterval\",\n            funcParams: [],\n        }\n        const baseAddresses = this._metadata.pools.map(pool => {\n            return pool.baseAddress\n        })\n        const marketInfoMulticallArgs = baseAddresses.map(address => ({\n            contract: this.contracts.marketRegistry,\n            contractName: ContractName.MARKET_REGISTRY,\n            funcName: \"getMarketInfo\",\n            funcParams: [address],\n        }))\n        const poolAddresses = this._metadata.pools.map(pool => {\n            return pool.address\n        })\n        const tickSpacingMulticallArgs = poolAddresses.map(address => ({\n            contract: this.contracts.pool.attach(address),\n            contractName: ContractName.POOL,\n            funcName: \"tickSpacing\",\n            funcParams: [],\n        }))\n        const contractCalls = [\n            mmRatioMulticallArgs,\n            imRatioMulticallArgs,\n            maxFundingRateMulticallArgs,\n            twapIntervalMulticallArgs,\n            ...marketInfoMulticallArgs,\n            ...tickSpacingMulticallArgs,\n        ]\n\n        return errorGuardAsync(\n            async () => {\n                logger(\"getClearingHouseMetadata\")\n                const result = await this._multicallReader.execute(contractCalls, { returnByContractAndFuncName: true })\n                const [mmRatio] = result[genKeyFromContractAndFuncName(mmRatioMulticallArgs)]\n                const [imRatio] = result[genKeyFromContractAndFuncName(imRatioMulticallArgs)]\n                const [maxFundingRate] = result[genKeyFromContractAndFuncName(maxFundingRateMulticallArgs)]\n                const [twapInterval] = result[genKeyFromContractAndFuncName(twapIntervalMulticallArgs)]\n\n                const marketInfoList = result[genKeyFromContractAndFuncName(marketInfoMulticallArgs[0])]\n                const rawTickSpacings = result[genKeyFromContractAndFuncName(tickSpacingMulticallArgs[0])]\n\n                const exchangeFeeRatios = baseAddresses.reduce((obj, curr, index) => {\n                    obj[curr] = scaleDownDecimals(new Big(marketInfoList[index].exchangeFeeRatio), RATIO_DECIMAL)\n                    return obj\n                }, {} as Record<string, Big>)\n                const insuranceFundFeeRatios = baseAddresses.reduce((obj, curr, index) => {\n                    obj[curr] = scaleDownDecimals(new Big(marketInfoList[index].insuranceFundFeeRatio), RATIO_DECIMAL)\n                    return obj\n                }, {} as Record<string, Big>)\n                const tickSpacings = poolAddresses.reduce((obj, curr, index) => {\n                    obj[curr] = rawTickSpacings[index]\n                    return obj\n                }, {} as Record<string, number>)\n\n                return {\n                    mmRatio: new Big(mmRatio),\n                    imRatio: new Big(imRatio),\n                    maxFundingRate: new Big(maxFundingRate),\n                    twapInterval: new Big(twapInterval),\n                    exchangeFeeRatios,\n                    insuranceFundFeeRatios,\n                    tickSpacings,\n                }\n            },\n            rawError =>\n                new ContractReadError<Multicall2>({\n                    contractName: ContractName.MULTICALL2,\n                    contractFunctionName: \"tryAggregate\",\n                    args: contractCallsParserForErrorHandling(contractCalls),\n                    rawError,\n                }),\n        )\n    }\n\n    async getTakerPositionSizeList(marketMap: MarketMap, account: string) {\n        const getAllPositionSizeContractCalls = Object.values(marketMap).map(({ baseAddress }) => ({\n            contract: this.contracts.accountBalance,\n            contractName: ContractName.ACCOUNT_BALANCE,\n            funcName: \"getTakerPositionSize\",\n            funcParams: [account, baseAddress],\n        }))\n        return errorGuardAsync(\n            async () => {\n                logger(\"getTakerPositionSizeList\")\n                const rawPositionSizeList = await this._multicallReader.execute([...getAllPositionSizeContractCalls])\n                return rawPositionSizeList.map(size => bigNumber2BigAndScaleDown(size))\n            },\n            rawError =>\n                new ContractReadError<Multicall2>({\n                    contractName: ContractName.MULTICALL2,\n                    contractFunctionName: \"tryAggregate\",\n                    args: contractCallsParserForErrorHandling(getAllPositionSizeContractCalls),\n                    rawError,\n                }),\n        )\n    }\n\n    async getTotalPositionSizeList(marketMap: MarketMap, account: string) {\n        const getAllPositionSizeContractCalls = Object.values(marketMap).map(({ baseAddress }) => ({\n            contract: this.contracts.accountBalance,\n            contractName: ContractName.ACCOUNT_BALANCE,\n            funcName: \"getTotalPositionSize\",\n            funcParams: [account, baseAddress],\n        }))\n        return errorGuardAsync(\n            async () => {\n                logger(\"getTotalPositionSizeList\")\n                const rawPositionSizeList = await this._multicallReader.execute([...getAllPositionSizeContractCalls])\n                return rawPositionSizeList.map(size => bigNumber2BigAndScaleDown(size))\n            },\n            rawError =>\n                new ContractReadError<Multicall2>({\n                    contractName: ContractName.MULTICALL2,\n                    contractFunctionName: \"tryAggregate\",\n                    args: contractCallsParserForErrorHandling(getAllPositionSizeContractCalls),\n                    rawError,\n                }),\n        )\n    }\n\n    async getTakerOpenNotionalList(marketMap: MarketMap, account: string) {\n        const getAllOpenNotionalContractCalls = Object.values(marketMap).map(({ baseAddress }) => ({\n            contract: this.contracts.accountBalance,\n            contractName: ContractName.ACCOUNT_BALANCE,\n            funcName: \"getTakerOpenNotional\",\n            funcParams: [account, baseAddress],\n        }))\n        return errorGuardAsync(\n            async () => {\n                logger(\"getTakerOpenNotionalList\")\n                const rawOpenNotionalList = await this._multicallReader.execute([...getAllOpenNotionalContractCalls])\n                return rawOpenNotionalList.map(openNotional => bigNumber2BigAndScaleDown(openNotional))\n            },\n            rawError =>\n                new ContractReadError<Multicall2>({\n                    contractName: ContractName.MULTICALL2,\n                    contractFunctionName: \"tryAggregate\",\n                    args: contractCallsParserForErrorHandling(getAllOpenNotionalContractCalls),\n                    rawError,\n                }),\n        )\n    }\n\n    async getTotalOpenNotionalList(marketMap: MarketMap, account: string) {\n        const getAllOpenNotionalContractCalls = Object.values(marketMap).map(({ baseAddress }) => ({\n            contract: this.contracts.accountBalance,\n            contractName: ContractName.ACCOUNT_BALANCE,\n            funcName: \"getTotalOpenNotional\",\n            funcParams: [account, baseAddress],\n        }))\n        return errorGuardAsync(\n            async () => {\n                logger(\"getTotalOpenNotionalList\")\n                const rawOpenNotionalList = await this._multicallReader.execute([...getAllOpenNotionalContractCalls])\n                return rawOpenNotionalList.map(openNotional => bigNumber2BigAndScaleDown(openNotional))\n            },\n            rawError =>\n                new ContractReadError<Multicall2>({\n                    contractName: ContractName.MULTICALL2,\n                    contractFunctionName: \"tryAggregate\",\n                    args: contractCallsParserForErrorHandling(getAllOpenNotionalContractCalls),\n                    rawError,\n                }),\n        )\n    }\n\n    async getTotalPositionValueList(marketMap: MarketMap, account: string) {\n        const getTotalPositionValueCalls = Object.values(marketMap).map(({ baseAddress }) => ({\n            contract: this.contracts.accountBalance,\n            contractName: ContractName.ACCOUNT_BALANCE,\n            funcName: \"getTotalPositionValue\",\n            funcParams: [account, baseAddress],\n        }))\n        return errorGuardAsync(\n            async () => {\n                logger(\"getTotalPositionValueList\")\n                const rawList = await this._multicallReader.execute([...getTotalPositionValueCalls])\n                return rawList.map(totalPositionValue => bigNumber2BigAndScaleDown(totalPositionValue))\n            },\n            rawError =>\n                new ContractReadError<Multicall2>({\n                    contractName: ContractName.MULTICALL2,\n                    contractFunctionName: \"tryAggregate\",\n                    args: contractCallsParserForErrorHandling(getTotalPositionValueCalls),\n                    rawError,\n                }),\n        )\n    }\n\n    async getPendingFundingPayments(marketMap: MarketMap, account: string) {\n        const contractCallParams = Object.values(marketMap).map(({ baseAddress }) => ({\n            contract: this.contracts.exchange,\n            contractName: ContractName.EXCHANGE,\n            funcName: \"getPendingFundingPayment\",\n            funcParams: [account, baseAddress],\n        }))\n        return errorGuardAsync(\n            async () => {\n                logger(\"getPendingFundingPayments\")\n                const rawPendingFundingPaymentList = await this._multicallReader.execute([...contractCallParams])\n                return Object.values(marketMap).reduce<Record<string, Big>>(\n                    (acc, next, index) => ({\n                        ...acc,\n                        [next.tickerSymbol]: bigNumber2BigAndScaleDown(rawPendingFundingPaymentList[index]),\n                    }),\n                    {},\n                )\n            },\n            rawError =>\n                new ContractReadError<Multicall2>({\n                    contractName: ContractName.MULTICALL2,\n                    contractFunctionName: \"tryAggregate\",\n                    args: contractCallsParserForErrorHandling(contractCallParams),\n                    rawError,\n                }),\n        )\n    }\n\n    async getMarketData(args: MulticallMarketDataArgs) {\n        const contractCalls = [\n            {\n                contract: this.contracts.pool.attach(args.poolAddress),\n                contractName: ContractName.POOL,\n                funcName: \"slot0\",\n                funcParams: [],\n            },\n            {\n                contract: this.contracts.baseToken.attach(args.baseAddress),\n                contractName: ContractName.BASE_TOKEN,\n                funcName: \"getIndexPrice\",\n                funcParams: [0],\n            },\n            {\n                contract: this.contracts.baseToken.attach(args.baseAddress),\n                contractName: ContractName.BASE_TOKEN,\n                funcName: \"getIndexPrice\",\n                funcParams: [args.twapTimeRange],\n            },\n        ]\n        return errorGuardAsync(\n            async () => {\n                logger(\"getMarketData\")\n                const multicallResult = await this._multicallReader.execute(contractCalls)\n                const [markPrice, indexPrice, indexTwapPrice] = multicallResult.map((value, index) => {\n                    if (index === 0) {\n                        // NOTE: multicallResult[0] = slot0, and we only need slot0.sqrtPriceX96 to calculate the markPrice\n                        const { sqrtPriceX96 } = value\n                        return fromSqrtX96(sqrtPriceX96)\n                    }\n                    return bigNumber2BigAndScaleDown(value)\n                })\n                return {\n                    markPrice,\n                    indexPrice,\n                    indexTwapPrice,\n                }\n            },\n            rawError =>\n                new ContractReadError<Multicall2>({\n                    contractName: ContractName.MULTICALL2,\n                    contractFunctionName: \"tryAggregate\",\n                    args: contractCallsParserForErrorHandling(contractCalls),\n                    rawError,\n                }),\n        )\n    }\n\n    async getPositionDraftRelatedData({\n        trader,\n        marketBaseAddresses,\n        currentMarketBaseSize,\n        currentMarketBaseAddress,\n    }: GetPositionDraftRelatedData) {\n        const swapCall = {\n            contract: this.contracts.quoter,\n            contractName: ContractName.QUOTER,\n            funcName: \"swap\",\n            funcParams: [\n                {\n                    baseToken: currentMarketBaseAddress,\n                    isBaseToQuote: true,\n                    isExactInput: true,\n                    amount: big2BigNumberAndScaleUp(currentMarketBaseSize),\n                    sqrtPriceLimitX96: 0,\n                },\n            ],\n        }\n        const getPnlAndPendingFeeCall = {\n            contract: this.contracts.accountBalance,\n            contractName: ContractName.ACCOUNT_BALANCE,\n            funcName: \"getPnlAndPendingFee\",\n            funcParams: [trader],\n        }\n        const otherMarketBaseAddresses = marketBaseAddresses.filter(address => address !== currentMarketBaseAddress)\n        const otherBaseDebtCalls = otherMarketBaseAddresses.map(baseAddress => ({\n            contract: this.contracts.accountBalance,\n            contractName: ContractName.ACCOUNT_BALANCE,\n            funcName: \"getBase\",\n            funcParams: [trader, baseAddress],\n        }))\n        const otherMarketIndexPriceCalls = otherMarketBaseAddresses.map(baseAddress => ({\n            contract: this.contracts.baseToken.attach(baseAddress),\n            contractName: ContractName.BASE_TOKEN,\n            funcName: \"getIndexPrice\",\n            funcParams: [0],\n        }))\n        const quoteDebtCalls = marketBaseAddresses.map(baseAddress => ({\n            contract: this.contracts.accountBalance,\n            contractName: ContractName.ACCOUNT_BALANCE,\n            funcName: \"getQuote\",\n            funcParams: [trader, baseAddress],\n        }))\n        const contractCalls = [\n            swapCall,\n            getPnlAndPendingFeeCall,\n            ...otherBaseDebtCalls,\n            ...otherMarketIndexPriceCalls,\n            ...quoteDebtCalls,\n        ]\n        return errorGuardAsync(\n            async () => {\n                logger(\"getPositionDraftRelatedData\")\n                const result = await this._multicallReader.execute(contractCalls, {\n                    returnByContractAndFuncName: true,\n                    failFirstByClient: false,\n                    failFirstByContract: false,\n                })\n                const [{ deltaAvailableBase, deltaAvailableQuote, exchangedPositionNotional, exchangedPositionSize }] =\n                    result[genKeyFromContractAndFuncName(swapCall)]\n\n                const [[owedPNL, unrealizedPNL, pendingFee]] =\n                    result[genKeyFromContractAndFuncName(getPnlAndPendingFeeCall)]\n\n                const otherBaseDebts = result[genKeyFromContractAndFuncName(otherBaseDebtCalls[0])]\n                const otherMarketIndexPrices = result[genKeyFromContractAndFuncName(otherMarketIndexPriceCalls[0])]\n                const quoteDebts = result[genKeyFromContractAndFuncName(quoteDebtCalls[0])]\n\n                const _deltaAvailableBase = deltaAvailableBase && bigNumber2BigAndScaleDown(deltaAvailableBase)\n                const _deltaAvailableQuote = deltaAvailableQuote && bigNumber2BigAndScaleDown(deltaAvailableQuote)\n                const _exchangedPositionNotional =\n                    exchangedPositionNotional && bigNumber2BigAndScaleDown(exchangedPositionNotional)\n                const _exchangedPositionSize = exchangedPositionSize && bigNumber2BigAndScaleDown(exchangedPositionSize)\n                const swapOutput = _deltaAvailableQuote\n\n                const _owedPNL = bigNumber2BigAndScaleDown(owedPNL)\n                const _unrealizedPNL = bigNumber2BigAndScaleDown(unrealizedPNL)\n                const _pendingFee = bigNumber2BigAndScaleDown(pendingFee)\n                const _otherBaseDebts = otherBaseDebts.map((baseDebt: BigNumber) => bigNumber2BigAndScaleDown(baseDebt))\n                const _otherMarketIndexPrices = otherMarketIndexPrices.map((indexPrice: BigNumber) =>\n                    bigNumber2BigAndScaleDown(indexPrice),\n                )\n                const _quoteDebts = quoteDebts.map((quoteDebt: BigNumber) => bigNumber2BigAndScaleDown(quoteDebt))\n                return {\n                    swap: {\n                        deltaAvailableBase: _deltaAvailableBase,\n                        deltaAvailableQuote: _deltaAvailableQuote,\n                        exchangedPositionNotional: _exchangedPositionNotional,\n                        exchangedPositionSize: _exchangedPositionSize,\n                        output: swapOutput,\n                    },\n                    getPnlAndPendingFee: {\n                        owedPNL: _owedPNL,\n                        unrealizedPNL: _unrealizedPNL,\n                        pendingFee: _pendingFee,\n                    },\n                    otherBaseDebts: _otherBaseDebts,\n                    otherMarketIndexPrices: _otherMarketIndexPrices,\n                    quoteDebts: _quoteDebts,\n                }\n            },\n            (rawError: any) => {\n                if (\n                    rawError.code === errors.CALL_EXCEPTION &&\n                    rawError.reason === ContractErrorCode.QUOTER_INSUFFICIENT_LIQUIDITY\n                ) {\n                    const params: ContractReadErrorParams<\"swap\"> = {\n                        contractName: ContractName.QUOTER,\n                        contractFunctionName: \"swap\",\n                        args: swapCall.funcParams[0],\n                        rawError,\n                    }\n                    return new InsufficientLiquidityError(params)\n                }\n\n                return new ContractReadError<Multicall2>({\n                    contractName: ContractName.MULTICALL2,\n                    contractFunctionName: \"tryAggregate\",\n                    args: contractCallsParserForErrorHandling(contractCalls),\n                    rawError,\n                })\n            },\n        )\n    }\n\n    async getAccountValues(account: string) {\n        const contractCalls = [\n            {\n                contract: this.contracts.vault,\n                contractName: ContractName.VAULT,\n                funcName: \"getFreeCollateral\",\n                funcParams: [account],\n            },\n            {\n                contract: this.contracts.clearingHouse,\n                contractName: ContractName.CLEARINGHOUSE,\n                funcName: \"getAccountValue\",\n                funcParams: [account],\n            },\n        ]\n        return errorGuardAsync(\n            async () => {\n                logger(\"getAccountValues\")\n                const multicallResult = await this._multicallReader.execute(contractCalls)\n                const freeCollateral = bigNumber2BigAndScaleDown(multicallResult[0], COLLATERAL_TOKEN_DECIMAL)\n                const accountValue = bigNumber2BigAndScaleDown(multicallResult[1])\n                return {\n                    freeCollateral,\n                    accountValue,\n                }\n            },\n            rawError =>\n                new ContractReadError<Multicall2>({\n                    contractName: ContractName.MULTICALL2,\n                    contractFunctionName: \"tryAggregate\",\n                    args: contractCallsParserForErrorHandling(contractCalls),\n                    rawError,\n                }),\n        )\n    }\n\n    async getTotalPositionValue(trader: string, baseToken: string) {\n        return errorGuardAsync(\n            async () => {\n                logger(\"getTotalPositionValue\")\n                const positionValue = await this.contracts.accountBalance.getTotalPositionValue(trader, baseToken)\n                return bigNumber2BigAndScaleDown(positionValue)\n            },\n            (rawError: any) =>\n                new ContractReadError({\n                    contractName: ContractName.ACCOUNT_BALANCE,\n                    contractFunctionName: \"getTotalPositionValue\",\n                    args: { trader, baseToken },\n                    rawError,\n                }),\n        )\n    }\n\n    async getTotalAbsPositionValue(trader: string) {\n        return errorGuardAsync(\n            async () => {\n                logger(\"getTotalAbsPositionValue\")\n                const value = await this.contracts.accountBalance.getTotalAbsPositionValue(trader)\n                return bigNumber2BigAndScaleDown(value)\n            },\n            (rawError: any) =>\n                new ContractReadError({\n                    contractName: ContractName.ACCOUNT_BALANCE,\n                    contractFunctionName: \"getTotalAbsPositionValue\",\n                    args: { trader },\n                    rawError,\n                }),\n        )\n    }\n\n    async getLiquidationPrice(trader: string, baseToken: string) {\n        return errorGuardAsync(\n            async () => {\n                logger(\"getLiquidationPrice\")\n                const liquidationPrice = await this.contracts.perpPortal.getLiquidationPrice(trader, baseToken)\n                return bigNumber2BigAndScaleDown(liquidationPrice)\n            },\n            (rawError: any) =>\n                new ContractReadError({\n                    contractName: ContractName.PerpPortal,\n                    contractFunctionName: \"getLiquidationPrice\",\n                    args: { trader, baseToken },\n                    rawError,\n                }),\n        )\n    }\n    // only taker position need this\n    async getLiquidationPriceList(marketMap: MarketMap, account: string) {\n        const contractCalls = Object.values(marketMap).map(({ baseAddress }) => ({\n            contract: this.contracts.perpPortal,\n            contractName: ContractName.PerpPortal,\n            funcName: \"getLiquidationPrice\",\n            funcParams: [account, baseAddress],\n        }))\n        return errorGuardAsync(\n            async () => {\n                logger(\"getLiquidationPriceList\")\n                const liquidationPriceList = await this._multicallReader.execute([...contractCalls])\n                return liquidationPriceList.map(liquidationPrice => bigNumber2BigAndScaleDown(liquidationPrice))\n            },\n            rawError =>\n                new ContractReadError<Multicall2>({\n                    contractName: ContractName.MULTICALL2,\n                    contractFunctionName: \"tryAggregate\",\n                    args: contractCallsParserForErrorHandling(contractCalls),\n                    rawError,\n                }),\n        )\n    }\n\n    async getClearingHouseOpenPositionAction() {\n        return errorGuardAsync(\n            async () => {\n                logger(\"getClearingHouseOpenPositionAction\")\n                return await this.contracts.delegateApproval.getClearingHouseOpenPositionAction()\n            },\n            rawError =>\n                new ContractReadError<DelegateApproval>({\n                    contractName: ContractName.DelegateApproval,\n                    contractFunctionName: \"getClearingHouseOpenPositionAction\",\n                    rawError,\n                }),\n        )\n    }\n\n    async canOpenPositionFor(trader: string, delegate: string) {\n        return errorGuardAsync(\n            async () => {\n                logger(\"canOpenPositionFor\")\n                return await this.contracts.delegateApproval.canOpenPositionFor(trader, delegate)\n            },\n            rawError =>\n                new ContractReadError<DelegateApproval>({\n                    contractName: ContractName.DelegateApproval,\n                    contractFunctionName: \"canOpenPositionFor\",\n                    rawError,\n                }),\n        )\n    }\n}\n"],"names":["constructor","contracts","provider","metadata","this","_provider","_metadata","_multicallReader","MulticallReader","contract","multicall2","async","account","errorGuardAsync","logger","balance","getBalance","bigNumber2BigAndScaleDown","rawError","ContractReadError","contractName","contractFunctionName","args","accountValue","vault","getAccountValue","SETTLEMENT_TOKEN_DECIMAL","ContractName","VAULT","freeCollateral","getFreeCollateral","COLLATERAL_TOKEN_DECIMAL","token","tokenAddress","address","tokenDecimals","decimals","getFreeCollateralByToken","getSettlementTokenValue","getBalanceByToken","collateralManager","collateralConfig","getCollateralConfig","priceFeed","collateralRatio","discountRatio","depositCap","collateralToken","collateralTokenMap","get","scaleDownDecimals","Big","RATIO_DECIMAL","toNumber","COLLATERAL_MANAGER","spender","_a","Error","allowance","Promise","all","COLLATERAL_TOKENS","settlementToken","SETTLEMENT_TOKEN","balanceOf","baseTokenAddress","contractBaseToken","baseToken","attach","priceFeedAddress","getPriceFeed","contractPriceFeed","baseTokenPriceFeed","aggregatorAddress","getAggregator","baseTokenPriceFeedAggregator","CHAINLINK_PRICE_FEED","context","BASE_TOKEN","isPaused","isClosed","contractCalls","funcName","funcParams","execute","MULTICALL2","contractCallsParserForErrorHandling","closedPrice","getClosedPrice","interval","indexPrice","getIndexPrice","poolAddress","pool","slot0","POOL","isBaseToQuote","isExactInput","amount","deltaAvailableBase","deltaAvailableQuote","exchangedPositionNotional","exchangedPositionSize","quoter","callStatic","swap","big2BigNumberAndScaleUp","sqrtPriceLimitX96","_deltaAvailableBase","_deltaAvailableQuote","output","params","QUOTER","code","errors","CALL_EXCEPTION","reason","ContractErrorCode","QUOTER_INSUFFICIENT_LIQUIDITY","InsufficientLiquidityError","trader","lowerTick","upperTick","fee","orderBook","getPendingFee","ORDERBOOK","getOpenOrderIds","marketMap","Object","values","map","baseAddress","idsByMarkets","getOpenLiquidityIds","forEach","index","push","id","orders","pointer","ids","len","length","result","slice","baseDebt","quoteDebt","liquidity","openLiquidityCalls","getOpenLiquidityIdsByMarket","info","getOpenOrder","reduce","acc","market","_totalTokenAmount","_totalPendingFee","totalTokenAmount","totalPendingFee","oppositeAmountBound","deadline","constants","MaxUint256","referralCode","HashZero","base","quote","clearingHouse","openPosition","deltaBase","deltaQuote","CLEARINGHOUSE","contractErrorCode","extractContractErrorCode","NOT_ENOUGH_FREE_COLLATERAL","NotEnoughFreeCollateralError","UNISWAP_BROKER_INSUFFICIENT_LIQUIDITY","UniswapBrokerInsufficientLiquidityError","OVER_PRICE_LIMIT_AFTER_SWAP","OverPriceLimitAfterSwapError","MARKET_NUMBER_EXCEEDS","MarketNumberExceedsError","ACCOUNT_BALANCE","marketsInfo","baseTokens","createIERC20Token","Token0","quoteTokens","quoteToken","Token1","contractCall","returnByContractAndFuncName","quoteAmount","genKeyFromContractAndFuncName","baseAmount","curr","toString","mmRatioMulticallArgs","clearingHouseConfig","CLEARINGHOUSE_CONFIG","imRatioMulticallArgs","maxFundingRateMulticallArgs","twapIntervalMulticallArgs","baseAddresses","pools","marketInfoMulticallArgs","marketRegistry","MARKET_REGISTRY","poolAddresses","tickSpacingMulticallArgs","mmRatio","imRatio","maxFundingRate","twapInterval","marketInfoList","rawTickSpacings","exchangeFeeRatios","obj","exchangeFeeRatio","insuranceFundFeeRatios","insuranceFundFeeRatio","tickSpacings","getAllPositionSizeContractCalls","accountBalance","size","getAllOpenNotionalContractCalls","openNotional","getTotalPositionValueCalls","totalPositionValue","contractCallParams","exchange","EXCHANGE","rawPendingFundingPaymentList","next","tickerSymbol","twapTimeRange","multicallResult","markPrice","indexTwapPrice","value","sqrtPriceX96","fromSqrtX96","marketBaseAddresses","currentMarketBaseSize","currentMarketBaseAddress","swapCall","getPnlAndPendingFeeCall","otherMarketBaseAddresses","filter","otherBaseDebtCalls","otherMarketIndexPriceCalls","quoteDebtCalls","failFirstByClient","failFirstByContract","owedPNL","unrealizedPNL","pendingFee","otherBaseDebts","otherMarketIndexPrices","quoteDebts","getPnlAndPendingFee","positionValue","getTotalPositionValue","getTotalAbsPositionValue","liquidationPrice","perpPortal","getLiquidationPrice","PerpPortal","delegateApproval","getClearingHouseOpenPositionAction","DelegateApproval","delegate","canOpenPositionFor"],"mappings":"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"}