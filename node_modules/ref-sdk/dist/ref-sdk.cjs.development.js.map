{"version":3,"file":"ref-sdk.cjs.development.js","sources":["../src/constant.ts","../src/error.ts","../src/utils.ts","../src/instantSwap.ts","../src/ref.ts","../src/pool.ts","../src/stable-swap.ts","../src/parallelSwapLogic.ts","../src/smartRoutingLogic.js","../src/swap.ts","../src/sendTransactions.ts"],"sourcesContent":["export const FEE_DIVISOR = 10000;\n\nexport const STABLE_LP_TOKEN_DECIMALS = 18;\nexport const RATED_POOL_LP_TOKEN_DECIMALS = 24;\n\nexport function getConfig(env: string | undefined = process.env.NEAR_ENV) {\n  switch (env) {\n    case 'mainnet':\n      return {\n        networkId: 'mainnet',\n        nodeUrl: 'https://rpc.mainnet.near.org',\n        walletUrl: 'https://wallet.near.org',\n        WRAP_NEAR_CONTRACT_ID: 'wrap.near',\n        REF_FI_CONTRACT_ID: 'v2.ref-finance.near',\n      };\n    case 'testnet':\n      return {\n        networkId: 'testnet',\n        nodeUrl: 'https://rpc.testnet.near.org',\n        walletUrl: 'https://wallet.testnet.near.org',\n        WRAP_NEAR_CONTRACT_ID: 'wrap.testnet',\n        REF_FI_CONTRACT_ID: 'ref-finance-101.testnet',\n      };\n    default:\n      return {\n        networkId: 'mainnet',\n        nodeUrl: 'https://rpc.mainnet.near.org',\n        walletUrl: 'https://wallet.near.org',\n        REF_FI_CONTRACT_ID: 'v2.ref-finance.near',\n        WRAP_NEAR_CONTRACT_ID: 'wrap.near',\n      };\n  }\n}\n\nexport const config = getConfig();\n\nexport const REF_FI_CONTRACT_ID = config.REF_FI_CONTRACT_ID;\n\nexport const STORAGE_TO_REGISTER_WITH_MFT = '0.1';\n\nexport const ONE_YOCTO_NEAR = '0.000000000000000000000001';\n\n// export const REF_FI_CONTRACT_ID = 'exchange.ref-dev.testnet';\n\n// export const config = {\n//   networkId: 'testnet',\n//   nodeUrl: 'https://rpc.testnet.near.org',\n//   walletUrl: 'https://wallet.testnet.near.org',\n// };\n","import { getConfig } from './constant';\n\nexport const formatError = (msg: string) => {\n  return new Error(msg);\n};\n\nexport const unNamedError = formatError('Something wrong happened');\n\nexport const SameInputTokenError = formatError(\n  'Input token should be different with output token'\n);\n\nexport const ZeroInputError = formatError(\n  'Input amount should be greater than 0'\n);\n\nexport const NoPoolError = formatError('No pool found for the input tokens');\n\nexport const NotLoginError = formatError('Please login in first');\n\nexport const SwapRouteError = formatError(\n  \"Something wrong happened, we don't get correct routes corrreponding to current input\"\n);\n\nexport const TokenNotExistError = formatError(\n  `This token doesn't exist in ${getConfig().networkId}`\n);\n","import { Pool, PoolRPCView, StablePool, SmartRoutingInputPool } from './types';\nimport {\n  RATED_POOL_LP_TOKEN_DECIMALS,\n  STABLE_LP_TOKEN_DECIMALS,\n} from './constant';\n\nimport { utils } from 'near-api-js';\n\nimport BN from 'bn.js';\n\nimport * as math from 'mathjs';\n\nexport const parsePool = (pool: PoolRPCView, id?: number): Pool => ({\n  id: Number(id && id >= 0 ? id : pool.id),\n  tokenIds: pool.token_account_ids,\n  supplies: pool.amounts.reduce(\n    (acc: { [tokenId: string]: string }, amount: string, i: number) => {\n      acc[pool.token_account_ids[i]] = amount;\n      return acc;\n    },\n    {}\n  ),\n  fee: pool.total_fee,\n  shareSupply: pool.shares_total_supply,\n  tvl: pool.tvl,\n  token0_ref_price: pool.token0_ref_price,\n  pool_kind: pool.pool_kind,\n});\n\nexport const poolFormatter = (pool: Pool) => {\n  return {\n    id: pool.id,\n    token1Id: pool.tokenIds[0],\n    token2Id: pool.tokenIds[1],\n    token1Supply: pool.supplies[pool.tokenIds[0]],\n    token2Supply: pool.supplies[pool.tokenIds[1]],\n    fee: pool.fee,\n    shares: pool.shareSupply,\n    token0_price: pool.token0_ref_price || '0',\n  } as SmartRoutingInputPool;\n};\n\nexport const isStablePoolToken = (\n  stablePools: StablePool[],\n  tokenId: string | Number\n) => {\n  return stablePools\n    .map(p => p.token_account_ids)\n    .flat()\n    .includes(tokenId.toString());\n};\n\nexport const isStablePool = (\n  stablePools: StablePool[],\n  poolId: string | number\n) => {\n  return stablePools.map(p => p.id.toString()).includes(poolId.toString());\n};\n\nexport const getStablePoolDecimal = (stablePool: StablePool) => {\n  return stablePool.pool_kind === 'RATED_SWAP'\n    ? RATED_POOL_LP_TOKEN_DECIMALS\n    : STABLE_LP_TOKEN_DECIMALS;\n};\n\nexport const round = (decimals: number, minAmountOut: string) => {\n  return Number.isInteger(Number(minAmountOut))\n    ? minAmountOut\n    : Math.ceil(\n        Math.round(Number(minAmountOut) * Math.pow(10, decimals)) /\n          Math.pow(10, decimals)\n      ).toString();\n};\n\nexport const convertToPercentDecimal = (percent: number) => {\n  return math.divide(percent, 100);\n};\n\nexport const percentOf = (percent: number, num: number | string) => {\n  return math.evaluate(`${convertToPercentDecimal(percent)} * ${num}`);\n};\n\nexport const percentLess = (percent: number, num: number | string) => {\n  return math.format(math.evaluate(`${num} - ${percentOf(percent, num)}`), {\n    notation: 'fixed',\n  });\n};\n\nexport const getGas = (gas: string) =>\n  gas ? new BN(gas) : new BN('100000000000000');\n\nexport const getAmount = (amount: string) =>\n  amount ? new BN(utils.format.parseNearAmount(amount) || '0') : new BN('0');\n\nexport const ONLY_ZEROS = /^0*\\.?0*$/;\n\nexport const toReadableNumber = (\n  decimals: number,\n  number: string = '0'\n): string => {\n  if (!decimals) return number;\n\n  const wholeStr = number.substring(0, number.length - decimals) || '0';\n  const fractionStr = number\n    .substring(number.length - decimals)\n    .padStart(decimals, '0')\n    .substring(0, decimals);\n\n  return `${wholeStr}.${fractionStr}`.replace(/\\.?0+$/, '');\n};\n\nexport const toNonDivisibleNumber = (\n  decimals: number,\n  number: string\n): string => {\n  if (decimals === null || decimals === undefined) return number;\n  const [wholePart, fracPart = ''] = number.split('.');\n\n  return `${wholePart}${fracPart.padEnd(decimals, '0').slice(0, decimals)}`\n    .replace(/^0+/, '')\n    .padStart(1, '0');\n};\n\nexport const scientificNotationToString = (strParam: string) => {\n  let flag = /e/.test(strParam);\n  if (!flag || !strParam) return strParam;\n\n  let sysbol = true;\n  if (/e-/.test(strParam)) {\n    sysbol = false;\n  }\n\n  const negative = Number(strParam) < 0 ? '-' : '';\n\n  let index = Number(strParam.match(/\\d+$/)?.[0]);\n\n  let basis = strParam.match(/[\\d\\.]+/)?.[0];\n\n  if (!index || !basis) return strParam;\n\n  const ifFraction = basis.includes('.');\n\n  let wholeStr;\n  let fractionStr;\n\n  if (ifFraction) {\n    wholeStr = basis.split('.')[0];\n    fractionStr = basis.split('.')[1];\n  } else {\n    wholeStr = basis;\n    fractionStr = '';\n  }\n\n  if (sysbol) {\n    if (!ifFraction) {\n      return negative + wholeStr.padEnd(index + wholeStr.length, '0');\n    } else {\n      if (fractionStr.length <= index) {\n        return negative + wholeStr + fractionStr.padEnd(index, '0');\n      } else {\n        return (\n          negative +\n          wholeStr +\n          fractionStr.substring(0, index) +\n          '.' +\n          fractionStr.substring(index)\n        );\n      }\n    }\n  } else {\n    if (!ifFraction)\n      return (\n        negative +\n        wholeStr.padStart(index + wholeStr.length, '0').replace(/^0/, '0.')\n      );\n    else {\n      return (\n        negative +\n        wholeStr.padStart(index + wholeStr.length, '0').replace(/^0/, '0.') +\n        fractionStr\n      );\n    }\n  }\n};\n\nexport const formatWithCommas = (value: string) => {\n  const pattern = /(-?\\d+)(\\d{3})/;\n  while (pattern.test(value)) {\n    value = value.replace(pattern, '$1,$2');\n  }\n  return value;\n};\n\nexport const toPrecision = (\n  number: string,\n  precision: number,\n  withCommas: boolean = false,\n  atLeastOne: boolean = true\n): string => {\n  const [whole, decimal = ''] = number.split('.');\n\n  let str = `${withCommas ? formatWithCommas(whole) : whole}.${decimal.slice(\n    0,\n    precision\n  )}`.replace(/\\.$/, '');\n  if (atLeastOne && Number(str) === 0 && str.length > 1) {\n    var n = str.lastIndexOf('0');\n    str = str.slice(0, n) + str.slice(n).replace('0', '1');\n  }\n\n  return str;\n};\n","import { TokenMetadata, EstimateSwapView, Transaction } from './types';\nimport { wallet, ftGetStorageBalance } from './ref';\nimport {\n  STORAGE_TO_REGISTER_WITH_MFT,\n  REF_FI_CONTRACT_ID,\n  ONE_YOCTO_NEAR,\n} from './constant';\nimport { round, percentLess } from './utils';\nimport { toNonDivisibleNumber } from './utils';\nimport { config } from './constant';\nimport { SwapRouteError } from './error';\n\nexport const instantSwap = async ({\n  tokenIn,\n  tokenOut,\n  amountIn,\n  slippageTolerance,\n  swapTodos,\n}: {\n  tokenIn: TokenMetadata;\n  tokenOut: TokenMetadata;\n  amountIn: string;\n  slippageTolerance: number;\n  swapTodos: EstimateSwapView[];\n}) => {\n  const transactions: Transaction[] = [];\n\n  if (swapTodos.at(-1)?.outputToken !== tokenOut.id) throw SwapRouteError;\n\n  // const registerToken = async (token: TokenMetadata) => {\n  //   const tokenRegistered = await ftGetStorageBalance(token.id).catch(() => {\n  //     throw new Error(`${token.id} doesn't exist.`);\n  //   });\n\n  //   if (tokenRegistered === null) {\n  //     transactions.push({\n  //       receiverId: token.id,\n  //       functionCalls: [\n  //         {\n  //           methodName: 'storage_deposit',\n  //           args: {\n  //             registration_only: true,\n  //             account_id: wallet.getAccountId(),\n  //           },\n  //           gas: '30000000000000',\n  //           amount: STORAGE_TO_REGISTER_WITH_MFT,\n  //         },\n  //       ],\n  //     });\n  //   }\n  // };\n\n  // await registerToken(tokenOut);\n  let actionsList: any = [];\n  let allSwapsTokens = swapTodos.map(s => [s.inputToken, s.outputToken]); // to get the hop tokens\n  for (let i in allSwapsTokens) {\n    let swapTokens = allSwapsTokens[i];\n    if (swapTokens[0] === tokenIn.id && swapTokens[1] === tokenOut.id) {\n      // parallel, direct hop route.\n      actionsList.push({\n        pool_id: swapTodos[i].pool.id,\n        token_in: tokenIn.id,\n        token_out: tokenOut.id,\n        amount_in: swapTodos[i].pool.partialAmountIn,\n        min_amount_out: round(\n          tokenOut.decimals,\n          toNonDivisibleNumber(\n            tokenOut.decimals,\n            percentLess(slippageTolerance, swapTodos[i].estimate)\n          )\n        ),\n      });\n    } else if (swapTokens[0] === tokenIn.id) {\n      // first hop in double hop route\n      //TODO -- put in a check to make sure this first hop matches with the next (i+1) hop as a second hop.\n      actionsList.push({\n        pool_id: swapTodos[i].pool.id,\n        token_in: swapTokens[0],\n        token_out: swapTokens[1],\n        amount_in: swapTodos[i].pool.partialAmountIn,\n        min_amount_out: '0',\n      });\n    } else {\n      // second hop in double hop route.\n      //TODO -- put in a check to make sure this second hop matches with the previous (i-1) hop as a first hop.\n      actionsList.push({\n        pool_id: swapTodos[i].pool.id,\n        token_in: swapTokens[0],\n        token_out: swapTokens[1],\n        min_amount_out: round(\n          tokenOut.decimals,\n          toNonDivisibleNumber(\n            tokenOut.decimals,\n            percentLess(slippageTolerance, swapTodos[i].estimate)\n          )\n        ),\n      });\n    }\n  }\n\n  transactions.push({\n    receiverId: tokenIn.id,\n    functionCalls: [\n      {\n        methodName: 'ft_transfer_call',\n        args: {\n          receiver_id: REF_FI_CONTRACT_ID,\n          amount: toNonDivisibleNumber(tokenIn.decimals, amountIn),\n          msg: JSON.stringify({\n            force: 0,\n            actions: actionsList,\n          }),\n        },\n        gas: '180000000000000',\n        amount: ONE_YOCTO_NEAR,\n      },\n    ],\n  });\n\n  // if (tokenIn.id === config.WRAP_NEAR_CONTRACT_ID) {\n  //   const registered = await ftGetStorageBalance(config.WRAP_NEAR_CONTRACT_ID);\n  //   if (registered === null) {\n  //     await registerToken(tokenIn);\n  //   }\n  // }\n\n  return transactions;\n};\n","import { REF_FI_CONTRACT_ID, config } from './constant';\nimport { keyStores, Near, WalletConnection } from 'near-api-js';\nimport { TokenNotExistError } from './error';\n\nimport {\n  TokenMetadata,\n  FTStorageBalance,\n  RefFiViewFunctionOptions,\n} from './types';\n\nexport const keyStore = new keyStores.BrowserLocalStorageKeyStore();\n\nexport const near = new Near({\n  keyStore,\n  headers: {},\n  ...config,\n});\n\nexport const wallet = new WalletConnection(near, REF_FI_CONTRACT_ID);\n\nexport const refFiViewFunction = ({\n  methodName,\n  args,\n}: RefFiViewFunctionOptions) => {\n  return wallet.account().viewFunction(REF_FI_CONTRACT_ID, methodName, args);\n};\n\nexport const ftViewFunction = (\n  tokenId: string,\n  { methodName, args }: RefFiViewFunctionOptions\n) => {\n  return wallet.account().viewFunction(tokenId, methodName, args);\n};\n\nexport const ftGetStorageBalance = (\n  tokenId: string,\n  accountId: string = wallet.getAccountId()\n): Promise<FTStorageBalance | null> => {\n  return ftViewFunction(tokenId, {\n    methodName: 'storage_balance_of',\n    args: { account_id: accountId },\n  });\n};\n\nexport const getTotalPools = async () => {\n  return refFiViewFunction({\n    methodName: 'get_number_of_pools',\n  });\n};\n\nexport const ftGetTokenMetadata = async (\n  id: string\n): Promise<TokenMetadata> => {\n  const metadata = await ftViewFunction(id, {\n    methodName: 'ft_metadata',\n  }).catch(() => {\n    throw TokenNotExistError;\n  });\n\n  return { ...metadata, id };\n};\n\nexport const ftGetTokensMetadata = async (tokenIds: string[]) => {\n  const tokensMetadata = await Promise.all(\n    tokenIds.map((id: string) => ftGetTokenMetadata(id))\n  );\n\n  return tokensMetadata.reduce((pre, cur, i) => {\n    return {\n      ...pre,\n      [tokenIds[i]]: cur,\n    };\n  }, {}) as Record<string, TokenMetadata>;\n};\n\n// export const executeMultipleTransactions = async (\n//   transactions: Transaction[],\n//   callbackUrl?: string\n// ) => {\n//   const currentTransactions = await Promise.all(\n//     transactions.map((t, i) => {\n//       return wallet.createTransaction({\n//         receiverId: t.receiverId,\n//         nonceOffset: i + 1,\n//         actions: t.functionCalls.map(fc =>\n//           functionCall(\n//             fc.methodName,\n//             fc.args as object,\n//             getGas(fc.gas || ''),\n//             getAmount(fc.amount || '')\n//           )\n//         ),\n//       });\n//     })\n//   );\n\n//   return wallet.requestSignTransactions(currentTransactions, callbackUrl);\n// };\n","import { getTotalPools, refFiViewFunction } from './ref';\nimport { Pool, PoolRPCView } from './types';\nimport { parsePool, toNonDivisibleNumber } from './utils';\nimport { unNamedError } from './error';\nimport { STABLE_LP_TOKEN_DECIMALS } from './constant';\n\nexport const DEFAULT_PAGE_LIMIT = 100;\n\nexport const getRatedPoolDetail = async ({ id }: { id: string | number }) => {\n  return refFiViewFunction({\n    methodName: 'get_rated_pool',\n    args: { pool_id: Number(id) },\n  })\n    .then(pool_info => ({\n      ...pool_info,\n      id: Number(id),\n      pool_kind: 'RATED_SWAP',\n    }))\n    .catch(() => {\n      throw unNamedError;\n    });\n};\n\nexport const getUnRatedPoolDetail = async ({ id }: { id: string | number }) => {\n  return refFiViewFunction({\n    methodName: 'get_stable_pool',\n    args: { pool_id: Number(id) },\n  })\n    .then(pool_info => ({\n      ...pool_info,\n      id: Number(id),\n      pool_kind: 'STABLE_SWAP',\n      rates: pool_info.c_amounts.map((_: any) =>\n        toNonDivisibleNumber(STABLE_LP_TOKEN_DECIMALS, '1')\n      ),\n    }))\n    .catch(() => {\n      throw unNamedError;\n    });\n};\n\nexport const getStablePoolsDetail = async (stablePools: Pool[]) => {\n  return Promise.all(\n    stablePools.map(pool =>\n      pool.pool_kind === 'RATED_SWAP'\n        ? getRatedPoolDetail({ id: pool.id })\n        : getUnRatedPoolDetail({ id: pool.id })\n    )\n  );\n};\n\nexport const getRefPools = async (\n  page: number = 1,\n  perPage: number = DEFAULT_PAGE_LIMIT\n): Promise<Pool[]> => {\n  const index = (page - 1) * perPage;\n\n  const poolData: PoolRPCView[] = await refFiViewFunction({\n    methodName: 'get_pools',\n    args: { from_index: index, limit: perPage },\n  });\n\n  return poolData.map((rawPool, i) => parsePool(rawPool, i + index));\n};\n\n// TODO: differentiate by network, include simple pools and stable pools\nexport const fetchAllRefPools = async () => {\n  const totalPools = await getTotalPools();\n  const pages = Math.ceil(totalPools / DEFAULT_PAGE_LIMIT);\n\n  const pools = (\n    await Promise.all([...Array(pages)].map((_, i) => getRefPools(i + 1)))\n  ).flat() as Pool[];\n\n  return {\n    simplePools: pools.filter(\n      p => p.pool_kind && p.pool_kind === 'SIMPLE_POOL'\n    ),\n    unRatedPools: pools.filter(\n      p => p.pool_kind && p.pool_kind === 'STABLE_SWAP'\n    ),\n    ratedPools: pools.filter(p => p.pool_kind && p.pool_kind === 'RATED_SWAP'),\n  };\n};\n","import { StablePool } from './types';\nimport { FEE_DIVISOR } from './constant';\nimport {\n  toReadableNumber,\n  toNonDivisibleNumber,\n  scientificNotationToString,\n} from './utils';\n\nimport Big from 'big.js';\n\nimport _ from 'lodash';\n\nconst tradeFee = (amount: number, trade_fee: number) => {\n  return (amount * trade_fee) / FEE_DIVISOR;\n};\n\nexport const calc_d = (amp: number, c_amounts: number[]) => {\n  const token_num = c_amounts.length;\n  const sum_amounts = _.sum(c_amounts);\n  let d_prev = 0;\n  let d = sum_amounts;\n  for (let i = 0; i < 256; i++) {\n    let d_prod = d;\n    for (let c_amount of c_amounts) {\n      d_prod = (d_prod * d) / (c_amount * token_num);\n    }\n    d_prev = d;\n    const ann = amp * token_num ** token_num;\n    const numerator = d_prev * (d_prod * token_num + ann * sum_amounts);\n    const denominator = d_prev * (ann - 1) + d_prod * (token_num + 1);\n    d = numerator / denominator;\n    if (Math.abs(d - d_prev) <= 1) break;\n  }\n  return d;\n};\n\nexport const calc_y = (\n  amp: number,\n  x_c_amount: number,\n  current_c_amounts: number[],\n  index_x: number,\n  index_y: number\n) => {\n  const token_num = current_c_amounts.length;\n  const ann = amp * token_num ** token_num;\n  const d = calc_d(amp, current_c_amounts);\n  let s = x_c_amount;\n  let c = (d * d) / x_c_amount;\n  for (let i = 0; i < token_num; i++) {\n    if (i != index_x && i != index_y) {\n      s += current_c_amounts[i];\n      c = (c * d) / current_c_amounts[i];\n    }\n  }\n  c = (c * d) / (ann * token_num ** token_num);\n  const b = d / ann + s;\n  let y_prev = 0;\n  let y = d;\n  for (let i = 0; i < 256; i++) {\n    y_prev = y;\n    const y_numerator = y ** 2 + c;\n    const y_denominator = 2 * y + b - d;\n    y = y_numerator / y_denominator;\n    if (Math.abs(y - y_prev) <= 1) break;\n  }\n\n  return y;\n};\n\nexport const calc_swap = (\n  amp: number,\n  in_token_idx: number,\n  in_c_amount: number,\n  out_token_idx: number,\n  old_c_amounts: number[],\n  trade_fee: number\n) => {\n  const y = calc_y(\n    amp,\n    in_c_amount + old_c_amounts[in_token_idx],\n    old_c_amounts,\n    in_token_idx,\n    out_token_idx\n  );\n  const dy = old_c_amounts[out_token_idx] - y;\n  const fee = tradeFee(dy, trade_fee);\n  const amount_swapped = dy - fee;\n  return [amount_swapped, fee, dy];\n};\n\nexport const getSwappedAmount = (\n  tokenInId: string,\n  tokenOutId: string,\n  amountIn: string,\n  stablePool: StablePool,\n  STABLE_LP_TOKEN_DECIMALS: number\n) => {\n  const amp = stablePool.amp;\n  const trade_fee = stablePool.total_fee;\n\n  // depended on pools\n  const in_token_idx = stablePool.token_account_ids.findIndex(\n    id => id === tokenInId\n  );\n  const out_token_idx = stablePool.token_account_ids.findIndex(\n    id => id === tokenOutId\n  );\n\n  const rates = stablePool.rates.map(r =>\n    toReadableNumber(STABLE_LP_TOKEN_DECIMALS, r)\n  );\n\n  const base_old_c_amounts = stablePool.c_amounts.map(amount =>\n    toReadableNumber(STABLE_LP_TOKEN_DECIMALS, amount)\n  );\n\n  const old_c_amounts = base_old_c_amounts\n    .map((amount, i) =>\n      toNonDivisibleNumber(\n        STABLE_LP_TOKEN_DECIMALS,\n        scientificNotationToString(\n          new Big(amount || 0).times(new Big(rates[i])).toString()\n        )\n      )\n    )\n    .map(amount => Number(amount));\n\n  const in_c_amount = Number(\n    toNonDivisibleNumber(\n      STABLE_LP_TOKEN_DECIMALS,\n      scientificNotationToString(\n        new Big(amountIn).times(new Big(rates[in_token_idx])).toString()\n      )\n    )\n  );\n\n  const [amount_swapped, fee, dy] = calc_swap(\n    amp,\n    in_token_idx,\n    in_c_amount,\n    out_token_idx,\n    old_c_amounts,\n    trade_fee\n  );\n\n  return [\n    amount_swapped / Number(rates[out_token_idx]),\n    fee,\n    dy / Number(rates[out_token_idx]),\n  ];\n};\n","//@ts-nocheck\nimport Big from 'big.js';\n\nimport { Pool } from './types';\n\nBig.RM = 0;\nBig.DP = 40;\nBig.NE = -40;\nBig.PE = 40;\n\ninterface FormatedPool extends Pool {\n  x?: string;\n  y?: string;\n  gamma_bps?: Big;\n}\n\n///////////////////////////////\n// Parallel Swap Logic Below //\n///////////////////////////////\n\n/** formatPoolNew\n * This function appends to the existing standard Pool struct and adds attributes that simplify the parallel swap algorithms.\n * Adds attributes \"x\" (for input token reserves in pool), \"y\" (for output token reserves in pool), and \"gamma_bps\" (for 1- fee in bps)\n * Our convention for our algorithm has been to use \"x\" as the input token and \"y\" as the output token.\n * @param pool    AMM structure containing reserves of inputToken and outputToken\n * @param inputToken the name of the inputToken being traded in.\n * @param outputToken the name of the outputToken being traded out.\n * @returns newFormatPool\n */\nexport function formatPoolNew(\n  pool: Pool,\n  inputToken: string,\n  outputToken: string\n) {\n  let p: FormatedPool = pool;\n  let x = p.supplies[inputToken];\n  let y = p.supplies[outputToken];\n  p['gamma_bps'] = new Big(10000).minus(p.fee);\n  p['x'] = x;\n  p['y'] = y;\n  return p;\n}\n\n/** solveForMuFloat\n * This function takes the set of token pools, the total input of inputToken, and the names of inputToken and outputToken and\n * solves for the Lagrange Multiplier \"mu\". Note that mu must be allowed to be aritrary precision floating point number. Mu will\n * be used in subsequent function calls to determine the best allocations of intputToken to be made per pool.\n * For more detailed math on how this function was derived, please see the white paper:\n * https://github.com/giddyphysicist/ParallelSwapForRefFinance/blob/main/ParallelSwapWhitePaper.pdf\n * @param pools   list of pools that contain inputToken and outputToken\n * @param totalDeltaX  total allocation (among all pools) being input of inputToken\n * @param inputToken   the name of the inputToken being traded in.\n * @param outputToken   the name of the outputToken being traded out.\n * @returns mu   the lagrange multiplier value calculated for a set of pools and inputToken amount.\n */\nexport function solveForMuFloat(\n  pools: Pool[],\n  totalDeltaX: string,\n  inputToken: string,\n  outputToken: string\n) {\n  if (pools.length > 0) {\n    let numerator = new Big(totalDeltaX);\n    let denominator = new Big(0);\n\n    for (var i = 0; i < pools.length; i++) {\n      let p = formatPoolNew(pools[i], inputToken, outputToken);\n      let numAdd = new Big(p.x).times(10000).div(p.gamma_bps);\n      numerator = numerator.plus(numAdd);\n      let denomAdd = new Big(p.x)\n        .times(p.y)\n        .div(p.gamma_bps)\n        .sqrt()\n        .times(100);\n      denominator = denominator.plus(denomAdd);\n    }\n\n    const mu = new Big(numerator).div(denominator);\n    return mu;\n  } else {\n    // console.log('ERROR - could not find pools that satisfy token pair');\n    const mu = NaN;\n    return mu;\n  }\n}\n\n/** calculate_dx_float\n * Once mu has been calculated for a set of pools and total input amount, the next step is\n * determining the total allocation per pool. This function evaluates the amount of input Token to be\n * allocated to the given pool. Note, in our original algorithmic convention, the 'x' variable was for the input token,\n * and the 'y' variable was for the output token. Here, the value dx is the part of the full amount of input token X.\n * Again, the detailed formulae for these operations can be found in the white paper referenced above.\n * @param mu   the lagrange multiplier value calculated for a set of pools and inputToken amount.\n * @param pool   AMM structure containing reserves of inputToken and outputToken\n * @param inputToken the name of the inputToken being traded in.\n * @param outputToken  the name of the outputToken being traded out.\n * @returns dxFloat   the allocation amount determined for the given pool\n */\nexport function calculate_dx_float(\n  mu: number | Big,\n  pool: FormatedPool,\n  inputToken: string,\n  outputToken: string\n) {\n  let p = formatPoolNew(pool, inputToken, outputToken);\n  let radical = new Big(p.x).times(p.y).div(p.gamma_bps);\n  let dxFloat = new Big(mu)\n    .times(100)\n    .times(radical.sqrt())\n    .minus(new Big(p.x).times(10000).div(p.gamma_bps));\n  return dxFloat;\n}\n\n/** calculate_dy_float\n * Once you have an allocation amount for a given pool, you can use the AMM constant-product formula to determine\n * the expected output amount of output Token.\n * Note, here, as earlier, our algorithmic convention uses \"y\" as the output token, and so \"dy\" is the fraction of\n * the total output of output Token, assuming there could be dy contributions from other parallel pools as well.\n * @param dx_float  input allocation amount of inputToken for the given pool\n * @param pool   a structure representing the reserves and fees for a given pool.\n * @param inputToken  the name of the inputToken being traded in.\n * @param outputToken  the name of the outputToken being traded out.\n * @returns dyFloat  the expected trade out amount out of outputToken\n */\nexport function calculate_dy_float(\n  dx_float: number,\n  pool: FormatedPool,\n  inputToken: string,\n  outputToken: string\n) {\n  if (dx_float <= 0) {\n    return new Big(0);\n  }\n  let p = formatPoolNew(pool, inputToken, outputToken);\n  let dx = new Big(dx_float);\n  let denom = new Big(10000).times(p.x).plus(new Big(p.gamma_bps).times(dx));\n  let numerator = new Big(p.y).times(dx).times(p.gamma_bps);\n  let dyFloat = numerator.div(denom).round();\n  return dyFloat;\n}\n\n/** calculateOptimalOutput\n * This is the main function, which calculates optimal values of inputToken to swap into each pool.\n * @param pools  list of relevant AMM pools containing inputToken and outputToken\n * @param inputAmount   the numeric total amount of inputToken to be traded into the group of swap pools.\n * @param inputToken   the name of the inputToken being traded in.\n * @param outputToken  the name of the outputToken being traded out.\n * @returns normalizedDxArray an array containing the amount allocations of inputToken per pool in the list of pools.\n */\nexport function calculateOptimalOutput(\n  pools: Pool[],\n  inputAmount: string,\n  inputToken: string,\n  outputToken: string\n) {\n  let mu = solveForMuFloat(pools, inputAmount, inputToken, outputToken);\n  let dxArray: Big[] = new Array();\n  let negativeDxValsFlag = false;\n  for (var i = 0; i < pools.length; i++) {\n    let pool = formatPoolNew(pools[i], inputToken, outputToken);\n    let dx = calculate_dx_float(mu, pool, inputToken, outputToken);\n    if (dx.lt(0)) {\n      negativeDxValsFlag = true;\n    }\n    let dxInt = new Big(dx).round();\n    dxArray.push(dxInt);\n  }\n  if (negativeDxValsFlag) {\n    dxArray = reducePools(pools, dxArray, inputAmount, inputToken, outputToken);\n  }\n  let dxArraySum = new Big(0);\n  for (var i = 0; i < dxArray.length; i++) {\n    dxArraySum = dxArraySum.plus(dxArray[i]);\n  }\n  let tempAllocationsArray = [];\n  for (var i = 0; i < dxArray.length; i++) {\n    let ndx = new Big(dxArray[i])\n      .times(inputAmount)\n      .div(dxArraySum)\n      .round();\n    tempAllocationsArray.push(ndx);\n  }\n  let allocationsArray = checkIntegerSumOfAllocations(\n    tempAllocationsArray,\n    inputAmount\n  );\n  let normalizedDxArray = [];\n  for (var i = 0; i < allocationsArray.length; i++) {\n    let ndx = allocationsArray[i];\n    normalizedDxArray.push(BigInt(ndx));\n    pools[i]['partialAmountIn'] = ndx.toString();\n  }\n  return normalizedDxArray;\n}\n\n/** reducePools\n * This function is used to implement part of the non-linear slack variables in the lagrange - multiplier\n * solution for parallel swap. Part of what comes out of the math is that sometimes, the optimal allocation for a pool\n * can be negative, which makes no physical sense. When this occurs, that particular pool needs to be flagged and the\n * lagrange constraint applied to force the allocation to be zero.\n * This function takes an already-solved set of pools, input allocation per pool, the total input amount, and the\n * inputToken name and outputToken name, and determines which, if any, allocations need to be set to zero.\n * However, when this occurs, and a pool is essentially ignored from the list, then the calculation for mu must be re-done.\n * So the calculateOptimalOutput function is then called on the reduced set of pools, and if no negative allocation values remain,\n * then the allocations on the reduced set is determined, and values of zero are put in for the 'failed' pools.\n * @param pools  list of pools that contain inputToken and outputToken\n * @param dxArray  list of input allocation per pool\n * @param inputAmount   total amount of inputToken to be traded among the pools\n * @param inputToken    the name of the inputToken\n * @param outputToken   the name of the outputToken\n * @returns newFullDxVec  the new full list of input allocations the same length as dxArray, containing zeros for failed pools.\n */\nexport function reducePools(\n  pools: Pool[],\n  dxArray: Big[],\n  inputAmount: string,\n  inputToken: string,\n  outputToken: string\n) {\n  let goodIndices = [];\n  for (var i = 0; i < dxArray.length; i++) {\n    let dx = dxArray[i];\n    if (dx.gte(0)) {\n      goodIndices.push(i);\n    }\n  }\n  if (goodIndices.length < 1) {\n    // console.log(\"ERROR OCCURRED -- ALL DX VALUES WERE NEGATIVE\")\n    return dxArray;\n  }\n  let newPools = [];\n  for (var j = 0; j < dxArray.length; j++) {\n    if (goodIndices.includes(j)) {\n      newPools.push(pools[j]);\n    }\n  }\n  let newDxVec = calculateOptimalOutput(\n    newPools,\n    inputAmount,\n    inputToken,\n    outputToken\n  );\n  let goodInd2newdx = {};\n  for (var k = 0; k < newDxVec.length; k++) {\n    goodInd2newdx[goodIndices[k]] = newDxVec[k];\n  }\n  let newFullDxVec = [];\n  for (var ii = 0; ii < pools.length; ii++) {\n    if (goodIndices.includes(ii)) {\n      newFullDxVec.push(goodInd2newdx[ii]);\n    } else {\n      newFullDxVec.push(0);\n    }\n  }\n  return newFullDxVec;\n}\n\nexport function checkIntegerSumOfAllocations(\n  allocations: Big[] | string[] | BigInt[],\n  totalInput: Big | string | BigInt\n) {\n  var totalInput = new Big(totalInput);\n  var allocations:\n    | Big[]\n    | string[]\n    | BigInt[] = allocations.map((item: Big | string | BigInt) =>\n    new Big(item).round()\n  );\n  let alloSum = allocations\n    .map(item => new Big(item))\n    .reduce((a, b) => a.plus(b), new Big(0));\n  let offset = totalInput.minus(alloSum);\n  //get largest allocation.\n  let currMax = new Big(0);\n  let currMaxInd = 0;\n  for (var i = 0; i < allocations.length; i++) {\n    if (allocations[i].gt(currMax)) {\n      currMaxInd = i;\n      currMax = allocations[i];\n    }\n  }\n  let newAllocations = [];\n  for (var j = 0; j < allocations.length; j++) {\n    if (j === currMaxInd) {\n      newAllocations.push(allocations[j].plus(offset).toString());\n    } else {\n      newAllocations.push(allocations[j].toString());\n    }\n  }\n  return newAllocations;\n}\n","/* eslint-disable no-undef */\n////////////////////////////////////////////////////////////////////////////\n// SMART ROUTE SWAP LOGIC\n////////////////////////////////////////////////////////////////////////////\nimport Big from 'big.js';\nimport { checkIntegerSumOfAllocations } from './parallelSwapLogic';\n\nimport { TokenMetadata } from './types';\n\nimport { ftGetTokenMetadata } from './ref';\n\nimport { percentLess, toNonDivisibleNumber } from './utils';\n\nBig.RM = 0;\nBig.DP = 40;\nBig.NE = -40;\nBig.PE = 40;\n\nfunction bisqrt(value) {\n  // For some ridiculous reason, the .sqrt() method for Big decimals is extremely slow (~10-20ms),\n  // which isn't so bad until you need to use it a bunch of times.\n  // Since we're dealing with super large numbers anyway, we can convert the Big decimal number into a BigInt,\n  // then run this BigInt Newton iteration square root function instead, and then convert back into a\n  // Big number. And it speeds up the operation by a crazy factor, ~10x faster.\n  if (value < BigInt(0)) {\n    throw 'square root of negative numbers is not supported';\n  }\n\n  if (value < BigInt(2)) {\n    return value;\n  }\n\n  function newtonIteration(n, x0) {\n    const x1 = (n / x0 + x0) >> BigInt(1);\n    if (x0 === x1 || x0 === x1 - BigInt(1)) {\n      return x0;\n    }\n    return newtonIteration(n, x1);\n  }\n\n  return newtonIteration(value, BigInt(1));\n}\n\nfunction getBetaForRoute(route, path) {\n  if (!route.length) {\n    route = [route];\n  }\n  if (route.length == 1) {\n    let p = route[0];\n    var beta = new Big(p.reserves[path[0]]);\n  } else if (route.length == 2) {\n    let p1 = route[0];\n    let p2 = route[1];\n    var beta = new Big(p1.reserves[path[0]]).times(\n      new Big(p2.reserves[path[1]])\n    );\n  }\n  return beta;\n}\n\nfunction getEpsilonForRoute(route, path) {\n  if (!route.length) {\n    route = [route];\n  }\n  if (route.length == 1) {\n    // Single Hop case\n    let p = route[0];\n    let gamma = new Big(10000).minus(new Big(p.fee)).div(new Big(10000));\n    var epsilon = Big(gamma);\n  } else if (route.length == 2) {\n    //Double Hop Case\n    let p1 = route[0];\n    let p2 = route[1];\n    let gamma1 = new Big(10000).minus(new Big(p1.fee)).div(new Big(10000));\n    let gamma2 = new Big(10000).minus(new Big(p2.fee)).div(Big(10000));\n    var epsilon = new Big(p2.reserves[path[1]])\n      .times(new Big(gamma1))\n      .plus(new Big(p1.reserves[path[1]]).times(gamma1).times(gamma2));\n  }\n  return epsilon;\n}\n\nfunction getAlphaForRoute(route, path) {\n  if (!route.length) {\n    route = [route];\n  }\n  if (route.length == 1) {\n    //console.log('single hop')\n    let p = route[0];\n    let inputToken = path[0];\n    let outputToken = path[1];\n    let gamma = new Big(10000).minus(new Big(p.fee)).div(new Big(10000));\n    let key1 = p.token1Id;\n    let key2 = p.token2Id;\n    let val1 = p.token1Supply;\n    let val2 = p.token2Supply;\n    p['reserves'] = { [key1]: val1, [key2]: val2 };\n    var alpha = new Big(p.reserves[inputToken]).times(\n      new Big(p.reserves[outputToken]).times(new Big(gamma))\n    );\n  } else if (route.length == 2) {\n    //console.log('double hop')\n    let p1 = route[0];\n    let p2 = route[1];\n    let key11 = p1.token1Id;\n    let key12 = p1.token2Id;\n    let val11 = p1.token1Supply;\n    let val12 = p1.token2Supply;\n    p1['reserves'] = { [key11]: val11, [key12]: val12 };\n    let key21 = p2.token1Id;\n    let key22 = p2.token2Id;\n    let val21 = p2.token1Supply;\n    let val22 = p2.token2Supply;\n    p2['reserves'] = { [key21]: val21, [key22]: val22 };\n    let inputToken = path[0];\n    let middleToken = path[1];\n    let outputToken = path[2];\n    let gamma1 = new Big(10000).minus(Big(p1.fee)).div(new Big(10000));\n    let gamma2 = new Big(10000).minus(new Big(p2.fee)).div(new Big(10000));\n    let alpha1 = new Big(p1.reserves[inputToken])\n      .times(new Big(p1.reserves[middleToken]))\n      .times(gamma1);\n    let alpha2 = new Big(p2.reserves[middleToken])\n      .times(new Big(p2.reserves[outputToken]))\n      .times(gamma2);\n    var alpha = alpha1.times(alpha2);\n  }\n  return alpha;\n}\n\nfunction getAlphaSumFromRoutes(routes, nodeRoutes) {\n  let alphaSum = new Big(0);\n  for (var i in routes) {\n    let route = routes[i];\n    let nodeRoute = nodeRoutes[i];\n    let alpha = getAlphaForRoute(route, nodeRoute);\n    // console.log('alpha is...');\n    // console.log(alpha.toString());\n    // below, we are replacing the built-in Big sqrt() method with a\n    // newton-iteration BigInt sqrt function, to speed it up by 10x.\n    let radical = new Big(bisqrt(BigInt(new Big(alpha).round().toFixed())));\n    // let radical = new Big(alpha).sqrt();\n    let epsilon = getEpsilonForRoute(route, nodeRoute);\n    let denom = new Big(epsilon);\n    alphaSum = alphaSum.plus(radical.div(denom));\n  }\n  return alphaSum;\n}\n\nfunction getBetaSumFromRoutes(routes, nodeRoutes) {\n  let betaSum = new Big(0);\n  for (var i in routes) {\n    let route = routes[i];\n    let nodeRoute = nodeRoutes[i];\n    let num = new Big(getBetaForRoute(route, nodeRoute));\n    let denom = new Big(getEpsilonForRoute(route, nodeRoute));\n    betaSum = betaSum.plus(num.div(denom));\n  }\n  return betaSum;\n}\n\nfunction getPhiFromRoutes(routes, nodeRoutes, totalInput) {\n  let alphaSum = getAlphaSumFromRoutes(routes, nodeRoutes);\n  let betaSum = getBetaSumFromRoutes(routes, nodeRoutes);\n  let phi = new Big(totalInput).plus(betaSum).div(alphaSum);\n  return phi;\n}\n\nfunction getAllocationForRoute(phi, route, path) {\n  let alpha = getAlphaForRoute(route, path);\n  let beta = getBetaForRoute(route, path);\n  let epsilon = getEpsilonForRoute(route, path);\n  // below, we are replacing the built-in Big sqrt() method with a\n  // newton-iteration BigInt sqrt function, to speed it up by 10x.\n  let allocation = new Big(phi)\n    .abs()\n    .times(new Big(bisqrt(BigInt(new Big(alpha).round().toFixed()))))\n    .minus(beta)\n    .div(epsilon);\n  return allocation;\n}\n\nfunction getAllocationVectorForRoutes(phi, routes, nodeRoutes) {\n  let allocationVec = [];\n  for (var i in routes) {\n    allocationVec.push(getAllocationForRoute(phi, routes[i], nodeRoutes[i]));\n  }\n  return allocationVec;\n}\n\nfunction getOptimalAllocationForRoutes(routes, nodeRoutes, totalInput) {\n  // console.log(\"CALLING GET OPTIMAL ALLOCATION FOR ROUTES:\")\n  // console.log(routes)\n  var totalInput = new Big(totalInput);\n  let phi = getPhiFromRoutes(routes, nodeRoutes, totalInput);\n  // console.log('PHI CALCULATED TO BE...')\n  // console.log(phi.toString())\n  let allocations = getAllocationVectorForRoutes(phi, routes, nodeRoutes);\n  if (allocations.every(item => item.lt(new Big(0)))) {\n    allocations = allocations.map(item => item.times(new Big(-1.0)));\n  }\n  if (allocations.some(item => item.lt(new Big(0)))) {\n    allocations = reduceRoutes(routes, nodeRoutes, allocations, totalInput);\n  }\n  let sumAllocations = allocations.reduce((a, b) => a.plus(b), new Big(0));\n  let normalizedAllocations = allocations.map(a =>\n    a.div(sumAllocations).times(new Big(totalInput))\n  );\n  return normalizedAllocations;\n}\n\nfunction reduceRoutes(routes, nodeRoutes, allocationVec, totalInput) {\n  // console.log(\"RUNNING REDUCE ROUTES\")\n  var totalInput = new Big(totalInput);\n  let goodIndices = [];\n  for (var i in allocationVec) {\n    let dx = allocationVec[i];\n    // console.log('DX IS...')\n    // console.log(dx.toString())\n    if (dx.gt(new Big(0))) {\n      goodIndices.push(i);\n    }\n  }\n  // console.log('GOOD INDICES ARE...');\n  // console.log(goodIndices);\n  let newRoutes = [];\n  let newNodeRoutes = [];\n  for (var i in goodIndices) {\n    let goodIndex = goodIndices[i];\n    newRoutes.push(routes[goodIndex]);\n    newNodeRoutes.push(nodeRoutes[goodIndex]);\n  }\n  allocationVec = getOptimalAllocationForRoutes(\n    newRoutes,\n    newNodeRoutes,\n    totalInput\n  );\n  let allocationDict = {};\n  for (var i in goodIndices) {\n    allocationDict[goodIndices[i]] = allocationVec[i];\n  }\n  var allocationVecNew = [];\n  for (var i in routes) {\n    if (goodIndices.includes(i)) {\n      allocationVecNew.push(allocationDict[i]);\n    } else {\n      let zeroAllocation = new Big(0);\n      allocationVecNew.push(zeroAllocation);\n    }\n  }\n  return allocationVecNew;\n}\n\nfunction getNodeRoutesFromPathsAndPoolChains(paths, poolChains) {\n  let multiplicity = [];\n  for (var i in poolChains) {\n    let pc = poolChains[i];\n    let mul = pc\n      .map(item => item.length)\n      .reduce((elem1, elem2) => elem1 * elem2, 1);\n    multiplicity.push(mul);\n  }\n  let nodeRoutes = [];\n  for (var j in paths) {\n    let path = paths[j];\n    let m = multiplicity[j];\n    for (var k = 0; k < m; k++) {\n      nodeRoutes.push(path);\n    }\n  }\n  return nodeRoutes;\n}\n\nfunction getPoolChainFromPaths(paths, pools, threshold = 0.001) {\n  let poolChains = [];\n  for (var pathInd in paths) {\n    let path = paths[pathInd];\n    let chain = [];\n    let pairs = [];\n    for (var i = 0; i < path.length - 1; i++) {\n      pairs.push([path[i], path[i + 1]]);\n    }\n    for (var pairInd in pairs) {\n      let pair = pairs[pairInd];\n      // console.log(pair);\n      let tokenPools = getPoolsByToken1ANDToken2(pools, pair[0], pair[1]);\n      chain.push(tokenPools);\n    }\n    poolChains.push(chain);\n  }\n  // return poolChains;\n  let culledPoolChains = getCulledPoolChains(poolChains, threshold);\n\n  return culledPoolChains;\n}\n\nfunction getCulledPoolChains(poolChains, threshold = 0.001) {\n  let newChains = [];\n  for (var pathInd in poolChains) {\n    let path = poolChains[pathInd];\n    let newPath = [];\n    for (var legInd in path) {\n      let leg = path[legInd];\n      let culledPath = cullPoolsWithInsufficientLiquidity(leg, threshold);\n      newPath.push(culledPath);\n    }\n    newChains.push(newPath);\n  }\n  return newChains;\n}\n\nfunction getRoutesFromPoolChain(poolChains) {\n  let routes = [];\n  for (var pci in poolChains) {\n    let poolChain = poolChains[pci];\n    //get cartesian product of each pool chain to get the list of routes.\n    let newRoutes = cartesianProduct(poolChain);\n    routes.push(...newRoutes);\n  }\n  for (var i in routes) {\n    if (!routes[i].length) {\n      routes[i] = [routes[i]];\n    }\n  }\n  return routes;\n}\n\nfunction getOutputSingleHop(pool, inputToken, outputToken, totalInput) {\n  var totalInput = new Big(totalInput);\n  // check if pool is forward or backward for inputToken/outputToken cf. token1Id/token2Id\n  if (inputToken === pool.token1Id && outputToken === pool.token2Id) {\n    // forward Pool\n    var reserves = {\n      [inputToken]: new Big(pool.token1Supply),\n      [outputToken]: new Big(pool.token2Supply),\n    };\n  } else if (inputToken === pool.token2Id && outputToken === pool.token1Id) {\n    // reverse pool\n    var reserves = {\n      [outputToken]: new Big(pool.token1Supply),\n      [inputToken]: new Big(pool.token2Supply),\n    };\n  } else {\n    return new Big(0);\n  }\n  let gamma = new Big(10000).minus(new Big(pool.fee)).div(new Big(10000));\n  // console.log(totalInput)\n  // console.log(gamma)\n  // console.log(reserves)\n  let num = totalInput.times(gamma).times(reserves[outputToken]);\n  let denom = reserves[inputToken].plus(gamma.times(totalInput));\n  return num.div(denom);\n}\n\nfunction getOutputDoubleHop(\n  pools,\n  inputToken,\n  middleToken,\n  outputToken,\n  totalInput\n) {\n  var totalInput = new Big(totalInput);\n  for (var poolIndex in pools) {\n    let p = pools[poolIndex];\n    p['gamma'] = new Big(10000).minus(new Big(p.fee)).div(new Big(10000));\n  }\n  let p1 = pools[0];\n  let p2 = pools[1];\n\n  if (inputToken === p1.token1Id && middleToken === p1.token2Id) {\n    // forward Pool\n    p1['reserves'] = {\n      [inputToken]: new Big(p1.token1Supply),\n      [middleToken]: new Big(p1.token2Supply),\n    };\n  } else if (middleToken === p1.token1Id && inputToken === p1.token2Id) {\n    //reverse pool\n    p1['reserves'] = {\n      [middleToken]: new Big(p1.token1Supply),\n      [inputToken]: new Big(p1.token2Supply),\n    };\n  }\n\n  if (middleToken === p2.token1Id && outputToken === p2.token2Id) {\n    // forward Pool\n    p2['reserves'] = {\n      [middleToken]: new Big(p2.token1Supply),\n      [outputToken]: new Big(p2.token2Supply),\n    };\n  } else if (outputToken === p2.token1Id && middleToken === p2.token2Id) {\n    //reverse pool\n    p2['reserves'] = {\n      [outputToken]: new Big(p2.token1Supply),\n      [middleToken]: new Big(p2.token2Supply),\n    };\n  }\n\n  let c1 = new Big(p1.reserves[middleToken]);\n  let a1 = new Big(p1.reserves[inputToken]);\n  let c2 = new Big(p2.reserves[middleToken]);\n  let b2 = new Big(p2.reserves[outputToken]);\n  let gamma1 = p1.gamma;\n  let gamma2 = p2.gamma;\n  let num = totalInput\n    .times(c1)\n    .times(b2)\n    .times(gamma1)\n    .times(gamma2);\n  let denom = c2\n    .times(a1)\n    .plus(\n      totalInput.times(c2.times(gamma1).plus(c1.times(gamma1).times(gamma2)))\n    );\n  // denom = c2*a1 + totalInput * (c2*gamma1 + c1*gamma1*gamma2)\n\n  return num.div(denom);\n}\n\nfunction getOutputFromRoute(route, nodeRoute, allocation) {\n  if (new Big(allocation).eq(new Big(0))) {\n    return new Big(0);\n  } else {\n    var allocation = new Big(allocation);\n  }\n  if (!route.length) {\n    route = [route];\n  }\n  if (route.length == 1) {\n    // single hop\n    let inputToken = nodeRoute[0];\n    let outputToken = nodeRoute[1];\n    let pool = route[0];\n    var output = getOutputSingleHop(pool, inputToken, outputToken, allocation);\n  } else if (route.length == 2) {\n    // DOUBLE HOP\n    let inputToken = nodeRoute[0];\n    let middleToken = nodeRoute[1];\n    let outputToken = nodeRoute[2];\n    let pools = route;\n    var output = getOutputDoubleHop(\n      pools,\n      inputToken,\n      middleToken,\n      outputToken,\n      allocation\n    );\n  }\n  return output;\n}\n\nfunction getOptOutputVec(routes, nodeRoutes, totalInput) {\n  let allocations = getOptimalAllocationForRoutes(\n    routes,\n    nodeRoutes,\n    totalInput\n  );\n  let result = [];\n  for (var i in routes) {\n    let route = routes[i];\n    let nodeRoute = nodeRoutes[i];\n    let allocation = allocations[i];\n    let output = getOutputFromRoute(route, nodeRoute, allocation);\n    result.push(output);\n  }\n  return {\n    result: result,\n    allocations: allocations,\n  };\n  //NOTE -- I made this return an object instead of the tuple returned in python. need to check the places it is called, and specify\n  // result field instead of tuple 0 position, and allocations field instead of tuple 1 position.\n}\n\nfunction getBestOptInputAndOutputSlower(routes, nodeRoutes, totalInput) {\n  let refDict = getOptOutputVecRefined(routes, nodeRoutes, totalInput);\n  let outputRefined = refDict.result;\n  let inputRefined = refDict.allocations;\n  inputRefined = checkIntegerSumOfAllocations(inputRefined, totalInput);\n  let rawDict = getOptOutputVec(routes, nodeRoutes, totalInput);\n  let outputRaw = rawDict.result;\n  let inputRaw = rawDict.allocations;\n  inputRaw = checkIntegerSumOfAllocations(inputRaw, totalInput);\n  let res1 = new Big(0);\n  let res2 = new Big(0);\n\n  for (var n in outputRefined) {\n    res1 = res1.plus(outputRefined[n]);\n  }\n  for (var nn in outputRaw) {\n    res2 = res2.plus(outputRaw[nn]);\n  }\n  // console.log('COMPARING SINGLE HOPS VS DOUBLE')\n  // console.log(res1.toString())\n  // console.log(res2.toString())\n  if (res1.gt(res2)) {\n    return { input: inputRefined, output: res1 };\n  } else {\n    return { input: inputRaw, output: res2 };\n  }\n}\n\nfunction getBestOptInputAndOutput(routes, nodeRoutes, totalInput) {\n  // let refDict = getOptOutputVecRefined(routes, nodeRoutes, totalInput);\n  // let outputRefined = refDict.result;\n  // let inputRefined = refDict.allocations;\n  // inputRefined = checkIntegerSumOfAllocations(inputRefined, totalInput);\n  let rawDict = getOptOutputVec(routes, nodeRoutes, totalInput);\n  let outputRaw = rawDict.result;\n  let inputRaw = rawDict.allocations;\n  inputRaw = checkIntegerSumOfAllocations(inputRaw, totalInput);\n  let res1 = new Big(0);\n  let res2 = new Big(0);\n\n  let res = outputRaw\n    .map(v => new Big(v))\n    .reduce((bv1, bv2) => bv1.plus(bv2), new Big(0));\n\n  return {\n    input: inputRaw,\n    output: res,\n  };\n}\n\nfunction getBestOptOutput(routes, nodeRoutes, totalInput) {\n  let outputRefined = getOptOutputVecRefined(routes, nodeRoutes, totalInput)\n    .result;\n  let outputRaw = getOptOutputVec(routes, nodeRoutes, totalInput).result;\n  let res1 = new Big(0);\n  let res2 = new Big(0);\n\n  for (var n in outputRefined) {\n    res1 = res1.plus(outputRefined[n]);\n  }\n  for (var nn in outputRaw) {\n    res2 = res2.plus(outputRaw[nn]);\n  }\n  if (res1.gt(res2)) {\n    return res1;\n  } else {\n    return res2;\n  }\n}\n\nfunction getBestOptInput(routes, nodeRoutes, totalInput) {\n  let refDict = getOptOutputVecRefined(routes, nodeRoutes, totalInput);\n  let outputRefined = refDict.result;\n  let inputRefined = refDict.allocations;\n  inputRefined = checkIntegerSumOfAllocations(inputRefined, totalInput);\n  let rawDict = getOptOutputVec(routes, nodeRoutes, totalInput);\n  let outputRaw = rawDict.result;\n  let inputRaw = rawDict.allocations;\n  inputRaw = checkIntegerSumOfAllocations(inputRaw, totalInput);\n  let res1 = new Big(0);\n  let res2 = new Big(0);\n\n  for (var n in outputRefined) {\n    res1 = res1.plus(outputRefined[n]);\n  }\n  for (var nn in outputRaw) {\n    res2 = res2.plus(outputRaw[nn]);\n  }\n  // console.log('COMPARING SINGLE HOPS VS DOUBLE')\n  // console.log(res1.toString())\n  // console.log(res2.toString())\n  if (res1.gt(res2)) {\n    return inputRefined;\n  } else {\n    return inputRaw;\n  }\n}\n\nfunction getOptOutputVecRefined(routes, nodeRoutes, totalInput) {\n  // need to calculate full result.\n  // if direct pools exist, need to calculate parallel result. if not, this portion is set to zero output.\n\n  // need to compare between outputs of the two results above.\n\n  let initLengthRoutes = routes.length;\n  let directRouteInds = [];\n  for (var routeInd in routes) {\n    let route = routes[routeInd];\n    if (!route.length) {\n      route = [route];\n    }\n    if (route.length == 1) {\n      directRouteInds.push(routeInd);\n    }\n  }\n  // console.log('DIRECT ROUTE INDS ARE')\n  // console.log(directRouteInds)\n  // if (directRouteInds.length < 1) {\n  var fullResultAllocations = getOptimalAllocationForRoutes(\n    routes,\n    nodeRoutes,\n    totalInput\n  );\n  var fullResult = [];\n  for (var i in routes) {\n    let r = routes[i];\n    let nr = nodeRoutes[i];\n    let a = fullResultAllocations[i];\n    let output = getOutputFromRoute(r, nr, a);\n    fullResult.push(output);\n  }\n  var fullResultTotal = fullResult.reduce((a, b) => a.plus(b), new Big(0));\n\n  // } else {\n  if (directRouteInds.length > 0) {\n    // console.log('DOING SINGLE HOP ONLY')\n    let droutes = [];\n    let dnodeRoutes = [];\n    for (var dri in directRouteInds) {\n      let ind = directRouteInds[dri];\n      droutes.push(routes[ind]);\n      dnodeRoutes.push(nodeRoutes[ind]);\n    }\n    let dallocations = getOptimalAllocationForRoutes(\n      droutes,\n      dnodeRoutes,\n      totalInput\n    );\n    let dallocDict = {};\n    for (var dd in dallocations) {\n      dallocDict[directRouteInds[dd]] = dallocations[dd];\n    }\n    var pallocations = [];\n\n    for (var ii = 0; ii < initLengthRoutes; ii++) {\n      if (directRouteInds.includes(ii.toString())) {\n        //console.log('ADDING ALLOCATION FOR SINGLE ROUTE')\n        pallocations.push(dallocDict[ii]);\n      } else {\n        pallocations.push(new Big(0));\n      }\n    }\n    var presult = [];\n    for (var j in routes) {\n      let route = routes[j];\n      let nodeRoute = nodeRoutes[j];\n      let allocation = pallocations[j];\n      let output = getOutputFromRoute(route, nodeRoute, allocation);\n      presult.push(output);\n    }\n    var presultTotal = presult.reduce((a, b) => a.plus(b), new Big(0));\n  } else {\n    var presultTotal = new Big(0);\n  }\n  if (presultTotal.gt(fullResultTotal)) {\n    var result = presult;\n    var allocations = pallocations;\n  } else {\n    var result = fullResult;\n    var allocations = fullResultAllocations;\n  }\n  // NEED TO COMPARE BETWEEEN DIRECT AND MULTI HOP TO GET BEST OUTPUT\n  return {\n    result: result,\n    allocations: allocations,\n  };\n}\n\nasync function getBestOptimalAllocationsAndOutputs(\n  pools,\n  inputToken,\n  outputToken,\n  totalInput,\n  maxPathLength = 3,\n  threshold = 0.001\n) {\n  var totalInput = new Big(totalInput);\n  let paths = await getPathsFromPools(\n    pools,\n    inputToken,\n    outputToken,\n    maxPathLength\n  );\n  if (!paths.length) {\n    return {\n      allocations: [],\n      outputs: new Big(0),\n      routes: [],\n      nodeRoutes: [],\n    };\n  }\n  let poolChains = await getPoolChainFromPaths(paths, pools, threshold);\n\n  let routes = await getRoutesFromPoolChain(poolChains);\n  let nodeRoutes = await getNodeRoutesFromPathsAndPoolChains(paths, poolChains);\n  // let allocations = await getBestOptInput(routes, nodeRoutes, totalInput);\n  // // fix integer rounding for allocations:\n  // allocations = checkIntegerSumOfAllocations(allocations, totalInput);\n  // let outputs = getBestOptOutput(routes, nodeRoutes, totalInput);\n  let inputOutput = await getBestOptInputAndOutput(\n    routes,\n    nodeRoutes,\n    totalInput\n  );\n  let allocations = inputOutput.input;\n  let outputs = inputOutput.output;\n\n  return {\n    allocations: allocations,\n    outputs: outputs,\n    routes: routes,\n    nodeRoutes: nodeRoutes,\n  };\n}\n\nfunction getHopsFromRoutes(routes, nodeRoutes, allocations) {\n  let hops = [];\n  for (var i in routes) {\n    var route = routes[i];\n    var nodeRoute = nodeRoutes[i];\n    var allocation = allocations[i];\n    if (!route.length) {\n      route = [route];\n    }\n    if (!route[0]) {\n      continue;\n    }\n    let hop = {\n      pool: route[0],\n      allocation: allocation,\n      inputToken: nodeRoute[0],\n      outputToken: nodeRoute[1],\n    };\n    hops.push(hop);\n  }\n  return hops;\n}\n\nfunction distillHopsByPool(hops) {\n  // console.log('some HOPS =');\n  // console.log(hops);\n  let distilledHops = [];\n  let poolIds = [];\n  let poolId2allocation = {};\n  for (var i in hops) {\n    let hop = hops[i];\n    if (hop.allocation === '0') {\n      continue;\n    }\n    // console.log(`HOP ${i} IS...`);\n    // console.log(hop);\n    let poolId = hop.pool['id'];\n    if (poolIds.includes(poolId)) {\n      poolId2allocation[poolId] = new Big(poolId2allocation[poolId])\n        .plus(new Big(hop.allocation))\n        .toString();\n    } else {\n      poolId2allocation[poolId] = new Big(hop.allocation).toString();\n      poolIds.push(poolId);\n    }\n  }\n  // let poolsWithOrder = [...new Set(...hops.map((item) => item.pool))]\n  let keys = Object.keys(poolId2allocation);\n  for (var j in keys) {\n    var poolId = keys[j];\n    let hop = hops.filter(\n      item => item.pool.id.toString() === poolId.toString()\n    )[0];\n    let distilledHop = {\n      pool: hop.pool,\n      allocation: poolId2allocation[poolId],\n      inputToken: hop.inputToken,\n      outputToken: hop.outputToken,\n    };\n    distilledHops.push(distilledHop);\n  }\n  return distilledHops;\n}\n\nfunction getDistilledHopActions(distilledHops, slippageTolerance) {\n  let actions = [];\n  for (var i in distilledHops) {\n    let hop = distilledHops[i];\n    let expectedAmountOut = getOutputSingleHop(\n      hop.pool,\n      hop.inputToken,\n      hop.outputToken,\n      hop.allocation\n    );\n    let minimumAmountOut = new Big(expectedAmountOut)\n      .times(new Big(1).minus(new Big(slippageTolerance).div(100)))\n      .round()\n      .toString(); //Here, assume slippage tolerance is a percentage. So 1% would be 1.0\n    let action = {\n      pool_id: hop.pool.id,\n      token_in: hop.inputToken,\n      token_out: hop.outputToken,\n      amount_in: hop.allocation,\n      min_amount_out: minimumAmountOut,\n    };\n    actions.push(action);\n  }\n  return actions;\n}\nfunction getMiddleTokenTotalsFromFirstHopActions(firstHopActions) {\n  let middleTokens = [...new Set(firstHopActions.map(item => item.token_out))];\n  let middleTokenTotals = {};\n  for (var i in middleTokens) {\n    let middleToken = middleTokens[i];\n    let mtActions = firstHopActions.filter(\n      item => item.token_out === middleToken\n    );\n    let mtTotal = mtActions\n      .map(item => new Big(item.min_amount_out))\n      .reduce((a, b) => a.plus(b), new Big(0))\n      .toString();\n    middleTokenTotals[middleToken] = mtTotal;\n  }\n  return middleTokenTotals;\n}\nfunction getRoutesAndAllocationsForMiddleToken(\n  routes,\n  nodeRoutes,\n  allocations,\n  middleToken,\n  middleTokenTotal\n) {\n  // get routes that use middle token.\n  // (input route alloction) /sum(input allocations of routes with middle token) * (total_middleToken)\n  let mask = [];\n  for (var i in nodeRoutes) {\n    if (nodeRoutes[i][1] === middleToken) {\n      mask.push(true);\n    } else {\n      mask.push(false);\n    }\n  }\n  let froutes = [];\n  let fallocations = [];\n  let fnoderoutes = [];\n  for (var i in routes) {\n    if (mask[i]) {\n      froutes.push(routes[i]);\n      fallocations.push(allocations[i]);\n      fnoderoutes.push(nodeRoutes[i]);\n    }\n  }\n  let sumfallocations = fallocations.reduce(\n    (a, b) => new Big(a).plus(new Big(b)),\n    new Big(0)\n  );\n  let middleAllocations = fallocations.map(item =>\n    new Big(item).div(sumfallocations).times(new Big(middleTokenTotal))\n  );\n  let secondHopRoutes = froutes.map(item => [item[1]]);\n  let secondHopNodeRoutes = fnoderoutes.map(item => [item[1], item[2]]);\n  middleAllocations = checkIntegerSumOfAllocations(\n    middleAllocations,\n    middleTokenTotal\n  );\n  return {\n    routes: secondHopRoutes,\n    nodeRoutes: secondHopNodeRoutes,\n    allocations: middleAllocations,\n  };\n}\n\nfunction getHopActionsFromRoutes(routes, nodeRoutes, allocations) {\n  // console.log('INSIDE GET HOP ACTIONS FROM ROUTES');\n  // console.log('ROUTES ARE...');\n  // console.log(routes);\n  // console.log('NODE ROUTES ARE...');\n  // console.log(nodeRoutes);\n  // console.log('ALLOCATIONS ARE...');\n  // console.log(allocations);\n  let totalInput = allocations\n    .map(a => new Big(a))\n    .reduce((a, b) => a.plus(b), new Big(0))\n    .toString();\n  let hops = [];\n  for (var i in routes) {\n    var route = routes[i];\n    var nodeRoute = nodeRoutes[i];\n    var allocation = allocations[i];\n    if (new Big(allocation).eq(new Big(0))) {\n      continue;\n    }\n    if (!route.length) {\n      route = [route];\n    }\n    if (!route[0]) {\n      continue;\n    }\n    for (var j in route) {\n      let pool = route[j];\n      // console.log('J IS...');\n      // console.log(j);\n      // console.log('NODE ROUTE IS...');\n      // console.log(nodeRoute);\n      if (j == 0) {\n        //first hop.\n        // console.log(nodeRoute[0]);\n        // console.log(nodeRoute[1]);\n        var hop = {\n          pool: pool,\n          allocation: allocation.toString(),\n          inputToken: nodeRoute[0],\n          outputToken: nodeRoute[1],\n          nodeRoute: nodeRoute,\n          route: route,\n          allRoutes: routes,\n          allNodeRoutes: nodeRoutes,\n          totalInputAmount: totalInput,\n          allAllocations: allocations,\n        };\n        // console.log('FIRST HOP IS...');\n        // console.log(hop);\n        hops.push(hop);\n        if (nodeRoute.length > 2) {\n          var middleTokenAllocation = getOutputSingleHop(\n            pool,\n            nodeRoute[0],\n            nodeRoute[1],\n            allocation\n          );\n        }\n      } else {\n        // second hop\n        var hop = {\n          pool: pool,\n          allocation: middleTokenAllocation.toString(),\n          inputToken: nodeRoute[1],\n          outputToken: nodeRoute[2],\n          nodeRoute: nodeRoute,\n          route: route,\n          allRoutes: routes,\n          allNodeRoutes: nodeRoutes,\n          totalInputAmount: totalInput,\n          allAllocations: allocations,\n        };\n        // console.log('SECOND HOP IS...');\n        // console.log(hop);\n        hops.push(hop);\n      }\n    }\n  }\n  // console.log('HOP ACTIONS FOUND TO BE');\n  // console.log(hops);\n  return hops;\n}\n\n// TODO: Clean this function. I don't need all the \"actions\" just the hops.\n// TODO: re-order actions to ensure each route is complete with zero input for second hop before starting next route.\nfunction getActionListFromRoutesAndAllocations(\n  routes,\n  nodeRoutes,\n  allocations\n) {\n  // REPLACE THE CODE BELOW WITH THE FUNCTION HERE.\n  return getHopActionsFromRoutes(routes, nodeRoutes, allocations);\n  var actions = [];\n  var all_hops = [];\n  let firstHops = getHopsFromRoutes(routes, nodeRoutes, allocations);\n\n  firstHops = firstHops.filter(hop => new Big(hop.allocation).gt(new Big(0)));\n  all_hops.push(...firstHops);\n  let distilledFirstHops = distillHopsByPool(firstHops);\n  let firstHopActions = getDistilledHopActions(\n    distilledFirstHops,\n    slippageTolerance\n  );\n  actions.push(...firstHopActions);\n  let middleTokenTotals = getMiddleTokenTotalsFromFirstHopActions(\n    firstHopActions\n  );\n  // console.log('first hop actions are...');\n  // console.log(firstHopActions);\n  let middleTokens = Object.keys(middleTokenTotals);\n  // console.log('middle token totals are...');\n  // console.log(middleTokenTotals);\n  // console.log('middle tokens are...');\n  // console.log(middleTokens);\n  for (var tokenIndex in middleTokens) {\n    var secondHops = [];\n    let middleToken = middleTokens[tokenIndex];\n    // console.log('current middle token is ');\n    // console.log(middleToken);\n    let middleTokenTotal = middleTokenTotals[middleToken];\n    // console.log('current middle token total is...');\n    // console.log(middleTokenTotal);\n    let middleTokenRoutesWithAllocations = getRoutesAndAllocationsForMiddleToken(\n      routes,\n      nodeRoutes,\n      allocations,\n      middleToken,\n      middleTokenTotal\n    );\n    // console.log('current middle tokens routes with allocations are...');\n    // console.log(middleTokenRoutesWithAllocations);\n    let middleTokenRoutes = middleTokenRoutesWithAllocations.routes;\n    let middleTokenAllocations = middleTokenRoutesWithAllocations.allocations;\n    let middleTokenNodeRoutes = middleTokenRoutesWithAllocations.nodeRoutes;\n    // console.log('middle token routes are...');\n    // console.log(middleTokenRoutes);\n    // console.log('middle token allocations are...');\n    // console.log(middleTokenAllocations);\n    // console.log('middle token node routes are...');\n    // console.log(middleTokenNodeRoutes);\n    secondHops.push(\n      ...getHopsFromRoutes(\n        middleTokenRoutes,\n        middleTokenNodeRoutes,\n        middleTokenAllocations\n      )\n    );\n    // console.log('CURRENT SECOND HOPS', secondHops);\n    // console.log(secondHops.length);\n    // console.log(secondHops.map((hop) => hop.allocation));\n    // console.log('filter out zero allocation 2nd hops:');\n    secondHops = secondHops.filter(hop =>\n      new Big(hop.allocation).gt(new Big(0))\n    );\n    // console.log(secondHops);\n    all_hops.push(...secondHops);\n    // console.log('second hops are currently...');\n    // console.log(secondHops);\n    let distilledSecondHopsForToken = distillHopsByPool(secondHops);\n    // console.log('distilled second hops are...');\n    let secondHopActionsForToken = getDistilledHopActions(\n      distilledSecondHopsForToken,\n      slippageTolerance\n    );\n    // console.log(secondHopActionsForToken);\n    actions.push(...secondHopActionsForToken);\n  }\n\n  //TODO: NEED TO RUN INTEGER ROUNDING FUNCTION ON MIDDLE TOKEN ALLOCATIONS\n\n  // TODO: check the node routes. for double-hop cases, find the hop action for each hop.\n  // For now, we are assuming no parallel swaps if there is a double-hop.\n\n  // Possible cases:\n  //  (1) 1 single-hop.\n  //  (2) Parallel single-hop ?\n  //  (3) 1 double-hop\n  //  (4) 2 double-hops\n\n  // We only have to worry about re-ordering the actions for cases (3) and (4).\n\n  let orderedHops = orderHops(all_hops, routes, nodeRoutes, allocations);\n\n  // console.log('ALL HOPS', all_hops);\n  return orderedHops;\n  // return actions;\n}\n\nfunction orderHops(hops, routes, nodeRoutes, allocations) {\n  // first get rid of zero allocation routes\n  // console.log('NODE ROUTES ARE...');\n  // console.log(nodeRoutes);\n  let filteredRoutes = [];\n  let filteredNodeRoutes = [];\n  let filteredAllocations = [];\n  for (var i in routes) {\n    // remove zero-allocation routes.\n    let allocation = new Big(allocations[i]);\n    if (allocation.gt(new Big(0))) {\n      filteredAllocations.push(allocation);\n      filteredRoutes.push(routes[i]);\n      filteredNodeRoutes.push(nodeRoutes[i]);\n    }\n    // console.log('FILTERED NODE ROUTES ARE...');\n    // console.log(filteredNodeRoutes);\n  }\n  // next check node routes to see if it is case 1, 2, 3, or 4.\n  // Possible cases:\n  //  (1) 1 single-hop.\n  //  (2) Parallel single-hop ?\n  //  (3) 1 double-hop\n  //  (4) 2 double-hops\n\n  if (filteredNodeRoutes.length === 1) {\n    // only one route.\n    let currentNodeRoute = filteredNodeRoutes[0];\n    if (currentNodeRoute.length === 2) {\n      // case 1.\n      return hops;\n    } else {\n      // case 3. assume there are only 3 nodes (double-hop)\n      //make sure order of hops is such that input token precedes output token.\n      //make sure the amount_in for second hop is zero (which will grab all of output of first hop to use.)\n      let firstHop = hops.filter(\n        hop => hop.inputToken === currentNodeRoute[0]\n      )[0];\n      let secondHop = hops.filter(\n        hop => hop.inputToken === currentNodeRoute[1]\n      )[0];\n      // set second hop amount in to 0 so that it will use whatever was generated by hop 1.\n      secondHop.pool.partialAmountIn = '0';\n\n      let orderedHops = [firstHop, secondHop];\n      return orderedHops;\n    }\n  } else if (filteredNodeRoutes.length === 2) {\n    // two routes.\n    let lengthNodeRoutes = filteredNodeRoutes.map(nr => nr.length);\n    // sub cases:\n    // [2,2] -- parallel swap. (direct) -- case 2\n    // [2,3] -- direct swap in parallel with double hop.\n    // [3,2] -- double hop in parallel with direct swap.\n    // [3,3] -- double hop in parallel with double hop. -- case 4\n    let orderedHops = [];\n    if (arrayEquals(lengthNodeRoutes, [2, 2])) {\n      return hops;\n    } else if (arrayEquals(lengthNodeRoutes, [2, 3])) {\n      directNodeRoute = filteredNodeRoutes[0];\n      doubleNodeRoute = filteredNodeRoutes[1];\n      let firstHop = hops.filter(\n        hop =>\n          hop.inputToken === directNodeRoute[0] &&\n          hop.outputToken === directNodeRoute[1]\n      )[0];\n      let secondHop = hops.filter(\n        hop => hop.inputToken === doubleNodeRoute[0]\n      )[0];\n      let thirdHop = hops.filter(\n        hop => hop.outputToken === doubleNodeRoute[2]\n      )[0];\n      // set third hop amount in to 0 so that it will use whatever was generated by hop 2.\n      thirdHop.pool.partialAmountIn = '0';\n      orderedHops = [firstHop, secondHop, thirdHop];\n      return orderedHops;\n    } else if (arrayEquals(lengthNodeRoutes, [3, 2])) {\n      directNodeRoute = filteredNodeRoutes[1];\n      doubleNodeRoute = filteredNodeRoutes[0];\n      let firstHop = hops.filter(\n        hop =>\n          hop.inputToken === directNodeRoute[0] &&\n          hop.outputToken === directNodeRoute[1]\n      )[0];\n      let secondHop = hops.filter(\n        hop => hop.inputToken === doubleNodeRoute[0]\n      )[0];\n      let thirdHop = hops.filter(\n        hop => hop.outputToken === doubleNodeRoute[2]\n      )[0];\n      // set third hop amount in to 0 so that it will use whatever was generated by hop 2.\n      thirdHop.pool.partialAmountIn = '0';\n      orderedHops = [firstHop, secondHop, thirdHop];\n      return orderedHops;\n    } else if (arrayEquals(lengthNodeRoutes, [3, 3])) {\n      orderedHops = [];\n\n      for (var i in filteredNodeRoutes) {\n        let doubleNodeRoute = filteredNodeRoutes[i];\n        let doubleHopMiddleToken = doubleNodeRoute[1];\n        let firstHop = hops.filter(\n          hop =>\n            hop.inputToken === doubleNodeRoute[0] &&\n            hop.outputToken === doubleHopMiddleToken\n        )[0];\n        let secondHop = hops.filter(\n          hop =>\n            hop.inputToken === doubleHopMiddleToken &&\n            hop.outputToken === doubleNodeRoute[2]\n        )[0];\n        // set second hop amount in to 0 so that it will use whatever was generated by hop 1.\n        secondHop.pool.partialAmountIn = '0';\n        orderedHops.push(firstHop);\n        orderedHops.push(secondHop);\n      }\n      return orderedHops;\n    } else {\n      return hops;\n    }\n    for (var i in filteredNodeRoutes) {\n      let currentNodeRoute = filteredNodeRoutes[i];\n      if (currentNodeRoute.length === 2) {\n      }\n    }\n  }\n\n  return hops;\n}\n\n// function getActionListFromRoutesAndAllocationsORIG(\n//   routes,\n//   nodeRoutes,\n//   allocations,\n//   slippageTolerance\n// ) {\n//   let actions = [];\n//   for (var i in routes) {\n//     let route = routes[i];\n//     let nodeRoute = nodeRoutes[i];\n//     let allocation = new Big(allocations[i]);\n//     if (allocation.eq(new Big(0))) {\n//       continue;\n//     }\n//     if (!route.length) {\n//       route = [route];\n//     }\n//     if (route.length === 1) {\n//       //single hop. only one action.\n//       let pool = route[0];\n//       let poolId = pool.id;\n//       let inputToken = nodeRoute[0];\n//       let outputToken = nodeRoute[1];\n//       let expectedAmountOut = getOutputSingleHop(\n//         pool,\n//         inputToken,\n//         outputToken,\n//         allocation\n//       );\n//       let minimumAmountOut = expectedAmountOut\n//         .times(new Big(1).minus(new Big(slippageTolerance).div(100)))\n//         .round()\n//         .toString(); //Here, assume slippage tolerance is a percentage. So 1% would be 1.0\n//       let action = {\n//         pool_id: poolId,\n//         token_in: inputToken,\n//         token_out: outputToken,\n//         amount_in: allocation.round().toString(),\n//         min_amount_out: minimumAmountOut.toString(),\n//       };\n//       actions.push(action);\n//     } else if (route.length === 2) {\n//       // double hop. two actions.\n//       let pool1 = route[0];\n//       let pool2 = route[1];\n//       let pool1Id = pool1.id;\n//       let pool2Id = pool2.id;\n//       let inputToken = nodeRoute[0];\n//       let middleToken = nodeRoute[1];\n//       let outputToken = nodeRoute[2];\n//       let expectedAmountOutFirstHop = getOutputSingleHop(\n//         pool1,\n//         inputToken,\n//         middleToken,\n//         allocation\n//       );\n//       let minimumAmountOutFirstHop = expectedAmountOutFirstHop\n//         .times(new Big(1).minus(new Big(slippageTolerance).div(100)))\n//         .round()\n//         .toString(); //Here, assume slippage tolerance is a percentage. So 1% would be 1.0\n\n//       let action1 = {\n//         pool_id: pool1Id,\n//         token_in: inputToken,\n//         token_out: middleToken,\n//         amount_in: allocation.round().toString(),\n//         min_amount_out: minimumAmountOutFirstHop,\n//       };\n//       let expectedFinalAmountOut = getOutputSingleHop(\n//         pool2,\n//         middleToken,\n//         outputToken,\n//         minimumAmountOutFirstHop\n//       );\n//       let minimumAMountOutSecondHop = expectedFinalAmountOut\n//         .times(new Big(1).minus(new Big(slippageTolerance).div(100)))\n//         .round()\n//         .toString();\n//       let action2 = {\n//         pool_id: pool2Id,\n//         token_in: middleToken,\n//         token_out: outputToken,\n//         amount_in: minimumAmountOutFirstHop,\n//         min_amount_out: minimumAMountOutSecondHop,\n//       };\n//       actions.push(action1);\n//       actions.push(action2);\n//     }\n//   }\n//   return actions;\n// }\n\nfunction* range(start, end) {\n  for (; start <= end; ++start) {\n    yield start;\n  }\n}\n\nfunction last(arr) {\n  return arr[arr.length - 1];\n}\n\nfunction* numericCombinations(n, r, loc = []) {\n  var idx = loc.length;\n  if (idx === r) {\n    yield loc;\n    return;\n  }\n  for (let next of range(idx ? last(loc) + 1 : 0, n - r + idx)) {\n    yield* numericCombinations(n, r, loc.concat(next));\n  }\n}\n\nfunction* combinations(arr, r) {\n  for (let idxs of numericCombinations(arr.length, r)) {\n    yield idxs.map(i => arr[i]);\n  }\n}\n\n//     #middleTokenTotals = getMiddleTokenTotals(routes,nodeRoutes,allocations)\n//     #TODO: complete this function with middle token checks.\n\n//     #consider all routes of length 2 with non-zero allocation. (double-hops)\n//     # among these, check for parallel swaps. That is, check for common node routes\n//     # for first hop. Then check for common node routes on second hop.\n//     # when common node routes occur for the first hop:\n//     # 1. Calculate the total expected output of intermediate token.\n//     # 2.\n//     # when common node routes occur for the second hop:\n//     # 1. get a ratio of the input allocations of the full routes associated with\n//     # these common node routes. allocate the total intermediate token output\n//     # toward these 2nd hop routes in the same ratio as their route input allocations.\n\nexport async function getSmartRouteSwapActions(\n  pools,\n  inputToken,\n  outputToken,\n  totalInput,\n  maxPathLength = 3,\n  threshold = 0.001,\n  numberOfRoutesLimit = 2,\n  MAX_NUMBER_PARALLEL_POOLS = 4,\n  decimalsCulledPoolIds = []\n) {\n  if (!totalInput) {\n    return [];\n  }\n  var totalInput = new Big(totalInput);\n\n  // remove pools that have an id from the decimalCulledPoolIds\n  pools = pools.filter(p => !decimalsCulledPoolIds.includes(p.id));\n\n  let resDict = await getBestOptimalAllocationsAndOutputs(\n    pools,\n    inputToken,\n    outputToken,\n    totalInput,\n    maxPathLength,\n    threshold\n  );\n\n  let allocations = resDict.allocations;\n\n  // let outputs = resDict.outputs;\n  let routes = resDict.routes;\n  let nodeRoutes = resDict.nodeRoutes;\n\n  let sortedIndexValues = argsort(allocations);\n  let topIndices = sortedIndexValues.slice(0, 10);\n  var reducedRoutes = [];\n  var reducedNodeRoutes = [];\n  for (var ind of topIndices) {\n    reducedRoutes.push(routes[ind]);\n    reducedNodeRoutes.push(nodeRoutes[ind]);\n  }\n  routes = reducedRoutes;\n  nodeRoutes = reducedNodeRoutes;\n\n  // TODO: compare pairs of routes to get the best allocation pair-wise.\n  var currentBestOutput = new Big(0);\n  var bestResDict = { routes: [] };\n  var bestAllocations = resDict.allocations;\n  var bestNodeRoutes = resDict.nodeRoutes;\n  var bestRoutes = resDict.routes;\n  // first check parallel swap with 4 actions. store result.\n  var parallelNodeRoutes = [];\n  var parallelRoutes = [];\n  for (var n in bestRoutes) {\n    let currentNodeRoute = bestNodeRoutes[n];\n    if (currentNodeRoute.length == 2) {\n      parallelNodeRoutes.push(currentNodeRoute);\n      parallelRoutes.push(bestRoutes[n]);\n    }\n  }\n  // console.log(`${parallelNodeRoutes.length} parallel routes found...`);\n  var bestRoutesAreParallel = false;\n  if (parallelNodeRoutes.length > 0) {\n    // first calculate the expected result using only parallel routes.\n    // let filteredAllocationsAndOutputs = getOptOutputVecRefined(parallelRoutes, parallelNodeRoutes, totalInput);\n    let filteredAllocationsAndOutputs = getOptOutputVec(\n      parallelRoutes,\n      parallelNodeRoutes,\n      totalInput\n    );\n    let parallellAllocations = filteredAllocationsAndOutputs.allocations;\n    let parallelOutputs = filteredAllocationsAndOutputs.result;\n\n    if (parallellAllocations.length > MAX_NUMBER_PARALLEL_POOLS) {\n      // now sort by allocation value to the top 4 parallel swaps:\n      let sortIndices = argsort(parallellAllocations);\n\n      sortIndices = sortIndices.slice(0, MAX_NUMBER_PARALLEL_POOLS);\n      var filteredParallelRoutes = [];\n      var filteredParallelNodeRoutes = [];\n      for (var i in sortIndices) {\n        filteredParallelRoutes.push(parallelRoutes[sortIndices[i]]);\n        filteredParallelNodeRoutes.push(parallelNodeRoutes[sortIndices[i]]);\n      }\n      filteredAllocationsAndOutputs = getOptOutputVec(\n        filteredParallelRoutes,\n        filteredParallelNodeRoutes,\n        totalInput\n      );\n      parallellAllocations = filteredAllocationsAndOutputs.allocations;\n      parallelOutputs = filteredAllocationsAndOutputs.result;\n    }\n\n    let parallelOutput = parallelOutputs.reduce(\n      (a, b) => a.plus(b),\n      new Big(0)\n    );\n    if (new Big(parallelOutput).gt(currentBestOutput)) {\n      bestAllocations = parallellAllocations;\n      currentBestOutput = parallelOutput;\n      // console.log(\n      //   'BEST OUTPUT FROM PARALLEL SWAPS IS NOW... ',\n      //   currentBestOutput.toString()\n      // );\n      bestRoutes = parallelRoutes;\n      bestNodeRoutes = parallelNodeRoutes;\n      bestRoutesAreParallel = true;\n    }\n  }\n  var canHaveTwoRoutes = false;\n  // initialize this variable to check if we can have two routes, or if all routes share a pool for an edge case.\n  // console.log('THE NUMBER OF ROUTES IS...', routes.length);\n\n  for (var i in routes) {\n    for (var j in routes) {\n      if (j > i) {\n        var route1 = routes[i];\n        var route2 = routes[j];\n        var nodeRoute1 = nodeRoutes[i];\n        var nodeRoute2 = nodeRoutes[j];\n        // check if they share a pool.\n        let route1PoolIds = new Set(route1.map(r => r.id));\n        let route2PoolIds = new Set(route2.map(r => r.id));\n        var sharePool = false;\n        for (var route1PoolId of route1PoolIds) {\n          if (route2PoolIds.has(route1PoolId)) {\n            sharePool = true;\n          }\n        }\n        if (sharePool) {\n          // routes are not independent. skip this pair.\n          // console.log('skipping this pair because pool was shared.');\n          continue;\n        } else {\n          canHaveTwoRoutes = true;\n          let currentRoutes = [route1, route2];\n          let currentNodeRoutes = [nodeRoute1, nodeRoute2];\n\n          let filteredAllocationsAndOutputs = getOptOutputVec(\n            currentRoutes,\n            currentNodeRoutes,\n            totalInput\n          );\n\n          let filteredAllocations = filteredAllocationsAndOutputs.allocations;\n          let filteredOutputs = filteredAllocationsAndOutputs.result;\n          // console.log('FILTERED ALLOCATIONS:');\n          // console.log(filteredAllocations.map((i) => i.toString()));\n          // console.log(filteredOutputs);\n          let totalOutput = filteredOutputs.reduce(\n            (a, b) => a.plus(b),\n            new Big(0)\n          );\n          if (new Big(totalOutput).gt(currentBestOutput)) {\n            bestAllocations = filteredAllocations;\n            currentBestOutput = totalOutput;\n            // console.log('BEST OUTPUT IS NOW... ', currentBestOutput.toString());\n            bestRoutes = currentRoutes;\n            bestNodeRoutes = currentNodeRoutes;\n            bestRoutesAreParallel = false;\n            // bestResDict = currentResDict\n          }\n\n          // if (currentResDict.outputs.gt(currentBestOutput)) {\n          // console.log('DIFF IS...', currentResDict.outputs.minus(currentBestOutput).toString());\n          // bestResDict = currentResDict;\n          // currentBestOutput = bestResDict.outputs;\n          // console.log('BEST OUTPUT IS NOW... ', currentBestOutput.toString());\n          // console.log(bestResDict.routes);\n          // console.log(bestResDict.allocations.map((i) => i.toString()));\n          // console.log(bestResDict.outputs.toString());\n        }\n      }\n    }\n  }\n\n  if (!canHaveTwoRoutes) {\n    // now we need to check through the routes in single manner to find the best one:\n    for (var i in routes) {\n      let currentRoutes = [routes[i]];\n      let currentNodeRoutes = [nodeRoutes[i]];\n      // let filteredAllocationsAndOutputs = getOptOutputVecRefined(currentRoutes, currentNodeRoutes, totalInput);\n      let filteredAllocationsAndOutputs = getOptOutputVec(\n        currentRoutes,\n        currentNodeRoutes,\n        totalInput\n      );\n\n      let filteredAllocations = filteredAllocationsAndOutputs.allocations;\n      let filteredOutputs = filteredAllocationsAndOutputs.result;\n      // console.log('FILTERED ALLOCATIONS:');\n      // console.log(filteredAllocations.map((i) => i.toString()));\n      // console.log(filteredOutputs);\n      let totalOutput = filteredOutputs.reduce((a, b) => a.plus(b), new Big(0));\n      if (new Big(totalOutput).gt(currentBestOutput)) {\n        bestAllocations = filteredAllocations;\n        currentBestOutput = totalOutput;\n        // console.log('BEST OUTPUT IS NOW... ', currentBestOutput.toString());\n        bestRoutes = currentRoutes;\n        bestNodeRoutes = currentNodeRoutes;\n        bestRoutesAreParallel = false;\n        // bestResDict = currentResDict\n      }\n    }\n  }\n\n  // resDict = bestResDict;\n\n  allocations = bestAllocations;\n\n  // let outputs = resDict.outputs;\n  routes = bestRoutes;\n  nodeRoutes = bestNodeRoutes;\n\n  if (routes.length < 1) {\n    return [];\n  }\n\n  // check the top numberOfRoutesLimit\n  // console.log('initial allocations are...');\n  // console.log(allocations.map((a) => a.toString()));\n  // console.log('fixed allocations are...');\n  // console.log(allocations.map((a) => new Big(a).toFixed()));\n  //SORT BY ALLOCATIONS\n  let allSortedIndices = argsort(allocations.map(a => new Big(a)));\n  if (bestRoutesAreParallel) {\n    numberOfRoutesLimit = 4;\n  }\n  let sortedIndices = allSortedIndices.slice(0, numberOfRoutesLimit);\n\n  // console.log('sorted Indices are');\n  // console.log(sortedIndices);\n  var filteredRoutes = [];\n  var filteredNodeRoutes = [];\n  for (var i in sortedIndices) {\n    let index = sortedIndices[i];\n    filteredRoutes.push(routes[index]);\n    filteredNodeRoutes.push(nodeRoutes[index]);\n  }\n\n  // console.log('filteredRoutes are ...');\n  // console.log(filteredRoutes);\n  for (var i in filteredRoutes) {\n    if (!filteredRoutes[i].length) {\n      filteredRoutes[i] = [filteredRoutes[i]];\n    }\n  }\n  // console.log('filtered Node routes are...');\n  // console.log(filteredNodeRoutes);\n\n  // THE BELOW CODE WILL ENSURE THAT ROUTES ARE INDEPENDENT (e.g. THE ROUTES WILL NOT SHARE A POOL)\n\n  let route1PoolIds = filteredRoutes[0].map(pool => pool.id);\n  // console.log('route 1 pool ids:');\n  // console.log(route1PoolIds);\n  if (filteredRoutes.length > 1) {\n    let route2PoolIds = filteredRoutes[1].map(pool => pool.id);\n    // console.log('route 2 pool ids:');\n    // console.log(route2PoolIds);\n    var sharedRoute = false;\n    for (var i in route2PoolIds) {\n      if (route1PoolIds.includes(route2PoolIds[i])) {\n        // a pool was shared between routes. need to calculate a new second route.\n        // console.log(\n        //   'a pool was shared between routes. going to calculate a new second route'\n        // );\n        sharedRoute = true;\n        break;\n      }\n    }\n  }\n\n  // NOTE -- this is a much simpler solution than that below. Instead of choosing the next best second route that doesn't share a\n  // pool with the first route, we could just use the first route and allocate all inputs to it.\n  // but, for larger transactions, it would be better to have option of two independent routes to spread out slippage.\n\n  // if (sharedRoute) {\n  //   filteredRoutes = [filteredRoutes[0]];\n  //   filteredNodeRoutes = [filteredNodeRoutes[0]];\n  //   // TODO -- later can add in a second route that doesn't share a pool with first.\n  // }\n\n  // We're going to find the next-highest allocation route that doesn't share a pool with the first route.\n  if (sharedRoute) {\n    let allFilteredRoutes = [];\n    let allFilteredNodeRoutes = [];\n    for (var i in allSortedIndices) {\n      allFilteredRoutes.push(routes[allSortedIndices[i]]);\n      allFilteredNodeRoutes.push(nodeRoutes[allSortedIndices[i]]);\n    }\n    let firstRoute = allFilteredRoutes[0];\n    // console.log('first route is...');\n    // console.log(firstRoute);\n    let firstRoutePoolIds = firstRoute.map(pool => pool.id);\n    for (var i in allFilteredRoutes) {\n      if (!allFilteredRoutes[i].length) {\n        allFilteredRoutes[i] = [allFilteredRoutes[i]];\n      }\n    }\n    // console.log('FIRST ROUTE POOL IDS ARE');\n    // console.log(firstRoutePoolIds);\n    let allFilteredRouteIds = allFilteredRoutes.map(route =>\n      route.map(pool => pool.id)\n    );\n    // console.log('allFilteredRouteIds are ...');\n    // console.log(allFilteredRouteIds);\n    for (var i in allFilteredRouteIds) {\n      // console.log('i is', i);\n      // console.log('ALL FILTERED ROUTES [i] IS...');\n      // console.log(allFilteredRouteIds[i]);\n      for (var j in allFilteredRouteIds[i]) {\n        // console.log('j is', j);\n        // console.log('ALL FILTERED ROUTES [i][j] IS...');\n        // console.log(allFilteredRouteIds[i][j]);\n        if (firstRoutePoolIds.includes(allFilteredRouteIds[i][j])) {\n          break;\n        }\n\n        var secondRoute = allFilteredRoutes[i];\n        if (!secondRoute.length) {\n          secondRoute = [secondRoute];\n        }\n        filteredRoutes = [allFilteredRoutes[0], secondRoute];\n        filteredNodeRoutes = [\n          allFilteredNodeRoutes[0],\n          allFilteredNodeRoutes[i],\n        ];\n        break;\n      }\n    }\n    // console.log('new filteredRoutes are ...');\n    // console.log(filteredRoutes);\n    // console.log('new filtered Node routes are...');\n    // console.log(filteredNodeRoutes);\n  }\n\n  // let filteredAllocations_check = getBestOptInput(\n  //   filteredRoutes,\n  //   filteredNodeRoutes,\n  //   totalInput\n  // );\n  // let filteredAllocationsAndOutputs = getOptOutputVecRefined(filteredRoutes, filteredNodeRoutes, totalInput);\n  let filteredAllocationsAndOutputs = getOptOutputVec(\n    filteredRoutes,\n    filteredNodeRoutes,\n    totalInput\n  );\n\n  let filteredAllocations = filteredAllocationsAndOutputs.allocations;\n  let filteredOutputs = filteredAllocationsAndOutputs.result;\n\n  filteredAllocations = checkIntegerSumOfAllocations(\n    filteredAllocations,\n    totalInput\n  ).map(stringAllo => new Big(stringAllo));\n\n  let hops = getActionListFromRoutesAndAllocations(\n    filteredRoutes,\n    filteredNodeRoutes,\n    filteredAllocations\n  );\n\n  var actions = [];\n  // console.log('hops are...');\n  // console.log(hops);\n\n  for (var i in hops) {\n    let hopInputTokenMeta = await ftGetTokenMetadata(hops[i].inputToken);\n    let hopOutputTokenMeta = await ftGetTokenMetadata(hops[i].outputToken);\n    let hopOutputTokenDecimals = hopOutputTokenMeta.decimals;\n\n    let expectedHopOutput = getOutputSingleHop(\n      hops[i].pool,\n      hops[i].inputToken,\n      hops[i].outputToken,\n      hops[i].allocation\n    );\n    let decimalEstimate = new Big(expectedHopOutput)\n      .div(new Big(10).pow(hopOutputTokenDecimals))\n      .toString();\n\n    // Need to check if expected Hop Output is > 1. If not, then cull the corresponding pool and re-calculate.\n    if (new Big(expectedHopOutput).lt(new Big(1))) {\n      // purge the pool and recalculate.\n\n      decimalsCulledPoolIds.push(hops[i].pool.id);\n      return getSmartRouteSwapActions(\n        pools,\n        inputToken,\n        outputToken,\n        totalInput,\n        (maxPathLength = maxPathLength),\n        (threshold = threshold),\n        (numberOfRoutesLimit = numberOfRoutesLimit),\n        (MAX_NUMBER_PARALLEL_POOLS = MAX_NUMBER_PARALLEL_POOLS),\n        (decimalsCulledPoolIds = decimalsCulledPoolIds)\n      );\n    }\n\n    if (\n      hops[i].inputToken == inputToken &&\n      hops[i].outputToken == outputToken\n    ) {\n      var status = 'parallel swap';\n    } else {\n      var status = 'stableSmart';\n    }\n\n    let tokens = await Promise.all(\n      hops[i].nodeRoute.map(async t => await ftGetTokenMetadata(t))\n    );\n\n    actions[i] = {\n      estimate: decimalEstimate,\n      pool: {\n        fee: hops[i].pool.fee,\n        gamma_bps: new Big(10000).minus(new Big(hops[i].pool.fee)), //.div(new Big(10000)), //hops[i].pool.gamma, //new Big(10000).minus(new Big(hops[i].pool.fee)).div(new Big(10000));\n        id: hops[i].pool.id,\n        partialAmountIn: new Big(hops[i].allocation).round().toString(),\n        supplies: {\n          [hops[i].pool.token1Id]: hops[i].pool.token1Supply,\n          [hops[i].pool.token2Id]: hops[i].pool.token2Supply,\n        },\n        token0_ref_price: hops[i].pool.token0_price,\n        tokenIds: [hops[i].pool.token1Id, hops[i].pool.token2Id],\n        Dex: hops[i].pool.Dex,\n      },\n      status: status,\n      token: hopInputTokenMeta,\n      outputToken: hops[i].outputToken,\n      inputToken: hops[i].inputToken,\n      nodeRoute: hops[i].nodeRoute,\n      route: hops[i].route,\n      allRoutes: hops[i].allRoutes,\n      allNodeRoutes: hops[i].allNodeRoutes,\n      totalInputAmount: hops[i].totalInputAmount,\n      allAllocations: hops[i].allAllocations,\n      tokens: tokens,\n      routeInputToken: inputToken,\n      routeOutputToken: outputToken,\n      overallPriceImpact: '0',\n    };\n    // console.log('INPUT TOKEN IS...');\n    // console.log(hops[i].inputToken);\n    actions[i].pool.x = actions[i].pool.supplies[hops[i].inputToken];\n    actions[i].pool.y = actions[i].pool.supplies[hops[i].outputToken];\n  }\n  // now set partial amount in for second hops equal to zero:\n  // also, set the total price impact value.\n  let overallPriceImpact = await calculateSmartRouteV2PriceImpact(actions);\n  for (var i in actions) {\n    let action = actions[i];\n    action.overallPriceImpact = overallPriceImpact;\n    if (action.outputToken === outputToken && action.inputToken != inputToken) {\n      // only want to set second hop partial amount in to zero\n      action.pool.partialAmountIn = '0';\n    }\n  }\n\n  return actions;\n}\n\nasync function calculateSmartRouteV2PriceImpact(actions) {\n  // the goal is to take a weighted average of the price impact per route, treating each one at a time.\n  // for single hop (parallel swaps), the price impact is calculated as before.\n  // for double-hop, the market price, P, is determined using reserves of tokens in each pool in the route.\n  // in both cases, we compare the 'market price', P , determined solely by reserves in pools, and the actual\n  // average price, R,  expected to be paid in the transaction.\n  // the price impact is then defined as (P-R)/R * 100 and is a percentage number, returned as a string.\n\n  let deltaY = actions\n    .filter(a => a.outputToken == a.routeOutputToken)\n    .map(a => new Big(a.estimate))\n    .reduce((a, b) => a.plus(b), new Big(0));\n  // console.log('DELTA Y IS...');\n  // console.log(deltaY.toString());\n\n  let inputTokenMeta = actions[0].tokens[0];\n  let deltaX = new Big(actions[0].totalInputAmount).div(\n    new Big(10).pow(inputTokenMeta.decimals)\n  );\n  let R = deltaY.div(deltaX);\n  var P = new Big(0);\n  let routes = actions[0].allRoutes;\n  let nodeRoutes = actions[0].allNodeRoutes;\n  let allocations = actions[0].allAllocations.map(a => new Big(a));\n  let totalAllocations = allocations\n    .map(a => new Big(a))\n    .reduce((a, b) => a.plus(b), new Big(0));\n\n  let weights = allocations.map(a => a.div(totalAllocations));\n\n  for (var i in routes) {\n    let route = routes[i];\n    let nodeRoute = nodeRoutes[i];\n    let tokens = await Promise.all(\n      nodeRoute.map(async t => await ftGetTokenMetadata(t))\n    );\n    let weight = weights[i];\n    if (route.length == 1) {\n      let num = new Big(route[0].reserves[nodeRoute[0]]).div(\n        new Big(10).pow(tokens[0].decimals)\n      );\n      let denom = new Big(route[0].reserves[nodeRoute[1]]).div(\n        new Big(10).pow(tokens[1].decimals)\n      );\n      var routeMarketPrice = num.div(denom);\n    } else {\n      let num1 = new Big(route[0].reserves[nodeRoute[0]]).div(\n        new Big(10).pow(tokens[0].decimals)\n      );\n\n      let denom1 = new Big(route[0].reserves[nodeRoute[1]]).div(\n        new Big(10).pow(tokens[1].decimals)\n      );\n\n      let num2 = new Big(route[1].reserves[nodeRoute[1]]).div(\n        new Big(10).pow(tokens[1].decimals)\n      );\n\n      let denom2 = new Big(route[1].reserves[nodeRoute[2]]).div(\n        new Big(10).pow(tokens[2].decimals)\n      );\n\n      var routeMarketPrice = num1\n        .div(denom1)\n        .times(num2)\n        .div(denom2);\n    }\n    P = P.plus(weight.times(new Big(1).div(routeMarketPrice)));\n  }\n\n  let priceImpact = P.minus(R)\n    .div(R)\n    .times(new Big(100))\n    .toString();\n  return priceImpact;\n}\n\nfunction decor(arr) {\n  var res = [];\n  for (var i in arr) {\n    res.push([arr[i], i]);\n  }\n  return res;\n}\nfunction argsort(arr) {\n  let undecor = a => a[1]; // leave only index\n  let decorated = decor(arr);\n\n  return decorated\n    .sort((a, b) => new Big(b[0]).minus(new Big(a[0])))\n    .map(undecor);\n}\n\nfunction getPoolsByToken1ORToken2(pools, token1, token2) {\n  let filteredPools = pools.filter(\n    item =>\n      item.token1Id === token1 ||\n      item.token2Id === token1 ||\n      item.token1Id === token2 ||\n      item.token2Id === token2\n  );\n  return filteredPools;\n}\n\nfunction getPoolsByToken1ANDToken2(\n  pools,\n  token1,\n  token2,\n  cullZeroLiquidityPools = true\n) {\n  let filteredPools = pools.filter(\n    item =>\n      (item.token1Id === token1 && item.token2Id === token2) ||\n      (item.token1Id === token2 && item.token2Id === token1)\n  );\n  if (cullZeroLiquidityPools) {\n    filteredPools = filteredPools.filter(\n      item => item.token1Supply != '0' && item.token2Supply != '0'\n    );\n  }\n  return filteredPools;\n}\n\nfunction getLiqudityOfPoolsFromList(pools) {\n  let liquidities = [];\n  for (var poolInd in pools) {\n    let pool = pools[poolInd];\n    pool.amounts = [pool.token1Supply, pool.token2Supply];\n    let poolBigAmounts = pool.amounts.map(item => new Big(item));\n    let liquidity = poolBigAmounts[0].times(poolBigAmounts[1]);\n    liquidities.push(liquidity);\n  }\n  return liquidities;\n}\n\nfunction getNormalizedLiquiditiesFromList(pools) {\n  let liquidities = getLiqudityOfPoolsFromList(pools);\n  let maxLiq = bigMax(liquidities);\n  let normalizedLiquidities = liquidities.map(item => item.div(maxLiq));\n  return normalizedLiquidities;\n}\n\nfunction bigMax(arrayOfBigs) {\n  if (arrayOfBigs.length < 1) {\n    return null;\n  }\n  let maxElem = arrayOfBigs[0];\n  for (var ind in arrayOfBigs) {\n    let val = arrayOfBigs[ind];\n    if (val.gt(maxElem)) {\n      maxElem = val;\n    }\n  }\n  return maxElem;\n}\n\nfunction cullPoolsWithInsufficientLiquidity(pools, threshold = 0.0001) {\n  var thresh = new Big(threshold);\n  let normLiq = getNormalizedLiquiditiesFromList(pools);\n  let filteredPools = [];\n  for (var i = 0; i < normLiq.length; i++) {\n    if (normLiq[i] > thresh) {\n      filteredPools.push(pools[i]);\n    }\n  }\n  return filteredPools;\n}\n\nfunction cartesianProduct(a) {\n  let result = a.reduce((a, b) => a.flatMap(d => b.map(e => [d, e].flat())));\n  return result;\n}\n\nfunction addEdge(g, edge) {\n  let src = edge[0];\n  let dst = edge[1];\n  if (Object.keys(g).includes(src)) {\n    if (!Object.keys(g[src]).includes(dst)) {\n      g[src][dst] = 1;\n    }\n  } else {\n    g[src] = {};\n    g[src][dst] = 1;\n  }\n  if (Object.keys(g).includes(dst)) {\n    if (!Object.keys(g[dst]).includes(src)) {\n      g[dst][src] = 1;\n    }\n  } else {\n    g[dst] = {};\n    g[dst][src] = 1;\n  }\n}\n\nfunction addEdges(g, edgeList) {\n  for (var n in edgeList) {\n    let edge = edgeList[n];\n    addEdge(g, edge);\n  }\n}\n\nfunction deleteEdge(g, edge) {\n  let gNew = JSON.parse(JSON.stringify(g)); // using this to deep clone graph structure\n  let e1 = edge[0];\n  let e2 = edge[1];\n  if (Object.keys(gNew).includes(e1)) {\n    if (Object.keys(gNew[e1]).includes(e2)) {\n      delete gNew[e1][e2];\n    }\n  }\n  if (Object.keys(gNew).includes(e2)) {\n    if (Object.keys(gNew[e2]).includes(e1)) {\n      delete gNew[e2][e1];\n    }\n  }\n  return gNew;\n}\n\nfunction deleteNode(g, node) {\n  let gNew = JSON.parse(JSON.stringify(g)); // using this to deep clone graph structure\n  if (Object.keys(gNew).includes(node)) {\n    delete gNew[node];\n  }\n  let keys = Object.keys(gNew);\n  for (var nodeInd in keys) {\n    let nodeNow = keys[nodeInd];\n    if (Object.keys(gNew[nodeNow]).includes(node)) {\n      delete gNew[nodeNow][node];\n    }\n  }\n  return gNew;\n}\n\nfunction dijkstra(graph, s) {\n  var solutions = {};\n  solutions[s] = {};\n  solutions[s].path = [];\n  solutions[s].dist = 0;\n\n  while (true) {\n    var parent = null;\n    var nearest = null;\n    var dist = Infinity;\n\n    //for each existing solution\n    for (var n in solutions) {\n      if (!solutions[n]) {\n        solutions[n] = {};\n      }\n      if (!solutions[n].path) continue;\n      var ndist = solutions[n].dist;\n      var adj = graph[n];\n      //for each of its adjacent nodes...\n      for (var a in adj) {\n        //without a solution already...\n        if (!solutions[a]) {\n          solutions[a] = {};\n        }\n        if (solutions[a].path) continue;\n        //choose nearest node with lowest *total* cost\n        var d = adj[a] + ndist;\n        if (d < dist) {\n          //reference parent\n          parent = solutions[n].path;\n          nearest = a;\n          dist = d;\n        }\n      }\n    }\n\n    //no more solutions\n    if (dist === Infinity) {\n      break;\n    }\n\n    //extend parent's solution path\n    solutions[nearest].path = parent.concat(nearest);\n    //extend parent's cost\n    solutions[nearest].dist = dist;\n  }\n\n  return solutions;\n}\n\nfunction shortestPath(g, src, dst, ignore_nodes = [], ignore_edges = []) {\n  let gTemp = JSON.parse(JSON.stringify(g)); // using this to deep clone graph structure. If we can use lodash, could use  _.cloneDeep(obj)\n  // remove nodes\n  for (var nodeInd in ignore_nodes) {\n    let nodeNow = ignore_nodes[nodeInd];\n    gTemp = deleteNode(gTemp, nodeNow);\n  }\n  // remove edges\n  for (var edgeInd in ignore_edges) {\n    let edgeNow = ignore_edges[edgeInd];\n    gTemp = deleteEdge(gTemp, edgeNow);\n  }\n  let solution = dijkstra(gTemp, src)[dst];\n  solution.path.unshift(src); // original algorithm doesn't include source node in path\n  return solution;\n}\n\nfunction* count(firstval = 0, step = 1) {\n  let x = firstval;\n  while (true) {\n    yield x;\n    x = x + 1;\n  }\n}\n\nclass PathBuffer {\n  constructor() {\n    this.paths = [];\n    this.sortedpaths = [];\n    //this.counter = count();\n  }\n  len() {\n    return this.sortedpaths.length;\n  }\n\n  push(cost, path) {\n    if (path && !arrayContains(this.paths, path)) {\n      this.sortedpaths.push([cost, path]);\n      this.sortedpaths.sort(function(a, b) {\n        return a[0] - b[0];\n      });\n      //heappush(this.sortedpaths, (cost, this.counter.next().value,path));\n      this.paths.push(path);\n    }\n  }\n\n  pop() {\n    //let val = heappop(this.sortedpaths);\n    let val = this.sortedpaths.shift();\n    let cost = val[0];\n    let path = val[1];\n    this.paths.splice(this.paths.indexOf(path), 1);\n    return path;\n  }\n}\n\nfunction arrayEquals(a, b) {\n  return (\n    Array.isArray(a) &&\n    Array.isArray(b) &&\n    a.length === b.length &&\n    a.every((val, index) => val === b[index])\n  );\n}\n\nfunction arrayContains(arr, obj) {\n  // checks to see if the input array contains a reference object, obj, using\n  // JSON.stringify() .\n  let obj_json = JSON.stringify(obj);\n  for (var itemInd in arr) {\n    if (JSON.stringify(arr[itemInd]) == obj_json) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction* yenFromPy(g, source, target) {\n  //adapted from the python implementation in networkx.algorithms.simple_paths.shortest_simple_paths()\n  let listA = [];\n  let listB = new PathBuffer();\n  let prev_path = null;\n\n  while (true) {\n    if (!prev_path) {\n      let sol = shortestPath(g, source, target);\n      let length = sol.dist;\n      let path = sol.path;\n      listB.push(length, path);\n    } else {\n      let ignore_nodes = [];\n      let ignore_edges = [];\n      for (var i = 1; i < prev_path.length; i++) {\n        let root = prev_path.slice(0, i);\n        let root_length = root.length;\n        for (var pathInd in listA) {\n          let path = listA[pathInd];\n\n          if (arrayEquals(path.slice(0, i), root)) {\n            let edgeToIgnore = [path[i - 1], path[i]];\n            ignore_edges.push(edgeToIgnore);\n          }\n        }\n        try {\n          let sol = shortestPath(\n            g,\n            root[root.length - 1],\n            target,\n            (ignore_nodes = ignore_nodes),\n            (ignore_edges = ignore_edges)\n          );\n          let length = sol.dist;\n          let spur = sol.path;\n          let path = root.slice(0, root.length - 1).concat(spur);\n          listB.push(root_length + length, path);\n        } catch (e) {\n          //console.log(`yenFromPy error was... ${e}`)\n          //dont do anything.\n        }\n        ignore_nodes.push(root[root.length - 1]);\n      }\n    }\n    if (listB.sortedpaths) {\n      try {\n        let path = listB.pop();\n        yield path;\n        listA.push(path);\n        prev_path = path;\n      } catch (e) {\n        break;\n      }\n    } else {\n      break;\n    }\n  }\n}\n\nfunction getKShortestPaths(g, source, target, k, maxPathLength = 3) {\n  let paths = [];\n  if (maxPathLength < 2) {\n    var maxPathLength = 2;\n  }\n  let gen = yenFromPy(g, source, target);\n  for (var n = 1; n <= k; n++) {\n    try {\n      let res = gen.next().value;\n      if (res && !arrayContains(paths, res)) {\n        if (res.length > maxPathLength) {\n          // console.log(\n          //   `found all hops of length ${\n          //     maxPathLength - 1\n          //   } or less... breaking out of generator`\n          // );\n          break;\n        }\n        paths.push(res);\n      }\n    } catch (e) {\n      break;\n    }\n  }\n  return paths;\n}\n\nasync function getPathsFromPools(\n  pools,\n  inputToken,\n  outputToken,\n  maxPathLength = 3\n) {\n  let graph = getGraphFromPoolList(pools);\n  return getKShortestPaths(graph, inputToken, outputToken, 100, maxPathLength);\n}\n\nasync function getAllPathsBelowLengthN(g, source, target, N, limit = 100) {\n  // use Yen's algorithm to find the paths of length N or below between source and target nodes in graph g.\n\n  let paths = [];\n\n  let gen = await yenFromPy(g, source, target);\n  let currentPathLength = 0;\n  let count = 1;\n  while (currentPathLength <= N) {\n    //   console.log(`CURRENT PATH LENGTH IS ${currentPathLength}`)\n    try {\n      let res = await gen.next().value;\n      //   console.log(`RES IS ${res}`)\n      if (res && !arrayContains(paths, res)) {\n        if (res.length > currentPathLength) {\n          currentPathLength = res.length;\n          if (currentPathLength > N) {\n            break;\n          }\n        }\n        paths.push(res);\n      }\n      count = count + 1;\n      if (count > limit) {\n        break;\n      }\n    } catch (e) {\n      //   console.log(e)\n      break;\n    }\n  }\n  return paths;\n}\n\nfunction getGraphFromPoolList(poolList) {\n  let pools = poolList.filter(\n    item => item.token1Supply != '0' && item.token2Supply != '0'\n  );\n  let transitions = pools.map(item => [item.token1Id, item.token2Id]);\n  let g = {};\n  addEdges(g, transitions);\n  return g;\n}\n\n////////////////////////////////////\n\n// MAIN FUNCTION\n\n////////////////////////////////////\n\n// TODO -- incorporate the following integrated function, which tries to\n// account for stablecoins within the context of smart routing.\n\n//TODO -- need the right API / hooks for GETSTABLESWAPACTION function and GETPARALLELSWAPACTIONS functions.\n\n//TODO -- transform the actions generated in this function into tranaction to execute.\n\n//TRYING: GETSTABLESWAPACTION <==> instantSwapGetTransactions\n\nexport async function stableSmart(\n  pools,\n  inputToken,\n  outputToken,\n  totalInput,\n  slippageTolerance\n) {\n  let smartRouteActions = await getSmartRouteSwapActions(\n    pools,\n    inputToken,\n    outputToken,\n    totalInput,\n    slippageTolerance\n  );\n  return smartRouteActions;\n}\n\nexport function getExpectedOutputFromActionsORIG(actions, outputToken) {\n  return actions\n    .filter(item => item.outputToken === outputToken)\n    .map(item => new Big(item.estimate))\n    .reduce((a, b) => a.plus(b), new Big(0));\n}\n\nfunction getFeeForRoute(route) {\n  if (!route.length) {\n    route = [route];\n  }\n  if (route.length == 1) {\n    // Single Hop case\n    let p = route[0];\n    return p.fee;\n  } else if (route.length == 2) {\n    //Double Hop Case\n    let p1 = route[0];\n    let p2 = route[1];\n    let fee1 = p1.fee;\n    let fee2 = p2.fee;\n    return fee1 + fee2;\n  }\n}\n\nexport function getAverageFeeForRoutes(routes, nodeRoutes, totalInput) {\n  let normalizedAllocations = getOptimalAllocationForRoutes(\n    routes,\n    nodeRoutes,\n    totalInput\n  ).map(a => a.div(new Big(totalInput)));\n  let averageFee = 0;\n  for (var i in routes) {\n    averageFee += normalizedAllocations[i] * getFeeForRoute(routes[i]);\n  }\n  return averageFee;\n}\n","import { TokenMetadata, Pool, StablePool, EstimateSwapView } from './types';\nimport {\n  toReadableNumber,\n  toNonDivisibleNumber,\n  scientificNotationToString,\n} from './utils';\nimport Big from 'big.js';\nimport { SameInputTokenError, ZeroInputError, NoPoolError } from './error';\nimport { ONLY_ZEROS, toPrecision } from './utils';\nimport _ from 'lodash';\nimport { FEE_DIVISOR } from './constant';\nimport { getSwappedAmount } from './stable-swap';\nimport { ftGetTokenMetadata, ftGetTokensMetadata } from './ref';\nimport { isStablePool } from './utils';\nimport {\n  getStablePoolDecimal,\n  isStablePoolToken,\n  poolFormatter,\n} from './utils';\nimport {\n  stableSmart,\n  getExpectedOutputFromActionsORIG,\n  //@ts-ignore\n} from './smartRoutingLogic.js';\n\nexport interface SwapParams {\n  tokenIn: TokenMetadata;\n  tokenOut: TokenMetadata;\n  amountIn: string;\n  simplePools: Pool[];\n  options?: SwapOptions;\n}\n\nexport interface SwapOptions {\n  enableSmartRouting?: boolean;\n  stablePools?: Pool[];\n  stablePoolsDetail?: StablePool[];\n}\n\nexport const getSimplePoolEstimate = ({\n  tokenIn,\n  tokenOut,\n  pool,\n  amountIn,\n}: {\n  tokenIn: TokenMetadata;\n  tokenOut: TokenMetadata;\n  pool: Pool;\n  amountIn: string;\n}) => {\n  const amount_with_fee = Number(amountIn) * (FEE_DIVISOR - pool.fee);\n  const in_balance = toReadableNumber(\n    tokenIn.decimals,\n    pool.supplies[tokenIn.id]\n  );\n  const out_balance = toReadableNumber(\n    tokenOut.decimals,\n    pool.supplies[tokenOut.id]\n  );\n  const estimate = new Big(\n    (\n      (amount_with_fee * Number(out_balance)) /\n      (FEE_DIVISOR * Number(in_balance) + amount_with_fee)\n    ).toString()\n  ).toFixed();\n\n  return {\n    token: tokenIn,\n    estimate,\n    pool,\n    outputToken: tokenOut.id,\n    inputToken: tokenIn.id,\n  };\n};\n\nexport const getStablePoolEstimate = ({\n  tokenIn,\n  tokenOut,\n  amountIn,\n  stablePool,\n}: {\n  tokenIn: TokenMetadata;\n  tokenOut: TokenMetadata;\n  amountIn: string;\n  stablePool: StablePool;\n}) => {\n  const STABLE_LP_TOKEN_DECIMALS = getStablePoolDecimal(stablePool);\n\n  const [amount_swapped, _, dy] = getSwappedAmount(\n    tokenIn.id,\n    tokenOut.id,\n    amountIn,\n    stablePool,\n    STABLE_LP_TOKEN_DECIMALS\n  );\n\n  const amountOut =\n    amount_swapped < 0 || isNaN(amount_swapped)\n      ? '0'\n      : toPrecision(scientificNotationToString(amount_swapped.toString()), 0);\n\n  const dyOut =\n    amount_swapped < 0 || isNaN(amount_swapped) || isNaN(dy)\n      ? '0'\n      : toPrecision(scientificNotationToString(dy.toString()), 0);\n\n  return {\n    estimate: toReadableNumber(STABLE_LP_TOKEN_DECIMALS, amountOut),\n    noFeeAmountOut: toReadableNumber(STABLE_LP_TOKEN_DECIMALS, dyOut),\n    pool: stablePool,\n    token: tokenIn,\n    outputToken: tokenOut.id,\n    inputToken: tokenIn.id,\n  };\n};\n\n/**\n * @description Get the estimate of the amount of tokenOut that can be received\n *\n */\nexport const singlePoolSwap = ({\n  tokenIn,\n  tokenOut,\n  simplePools,\n  amountIn,\n  stablePools,\n}: {\n  tokenIn: TokenMetadata;\n  tokenOut: TokenMetadata;\n  simplePools: Pool[];\n  amountIn: string;\n  stablePools?: StablePool[];\n}) => {\n  if (!simplePools || simplePools.length === 0) {\n    throw NoPoolError;\n  }\n\n  // const pools = simplePools.concat(stablePools);\n\n  const simplePoolsThisPair = simplePools.filter(\n    p => p.tokenIds.includes(tokenIn.id) && p.tokenIds.includes(tokenOut.id)\n  );\n\n  const estimatesSimplePool = simplePoolsThisPair.map(pool =>\n    getSimplePoolEstimate({\n      tokenIn,\n      tokenOut,\n      pool,\n      amountIn,\n    })\n  );\n\n  const stablePoolThisPair = stablePools?.filter(\n    sp =>\n      sp.token_account_ids.includes(tokenIn.id) &&\n      sp.token_account_ids.includes(tokenOut.id)\n  );\n\n  // different stable lp token decimal for different type of pools\n  const estimatesStablePool = stablePoolThisPair?.map(stablePool =>\n    getStablePoolEstimate({\n      tokenIn,\n      tokenOut,\n      amountIn,\n      stablePool,\n    })\n  );\n\n  const maxSimplePoolEstimate =\n    estimatesSimplePool.length === 1\n      ? estimatesSimplePool[0]\n      : _.maxBy(estimatesSimplePool, estimate => Number(estimate.estimate));\n\n  if (!estimatesStablePool) return maxSimplePoolEstimate;\n\n  const maxStablePoolEstimate =\n    estimatesStablePool.length === 1\n      ? estimatesStablePool[0]\n      : _.maxBy(estimatesStablePool, estimate => Number(estimate.estimate));\n\n  return Number(maxSimplePoolEstimate?.estimate) >\n    Number(maxStablePoolEstimate?.estimate)\n    ? maxSimplePoolEstimate\n    : maxStablePoolEstimate;\n};\n\nexport const getStablePoolsThisPair = ({\n  tokenInId,\n  tokenOutId,\n  stablePools,\n}: {\n  tokenInId: string;\n  tokenOutId: string;\n  stablePools: Pool[];\n}) => {\n  return stablePools.filter(\n    p =>\n      p.tokenIds.includes(tokenInId) &&\n      p.tokenIds.includes(tokenOutId) &&\n      tokenInId !== tokenOutId\n  );\n};\n\nexport const getPoolsByTokens = ({\n  pools,\n  tokenInId,\n  tokenOutId,\n}: {\n  pools: Pool[];\n  tokenInId: string;\n  tokenOutId: string;\n}) => {\n  if (tokenInId === tokenOutId) return [];\n\n  return pools.filter(\n    p => p.tokenIds.includes(tokenInId) && p.tokenIds.includes(tokenOutId)\n  );\n};\n\nexport const getPoolEstimate = async ({\n  tokenIn,\n  tokenOut,\n  amountIn,\n  stablePoolDetail,\n  pool,\n}: {\n  tokenIn: TokenMetadata;\n  tokenOut: TokenMetadata;\n  amountIn: string;\n  pool: Pool;\n  stablePoolDetail?: StablePool;\n}) => {\n  if (!!stablePoolDetail) {\n    return getStablePoolEstimate({\n      tokenIn,\n      tokenOut,\n      stablePool: stablePoolDetail,\n      amountIn,\n    });\n  } else {\n    return getSimplePoolEstimate({\n      tokenIn,\n      tokenOut,\n      pool,\n      amountIn,\n    });\n  }\n};\n\nexport async function getHybridStableSmart(\n  tokenIn: TokenMetadata,\n  tokenOut: TokenMetadata,\n  amountIn: string,\n  stablePools: Pool[],\n  stablePoolsDetail: StablePool[],\n  simplePools: Pool[]\n) {\n  if (\n    !isStablePoolToken(stablePoolsDetail, tokenIn.id) &&\n    !isStablePoolToken(stablePoolsDetail, tokenOut.id)\n  ) {\n    return { actions: [], estimate: '0' };\n  }\n\n  const stablePoolsDetailById = stablePoolsDetail.reduce((acc, cur) => {\n    return {\n      ...acc,\n      [cur.id]: cur,\n    };\n  }, {} as Record<string, StablePool>);\n\n  const parsedAmountIn = toNonDivisibleNumber(tokenIn.decimals, amountIn);\n\n  let pool1: Pool, pool2: Pool;\n\n  let pools1: Pool[] = [];\n  let pools2: Pool[] = [];\n\n  let pools1Right: Pool[] = [];\n  let pools2Right: Pool[] = [];\n\n  let candidatePools: Pool[][] = [];\n\n  /**\n   * find possible routes for this pair\n   *\n   *\n   */\n\n  if (isStablePoolToken(stablePoolsDetail, tokenIn.id)) {\n    // first hop will be through stable pool.\n    pools1 = stablePools.filter(pool => pool.tokenIds.includes(tokenIn.id));\n\n    const otherStables = pools1\n      .map(pool => pool.tokenIds.filter(id => id !== tokenIn.id))\n      .flat();\n\n    for (var otherStable of otherStables) {\n      let stablePoolsThisPair = getStablePoolsThisPair({\n        tokenInId: otherStable,\n        tokenOutId: tokenOut.id,\n        stablePools,\n      });\n\n      let tmpPools = getPoolsByTokens({\n        tokenInId: otherStable,\n        tokenOutId: tokenOut.id,\n        pools: simplePools,\n      });\n      const tobeAddedPools = tmpPools.concat(stablePoolsThisPair);\n      pools2.push(\n        ...tobeAddedPools.filter(p => {\n          const supplies = Object.values(p.supplies);\n          return new Big(supplies[0]).times(new Big(supplies[1])).gt(0);\n        })\n      );\n    }\n  }\n\n  if (isStablePoolToken(stablePoolsDetail, tokenOut.id)) {\n    // second hop will be through stable pool.\n    pools2Right = stablePools.filter(pool =>\n      pool.tokenIds.includes(tokenOut.id)\n    );\n\n    const otherStables = pools2Right\n      .map(pool => pool.tokenIds.filter(id => id !== tokenOut.id))\n      .flat();\n    for (let otherStable of otherStables) {\n      let stablePoolsThisPair = getStablePoolsThisPair({\n        tokenInId: tokenIn.id,\n        tokenOutId: otherStable,\n        stablePools,\n      });\n\n      let tmpPools = getPoolsByTokens({\n        tokenInId: tokenIn.id,\n        tokenOutId: otherStable,\n        pools: simplePools,\n      });\n\n      const tobeAddedPools = tmpPools.concat(stablePoolsThisPair);\n\n      pools1Right.push(\n        ...tobeAddedPools.filter(p => {\n          const supplies = Object.values(p.supplies);\n          return new Big(supplies[0]).times(new Big(supplies[1])).gt(0);\n        })\n      );\n    }\n  }\n\n  // find candidate pools\n\n  for (let p1 of pools1) {\n    let middleTokens = p1.tokenIds.filter((id: string) => id !== tokenIn.id);\n    for (let middleToken of middleTokens) {\n      let p2s = pools2.filter(\n        p =>\n          p.tokenIds.includes(middleToken) &&\n          p.tokenIds.includes(tokenOut.id) &&\n          middleToken !== tokenOut.id\n      );\n      let p2 = _.maxBy(p2s, p =>\n        Number(\n          new Big(toReadableNumber(tokenOut.decimals, p.supplies[tokenOut.id]))\n        )\n      );\n\n      if (middleToken === tokenOut.id) {\n        p2 = p1;\n      }\n\n      if (p1 && p2) {\n        if (p1.id === p2.id) candidatePools.push([p1]);\n        else candidatePools.push([p1, p2]);\n      }\n    }\n  }\n  for (let p1 of pools1Right) {\n    let middleTokens = p1.tokenIds.filter((id: string) => id !== tokenIn.id);\n    for (let middleToken of middleTokens) {\n      let p2s = pools2Right.filter(\n        p =>\n          p.tokenIds.includes(middleToken) &&\n          p.tokenIds.includes(tokenOut.id) &&\n          middleToken !== tokenOut.id\n      );\n      let p2 = _.maxBy(p2s, p =>\n        Number(\n          new Big(toReadableNumber(tokenOut.decimals, p.supplies[tokenOut.id]))\n        )\n      );\n\n      if (middleToken === tokenOut.id) {\n        p2 = p1;\n      }\n\n      if (p1 && p2) {\n        if (p1.id === p2.id) candidatePools.push([p1]);\n        else candidatePools.push([p1, p2]);\n      }\n    }\n  }\n\n  if (candidatePools.length > 0) {\n    const tokensMedata = await ftGetTokensMetadata(\n      candidatePools.map(cp => cp.map(p => p.tokenIds).flat()).flat()\n    );\n\n    const BestPoolPair =\n      candidatePools.length === 1\n        ? candidatePools[0]\n        : _.maxBy(candidatePools, poolPair => {\n            // only one pool case, only for stable tokens\n            if (poolPair.length === 1) {\n              if (isStablePool(stablePoolsDetail, poolPair[0].id)) {\n                const stablePoolThisPair = getStablePoolsThisPair({\n                  tokenInId: tokenIn.id,\n                  tokenOutId: tokenOut.id,\n                  stablePools,\n                })[0];\n\n                const stablePoolDetailThisPair = stablePoolsDetail.find(\n                  spd => spd.id === stablePoolThisPair.id\n                );\n\n                return Number(\n                  getStablePoolEstimate({\n                    tokenIn,\n                    tokenOut,\n                    stablePool: stablePoolDetailThisPair as StablePool,\n                    amountIn,\n                  }).estimate\n                );\n              } else {\n                return Number(\n                  getSimplePoolEstimate({\n                    tokenIn,\n                    tokenOut,\n                    amountIn,\n                    pool: poolPair[0],\n                  }).estimate\n                );\n              }\n            }\n\n            const [tmpPool1, tmpPool2] = poolPair;\n            const tokenMidId = poolPair[0].tokenIds.find((t: string) =>\n              poolPair[1].tokenIds.includes(t)\n            ) as string;\n\n            const tokenMidMeta = tokensMedata[tokenMidId];\n\n            const estimate1 = {\n              ...(isStablePool(stablePoolsDetail, tmpPool1.id)\n                ? getStablePoolEstimate({\n                    tokenIn,\n                    tokenOut: tokenMidMeta,\n                    amountIn,\n                    stablePool: stablePoolsDetailById[tmpPool1.id],\n                  })\n                : getSimplePoolEstimate({\n                    tokenIn,\n                    tokenOut: tokenMidMeta,\n                    amountIn,\n                    pool: tmpPool1,\n                  })),\n            };\n\n            const estimate2 = {\n              ...(isStablePool(stablePoolsDetail, tmpPool2.id)\n                ? getStablePoolEstimate({\n                    tokenIn: tokenMidMeta,\n                    tokenOut,\n                    amountIn: estimate1.estimate,\n                    stablePool: stablePoolsDetailById[tmpPool2.id],\n                  })\n                : getSimplePoolEstimate({\n                    tokenIn: tokenMidMeta,\n                    tokenOut,\n                    pool: tmpPool2,\n                    amountIn: estimate1.estimate,\n                  })),\n            };\n\n            return Number(estimate2.estimate);\n          });\n\n    // one pool case only get best price\n\n    if (!BestPoolPair) return { actions: [], estimate: '0' };\n\n    if (BestPoolPair.length === 1) {\n      const bestPool = BestPoolPair[0];\n      const estimate = await getPoolEstimate({\n        tokenIn,\n        tokenOut,\n        amountIn,\n        pool: bestPool,\n        stablePoolDetail: stablePoolsDetailById[bestPool.id],\n      });\n\n      return {\n        actions: [\n          {\n            ...estimate,\n            pool: { ...bestPool, parsedAmountIn: parsedAmountIn },\n            tokens: [tokenIn, tokenOut],\n            inputToken: tokenIn.id,\n            outputToken: tokenOut.id,\n            totalInputAmount: toNonDivisibleNumber(tokenIn.decimals, amountIn),\n          },\n        ],\n        estimate: estimate.estimate,\n      };\n    }\n\n    // two pool case get best price\n    [pool1, pool2] = BestPoolPair;\n\n    const tokenMidId = BestPoolPair[0].tokenIds.find((t: string) =>\n      BestPoolPair[1].tokenIds.includes(t)\n    ) as string;\n\n    const tokenMidMeta = await ftGetTokenMetadata(tokenMidId);\n\n    const estimate1 = {\n      ...(isStablePool(stablePoolsDetail, pool1.id)\n        ? getStablePoolEstimate({\n            tokenIn,\n            tokenOut: tokenMidMeta,\n            amountIn,\n            stablePool: stablePoolsDetailById[pool1.id],\n          })\n        : getSimplePoolEstimate({\n            tokenIn,\n            tokenOut: tokenMidMeta,\n            amountIn,\n            pool: pool1,\n          })),\n      tokens: [tokenIn, tokenMidMeta, tokenOut],\n      inputToken: tokenIn.id,\n      outputToken: tokenMidMeta.id,\n    };\n\n    estimate1.pool.partialAmountIn = parsedAmountIn;\n\n    const estimate2 = {\n      ...(isStablePool(stablePoolsDetail, pool2.id)\n        ? getStablePoolEstimate({\n            tokenIn: tokenMidMeta,\n            tokenOut,\n            amountIn: estimate1.estimate,\n            stablePool: stablePoolsDetailById[pool2.id],\n          })\n        : getSimplePoolEstimate({\n            tokenIn: tokenMidMeta,\n            tokenOut,\n            amountIn: estimate1.estimate,\n            pool: pool2,\n          })),\n\n      tokens: [tokenIn, tokenMidMeta, tokenOut],\n      inputToken: tokenMidMeta.id,\n      outputToken: tokenOut.id,\n    };\n\n    return { actions: [estimate1, estimate2], estimate: estimate2.estimate };\n  }\n\n  return { actions: [], estimate: '0' };\n}\n\n// simple pools and stable pools for this pair\nexport const estimateSwap = async ({\n  tokenIn,\n  tokenOut,\n  amountIn,\n  simplePools,\n  options,\n}: SwapParams) => {\n  if (tokenIn.id === tokenOut.id) throw SameInputTokenError;\n\n  if (ONLY_ZEROS.test(amountIn)) throw ZeroInputError;\n\n  const { enableSmartRouting, stablePools, stablePoolsDetail } = options || {};\n\n  const parsedAmountIn = toNonDivisibleNumber(tokenIn.decimals, amountIn);\n\n  if (!enableSmartRouting) {\n    const estimate = singlePoolSwap({\n      tokenIn,\n      tokenOut,\n      simplePools,\n      amountIn,\n      stablePools: stablePoolsDetail,\n    });\n\n    return [\n      {\n        ...estimate,\n        pool: { ...estimate?.pool, partialAmountIn: parsedAmountIn },\n      },\n    ] as EstimateSwapView[];\n  } else {\n    const inputPools = simplePools.map(p => poolFormatter(p));\n\n    const simplePoolSmartRoutingActions = await stableSmart(\n      inputPools,\n      tokenIn.id,\n      tokenOut.id,\n      parsedAmountIn\n    );\n\n    const simplePoolSmartRoutingEstimate = getExpectedOutputFromActionsORIG(\n      simplePoolSmartRoutingActions,\n      tokenOut.id\n    ).toString();\n\n    const hybridSmartRoutingRes = await getHybridStableSmart(\n      tokenIn,\n      tokenOut,\n      amountIn,\n      stablePools || [],\n      stablePoolsDetail || [],\n      simplePools\n    );\n\n    const hybridSmartRoutingEstimate = hybridSmartRoutingRes.estimate.toString();\n\n    if (\n      new Big(simplePoolSmartRoutingEstimate || '0').gte(\n        hybridSmartRoutingEstimate || '0'\n      )\n    ) {\n      if (!simplePoolSmartRoutingActions?.length) throw NoPoolError;\n      return simplePoolSmartRoutingActions as EstimateSwapView[];\n    } else {\n      return hybridSmartRoutingRes.actions as EstimateSwapView[];\n    }\n  }\n};\n","import {\n  keyStores,\n  KeyPair,\n  InMemorySigner,\n  providers,\n  transactions as nearTransactions,\n} from 'near-api-js';\nimport { InMemoryKeyStore } from 'near-api-js/lib/key_stores';\nimport { getConfig } from './constant';\nimport { keyStore } from './ref';\n\n// const KEY_PATH = `/.near-credentials/testnet/juaner.testnet.json`;\n\nexport const provider = new providers.JsonRpcProvider({\n  url: getConfig().nodeUrl,\n});\n\nexport const getMemorySigner = ({\n  AccountId,\n  keyPath,\n}: {\n  AccountId: string;\n  keyPath: string;\n}) => {\n  const homedir = require('os').homedir();\n  const CREDENTIALS_DIR = '.near-credentials';\n  const credentialsPath = require('path').join(homedir, CREDENTIALS_DIR);\n  const myKeyStore = new keyStores.UnencryptedFileSystemKeyStore(\n    credentialsPath\n  );\n  // myKeyStore.setKey(\n  //   getConfig().networkId,\n  //   AccountId,\n  //   KeyPair.fromString(credentials.private_key)\n  // );\n\n  const signer = new InMemorySigner(myKeyStore);\n\n  console.log(signer);\n\n  // return signer;\n};\n\n// export const getSignedTransactions = async () => {\n//   const block = await provider.block({ finality: 'final' });\n\n//   for (let i = 0; i < transactions.length; i += 1) {\n//     const transaction = transactions[i];\n//     const publicKey = await signer.getPublicKey(\n//       transaction.signerId,\n//       getConfig().networkId\n//     );\n\n//     if (!publicKey) {\n//       throw new Error('No public key found');\n//     }\n\n//     const accessKey = await provider.query<AccessKeyView>({\n//       request_type: 'view_access_key',\n//       finality: 'final',\n//       account_id: transaction.signerId,\n//       public_key: publicKey.toString(),\n//     });\n\n//     if (!validateAccessKey(transaction, accessKey)) {\n//       throw new Error('Invalid access key');\n//     }\n\n//     const tx = nearTransactions.createTransaction(\n//       transactions[i].signerId,\n//       utils.PublicKey.from(publicKey.toString()),\n//       transactions[i].receiverId,\n//       accessKey.nonce + i + 1,\n//       transaction.actions.map(action => createAction(action)),\n//       utils.serialize.base_decode(block.header.hash)\n//     );\n\n//     const [, signedTx] = await nearTransactions.signTransaction(\n//       tx,\n//       signer,\n//       transactions[i].signerId,\n//       options.network.networkId\n//     );\n\n//     signedTransactions.push(signedTx);\n//   }\n// };\n"],"names":["FEE_DIVISOR","STABLE_LP_TOKEN_DECIMALS","RATED_POOL_LP_TOKEN_DECIMALS","getConfig","env","process","NEAR_ENV","networkId","nodeUrl","walletUrl","WRAP_NEAR_CONTRACT_ID","REF_FI_CONTRACT_ID","config","STORAGE_TO_REGISTER_WITH_MFT","ONE_YOCTO_NEAR","formatError","msg","Error","unNamedError","SameInputTokenError","ZeroInputError","NoPoolError","NotLoginError","SwapRouteError","TokenNotExistError","parsePool","pool","id","Number","tokenIds","token_account_ids","supplies","amounts","reduce","acc","amount","i","fee","total_fee","shareSupply","shares_total_supply","tvl","token0_ref_price","pool_kind","poolFormatter","token1Id","token2Id","token1Supply","token2Supply","shares","token0_price","isStablePoolToken","stablePools","tokenId","map","p","flat","includes","toString","isStablePool","poolId","getStablePoolDecimal","stablePool","round","decimals","minAmountOut","isInteger","Math","ceil","pow","convertToPercentDecimal","percent","math","percentOf","num","percentLess","notation","getGas","gas","BN","getAmount","utils","format","parseNearAmount","ONLY_ZEROS","toReadableNumber","number","wholeStr","substring","length","fractionStr","padStart","replace","toNonDivisibleNumber","undefined","split","wholePart","fracPart","padEnd","slice","scientificNotationToString","strParam","flag","test","sysbol","negative","index","match","basis","ifFraction","formatWithCommas","value","pattern","toPrecision","precision","withCommas","atLeastOne","whole","decimal","str","n","lastIndexOf","instantSwap","tokenIn","tokenOut","amountIn","slippageTolerance","swapTodos","transactions","at","outputToken","actionsList","allSwapsTokens","s","inputToken","swapTokens","push","pool_id","token_in","token_out","amount_in","partialAmountIn","min_amount_out","estimate","receiverId","functionCalls","methodName","args","receiver_id","JSON","stringify","force","actions","keyStore","keyStores","BrowserLocalStorageKeyStore","near","Near","headers","wallet","WalletConnection","refFiViewFunction","account","viewFunction","ftViewFunction","ftGetStorageBalance","accountId","getAccountId","account_id","getTotalPools","ftGetTokenMetadata","metadata","ftGetTokensMetadata","Promise","all","tokensMetadata","pre","cur","DEFAULT_PAGE_LIMIT","getRatedPoolDetail","then","pool_info","getUnRatedPoolDetail","rates","c_amounts","_","getStablePoolsDetail","getRefPools","page","perPage","from_index","limit","poolData","rawPool","fetchAllRefPools","totalPools","pages","Array","pools","simplePools","filter","unRatedPools","ratedPools","tradeFee","trade_fee","calc_d","amp","token_num","sum_amounts","sum","d_prev","d","d_prod","c_amount","ann","numerator","denominator","abs","calc_y","x_c_amount","current_c_amounts","index_x","index_y","c","b","y_prev","y","y_numerator","y_denominator","calc_swap","in_token_idx","in_c_amount","out_token_idx","old_c_amounts","dy","amount_swapped","getSwappedAmount","tokenInId","tokenOutId","findIndex","r","base_old_c_amounts","Big","times","RM","DP","NE","PE","checkIntegerSumOfAllocations","allocations","totalInput","item","alloSum","a","plus","offset","minus","currMax","currMaxInd","gt","newAllocations","j","yenFromPy","bisqrt","BigInt","newtonIteration","x0","x1","getBetaForRoute","route","path","beta","reserves","p1","p2","getEpsilonForRoute","gamma","div","epsilon","gamma1","gamma2","getAlphaForRoute","key1","key2","val1","val2","alpha","key11","key12","val11","val12","key21","key22","val21","val22","middleToken","alpha1","alpha2","getAlphaSumFromRoutes","routes","nodeRoutes","alphaSum","nodeRoute","radical","toFixed","denom","getBetaSumFromRoutes","betaSum","getPhiFromRoutes","phi","getAllocationForRoute","allocation","getAllocationVectorForRoutes","allocationVec","getOptimalAllocationForRoutes","every","lt","some","reduceRoutes","sumAllocations","normalizedAllocations","goodIndices","dx","newRoutes","newNodeRoutes","goodIndex","allocationDict","allocationVecNew","zeroAllocation","getNodeRoutesFromPathsAndPoolChains","paths","poolChains","multiplicity","pc","mul","elem1","elem2","m","k","getPoolChainFromPaths","threshold","pathInd","chain","pairs","pairInd","pair","tokenPools","getPoolsByToken1ANDToken2","culledPoolChains","getCulledPoolChains","newChains","newPath","legInd","leg","culledPath","cullPoolsWithInsufficientLiquidity","getRoutesFromPoolChain","pci","poolChain","cartesianProduct","getOutputSingleHop","getOutputDoubleHop","poolIndex","c1","a1","c2","b2","getOutputFromRoute","eq","output","getOptOutputVec","result","getBestOptInputAndOutput","rawDict","outputRaw","inputRaw","res1","res2","res","v","bv1","bv2","input","getBestOptimalAllocationsAndOutputs","maxPathLength","getPathsFromPools","outputs","inputOutput","getHopActionsFromRoutes","hops","hop","allRoutes","allNodeRoutes","totalInputAmount","allAllocations","middleTokenAllocation","getActionListFromRoutesAndAllocations","getSmartRouteSwapActions","numberOfRoutesLimit","MAX_NUMBER_PARALLEL_POOLS","decimalsCulledPoolIds","resDict","sortedIndexValues","argsort","topIndices","reducedRoutes","reducedNodeRoutes","ind","currentBestOutput","bestAllocations","bestNodeRoutes","bestRoutes","parallelNodeRoutes","parallelRoutes","currentNodeRoute","bestRoutesAreParallel","filteredAllocationsAndOutputs","parallellAllocations","parallelOutputs","sortIndices","filteredParallelRoutes","filteredParallelNodeRoutes","parallelOutput","canHaveTwoRoutes","route1","route2","nodeRoute1","nodeRoute2","route1PoolIds","Set","route2PoolIds","sharePool","route1PoolId","has","currentRoutes","currentNodeRoutes","filteredAllocations","filteredOutputs","totalOutput","allSortedIndices","sortedIndices","filteredRoutes","filteredNodeRoutes","sharedRoute","allFilteredRoutes","allFilteredNodeRoutes","firstRoute","firstRoutePoolIds","allFilteredRouteIds","secondRoute","stringAllo","hopInputTokenMeta","hopOutputTokenMeta","hopOutputTokenDecimals","expectedHopOutput","decimalEstimate","status","t","tokens","gamma_bps","Dex","token","routeInputToken","routeOutputToken","overallPriceImpact","x","calculateSmartRouteV2PriceImpact","action","deltaY","inputTokenMeta","deltaX","R","P","totalAllocations","weights","weight","routeMarketPrice","num1","denom1","num2","denom2","priceImpact","decor","arr","undecor","decorated","sort","token1","token2","cullZeroLiquidityPools","filteredPools","getLiqudityOfPoolsFromList","liquidities","poolInd","poolBigAmounts","liquidity","getNormalizedLiquiditiesFromList","maxLiq","bigMax","normalizedLiquidities","arrayOfBigs","maxElem","val","thresh","normLiq","flatMap","e","addEdge","g","edge","src","dst","Object","keys","addEdges","edgeList","deleteEdge","gNew","parse","e1","e2","deleteNode","node","nodeInd","nodeNow","dijkstra","graph","solutions","dist","parent","nearest","Infinity","ndist","adj","concat","shortestPath","ignore_nodes","ignore_edges","gTemp","edgeInd","edgeNow","solution","unshift","PathBuffer","sortedpaths","len","cost","arrayContains","pop","shift","splice","indexOf","arrayEquals","isArray","obj","obj_json","itemInd","source","target","listA","listB","prev_path","sol","root","root_length","edgeToIgnore","spur","getKShortestPaths","gen","next","getGraphFromPoolList","poolList","transitions","stableSmart","smartRouteActions","getExpectedOutputFromActionsORIG","getSimplePoolEstimate","amount_with_fee","in_balance","out_balance","getStablePoolEstimate","amountOut","isNaN","dyOut","noFeeAmountOut","singlePoolSwap","simplePoolsThisPair","estimatesSimplePool","stablePoolThisPair","sp","estimatesStablePool","maxSimplePoolEstimate","maxBy","maxStablePoolEstimate","getStablePoolsThisPair","getPoolsByTokens","getPoolEstimate","stablePoolDetail","getHybridStableSmart","stablePoolsDetail","stablePoolsDetailById","parsedAmountIn","pools1","pools2","pools1Right","pools2Right","candidatePools","otherStables","otherStable","stablePoolsThisPair","tmpPools","tobeAddedPools","values","middleTokens","p2s","cp","tokensMedata","BestPoolPair","poolPair","stablePoolDetailThisPair","find","spd","tmpPool1","tmpPool2","tokenMidId","tokenMidMeta","estimate1","estimate2","bestPool","pool1","pool2","estimateSwap","options","enableSmartRouting","inputPools","simplePoolSmartRoutingActions","simplePoolSmartRoutingEstimate","hybridSmartRoutingRes","hybridSmartRoutingEstimate","gte","provider","providers","JsonRpcProvider","url","getMemorySigner","homedir","require","CREDENTIALS_DIR","credentialsPath","join","myKeyStore","UnencryptedFileSystemKeyStore","signer","InMemorySigner","console","log"],"mappings":"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"}