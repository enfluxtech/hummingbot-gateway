{"version":3,"file":"LiquidityBase.js","sources":["../../../../src/core/liquidity/LiquidityBase.ts"],"sourcesContent":["import { Channel, ChannelEventSource, ChannelRegistry } from \"../../internal\"\nimport { TICK_MAX, TICK_MIN, tickToPrice } from \"../../utils\"\n\nimport Big from \"big.js\"\nimport { Market } from \"../market\"\nimport { Q96 } from \"../../constants\"\n\nexport enum RangeType {\n    RANGE_UNINITIALIZED = \"RANGE_UNINITIALIZED\",\n    RANGE_INVALID = \"RANGE_INVALID\",\n    RANGE_INSIDE = \"RANGE_INSIDE\",\n    RANGE_AT_LEFT = \"RANGE_AT_LEFT\", // lower < upper < markPrice\n    RANGE_AT_RIGHT = \"RANGE_AT_RIGHT\", // markPrice < lower < upper\n}\n\ntype LiquidityBaseEventName = \"updateError\" | \"updated\"\n\nexport interface EventPayloadRangeTypeUpdated {\n    rangeType: RangeType\n    markPrice: Big\n}\n\nexport interface LiquidityBaseConstructorData {\n    market: Market\n}\n\nexport class LiquidityBase<EventName extends string = \"\"> extends Channel<EventName | LiquidityBaseEventName> {\n    readonly market: Market\n\n    // TODO: should have init value?\n    protected _lowerTick = TICK_MIN\n    protected _upperTick = TICK_MAX\n    protected _markPrice?: Big\n\n    constructor({ market }: LiquidityBaseConstructorData, _channelRegistry?: ChannelRegistry) {\n        super(_channelRegistry)\n\n        this.market = market\n    }\n\n    get lowerTick() {\n        return this._lowerTick\n    }\n\n    get upperTick() {\n        return this._upperTick\n    }\n\n    get lowerTickPrice() {\n        return tickToPrice(this._lowerTick)\n    }\n\n    get upperTickPrice() {\n        return tickToPrice(this._upperTick)\n    }\n\n    async getRangeType({ cache = true } = {}) {\n        const { markPrice } = await this.market.getPrices({ cache })\n        return LiquidityBase.getRangeTypeByMarkPrice(markPrice, this.lowerTickPrice, this.upperTickPrice)\n    }\n\n    protected _getEventSourceMap() {\n        const updateDataEventSource = new ChannelEventSource<EventName | LiquidityBaseEventName>({\n            eventSourceStarter: () => {\n                return this.market.on(\"updated\", () => this.emit(\"updated\", this))\n            },\n        })\n\n        return {\n            updated: updateDataEventSource,\n            updateError: updateDataEventSource,\n        }\n    }\n\n    static getRangeTypeByMarkPrice(markPrice: Big, lowerTickPrice: Big, upperTickPrice: Big) {\n        if (upperTickPrice.lte(lowerTickPrice)) {\n            return RangeType.RANGE_INVALID\n        }\n        if (markPrice.gte(upperTickPrice)) {\n            return RangeType.RANGE_AT_LEFT\n        } else if (markPrice.lte(lowerTickPrice)) {\n            return RangeType.RANGE_AT_RIGHT\n        }\n        return RangeType.RANGE_INSIDE\n    }\n\n    static getLiquidityFromBaseToken(markPriceSqrtX96: Big, upperPriceSqrtX96: Big, amount: Big) {\n        const numerator = amount.mul(markPriceSqrtX96).mul(upperPriceSqrtX96)\n        const denominator = Q96.mul(upperPriceSqrtX96.sub(markPriceSqrtX96))\n\n        return numerator.div(denominator)\n    }\n\n    static getLiquidityFromQuoteToken(markPriceSqrtX96: Big, lowerPriceSqrtX96: Big, amount: Big) {\n        const numerator = amount.mul(Q96)\n        const denominator = markPriceSqrtX96.sub(lowerPriceSqrtX96)\n\n        return numerator.div(denominator)\n    }\n\n    static getBaseTokenAmountFromLiquidity(priceASqrtX96: Big, priceBSqrtX96: Big, liquidity: Big) {\n        const [lowerPriceSqrtX96, upperPriceSqrtX96] = priceASqrtX96.lt(priceBSqrtX96)\n            ? [priceASqrtX96, priceBSqrtX96]\n            : [priceBSqrtX96, priceASqrtX96]\n\n        const numerator1 = liquidity.mul(Q96)\n        const numerator2 = upperPriceSqrtX96.sub(lowerPriceSqrtX96)\n        const numerator = numerator1.mul(numerator2)\n        const denominator = upperPriceSqrtX96.mul(lowerPriceSqrtX96)\n\n        return numerator.div(denominator)\n    }\n\n    static getQuoteTokenAmountFromLiquidity(priceASqrtX96: Big, priceBSqrtX96: Big, liquidity: Big) {\n        const [lowerPriceSqrtX96, upperPriceSqrtX96] = priceASqrtX96.lt(priceBSqrtX96)\n            ? [priceASqrtX96, priceBSqrtX96]\n            : [priceBSqrtX96, priceASqrtX96]\n\n        const numerator = liquidity.mul(upperPriceSqrtX96.sub(lowerPriceSqrtX96))\n        const denominator = Q96\n\n        return numerator.div(denominator)\n    }\n\n    /**\n     * Computes the maximum amount of liquidity received for a given amount of token0, token1,\n     * and the prices at the tick boundaries.\n     * @param sqrtRatioCurrentX96 the current price\n     * @param sqrtRatioAX96 price at lower boundary\n     * @param sqrtRatioBX96 price at upper boundary\n     * @param baseAmount base token amount\n     * @param quoteAmount quote token amount\n     *\n     * NOTE: code can be referenced to uniswap contract and sdk\n     * https://github.com/Uniswap/v3-sdk/blob/main/src/utils/maxLiquidityForAmounts.ts#L68\n     * https://github.com/Uniswap/v3-periphery/blob/main/contracts/libraries/LiquidityAmounts.sol#L56\n     */\n    static maxLiquidityForAmounts(\n        sqrtRatioCurrentX96: Big,\n        sqrtRatioAX96: Big,\n        sqrtRatioBX96: Big,\n        baseAmount: Big,\n        quoteAmount: Big,\n    ): Big {\n        if (sqrtRatioAX96.gt(sqrtRatioBX96)) {\n            // NOTE: A < B\n            ;[sqrtRatioAX96, sqrtRatioBX96] = [sqrtRatioBX96, sqrtRatioAX96]\n        }\n        if (sqrtRatioCurrentX96.lte(sqrtRatioAX96)) {\n            // NOTE: Current < A < B\n            return LiquidityBase.getLiquidityFromBaseToken(sqrtRatioAX96, sqrtRatioBX96, baseAmount)\n        } else if (sqrtRatioCurrentX96.lt(sqrtRatioBX96)) {\n            // NOTE: A < Current < B\n            const liquidityBaseToken = LiquidityBase.getLiquidityFromBaseToken(\n                sqrtRatioCurrentX96,\n                sqrtRatioBX96,\n                baseAmount,\n            )\n            const liquidityQuoteToken = LiquidityBase.getLiquidityFromQuoteToken(\n                sqrtRatioCurrentX96,\n                sqrtRatioAX96,\n                quoteAmount,\n            )\n            return liquidityBaseToken.lt(liquidityQuoteToken) ? liquidityBaseToken : liquidityQuoteToken\n        }\n        // NOTE: A < B < Current\n        return LiquidityBase.getLiquidityFromQuoteToken(sqrtRatioBX96, sqrtRatioAX96, quoteAmount)\n    }\n}\n"],"names":["RangeType","LiquidityBase","Channel","constructor","market","_channelRegistry","super","this","_lowerTick","TICK_MIN","_upperTick","TICK_MAX","lowerTick","upperTick","lowerTickPrice","tickToPrice","upperTickPrice","async","cache","markPrice","getPrices","getRangeTypeByMarkPrice","_getEventSourceMap","updateDataEventSource","ChannelEventSource","eventSourceStarter","on","emit","updated","updateError","static","lte","RANGE_INVALID","gte","RANGE_AT_LEFT","RANGE_AT_RIGHT","RANGE_INSIDE","markPriceSqrtX96","upperPriceSqrtX96","amount","numerator","mul","denominator","Q96","sub","div","lowerPriceSqrtX96","priceASqrtX96","priceBSqrtX96","liquidity","lt","numerator1","numerator2","sqrtRatioCurrentX96","sqrtRatioAX96","sqrtRatioBX96","baseAmount","quoteAmount","gt","getLiquidityFromBaseToken","liquidityBaseToken","liquidityQuoteToken","getLiquidityFromQuoteToken"],"mappings":"uUAOYA,GAAZ,SAAYA,GACRA,EAAA,oBAAA,sBACAA,EAAA,cAAA,gBACAA,EAAA,aAAA,eACAA,EAAA,cAAA,gBACAA,EAAA,eAAA,gBACH,CAND,CAAYA,IAAAA,EAMX,CAAA,IAaK,MAAOC,UAAqDC,EAQ9DC,aAAYC,OAAEA,GAAwCC,GAClDC,MAAMD,GALAE,KAAUC,WAAGC,EACbF,KAAUG,WAAGC,EAMnBJ,KAAKH,OAASA,CACjB,CAEGQ,gBACA,OAAOL,KAAKC,UACf,CAEGK,gBACA,OAAON,KAAKG,UACf,CAEGI,qBACA,OAAOC,EAAYR,KAAKC,WAC3B,CAEGQ,qBACA,OAAOD,EAAYR,KAAKG,WAC3B,CAEDO,oBAAmBC,MAAEA,GAAQ,GAAS,CAAA,GAClC,MAAMC,UAAEA,SAAoBZ,KAAKH,OAAOgB,UAAU,CAAEF,UACpD,OAAOjB,EAAcoB,wBAAwBF,EAAWZ,KAAKO,eAAgBP,KAAKS,eACrF,CAESM,qBACN,MAAMC,EAAwB,IAAIC,EAAuD,CACrFC,mBAAoB,IACTlB,KAAKH,OAAOsB,GAAG,WAAW,IAAMnB,KAAKoB,KAAK,UAAWpB,UAIpE,MAAO,CACHqB,QAASL,EACTM,YAAaN,EAEpB,CAEDO,+BAA+BX,EAAgBL,EAAqBE,GAChE,OAAIA,EAAee,IAAIjB,GACZd,EAAUgC,cAEjBb,EAAUc,IAAIjB,GACPhB,EAAUkC,cACVf,EAAUY,IAAIjB,GACdd,EAAUmC,eAEdnC,EAAUoC,YACpB,CAEDN,iCAAiCO,EAAuBC,EAAwBC,GAC5E,MAAMC,EAAYD,EAAOE,IAAIJ,GAAkBI,IAAIH,GAC7CI,EAAcC,EAAIF,IAAIH,EAAkBM,IAAIP,IAElD,OAAOG,EAAUK,IAAIH,EACxB,CAEDZ,kCAAkCO,EAAuBS,EAAwBP,GAC7E,MAAMC,EAAYD,EAAOE,IAAIE,GACvBD,EAAcL,EAAiBO,IAAIE,GAEzC,OAAON,EAAUK,IAAIH,EACxB,CAEDZ,uCAAuCiB,EAAoBC,EAAoBC,GAC3E,MAAOH,EAAmBR,GAAqBS,EAAcG,GAAGF,GAC1D,CAACD,EAAeC,GAChB,CAACA,EAAeD,GAEhBI,EAAaF,EAAUR,IAAIE,GAC3BS,EAAad,EAAkBM,IAAIE,GACnCN,EAAYW,EAAWV,IAAIW,GAC3BV,EAAcJ,EAAkBG,IAAIK,GAE1C,OAAON,EAAUK,IAAIH,EACxB,CAEDZ,wCAAwCiB,EAAoBC,EAAoBC,GAC5E,MAAOH,EAAmBR,GAAqBS,EAAcG,GAAGF,GAC1D,CAACD,EAAeC,GAChB,CAACA,EAAeD,GAEhBP,EAAYS,EAAUR,IAAIH,EAAkBM,IAAIE,IAChDJ,EAAcC,EAEpB,OAAOH,EAAUK,IAAIH,EACxB,CAeDZ,8BACIuB,EACAC,EACAC,EACAC,EACAC,GAMA,GAJIH,EAAcI,GAAGH,MAEfD,EAAeC,GAAiB,CAACA,EAAeD,IAElDD,EAAoBtB,IAAIuB,GAExB,OAAOrD,EAAc0D,0BAA0BL,EAAeC,EAAeC,GAC1E,GAAIH,EAAoBH,GAAGK,GAAgB,CAE9C,MAAMK,EAAqB3D,EAAc0D,0BACrCN,EACAE,EACAC,GAEEK,EAAsB5D,EAAc6D,2BACtCT,EACAC,EACAG,GAEJ,OAAOG,EAAmBV,GAAGW,GAAuBD,EAAqBC,CAC5E,CAED,OAAO5D,EAAc6D,2BAA2BP,EAAeD,EAAeG,EACjF"}