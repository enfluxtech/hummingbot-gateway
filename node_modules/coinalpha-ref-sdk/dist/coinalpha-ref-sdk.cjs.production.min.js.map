{"version":3,"file":"coinalpha-ref-sdk.cjs.production.min.js","sources":["../src/constant.ts","../src/error.ts","../src/utils.ts","../src/near.ts","../src/ref.ts","../src/instantSwap.ts","../src/pool.ts","../src/stable-swap.ts","../src/parallelSwapLogic.ts","../src/smartRoutingLogic.js","../src/swap.ts"],"sourcesContent":["export const FEE_DIVISOR = 10000;\n\nexport const STABLE_LP_TOKEN_DECIMALS = 18;\nexport const RATED_POOL_LP_TOKEN_DECIMALS = 24;\n\nexport function getConfig(env: string | undefined = process.env.NEAR_ENV) {\n  switch (env) {\n    case 'mainnet':\n      return {\n        networkId: 'mainnet',\n        nodeUrl: 'https://rpc.mainnet.near.org',\n        walletUrl: 'https://wallet.near.org',\n        WRAP_NEAR_CONTRACT_ID: 'wrap.near',\n        REF_FI_CONTRACT_ID: 'v2.ref-finance.near',\n      };\n    case 'testnet':\n      return {\n        networkId: 'testnet',\n        nodeUrl: 'https://rpc.testnet.near.org',\n        walletUrl: 'https://wallet.testnet.near.org',\n        WRAP_NEAR_CONTRACT_ID: 'wrap.testnet',\n        REF_FI_CONTRACT_ID: 'ref-finance-101.testnet',\n      };\n    default:\n      return {\n        networkId: 'mainnet',\n        nodeUrl: 'https://rpc.mainnet.near.org',\n        walletUrl: 'https://wallet.near.org',\n        REF_FI_CONTRACT_ID: 'v2.ref-finance.near',\n        WRAP_NEAR_CONTRACT_ID: 'wrap.near',\n      };\n  }\n}\n\nexport const config = getConfig();\n\nexport const REF_FI_CONTRACT_ID = config.REF_FI_CONTRACT_ID;\n\nexport const STORAGE_TO_REGISTER_WITH_MFT = '0.1';\n\nexport const ONE_YOCTO_NEAR = '0.000000000000000000000001';\n","import { getConfig } from './constant';\n\nexport const formatError = (msg: string) => {\n  return new Error(msg);\n};\n\nexport const unNamedError = formatError('Something wrong happened');\n\nexport const SameInputTokenError = formatError(\n  'Input token should be different with output token'\n);\n\nexport const ZeroInputError = formatError(\n  'Input amount should be greater than 0'\n);\n\nexport const NoPoolError = formatError('No pool found for the input tokens');\n\nexport const NotLoginError = formatError('Please login in first');\n\nexport const SwapRouteError = formatError(\n  \"Something wrong happened, we don't get correct routes corrreponding to current input\"\n);\n\nexport const TokenNotExistError = formatError(\n  `This token doesn't exist in ${getConfig().networkId}`\n);\n\nexport const NoPuiblicKeyError = formatError('No public key found');\n\nexport const NoLocalSignerError = formatError('No local signer found');\n\nexport const InValidAccessKeyError = formatError('Invalid access key');\n\nexport const AccountIdMisMatch = formatError(\n  \"Your input account id doesn't match the account id in the credential\"\n);\n\nexport const NoCredential = formatError('No Credential to such path');\n","import {\n  Pool,\n  PoolRPCView,\n  StablePool,\n  SmartRoutingInputPool,\n  Transaction,\n} from './types';\nimport {\n  RATED_POOL_LP_TOKEN_DECIMALS,\n  STABLE_LP_TOKEN_DECIMALS,\n} from './constant';\n\nimport { transactions, utils } from 'near-api-js';\n\nimport BN from 'bn.js';\n\nimport * as math from 'mathjs';\nimport { REF_FI_CONTRACT_ID } from './constant';\n\nexport const parsePool = (pool: PoolRPCView, id?: number): Pool => ({\n  id: Number(typeof id === 'number' ? id : pool.id),\n  tokenIds: pool.token_account_ids,\n  supplies: pool.amounts.reduce(\n    (acc: { [tokenId: string]: string }, amount: string, i: number) => {\n      acc[pool.token_account_ids[i]] = amount;\n      return acc;\n    },\n    {}\n  ),\n  fee: pool.total_fee,\n  shareSupply: pool.shares_total_supply,\n  tvl: pool.tvl,\n  token0_ref_price: pool.token0_ref_price,\n  pool_kind: pool.pool_kind,\n});\n\nexport const poolFormatter = (pool: Pool) => {\n  return {\n    id: pool.id,\n    token1Id: pool.tokenIds[0],\n    token2Id: pool.tokenIds[1],\n    token1Supply: pool.supplies[pool.tokenIds[0]],\n    token2Supply: pool.supplies[pool.tokenIds[1]],\n    fee: pool.fee,\n    shares: pool.shareSupply,\n    token0_price: pool.token0_ref_price || '0',\n  } as SmartRoutingInputPool;\n};\n\nexport const isStablePoolToken = (\n  stablePools: StablePool[],\n  tokenId: string | Number\n) => {\n  return stablePools\n    .map(p => p.token_account_ids)\n    .flat()\n    .includes(tokenId.toString());\n};\n\nexport const isStablePool = (\n  stablePools: StablePool[],\n  poolId: string | number\n) => {\n  return stablePools.map(p => p.id.toString()).includes(poolId.toString());\n};\n\nexport const getStablePoolDecimal = (stablePool: StablePool) => {\n  return stablePool.pool_kind === 'RATED_SWAP'\n    ? RATED_POOL_LP_TOKEN_DECIMALS\n    : STABLE_LP_TOKEN_DECIMALS;\n};\n\nexport const round = (decimals: number, minAmountOut: string) => {\n  return Number.isInteger(Number(minAmountOut))\n    ? minAmountOut\n    : Math.ceil(\n        Math.round(Number(minAmountOut) * Math.pow(10, decimals)) /\n          Math.pow(10, decimals)\n      ).toString();\n};\n\nexport const convertToPercentDecimal = (percent: number) => {\n  return math.divide(percent, 100);\n};\n\nexport const percentOf = (percent: number, num: number | string) => {\n  return math.evaluate(`${convertToPercentDecimal(percent)} * ${num}`);\n};\n\nexport const percentLess = (percent: number, num: number | string) => {\n  return math.format(math.evaluate(`${num} - ${percentOf(percent, num)}`), {\n    notation: 'fixed',\n  });\n};\n\nexport const getGas = (gas: string | undefined) =>\n  gas ? new BN(gas) : new BN('100000000000000');\n\nexport const getAmount = (amount: string) =>\n  amount ? new BN(utils.format.parseNearAmount(amount) || '0') : new BN('0');\n\nexport const ONLY_ZEROS = /^0*\\.?0*$/;\n\nexport const toReadableNumber = (\n  decimals: number,\n  number: string = '0'\n): string => {\n  if (!decimals) return number;\n\n  const wholeStr = number.substring(0, number.length - decimals) || '0';\n  const fractionStr = number\n    .substring(number.length - decimals)\n    .padStart(decimals, '0')\n    .substring(0, decimals);\n\n  return `${wholeStr}.${fractionStr}`.replace(/\\.?0+$/, '');\n};\n\nexport const toNonDivisibleNumber = (\n  decimals: number,\n  number: string\n): string => {\n  if (decimals === null || decimals === undefined) return number;\n  const [wholePart, fracPart = ''] = number.split('.');\n\n  return `${wholePart}${fracPart.padEnd(decimals, '0').slice(0, decimals)}`\n    .replace(/^0+/, '')\n    .padStart(1, '0');\n};\n\nexport const scientificNotationToString = (strParam: string) => {\n  let flag = /e/.test(strParam);\n  if (!flag || !strParam) return strParam;\n\n  let sysbol = true;\n  if (/e-/.test(strParam)) {\n    sysbol = false;\n  }\n\n  const negative = Number(strParam) < 0 ? '-' : '';\n\n  let index = Number(strParam.match(/\\d+$/)?.[0]);\n\n  let basis = strParam.match(/[\\d\\.]+/)?.[0];\n\n  if (!index || !basis) return strParam;\n\n  const ifFraction = basis.includes('.');\n\n  let wholeStr;\n  let fractionStr;\n\n  if (ifFraction) {\n    wholeStr = basis.split('.')[0];\n    fractionStr = basis.split('.')[1];\n  } else {\n    wholeStr = basis;\n    fractionStr = '';\n  }\n\n  if (sysbol) {\n    if (!ifFraction) {\n      return negative + wholeStr.padEnd(index + wholeStr.length, '0');\n    } else {\n      if (fractionStr.length <= index) {\n        return negative + wholeStr + fractionStr.padEnd(index, '0');\n      } else {\n        return (\n          negative +\n          wholeStr +\n          fractionStr.substring(0, index) +\n          '.' +\n          fractionStr.substring(index)\n        );\n      }\n    }\n  } else {\n    if (!ifFraction)\n      return (\n        negative +\n        wholeStr.padStart(index + wholeStr.length, '0').replace(/^0/, '0.')\n      );\n    else {\n      return (\n        negative +\n        wholeStr.padStart(index + wholeStr.length, '0').replace(/^0/, '0.') +\n        fractionStr\n      );\n    }\n  }\n};\n\nexport const formatWithCommas = (value: string) => {\n  const pattern = /(-?\\d+)(\\d{3})/;\n  while (pattern.test(value)) {\n    value = value.replace(pattern, '$1,$2');\n  }\n  return value;\n};\n\nexport const toPrecision = (\n  number: string,\n  precision: number,\n  withCommas: boolean = false,\n  atLeastOne: boolean = true\n): string => {\n  const [whole, decimal = ''] = number.split('.');\n\n  let str = `${withCommas ? formatWithCommas(whole) : whole}.${decimal.slice(\n    0,\n    precision\n  )}`.replace(/\\.$/, '');\n  if (atLeastOne && Number(str) === 0 && str.length > 1) {\n    var n = str.lastIndexOf('0');\n    str = str.slice(0, n) + str.slice(n).replace('0', '1');\n  }\n\n  return str;\n};\n\nexport const transformTransactions = (\n  transactions: Transaction[],\n  AccountId: string\n) => {\n  return transactions.map((t: Transaction) => {\n    return {\n      signerId: AccountId,\n      receiverId: t.receiverId,\n      actions: t.functionCalls.map(fc => {\n        return {\n          type: 'FunctionCall',\n          params: {\n            methodName: fc.methodName,\n            args: fc.args || {},\n            gas: getGas(fc.gas)\n              .toNumber()\n              .toFixed(),\n            deposit: utils.format.parseNearAmount(fc.amount || '0')!,\n          },\n        };\n      }),\n    };\n  });\n};\n","import {\n  keyStores,\n  KeyPair,\n  InMemorySigner,\n  providers,\n  transactions as nearTransactions,\n  utils,\n} from 'near-api-js';\nimport BN from 'bn.js';\nimport { getConfig } from './constant';\nimport fs from 'fs';\nimport os from 'os';\nimport {\n  NoPuiblicKeyError,\n  InValidAccessKeyError,\n  NoCredential,\n} from './error';\nimport { AccessKeyView } from 'near-api-js/lib/providers/provider';\nimport { TransformedTransaction } from './types';\nimport { Transaction } from './types';\nimport { transformTransactions } from './utils';\nimport { AccountIdMisMatch } from './error';\n\nexport const getKeyStore = () => {\n  return typeof window === 'undefined'\n    ? new keyStores.InMemoryKeyStore()\n    : new keyStores.BrowserLocalStorageKeyStore();\n};\n\nexport const provider = new providers.JsonRpcProvider({\n  url: getConfig().nodeUrl,\n});\n\nexport const getMemorySigner = async ({\n  AccountId,\n  keyPath,\n}: {\n  AccountId: string;\n  keyPath: string;\n}) => {\n  try {\n    const homedir = os.homedir();\n    const credentials = JSON.parse(\n      fs.readFileSync(homedir + keyPath).toString()\n    );\n\n    const credentialAccountId = credentials?.account_id;\n\n    if (!credentialAccountId) throw NoCredential;\n\n    if (credentialAccountId !== AccountId) throw AccountIdMisMatch;\n\n    const myKeyStore = new keyStores.InMemoryKeyStore();\n    myKeyStore.setKey(\n      getConfig().networkId,\n      AccountId,\n      KeyPair.fromString(credentials.private_key)\n    );\n\n    const signer = new InMemorySigner(myKeyStore);\n\n    return signer;\n  } catch (error) {\n    throw error;\n  }\n};\n\nconst validateAccessKey = (\n  transaction: TransformedTransaction,\n  accessKey: AccessKeyView\n) => {\n  if (accessKey.permission === 'FullAccess') {\n    return accessKey;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  const { receiver_id, method_names } = accessKey.permission.FunctionCall;\n\n  if (transaction.receiverId !== receiver_id) {\n    return null;\n  }\n\n  return transaction.actions.every(action => {\n    if (action.type !== 'FunctionCall') {\n      return false;\n    }\n\n    const { methodName, deposit } = action.params;\n\n    if (method_names.length && method_names.includes(methodName)) {\n      return false;\n    }\n\n    return parseFloat(deposit) <= 0;\n  });\n};\n\nexport const getSignedTransactionsByMemoryKey = async ({\n  transactionsRef,\n  AccountId,\n  keyPath,\n}: {\n  transactionsRef: Transaction[];\n  AccountId: string;\n  keyPath: string;\n}) => {\n  const transactions = transformTransactions(transactionsRef, AccountId);\n\n  const block = await provider.block({ finality: 'final' });\n\n  const signedTransactions: Array<nearTransactions.SignedTransaction> = [];\n  const signer = await getMemorySigner({\n    AccountId,\n    keyPath,\n  });\n\n  for (let i = 0; i < transactions.length; i += 1) {\n    const transaction = transactions[i];\n\n    const publicKey = await signer.getPublicKey(\n      AccountId,\n      getConfig().networkId\n    );\n    if (!publicKey) {\n      throw NoPuiblicKeyError;\n    }\n\n    const accessKey = await provider.query<AccessKeyView>({\n      request_type: 'view_access_key',\n      finality: 'final',\n      account_id: AccountId,\n      public_key: publicKey.toString(),\n    });\n\n    if (!validateAccessKey(transaction, accessKey)) {\n      throw InValidAccessKeyError;\n    }\n\n    const tx = nearTransactions.createTransaction(\n      AccountId,\n      utils.PublicKey.from(publicKey.toString()),\n      transactions[i].receiverId,\n      accessKey.nonce + i + 1,\n      transaction.actions.map(action => {\n        const { methodName, args, gas, deposit } = action.params;\n        return nearTransactions.functionCall(\n          methodName,\n          args,\n          new BN(gas),\n          new BN(deposit)\n        );\n      }),\n      utils.serialize.base_decode(block.header.hash)\n    );\n\n    const [, signedTx] = await nearTransactions.signTransaction(\n      tx,\n      signer,\n      transactions[i].signerId,\n      getConfig().networkId\n    );\n    signedTransactions.push(signedTx);\n  }\n\n  return signedTransactions;\n};\n\nexport const sendTransactionsByMemoryKey = async ({\n  signedTransactions,\n}: {\n  signedTransactions: nearTransactions.SignedTransaction[];\n}) => {\n  try {\n    const results: Array<providers.FinalExecutionOutcome> = [];\n\n    for (let i = 0; i < signedTransactions.length; i += 1) {\n      results.push(await provider.sendTransaction(signedTransactions[i]));\n    }\n\n    return results;\n  } catch (err) {\n    throw err;\n  }\n};\n","import { REF_FI_CONTRACT_ID, config } from './constant';\nimport { keyStores, Near, WalletConnection } from 'near-api-js';\nimport { TokenNotExistError } from './error';\nimport { getKeyStore } from './near';\n\nimport {\n  TokenMetadata,\n  FTStorageBalance,\n  RefFiViewFunctionOptions,\n} from './types';\n\n// export const keyStore = new keyStores.BrowserLocalStorageKeyStore();\n\nexport const near = new Near({\n  keyStore: getKeyStore(),\n  headers: {},\n  ...config,\n});\n\nexport const refFiViewFunction = async ({\n  methodName,\n  args,\n}: RefFiViewFunctionOptions) => {\n  const nearConnection = await near.account(REF_FI_CONTRACT_ID);\n\n  return nearConnection.viewFunction(REF_FI_CONTRACT_ID, methodName, args);\n};\n\nexport const ftViewFunction = async (\n  tokenId: string,\n  { methodName, args }: RefFiViewFunctionOptions\n) => {\n  const nearConnection = await near.account(REF_FI_CONTRACT_ID);\n\n  return nearConnection.viewFunction(tokenId, methodName, args);\n};\n\nexport const ftGetStorageBalance = (\n  tokenId: string,\n  AccountId: string\n): Promise<FTStorageBalance | null> => {\n  return ftViewFunction(tokenId, {\n    methodName: 'storage_balance_of',\n    args: { account_id: AccountId },\n  });\n};\n\nexport const getTotalPools = async () => {\n  return refFiViewFunction({\n    methodName: 'get_number_of_pools',\n  });\n};\n\nexport const ftGetTokenMetadata = async (\n  id: string\n): Promise<TokenMetadata> => {\n  const metadata = await ftViewFunction(id, {\n    methodName: 'ft_metadata',\n  }).catch(() => {\n    throw TokenNotExistError;\n  });\n\n  return { ...metadata, id };\n};\n\nexport const ftGetTokensMetadata = async (tokenIds: string[]) => {\n  const tokensMetadata = await Promise.all(\n    tokenIds.map((id: string) => ftGetTokenMetadata(id))\n  );\n\n  return tokensMetadata.reduce((pre, cur, i) => {\n    return {\n      ...pre,\n      [tokenIds[i]]: cur,\n    };\n  }, {}) as Record<string, TokenMetadata>;\n};\n","import { TokenMetadata, EstimateSwapView, Transaction } from './types';\nimport { ftGetStorageBalance } from './ref';\nimport {\n  STORAGE_TO_REGISTER_WITH_MFT,\n  REF_FI_CONTRACT_ID,\n  ONE_YOCTO_NEAR,\n} from './constant';\nimport { round, percentLess } from './utils';\nimport { toNonDivisibleNumber } from './utils';\nimport { config } from './constant';\nimport { SwapRouteError } from './error';\n\nexport const instantSwap = async ({\n  tokenIn,\n  tokenOut,\n  amountIn,\n  slippageTolerance,\n  swapTodos,\n  AccountId,\n}: {\n  tokenIn: TokenMetadata;\n  tokenOut: TokenMetadata;\n  amountIn: string;\n  slippageTolerance: number;\n  swapTodos: EstimateSwapView[];\n  AccountId: string;\n}) => {\n  const transactions: Transaction[] = [];\n\n  if (swapTodos?.at(-1)?.outputToken !== tokenOut.id) throw SwapRouteError;\n\n  const registerToken = async (token: TokenMetadata) => {\n    const tokenRegistered = await ftGetStorageBalance(\n      token.id,\n      AccountId\n    ).catch(() => {\n      throw new Error(`${token.id} doesn't exist.`);\n    });\n\n    if (tokenRegistered === null) {\n      transactions.push({\n        receiverId: token.id,\n        functionCalls: [\n          {\n            methodName: 'storage_deposit',\n            args: {\n              registration_only: true,\n              account_id: AccountId,\n            },\n            gas: '30000000000000',\n            amount: STORAGE_TO_REGISTER_WITH_MFT,\n          },\n        ],\n      });\n    }\n  };\n\n  await registerToken(tokenOut);\n  let actionsList: any = [];\n  let allSwapsTokens = swapTodos.map(s => [s.inputToken, s.outputToken]); // to get the hop tokens\n  for (let i in allSwapsTokens) {\n    let swapTokens = allSwapsTokens[i];\n    if (swapTokens[0] === tokenIn.id && swapTokens[1] === tokenOut.id) {\n      // parallel, direct hop route.\n      actionsList.push({\n        pool_id: swapTodos[i].pool.id,\n        token_in: tokenIn.id,\n        token_out: tokenOut.id,\n        amount_in: swapTodos[i].pool.partialAmountIn,\n        min_amount_out: round(\n          tokenOut.decimals,\n          toNonDivisibleNumber(\n            tokenOut.decimals,\n            percentLess(slippageTolerance, swapTodos[i].estimate)\n          )\n        ),\n      });\n    } else if (swapTokens[0] === tokenIn.id) {\n      // first hop in double hop route\n      //TODO -- put in a check to make sure this first hop matches with the next (i+1) hop as a second hop.\n      actionsList.push({\n        pool_id: swapTodos[i].pool.id,\n        token_in: swapTokens[0],\n        token_out: swapTokens[1],\n        amount_in: swapTodos[i].pool.partialAmountIn,\n        min_amount_out: '0',\n      });\n    } else {\n      // second hop in double hop route.\n      //TODO -- put in a check to make sure this second hop matches with the previous (i-1) hop as a first hop.\n      actionsList.push({\n        pool_id: swapTodos[i].pool.id,\n        token_in: swapTokens[0],\n        token_out: swapTokens[1],\n        min_amount_out: round(\n          tokenOut.decimals,\n          toNonDivisibleNumber(\n            tokenOut.decimals,\n            percentLess(slippageTolerance, swapTodos[i].estimate)\n          )\n        ),\n      });\n    }\n  }\n\n  transactions.push({\n    receiverId: tokenIn.id,\n    functionCalls: [\n      {\n        methodName: 'ft_transfer_call',\n        args: {\n          receiver_id: REF_FI_CONTRACT_ID,\n          amount: toNonDivisibleNumber(tokenIn.decimals, amountIn),\n          msg: JSON.stringify({\n            force: 0,\n            actions: actionsList,\n          }),\n        },\n        gas: '180000000000000',\n        amount: ONE_YOCTO_NEAR,\n      },\n    ],\n  });\n\n  if (tokenIn.id === config.WRAP_NEAR_CONTRACT_ID) {\n    const registered = await ftGetStorageBalance(\n      config.WRAP_NEAR_CONTRACT_ID,\n      AccountId\n    );\n    if (registered === null) {\n      await registerToken(tokenIn);\n    }\n  }\n\n  return transactions;\n};\n","import { getTotalPools, refFiViewFunction } from './ref';\nimport { Pool, PoolRPCView } from './types';\nimport { parsePool, toNonDivisibleNumber } from './utils';\nimport { unNamedError } from './error';\nimport { STABLE_LP_TOKEN_DECIMALS } from './constant';\n\nexport const DEFAULT_PAGE_LIMIT = 100;\n\nexport const getRatedPoolDetail = async ({ id }: { id: string | number }) => {\n  return refFiViewFunction({\n    methodName: 'get_rated_pool',\n    args: { pool_id: Number(id) },\n  })\n    .then(pool_info => ({\n      ...pool_info,\n      id: Number(id),\n      pool_kind: 'RATED_SWAP',\n    }))\n    .catch(() => {\n      throw unNamedError;\n    });\n};\n\nexport const getUnRatedPoolDetail = async ({ id }: { id: string | number }) => {\n  return refFiViewFunction({\n    methodName: 'get_stable_pool',\n    args: { pool_id: Number(id) },\n  })\n    .then(pool_info => ({\n      ...pool_info,\n      id: Number(id),\n      pool_kind: 'STABLE_SWAP',\n      rates: pool_info.c_amounts.map((_: any) =>\n        toNonDivisibleNumber(STABLE_LP_TOKEN_DECIMALS, '1')\n      ),\n    }))\n    .catch(() => {\n      throw unNamedError;\n    });\n};\n\nexport const getStablePools = async (stablePools: Pool[]) => {\n  return Promise.all(\n    stablePools.map(pool =>\n      pool.pool_kind === 'RATED_SWAP'\n        ? getRatedPoolDetail({ id: pool.id })\n        : getUnRatedPoolDetail({ id: pool.id })\n    )\n  );\n};\n\nexport const getRefPools = async (\n  page: number = 1,\n  perPage: number = DEFAULT_PAGE_LIMIT\n): Promise<Pool[]> => {\n  const index = (page - 1) * perPage;\n\n  const poolData: PoolRPCView[] = await refFiViewFunction({\n    methodName: 'get_pools',\n    args: { from_index: index, limit: perPage },\n  });\n\n  return poolData.map((rawPool, i) => parsePool(rawPool, i + index));\n};\n\nexport const fetchAllPools = async () => {\n  const totalPools = await getTotalPools();\n  const pages = Math.ceil(totalPools / DEFAULT_PAGE_LIMIT);\n\n  const pools = (\n    await Promise.all(\n      [...Array(pages)].fill(0).map((_, i) => getRefPools(i + 1))\n    )\n  ).flat() as Pool[];\n\n  return {\n    simplePools: pools.filter(\n      p => p.pool_kind && p.pool_kind === 'SIMPLE_POOL'\n    ),\n    unRatedPools: pools.filter(\n      p => p.pool_kind && p.pool_kind === 'STABLE_SWAP'\n    ),\n    ratedPools: pools.filter(p => p.pool_kind && p.pool_kind === 'RATED_SWAP'),\n  };\n};\n","import { StablePool } from './types';\nimport { FEE_DIVISOR } from './constant';\n\nimport {\n  toReadableNumber,\n  toNonDivisibleNumber,\n  scientificNotationToString,\n} from './utils';\n\nimport Big from 'big.js';\n\nimport _ from 'lodash';\n\nconst tradeFee = (amount: number, trade_fee: number) => {\n  return (amount * trade_fee) / FEE_DIVISOR;\n};\n\nexport const calc_d = (amp: number, c_amounts: number[]) => {\n  const token_num = c_amounts.length;\n  const sum_amounts = _.sum(c_amounts);\n  let d_prev = 0;\n  let d = sum_amounts;\n  for (let i = 0; i < 256; i++) {\n    let d_prod = d;\n    for (let c_amount of c_amounts) {\n      d_prod = (d_prod * d) / (c_amount * token_num);\n    }\n    d_prev = d;\n    const ann = amp * token_num ** token_num;\n    const numerator = d_prev * (d_prod * token_num + ann * sum_amounts);\n    const denominator = d_prev * (ann - 1) + d_prod * (token_num + 1);\n    d = numerator / denominator;\n    if (Math.abs(d - d_prev) <= 1) break;\n  }\n  return d;\n};\n\nexport const calc_y = (\n  amp: number,\n  x_c_amount: number,\n  current_c_amounts: number[],\n  index_x: number,\n  index_y: number\n) => {\n  const token_num = current_c_amounts.length;\n  const ann = amp * token_num ** token_num;\n  const d = calc_d(amp, current_c_amounts);\n  let s = x_c_amount;\n  let c = (d * d) / x_c_amount;\n  for (let i = 0; i < token_num; i++) {\n    if (i != index_x && i != index_y) {\n      s += current_c_amounts[i];\n      c = (c * d) / current_c_amounts[i];\n    }\n  }\n  c = (c * d) / (ann * token_num ** token_num);\n  const b = d / ann + s;\n  let y_prev = 0;\n  let y = d;\n  for (let i = 0; i < 256; i++) {\n    y_prev = y;\n    const y_numerator = y ** 2 + c;\n    const y_denominator = 2 * y + b - d;\n    y = y_numerator / y_denominator;\n    if (Math.abs(y - y_prev) <= 1) break;\n  }\n\n  return y;\n};\n\nexport const calc_swap = (\n  amp: number,\n  in_token_idx: number,\n  in_c_amount: number,\n  out_token_idx: number,\n  old_c_amounts: number[],\n  trade_fee: number\n) => {\n  const y = calc_y(\n    amp,\n    in_c_amount + old_c_amounts[in_token_idx],\n    old_c_amounts,\n    in_token_idx,\n    out_token_idx\n  );\n  const dy = old_c_amounts[out_token_idx] - y;\n  const fee = tradeFee(dy, trade_fee);\n  const amount_swapped = dy - fee;\n  return [amount_swapped, fee, dy];\n};\n\nexport const getSwappedAmount = (\n  tokenInId: string,\n  tokenOutId: string,\n  amountIn: string,\n  stablePool: StablePool,\n  STABLE_LP_TOKEN_DECIMALS: number\n) => {\n  const amp = stablePool.amp;\n  const trade_fee = stablePool.total_fee;\n\n  // depended on pools\n  const in_token_idx = stablePool.token_account_ids.findIndex(\n    id => id === tokenInId\n  );\n  const out_token_idx = stablePool.token_account_ids.findIndex(\n    id => id === tokenOutId\n  );\n\n  const rates = stablePool.rates.map(r =>\n    toReadableNumber(STABLE_LP_TOKEN_DECIMALS, r)\n  );\n\n  const base_old_c_amounts = stablePool.c_amounts.map(amount =>\n    toReadableNumber(STABLE_LP_TOKEN_DECIMALS, amount)\n  );\n\n  const old_c_amounts = base_old_c_amounts\n    .map((amount, i) =>\n      toNonDivisibleNumber(\n        STABLE_LP_TOKEN_DECIMALS,\n        scientificNotationToString(\n          new Big(amount || 0).times(new Big(rates[i])).toString()\n        )\n      )\n    )\n    .map(amount => Number(amount));\n\n  const in_c_amount = Number(\n    toNonDivisibleNumber(\n      STABLE_LP_TOKEN_DECIMALS,\n      scientificNotationToString(\n        new Big(amountIn).times(new Big(rates[in_token_idx])).toString()\n      )\n    )\n  );\n\n  const [amount_swapped, fee, dy] = calc_swap(\n    amp,\n    in_token_idx,\n    in_c_amount,\n    out_token_idx,\n    old_c_amounts,\n    trade_fee\n  );\n\n  return [\n    amount_swapped / Number(rates[out_token_idx]),\n    fee,\n    dy / Number(rates[out_token_idx]),\n  ];\n};\n","//@ts-nocheck\nimport Big from 'big.js';\n\nimport { Pool } from './types';\n\nBig.RM = 0;\nBig.DP = 40;\nBig.NE = -40;\nBig.PE = 40;\n\ninterface FormatedPool extends Pool {\n  x?: string;\n  y?: string;\n  gamma_bps?: Big;\n}\n\n///////////////////////////////\n// Parallel Swap Logic Below //\n///////////////////////////////\n\n/** formatPoolNew\n * This function appends to the existing standard Pool struct and adds attributes that simplify the parallel swap algorithms.\n * Adds attributes \"x\" (for input token reserves in pool), \"y\" (for output token reserves in pool), and \"gamma_bps\" (for 1- fee in bps)\n * Our convention for our algorithm has been to use \"x\" as the input token and \"y\" as the output token.\n * @param pool    AMM structure containing reserves of inputToken and outputToken\n * @param inputToken the name of the inputToken being traded in.\n * @param outputToken the name of the outputToken being traded out.\n * @returns newFormatPool\n */\nexport function formatPoolNew(\n  pool: Pool,\n  inputToken: string,\n  outputToken: string\n) {\n  let p: FormatedPool = pool;\n  let x = p.supplies[inputToken];\n  let y = p.supplies[outputToken];\n  p['gamma_bps'] = new Big(10000).minus(p.fee);\n  p['x'] = x;\n  p['y'] = y;\n  return p;\n}\n\n/** solveForMuFloat\n * This function takes the set of token pools, the total input of inputToken, and the names of inputToken and outputToken and\n * solves for the Lagrange Multiplier \"mu\". Note that mu must be allowed to be aritrary precision floating point number. Mu will\n * be used in subsequent function calls to determine the best allocations of intputToken to be made per pool.\n * For more detailed math on how this function was derived, please see the white paper:\n * https://github.com/giddyphysicist/ParallelSwapForRefFinance/blob/main/ParallelSwapWhitePaper.pdf\n * @param pools   list of pools that contain inputToken and outputToken\n * @param totalDeltaX  total allocation (among all pools) being input of inputToken\n * @param inputToken   the name of the inputToken being traded in.\n * @param outputToken   the name of the outputToken being traded out.\n * @returns mu   the lagrange multiplier value calculated for a set of pools and inputToken amount.\n */\nexport function solveForMuFloat(\n  pools: Pool[],\n  totalDeltaX: string,\n  inputToken: string,\n  outputToken: string\n) {\n  if (pools.length > 0) {\n    let numerator = new Big(totalDeltaX);\n    let denominator = new Big(0);\n\n    for (var i = 0; i < pools.length; i++) {\n      let p = formatPoolNew(pools[i], inputToken, outputToken);\n      let numAdd = new Big(p.x).times(10000).div(p.gamma_bps);\n      numerator = numerator.plus(numAdd);\n      let denomAdd = new Big(p.x)\n        .times(p.y)\n        .div(p.gamma_bps)\n        .sqrt()\n        .times(100);\n      denominator = denominator.plus(denomAdd);\n    }\n\n    const mu = new Big(numerator).div(denominator);\n    return mu;\n  } else {\n    // console.log('ERROR - could not find pools that satisfy token pair');\n    const mu = NaN;\n    return mu;\n  }\n}\n\n/** calculate_dx_float\n * Once mu has been calculated for a set of pools and total input amount, the next step is\n * determining the total allocation per pool. This function evaluates the amount of input Token to be\n * allocated to the given pool. Note, in our original algorithmic convention, the 'x' variable was for the input token,\n * and the 'y' variable was for the output token. Here, the value dx is the part of the full amount of input token X.\n * Again, the detailed formulae for these operations can be found in the white paper referenced above.\n * @param mu   the lagrange multiplier value calculated for a set of pools and inputToken amount.\n * @param pool   AMM structure containing reserves of inputToken and outputToken\n * @param inputToken the name of the inputToken being traded in.\n * @param outputToken  the name of the outputToken being traded out.\n * @returns dxFloat   the allocation amount determined for the given pool\n */\nexport function calculate_dx_float(\n  mu: number | Big,\n  pool: FormatedPool,\n  inputToken: string,\n  outputToken: string\n) {\n  let p = formatPoolNew(pool, inputToken, outputToken);\n  let radical = new Big(p.x).times(p.y).div(p.gamma_bps);\n  let dxFloat = new Big(mu)\n    .times(100)\n    .times(radical.sqrt())\n    .minus(new Big(p.x).times(10000).div(p.gamma_bps));\n  return dxFloat;\n}\n\n/** calculate_dy_float\n * Once you have an allocation amount for a given pool, you can use the AMM constant-product formula to determine\n * the expected output amount of output Token.\n * Note, here, as earlier, our algorithmic convention uses \"y\" as the output token, and so \"dy\" is the fraction of\n * the total output of output Token, assuming there could be dy contributions from other parallel pools as well.\n * @param dx_float  input allocation amount of inputToken for the given pool\n * @param pool   a structure representing the reserves and fees for a given pool.\n * @param inputToken  the name of the inputToken being traded in.\n * @param outputToken  the name of the outputToken being traded out.\n * @returns dyFloat  the expected trade out amount out of outputToken\n */\nexport function calculate_dy_float(\n  dx_float: number,\n  pool: FormatedPool,\n  inputToken: string,\n  outputToken: string\n) {\n  if (dx_float <= 0) {\n    return new Big(0);\n  }\n  let p = formatPoolNew(pool, inputToken, outputToken);\n  let dx = new Big(dx_float);\n  let denom = new Big(10000).times(p.x).plus(new Big(p.gamma_bps).times(dx));\n  let numerator = new Big(p.y).times(dx).times(p.gamma_bps);\n  let dyFloat = numerator.div(denom).round();\n  return dyFloat;\n}\n\n/** calculateOptimalOutput\n * This is the main function, which calculates optimal values of inputToken to swap into each pool.\n * @param pools  list of relevant AMM pools containing inputToken and outputToken\n * @param inputAmount   the numeric total amount of inputToken to be traded into the group of swap pools.\n * @param inputToken   the name of the inputToken being traded in.\n * @param outputToken  the name of the outputToken being traded out.\n * @returns normalizedDxArray an array containing the amount allocations of inputToken per pool in the list of pools.\n */\nexport function calculateOptimalOutput(\n  pools: Pool[],\n  inputAmount: string,\n  inputToken: string,\n  outputToken: string\n) {\n  let mu = solveForMuFloat(pools, inputAmount, inputToken, outputToken);\n  let dxArray: Big[] = new Array();\n  let negativeDxValsFlag = false;\n  for (var i = 0; i < pools.length; i++) {\n    let pool = formatPoolNew(pools[i], inputToken, outputToken);\n    let dx = calculate_dx_float(mu, pool, inputToken, outputToken);\n    if (dx.lt(0)) {\n      negativeDxValsFlag = true;\n    }\n    let dxInt = new Big(dx).round();\n    dxArray.push(dxInt);\n  }\n  if (negativeDxValsFlag) {\n    dxArray = reducePools(pools, dxArray, inputAmount, inputToken, outputToken);\n  }\n  let dxArraySum = new Big(0);\n  for (var i = 0; i < dxArray.length; i++) {\n    dxArraySum = dxArraySum.plus(dxArray[i]);\n  }\n  let tempAllocationsArray = [];\n  for (var i = 0; i < dxArray.length; i++) {\n    let ndx = new Big(dxArray[i])\n      .times(inputAmount)\n      .div(dxArraySum)\n      .round();\n    tempAllocationsArray.push(ndx);\n  }\n  let allocationsArray = checkIntegerSumOfAllocations(\n    tempAllocationsArray,\n    inputAmount\n  );\n  let normalizedDxArray = [];\n  for (var i = 0; i < allocationsArray.length; i++) {\n    let ndx = allocationsArray[i];\n    normalizedDxArray.push(BigInt(ndx));\n    pools[i]['partialAmountIn'] = ndx.toString();\n  }\n  return normalizedDxArray;\n}\n\n/** reducePools\n * This function is used to implement part of the non-linear slack variables in the lagrange - multiplier\n * solution for parallel swap. Part of what comes out of the math is that sometimes, the optimal allocation for a pool\n * can be negative, which makes no physical sense. When this occurs, that particular pool needs to be flagged and the\n * lagrange constraint applied to force the allocation to be zero.\n * This function takes an already-solved set of pools, input allocation per pool, the total input amount, and the\n * inputToken name and outputToken name, and determines which, if any, allocations need to be set to zero.\n * However, when this occurs, and a pool is essentially ignored from the list, then the calculation for mu must be re-done.\n * So the calculateOptimalOutput function is then called on the reduced set of pools, and if no negative allocation values remain,\n * then the allocations on the reduced set is determined, and values of zero are put in for the 'failed' pools.\n * @param pools  list of pools that contain inputToken and outputToken\n * @param dxArray  list of input allocation per pool\n * @param inputAmount   total amount of inputToken to be traded among the pools\n * @param inputToken    the name of the inputToken\n * @param outputToken   the name of the outputToken\n * @returns newFullDxVec  the new full list of input allocations the same length as dxArray, containing zeros for failed pools.\n */\nexport function reducePools(\n  pools: Pool[],\n  dxArray: Big[],\n  inputAmount: string,\n  inputToken: string,\n  outputToken: string\n) {\n  let goodIndices = [];\n  for (var i = 0; i < dxArray.length; i++) {\n    let dx = dxArray[i];\n    if (dx.gte(0)) {\n      goodIndices.push(i);\n    }\n  }\n  if (goodIndices.length < 1) {\n    // console.log(\"ERROR OCCURRED -- ALL DX VALUES WERE NEGATIVE\")\n    return dxArray;\n  }\n  let newPools = [];\n  for (var j = 0; j < dxArray.length; j++) {\n    if (goodIndices.includes(j)) {\n      newPools.push(pools[j]);\n    }\n  }\n  let newDxVec = calculateOptimalOutput(\n    newPools,\n    inputAmount,\n    inputToken,\n    outputToken\n  );\n  let goodInd2newdx = {};\n  for (var k = 0; k < newDxVec.length; k++) {\n    goodInd2newdx[goodIndices[k]] = newDxVec[k];\n  }\n  let newFullDxVec = [];\n  for (var ii = 0; ii < pools.length; ii++) {\n    if (goodIndices.includes(ii)) {\n      newFullDxVec.push(goodInd2newdx[ii]);\n    } else {\n      newFullDxVec.push(0);\n    }\n  }\n  return newFullDxVec;\n}\n\nexport function checkIntegerSumOfAllocations(\n  allocations: Big[] | string[] | BigInt[],\n  totalInput: Big | string | BigInt\n) {\n  var totalInput = new Big(totalInput);\n  var allocations:\n    | Big[]\n    | string[]\n    | BigInt[] = allocations.map((item: Big | string | BigInt) =>\n    new Big(item).round()\n  );\n  let alloSum = allocations\n    .map(item => new Big(item))\n    .reduce((a, b) => a.plus(b), new Big(0));\n  let offset = totalInput.minus(alloSum);\n  //get largest allocation.\n  let currMax = new Big(0);\n  let currMaxInd = 0;\n  for (var i = 0; i < allocations.length; i++) {\n    if (allocations[i].gt(currMax)) {\n      currMaxInd = i;\n      currMax = allocations[i];\n    }\n  }\n  let newAllocations = [];\n  for (var j = 0; j < allocations.length; j++) {\n    if (j === currMaxInd) {\n      newAllocations.push(allocations[j].plus(offset).toString());\n    } else {\n      newAllocations.push(allocations[j].toString());\n    }\n  }\n  return newAllocations;\n}\n","/* eslint-disable no-undef */\n////////////////////////////////////////////////////////////////////////////\n// SMART ROUTE SWAP LOGIC\n////////////////////////////////////////////////////////////////////////////\nimport Big from 'big.js';\nimport { checkIntegerSumOfAllocations } from './parallelSwapLogic';\n\nimport { TokenMetadata } from './types';\n\nimport { ftGetTokenMetadata } from './ref';\n\nimport { percentLess, toNonDivisibleNumber } from './utils';\n\nBig.RM = 0;\nBig.DP = 40;\nBig.NE = -40;\nBig.PE = 40;\n\nfunction bisqrt(value) {\n  // For some ridiculous reason, the .sqrt() method for Big decimals is extremely slow (~10-20ms),\n  // which isn't so bad until you need to use it a bunch of times.\n  // Since we're dealing with super large numbers anyway, we can convert the Big decimal number into a BigInt,\n  // then run this BigInt Newton iteration square root function instead, and then convert back into a\n  // Big number. And it speeds up the operation by a crazy factor, ~10x faster.\n  if (value < BigInt(0)) {\n    throw 'square root of negative numbers is not supported';\n  }\n\n  if (value < BigInt(2)) {\n    return value;\n  }\n\n  function newtonIteration(n, x0) {\n    const x1 = (n / x0 + x0) >> BigInt(1);\n    if (x0 === x1 || x0 === x1 - BigInt(1)) {\n      return x0;\n    }\n    return newtonIteration(n, x1);\n  }\n\n  return newtonIteration(value, BigInt(1));\n}\n\nfunction getBetaForRoute(route, path) {\n  if (!route.length) {\n    route = [route];\n  }\n  if (route.length == 1) {\n    let p = route[0];\n    var beta = new Big(p.reserves[path[0]]);\n  } else if (route.length == 2) {\n    let p1 = route[0];\n    let p2 = route[1];\n    var beta = new Big(p1.reserves[path[0]]).times(\n      new Big(p2.reserves[path[1]])\n    );\n  }\n  return beta;\n}\n\nfunction getEpsilonForRoute(route, path) {\n  if (!route.length) {\n    route = [route];\n  }\n  if (route.length == 1) {\n    // Single Hop case\n    let p = route[0];\n    let gamma = new Big(10000).minus(new Big(p.fee)).div(new Big(10000));\n    var epsilon = Big(gamma);\n  } else if (route.length == 2) {\n    //Double Hop Case\n    let p1 = route[0];\n    let p2 = route[1];\n    let gamma1 = new Big(10000).minus(new Big(p1.fee)).div(new Big(10000));\n    let gamma2 = new Big(10000).minus(new Big(p2.fee)).div(Big(10000));\n    var epsilon = new Big(p2.reserves[path[1]])\n      .times(new Big(gamma1))\n      .plus(new Big(p1.reserves[path[1]]).times(gamma1).times(gamma2));\n  }\n  return epsilon;\n}\n\nfunction getAlphaForRoute(route, path) {\n  if (!route.length) {\n    route = [route];\n  }\n  if (route.length == 1) {\n    //console.log('single hop')\n    let p = route[0];\n    let inputToken = path[0];\n    let outputToken = path[1];\n    let gamma = new Big(10000).minus(new Big(p.fee)).div(new Big(10000));\n    let key1 = p.token1Id;\n    let key2 = p.token2Id;\n    let val1 = p.token1Supply;\n    let val2 = p.token2Supply;\n    p['reserves'] = { [key1]: val1, [key2]: val2 };\n    var alpha = new Big(p.reserves[inputToken]).times(\n      new Big(p.reserves[outputToken]).times(new Big(gamma))\n    );\n  } else if (route.length == 2) {\n    //console.log('double hop')\n    let p1 = route[0];\n    let p2 = route[1];\n    let key11 = p1.token1Id;\n    let key12 = p1.token2Id;\n    let val11 = p1.token1Supply;\n    let val12 = p1.token2Supply;\n    p1['reserves'] = { [key11]: val11, [key12]: val12 };\n    let key21 = p2.token1Id;\n    let key22 = p2.token2Id;\n    let val21 = p2.token1Supply;\n    let val22 = p2.token2Supply;\n    p2['reserves'] = { [key21]: val21, [key22]: val22 };\n    let inputToken = path[0];\n    let middleToken = path[1];\n    let outputToken = path[2];\n    let gamma1 = new Big(10000).minus(Big(p1.fee)).div(new Big(10000));\n    let gamma2 = new Big(10000).minus(new Big(p2.fee)).div(new Big(10000));\n    let alpha1 = new Big(p1.reserves[inputToken])\n      .times(new Big(p1.reserves[middleToken]))\n      .times(gamma1);\n    let alpha2 = new Big(p2.reserves[middleToken])\n      .times(new Big(p2.reserves[outputToken]))\n      .times(gamma2);\n    var alpha = alpha1.times(alpha2);\n  }\n  return alpha;\n}\n\nfunction getAlphaSumFromRoutes(routes, nodeRoutes) {\n  let alphaSum = new Big(0);\n  for (var i in routes) {\n    let route = routes[i];\n    let nodeRoute = nodeRoutes[i];\n    let alpha = getAlphaForRoute(route, nodeRoute);\n    // console.log('alpha is...');\n    // console.log(alpha.toString());\n    // below, we are replacing the built-in Big sqrt() method with a\n    // newton-iteration BigInt sqrt function, to speed it up by 10x.\n    let radical = new Big(bisqrt(BigInt(new Big(alpha).round().toFixed())));\n    // let radical = new Big(alpha).sqrt();\n    let epsilon = getEpsilonForRoute(route, nodeRoute);\n    let denom = new Big(epsilon);\n    alphaSum = alphaSum.plus(radical.div(denom));\n  }\n  return alphaSum;\n}\n\nfunction getBetaSumFromRoutes(routes, nodeRoutes) {\n  let betaSum = new Big(0);\n  for (var i in routes) {\n    let route = routes[i];\n    let nodeRoute = nodeRoutes[i];\n    let num = new Big(getBetaForRoute(route, nodeRoute));\n    let denom = new Big(getEpsilonForRoute(route, nodeRoute));\n    betaSum = betaSum.plus(num.div(denom));\n  }\n  return betaSum;\n}\n\nfunction getPhiFromRoutes(routes, nodeRoutes, totalInput) {\n  let alphaSum = getAlphaSumFromRoutes(routes, nodeRoutes);\n  let betaSum = getBetaSumFromRoutes(routes, nodeRoutes);\n  let phi = new Big(totalInput).plus(betaSum).div(alphaSum);\n  return phi;\n}\n\nfunction getAllocationForRoute(phi, route, path) {\n  let alpha = getAlphaForRoute(route, path);\n  let beta = getBetaForRoute(route, path);\n  let epsilon = getEpsilonForRoute(route, path);\n  // below, we are replacing the built-in Big sqrt() method with a\n  // newton-iteration BigInt sqrt function, to speed it up by 10x.\n  let allocation = new Big(phi)\n    .abs()\n    .times(new Big(bisqrt(BigInt(new Big(alpha).round().toFixed()))))\n    .minus(beta)\n    .div(epsilon);\n  return allocation;\n}\n\nfunction getAllocationVectorForRoutes(phi, routes, nodeRoutes) {\n  let allocationVec = [];\n  for (var i in routes) {\n    allocationVec.push(getAllocationForRoute(phi, routes[i], nodeRoutes[i]));\n  }\n  return allocationVec;\n}\n\nfunction getOptimalAllocationForRoutes(routes, nodeRoutes, totalInput) {\n  // console.log(\"CALLING GET OPTIMAL ALLOCATION FOR ROUTES:\")\n  // console.log(routes)\n  var totalInput = new Big(totalInput);\n  let phi = getPhiFromRoutes(routes, nodeRoutes, totalInput);\n  // console.log('PHI CALCULATED TO BE...')\n  // console.log(phi.toString())\n  let allocations = getAllocationVectorForRoutes(phi, routes, nodeRoutes);\n  if (allocations.every(item => item.lt(new Big(0)))) {\n    allocations = allocations.map(item => item.times(new Big(-1.0)));\n  }\n  if (allocations.some(item => item.lt(new Big(0)))) {\n    allocations = reduceRoutes(routes, nodeRoutes, allocations, totalInput);\n  }\n  let sumAllocations = allocations.reduce((a, b) => a.plus(b), new Big(0));\n  let normalizedAllocations = allocations.map(a =>\n    a.div(sumAllocations).times(new Big(totalInput))\n  );\n  return normalizedAllocations;\n}\n\nfunction reduceRoutes(routes, nodeRoutes, allocationVec, totalInput) {\n  // console.log(\"RUNNING REDUCE ROUTES\")\n  var totalInput = new Big(totalInput);\n  let goodIndices = [];\n  for (var i in allocationVec) {\n    let dx = allocationVec[i];\n    // console.log('DX IS...')\n    // console.log(dx.toString())\n    if (dx.gt(new Big(0))) {\n      goodIndices.push(i);\n    }\n  }\n  // console.log('GOOD INDICES ARE...');\n  // console.log(goodIndices);\n  let newRoutes = [];\n  let newNodeRoutes = [];\n  for (var i in goodIndices) {\n    let goodIndex = goodIndices[i];\n    newRoutes.push(routes[goodIndex]);\n    newNodeRoutes.push(nodeRoutes[goodIndex]);\n  }\n  allocationVec = getOptimalAllocationForRoutes(\n    newRoutes,\n    newNodeRoutes,\n    totalInput\n  );\n  let allocationDict = {};\n  for (var i in goodIndices) {\n    allocationDict[goodIndices[i]] = allocationVec[i];\n  }\n  var allocationVecNew = [];\n  for (var i in routes) {\n    if (goodIndices.includes(i)) {\n      allocationVecNew.push(allocationDict[i]);\n    } else {\n      let zeroAllocation = new Big(0);\n      allocationVecNew.push(zeroAllocation);\n    }\n  }\n  return allocationVecNew;\n}\n\nfunction getNodeRoutesFromPathsAndPoolChains(paths, poolChains) {\n  let multiplicity = [];\n  for (var i in poolChains) {\n    let pc = poolChains[i];\n    let mul = pc\n      .map(item => item.length)\n      .reduce((elem1, elem2) => elem1 * elem2, 1);\n    multiplicity.push(mul);\n  }\n  let nodeRoutes = [];\n  for (var j in paths) {\n    let path = paths[j];\n    let m = multiplicity[j];\n    for (var k = 0; k < m; k++) {\n      nodeRoutes.push(path);\n    }\n  }\n  return nodeRoutes;\n}\n\nfunction getPoolChainFromPaths(paths, pools, threshold = 0.001) {\n  let poolChains = [];\n  for (var pathInd in paths) {\n    let path = paths[pathInd];\n    let chain = [];\n    let pairs = [];\n    for (var i = 0; i < path.length - 1; i++) {\n      pairs.push([path[i], path[i + 1]]);\n    }\n    for (var pairInd in pairs) {\n      let pair = pairs[pairInd];\n      // console.log(pair);\n      let tokenPools = getPoolsByToken1ANDToken2(pools, pair[0], pair[1]);\n      chain.push(tokenPools);\n    }\n    poolChains.push(chain);\n  }\n  // return poolChains;\n  let culledPoolChains = getCulledPoolChains(poolChains, threshold);\n\n  return culledPoolChains;\n}\n\nfunction getCulledPoolChains(poolChains, threshold = 0.001) {\n  let newChains = [];\n  for (var pathInd in poolChains) {\n    let path = poolChains[pathInd];\n    let newPath = [];\n    for (var legInd in path) {\n      let leg = path[legInd];\n      let culledPath = cullPoolsWithInsufficientLiquidity(leg, threshold);\n      newPath.push(culledPath);\n    }\n    newChains.push(newPath);\n  }\n  return newChains;\n}\n\nfunction getRoutesFromPoolChain(poolChains) {\n  let routes = [];\n  for (var pci in poolChains) {\n    let poolChain = poolChains[pci];\n    //get cartesian product of each pool chain to get the list of routes.\n    let newRoutes = cartesianProduct(poolChain);\n    routes.push(...newRoutes);\n  }\n  for (var i in routes) {\n    if (!routes[i].length) {\n      routes[i] = [routes[i]];\n    }\n  }\n  return routes;\n}\n\nfunction getOutputSingleHop(pool, inputToken, outputToken, totalInput) {\n  var totalInput = new Big(totalInput);\n  // check if pool is forward or backward for inputToken/outputToken cf. token1Id/token2Id\n  if (inputToken === pool.token1Id && outputToken === pool.token2Id) {\n    // forward Pool\n    var reserves = {\n      [inputToken]: new Big(pool.token1Supply),\n      [outputToken]: new Big(pool.token2Supply),\n    };\n  } else if (inputToken === pool.token2Id && outputToken === pool.token1Id) {\n    // reverse pool\n    var reserves = {\n      [outputToken]: new Big(pool.token1Supply),\n      [inputToken]: new Big(pool.token2Supply),\n    };\n  } else {\n    return new Big(0);\n  }\n  let gamma = new Big(10000).minus(new Big(pool.fee)).div(new Big(10000));\n  // console.log(totalInput)\n  // console.log(gamma)\n  // console.log(reserves)\n  let num = totalInput.times(gamma).times(reserves[outputToken]);\n  let denom = reserves[inputToken].plus(gamma.times(totalInput));\n  return num.div(denom);\n}\n\nfunction getOutputDoubleHop(\n  pools,\n  inputToken,\n  middleToken,\n  outputToken,\n  totalInput\n) {\n  var totalInput = new Big(totalInput);\n  for (var poolIndex in pools) {\n    let p = pools[poolIndex];\n    p['gamma'] = new Big(10000).minus(new Big(p.fee)).div(new Big(10000));\n  }\n  let p1 = pools[0];\n  let p2 = pools[1];\n\n  if (inputToken === p1.token1Id && middleToken === p1.token2Id) {\n    // forward Pool\n    p1['reserves'] = {\n      [inputToken]: new Big(p1.token1Supply),\n      [middleToken]: new Big(p1.token2Supply),\n    };\n  } else if (middleToken === p1.token1Id && inputToken === p1.token2Id) {\n    //reverse pool\n    p1['reserves'] = {\n      [middleToken]: new Big(p1.token1Supply),\n      [inputToken]: new Big(p1.token2Supply),\n    };\n  }\n\n  if (middleToken === p2.token1Id && outputToken === p2.token2Id) {\n    // forward Pool\n    p2['reserves'] = {\n      [middleToken]: new Big(p2.token1Supply),\n      [outputToken]: new Big(p2.token2Supply),\n    };\n  } else if (outputToken === p2.token1Id && middleToken === p2.token2Id) {\n    //reverse pool\n    p2['reserves'] = {\n      [outputToken]: new Big(p2.token1Supply),\n      [middleToken]: new Big(p2.token2Supply),\n    };\n  }\n\n  let c1 = new Big(p1.reserves[middleToken]);\n  let a1 = new Big(p1.reserves[inputToken]);\n  let c2 = new Big(p2.reserves[middleToken]);\n  let b2 = new Big(p2.reserves[outputToken]);\n  let gamma1 = p1.gamma;\n  let gamma2 = p2.gamma;\n  let num = totalInput\n    .times(c1)\n    .times(b2)\n    .times(gamma1)\n    .times(gamma2);\n  let denom = c2\n    .times(a1)\n    .plus(\n      totalInput.times(c2.times(gamma1).plus(c1.times(gamma1).times(gamma2)))\n    );\n  // denom = c2*a1 + totalInput * (c2*gamma1 + c1*gamma1*gamma2)\n\n  return num.div(denom);\n}\n\nfunction getOutputFromRoute(route, nodeRoute, allocation) {\n  if (new Big(allocation).eq(new Big(0))) {\n    return new Big(0);\n  } else {\n    var allocation = new Big(allocation);\n  }\n  if (!route.length) {\n    route = [route];\n  }\n  if (route.length == 1) {\n    // single hop\n    let inputToken = nodeRoute[0];\n    let outputToken = nodeRoute[1];\n    let pool = route[0];\n    var output = getOutputSingleHop(pool, inputToken, outputToken, allocation);\n  } else if (route.length == 2) {\n    // DOUBLE HOP\n    let inputToken = nodeRoute[0];\n    let middleToken = nodeRoute[1];\n    let outputToken = nodeRoute[2];\n    let pools = route;\n    var output = getOutputDoubleHop(\n      pools,\n      inputToken,\n      middleToken,\n      outputToken,\n      allocation\n    );\n  }\n  return output;\n}\n\nfunction getOptOutputVec(routes, nodeRoutes, totalInput) {\n  let allocations = getOptimalAllocationForRoutes(\n    routes,\n    nodeRoutes,\n    totalInput\n  );\n  let result = [];\n  for (var i in routes) {\n    let route = routes[i];\n    let nodeRoute = nodeRoutes[i];\n    let allocation = allocations[i];\n    let output = getOutputFromRoute(route, nodeRoute, allocation);\n    result.push(output);\n  }\n  return {\n    result: result,\n    allocations: allocations,\n  };\n  //NOTE -- I made this return an object instead of the tuple returned in python. need to check the places it is called, and specify\n  // result field instead of tuple 0 position, and allocations field instead of tuple 1 position.\n}\n\nfunction getBestOptInputAndOutputSlower(routes, nodeRoutes, totalInput) {\n  let refDict = getOptOutputVecRefined(routes, nodeRoutes, totalInput);\n  let outputRefined = refDict.result;\n  let inputRefined = refDict.allocations;\n  inputRefined = checkIntegerSumOfAllocations(inputRefined, totalInput);\n  let rawDict = getOptOutputVec(routes, nodeRoutes, totalInput);\n  let outputRaw = rawDict.result;\n  let inputRaw = rawDict.allocations;\n  inputRaw = checkIntegerSumOfAllocations(inputRaw, totalInput);\n  let res1 = new Big(0);\n  let res2 = new Big(0);\n\n  for (var n in outputRefined) {\n    res1 = res1.plus(outputRefined[n]);\n  }\n  for (var nn in outputRaw) {\n    res2 = res2.plus(outputRaw[nn]);\n  }\n  // console.log('COMPARING SINGLE HOPS VS DOUBLE')\n  // console.log(res1.toString())\n  // console.log(res2.toString())\n  if (res1.gt(res2)) {\n    return { input: inputRefined, output: res1 };\n  } else {\n    return { input: inputRaw, output: res2 };\n  }\n}\n\nfunction getBestOptInputAndOutput(routes, nodeRoutes, totalInput) {\n  // let refDict = getOptOutputVecRefined(routes, nodeRoutes, totalInput);\n  // let outputRefined = refDict.result;\n  // let inputRefined = refDict.allocations;\n  // inputRefined = checkIntegerSumOfAllocations(inputRefined, totalInput);\n  let rawDict = getOptOutputVec(routes, nodeRoutes, totalInput);\n  let outputRaw = rawDict.result;\n  let inputRaw = rawDict.allocations;\n  inputRaw = checkIntegerSumOfAllocations(inputRaw, totalInput);\n  let res1 = new Big(0);\n  let res2 = new Big(0);\n\n  let res = outputRaw\n    .map(v => new Big(v))\n    .reduce((bv1, bv2) => bv1.plus(bv2), new Big(0));\n\n  return {\n    input: inputRaw,\n    output: res,\n  };\n}\n\nfunction getBestOptOutput(routes, nodeRoutes, totalInput) {\n  let outputRefined = getOptOutputVecRefined(routes, nodeRoutes, totalInput)\n    .result;\n  let outputRaw = getOptOutputVec(routes, nodeRoutes, totalInput).result;\n  let res1 = new Big(0);\n  let res2 = new Big(0);\n\n  for (var n in outputRefined) {\n    res1 = res1.plus(outputRefined[n]);\n  }\n  for (var nn in outputRaw) {\n    res2 = res2.plus(outputRaw[nn]);\n  }\n  if (res1.gt(res2)) {\n    return res1;\n  } else {\n    return res2;\n  }\n}\n\nfunction getBestOptInput(routes, nodeRoutes, totalInput) {\n  let refDict = getOptOutputVecRefined(routes, nodeRoutes, totalInput);\n  let outputRefined = refDict.result;\n  let inputRefined = refDict.allocations;\n  inputRefined = checkIntegerSumOfAllocations(inputRefined, totalInput);\n  let rawDict = getOptOutputVec(routes, nodeRoutes, totalInput);\n  let outputRaw = rawDict.result;\n  let inputRaw = rawDict.allocations;\n  inputRaw = checkIntegerSumOfAllocations(inputRaw, totalInput);\n  let res1 = new Big(0);\n  let res2 = new Big(0);\n\n  for (var n in outputRefined) {\n    res1 = res1.plus(outputRefined[n]);\n  }\n  for (var nn in outputRaw) {\n    res2 = res2.plus(outputRaw[nn]);\n  }\n  // console.log('COMPARING SINGLE HOPS VS DOUBLE')\n  // console.log(res1.toString())\n  // console.log(res2.toString())\n  if (res1.gt(res2)) {\n    return inputRefined;\n  } else {\n    return inputRaw;\n  }\n}\n\nfunction getOptOutputVecRefined(routes, nodeRoutes, totalInput) {\n  // need to calculate full result.\n  // if direct pools exist, need to calculate parallel result. if not, this portion is set to zero output.\n\n  // need to compare between outputs of the two results above.\n\n  let initLengthRoutes = routes.length;\n  let directRouteInds = [];\n  for (var routeInd in routes) {\n    let route = routes[routeInd];\n    if (!route.length) {\n      route = [route];\n    }\n    if (route.length == 1) {\n      directRouteInds.push(routeInd);\n    }\n  }\n  // console.log('DIRECT ROUTE INDS ARE')\n  // console.log(directRouteInds)\n  // if (directRouteInds.length < 1) {\n  var fullResultAllocations = getOptimalAllocationForRoutes(\n    routes,\n    nodeRoutes,\n    totalInput\n  );\n  var fullResult = [];\n  for (var i in routes) {\n    let r = routes[i];\n    let nr = nodeRoutes[i];\n    let a = fullResultAllocations[i];\n    let output = getOutputFromRoute(r, nr, a);\n    fullResult.push(output);\n  }\n  var fullResultTotal = fullResult.reduce((a, b) => a.plus(b), new Big(0));\n\n  // } else {\n  if (directRouteInds.length > 0) {\n    // console.log('DOING SINGLE HOP ONLY')\n    let droutes = [];\n    let dnodeRoutes = [];\n    for (var dri in directRouteInds) {\n      let ind = directRouteInds[dri];\n      droutes.push(routes[ind]);\n      dnodeRoutes.push(nodeRoutes[ind]);\n    }\n    let dallocations = getOptimalAllocationForRoutes(\n      droutes,\n      dnodeRoutes,\n      totalInput\n    );\n    let dallocDict = {};\n    for (var dd in dallocations) {\n      dallocDict[directRouteInds[dd]] = dallocations[dd];\n    }\n    var pallocations = [];\n\n    for (var ii = 0; ii < initLengthRoutes; ii++) {\n      if (directRouteInds.includes(ii.toString())) {\n        //console.log('ADDING ALLOCATION FOR SINGLE ROUTE')\n        pallocations.push(dallocDict[ii]);\n      } else {\n        pallocations.push(new Big(0));\n      }\n    }\n    var presult = [];\n    for (var j in routes) {\n      let route = routes[j];\n      let nodeRoute = nodeRoutes[j];\n      let allocation = pallocations[j];\n      let output = getOutputFromRoute(route, nodeRoute, allocation);\n      presult.push(output);\n    }\n    var presultTotal = presult.reduce((a, b) => a.plus(b), new Big(0));\n  } else {\n    var presultTotal = new Big(0);\n  }\n  if (presultTotal.gt(fullResultTotal)) {\n    var result = presult;\n    var allocations = pallocations;\n  } else {\n    var result = fullResult;\n    var allocations = fullResultAllocations;\n  }\n  // NEED TO COMPARE BETWEEEN DIRECT AND MULTI HOP TO GET BEST OUTPUT\n  return {\n    result: result,\n    allocations: allocations,\n  };\n}\n\nasync function getBestOptimalAllocationsAndOutputs(\n  pools,\n  inputToken,\n  outputToken,\n  totalInput,\n  maxPathLength = 3,\n  threshold = 0.001\n) {\n  var totalInput = new Big(totalInput);\n  let paths = await getPathsFromPools(\n    pools,\n    inputToken,\n    outputToken,\n    maxPathLength\n  );\n  if (!paths.length) {\n    return {\n      allocations: [],\n      outputs: new Big(0),\n      routes: [],\n      nodeRoutes: [],\n    };\n  }\n  let poolChains = await getPoolChainFromPaths(paths, pools, threshold);\n\n  let routes = await getRoutesFromPoolChain(poolChains);\n  let nodeRoutes = await getNodeRoutesFromPathsAndPoolChains(paths, poolChains);\n  // let allocations = await getBestOptInput(routes, nodeRoutes, totalInput);\n  // // fix integer rounding for allocations:\n  // allocations = checkIntegerSumOfAllocations(allocations, totalInput);\n  // let outputs = getBestOptOutput(routes, nodeRoutes, totalInput);\n  let inputOutput = await getBestOptInputAndOutput(\n    routes,\n    nodeRoutes,\n    totalInput\n  );\n  let allocations = inputOutput.input;\n  let outputs = inputOutput.output;\n\n  return {\n    allocations: allocations,\n    outputs: outputs,\n    routes: routes,\n    nodeRoutes: nodeRoutes,\n  };\n}\n\nfunction getHopsFromRoutes(routes, nodeRoutes, allocations) {\n  let hops = [];\n  for (var i in routes) {\n    var route = routes[i];\n    var nodeRoute = nodeRoutes[i];\n    var allocation = allocations[i];\n    if (!route.length) {\n      route = [route];\n    }\n    if (!route[0]) {\n      continue;\n    }\n    let hop = {\n      pool: route[0],\n      allocation: allocation,\n      inputToken: nodeRoute[0],\n      outputToken: nodeRoute[1],\n    };\n    hops.push(hop);\n  }\n  return hops;\n}\n\nfunction distillHopsByPool(hops) {\n  // console.log('some HOPS =');\n  // console.log(hops);\n  let distilledHops = [];\n  let poolIds = [];\n  let poolId2allocation = {};\n  for (var i in hops) {\n    let hop = hops[i];\n    if (hop.allocation === '0') {\n      continue;\n    }\n    // console.log(`HOP ${i} IS...`);\n    // console.log(hop);\n    let poolId = hop.pool['id'];\n    if (poolIds.includes(poolId)) {\n      poolId2allocation[poolId] = new Big(poolId2allocation[poolId])\n        .plus(new Big(hop.allocation))\n        .toString();\n    } else {\n      poolId2allocation[poolId] = new Big(hop.allocation).toString();\n      poolIds.push(poolId);\n    }\n  }\n  // let poolsWithOrder = [...new Set(...hops.map((item) => item.pool))]\n  let keys = Object.keys(poolId2allocation);\n  for (var j in keys) {\n    var poolId = keys[j];\n    let hop = hops.filter(\n      item => item.pool.id.toString() === poolId.toString()\n    )[0];\n    let distilledHop = {\n      pool: hop.pool,\n      allocation: poolId2allocation[poolId],\n      inputToken: hop.inputToken,\n      outputToken: hop.outputToken,\n    };\n    distilledHops.push(distilledHop);\n  }\n  return distilledHops;\n}\n\nfunction getDistilledHopActions(distilledHops, slippageTolerance) {\n  let actions = [];\n  for (var i in distilledHops) {\n    let hop = distilledHops[i];\n    let expectedAmountOut = getOutputSingleHop(\n      hop.pool,\n      hop.inputToken,\n      hop.outputToken,\n      hop.allocation\n    );\n    let minimumAmountOut = new Big(expectedAmountOut)\n      .times(new Big(1).minus(new Big(slippageTolerance).div(100)))\n      .round()\n      .toString(); //Here, assume slippage tolerance is a percentage. So 1% would be 1.0\n    let action = {\n      pool_id: hop.pool.id,\n      token_in: hop.inputToken,\n      token_out: hop.outputToken,\n      amount_in: hop.allocation,\n      min_amount_out: minimumAmountOut,\n    };\n    actions.push(action);\n  }\n  return actions;\n}\nfunction getMiddleTokenTotalsFromFirstHopActions(firstHopActions) {\n  let middleTokens = [...new Set(firstHopActions.map(item => item.token_out))];\n  let middleTokenTotals = {};\n  for (var i in middleTokens) {\n    let middleToken = middleTokens[i];\n    let mtActions = firstHopActions.filter(\n      item => item.token_out === middleToken\n    );\n    let mtTotal = mtActions\n      .map(item => new Big(item.min_amount_out))\n      .reduce((a, b) => a.plus(b), new Big(0))\n      .toString();\n    middleTokenTotals[middleToken] = mtTotal;\n  }\n  return middleTokenTotals;\n}\nfunction getRoutesAndAllocationsForMiddleToken(\n  routes,\n  nodeRoutes,\n  allocations,\n  middleToken,\n  middleTokenTotal\n) {\n  // get routes that use middle token.\n  // (input route alloction) /sum(input allocations of routes with middle token) * (total_middleToken)\n  let mask = [];\n  for (var i in nodeRoutes) {\n    if (nodeRoutes[i][1] === middleToken) {\n      mask.push(true);\n    } else {\n      mask.push(false);\n    }\n  }\n  let froutes = [];\n  let fallocations = [];\n  let fnoderoutes = [];\n  for (var i in routes) {\n    if (mask[i]) {\n      froutes.push(routes[i]);\n      fallocations.push(allocations[i]);\n      fnoderoutes.push(nodeRoutes[i]);\n    }\n  }\n  let sumfallocations = fallocations.reduce(\n    (a, b) => new Big(a).plus(new Big(b)),\n    new Big(0)\n  );\n  let middleAllocations = fallocations.map(item =>\n    new Big(item).div(sumfallocations).times(new Big(middleTokenTotal))\n  );\n  let secondHopRoutes = froutes.map(item => [item[1]]);\n  let secondHopNodeRoutes = fnoderoutes.map(item => [item[1], item[2]]);\n  middleAllocations = checkIntegerSumOfAllocations(\n    middleAllocations,\n    middleTokenTotal\n  );\n  return {\n    routes: secondHopRoutes,\n    nodeRoutes: secondHopNodeRoutes,\n    allocations: middleAllocations,\n  };\n}\n\nfunction getHopActionsFromRoutes(routes, nodeRoutes, allocations) {\n  // console.log('INSIDE GET HOP ACTIONS FROM ROUTES');\n  // console.log('ROUTES ARE...');\n  // console.log(routes);\n  // console.log('NODE ROUTES ARE...');\n  // console.log(nodeRoutes);\n  // console.log('ALLOCATIONS ARE...');\n  // console.log(allocations);\n  let totalInput = allocations\n    .map(a => new Big(a))\n    .reduce((a, b) => a.plus(b), new Big(0))\n    .toString();\n  let hops = [];\n  for (var i in routes) {\n    var route = routes[i];\n    var nodeRoute = nodeRoutes[i];\n    var allocation = allocations[i];\n    if (new Big(allocation).eq(new Big(0))) {\n      continue;\n    }\n    if (!route.length) {\n      route = [route];\n    }\n    if (!route[0]) {\n      continue;\n    }\n    for (var j in route) {\n      let pool = route[j];\n      // console.log('J IS...');\n      // console.log(j);\n      // console.log('NODE ROUTE IS...');\n      // console.log(nodeRoute);\n      if (j == 0) {\n        //first hop.\n        // console.log(nodeRoute[0]);\n        // console.log(nodeRoute[1]);\n        var hop = {\n          pool: pool,\n          allocation: allocation.toString(),\n          inputToken: nodeRoute[0],\n          outputToken: nodeRoute[1],\n          nodeRoute: nodeRoute,\n          route: route,\n          allRoutes: routes,\n          allNodeRoutes: nodeRoutes,\n          totalInputAmount: totalInput,\n          allAllocations: allocations,\n        };\n        // console.log('FIRST HOP IS...');\n        // console.log(hop);\n        hops.push(hop);\n        if (nodeRoute.length > 2) {\n          var middleTokenAllocation = getOutputSingleHop(\n            pool,\n            nodeRoute[0],\n            nodeRoute[1],\n            allocation\n          );\n        }\n      } else {\n        // second hop\n        var hop = {\n          pool: pool,\n          allocation: middleTokenAllocation.toString(),\n          inputToken: nodeRoute[1],\n          outputToken: nodeRoute[2],\n          nodeRoute: nodeRoute,\n          route: route,\n          allRoutes: routes,\n          allNodeRoutes: nodeRoutes,\n          totalInputAmount: totalInput,\n          allAllocations: allocations,\n        };\n        // console.log('SECOND HOP IS...');\n        // console.log(hop);\n        hops.push(hop);\n      }\n    }\n  }\n  // console.log('HOP ACTIONS FOUND TO BE');\n  // console.log(hops);\n  return hops;\n}\n\n// TODO: Clean this function. I don't need all the \"actions\" just the hops.\n// TODO: re-order actions to ensure each route is complete with zero input for second hop before starting next route.\nfunction getActionListFromRoutesAndAllocations(\n  routes,\n  nodeRoutes,\n  allocations\n) {\n  // REPLACE THE CODE BELOW WITH THE FUNCTION HERE.\n  return getHopActionsFromRoutes(routes, nodeRoutes, allocations);\n  var actions = [];\n  var all_hops = [];\n  let firstHops = getHopsFromRoutes(routes, nodeRoutes, allocations);\n\n  firstHops = firstHops.filter(hop => new Big(hop.allocation).gt(new Big(0)));\n  all_hops.push(...firstHops);\n  let distilledFirstHops = distillHopsByPool(firstHops);\n  let firstHopActions = getDistilledHopActions(\n    distilledFirstHops,\n    slippageTolerance\n  );\n  actions.push(...firstHopActions);\n  let middleTokenTotals = getMiddleTokenTotalsFromFirstHopActions(\n    firstHopActions\n  );\n  // console.log('first hop actions are...');\n  // console.log(firstHopActions);\n  let middleTokens = Object.keys(middleTokenTotals);\n  // console.log('middle token totals are...');\n  // console.log(middleTokenTotals);\n  // console.log('middle tokens are...');\n  // console.log(middleTokens);\n  for (var tokenIndex in middleTokens) {\n    var secondHops = [];\n    let middleToken = middleTokens[tokenIndex];\n    // console.log('current middle token is ');\n    // console.log(middleToken);\n    let middleTokenTotal = middleTokenTotals[middleToken];\n    // console.log('current middle token total is...');\n    // console.log(middleTokenTotal);\n    let middleTokenRoutesWithAllocations = getRoutesAndAllocationsForMiddleToken(\n      routes,\n      nodeRoutes,\n      allocations,\n      middleToken,\n      middleTokenTotal\n    );\n    // console.log('current middle tokens routes with allocations are...');\n    // console.log(middleTokenRoutesWithAllocations);\n    let middleTokenRoutes = middleTokenRoutesWithAllocations.routes;\n    let middleTokenAllocations = middleTokenRoutesWithAllocations.allocations;\n    let middleTokenNodeRoutes = middleTokenRoutesWithAllocations.nodeRoutes;\n    // console.log('middle token routes are...');\n    // console.log(middleTokenRoutes);\n    // console.log('middle token allocations are...');\n    // console.log(middleTokenAllocations);\n    // console.log('middle token node routes are...');\n    // console.log(middleTokenNodeRoutes);\n    secondHops.push(\n      ...getHopsFromRoutes(\n        middleTokenRoutes,\n        middleTokenNodeRoutes,\n        middleTokenAllocations\n      )\n    );\n    // console.log('CURRENT SECOND HOPS', secondHops);\n    // console.log(secondHops.length);\n    // console.log(secondHops.map((hop) => hop.allocation));\n    // console.log('filter out zero allocation 2nd hops:');\n    secondHops = secondHops.filter(hop =>\n      new Big(hop.allocation).gt(new Big(0))\n    );\n    // console.log(secondHops);\n    all_hops.push(...secondHops);\n    // console.log('second hops are currently...');\n    // console.log(secondHops);\n    let distilledSecondHopsForToken = distillHopsByPool(secondHops);\n    // console.log('distilled second hops are...');\n    let secondHopActionsForToken = getDistilledHopActions(\n      distilledSecondHopsForToken,\n      slippageTolerance\n    );\n    // console.log(secondHopActionsForToken);\n    actions.push(...secondHopActionsForToken);\n  }\n\n  //TODO: NEED TO RUN INTEGER ROUNDING FUNCTION ON MIDDLE TOKEN ALLOCATIONS\n\n  // TODO: check the node routes. for double-hop cases, find the hop action for each hop.\n  // For now, we are assuming no parallel swaps if there is a double-hop.\n\n  // Possible cases:\n  //  (1) 1 single-hop.\n  //  (2) Parallel single-hop ?\n  //  (3) 1 double-hop\n  //  (4) 2 double-hops\n\n  // We only have to worry about re-ordering the actions for cases (3) and (4).\n\n  let orderedHops = orderHops(all_hops, routes, nodeRoutes, allocations);\n\n  // console.log('ALL HOPS', all_hops);\n  return orderedHops;\n  // return actions;\n}\n\nfunction orderHops(hops, routes, nodeRoutes, allocations) {\n  // first get rid of zero allocation routes\n  // console.log('NODE ROUTES ARE...');\n  // console.log(nodeRoutes);\n  let filteredRoutes = [];\n  let filteredNodeRoutes = [];\n  let filteredAllocations = [];\n  for (var i in routes) {\n    // remove zero-allocation routes.\n    let allocation = new Big(allocations[i]);\n    if (allocation.gt(new Big(0))) {\n      filteredAllocations.push(allocation);\n      filteredRoutes.push(routes[i]);\n      filteredNodeRoutes.push(nodeRoutes[i]);\n    }\n    // console.log('FILTERED NODE ROUTES ARE...');\n    // console.log(filteredNodeRoutes);\n  }\n  // next check node routes to see if it is case 1, 2, 3, or 4.\n  // Possible cases:\n  //  (1) 1 single-hop.\n  //  (2) Parallel single-hop ?\n  //  (3) 1 double-hop\n  //  (4) 2 double-hops\n\n  if (filteredNodeRoutes.length === 1) {\n    // only one route.\n    let currentNodeRoute = filteredNodeRoutes[0];\n    if (currentNodeRoute.length === 2) {\n      // case 1.\n      return hops;\n    } else {\n      // case 3. assume there are only 3 nodes (double-hop)\n      //make sure order of hops is such that input token precedes output token.\n      //make sure the amount_in for second hop is zero (which will grab all of output of first hop to use.)\n      let firstHop = hops.filter(\n        hop => hop.inputToken === currentNodeRoute[0]\n      )[0];\n      let secondHop = hops.filter(\n        hop => hop.inputToken === currentNodeRoute[1]\n      )[0];\n      // set second hop amount in to 0 so that it will use whatever was generated by hop 1.\n      secondHop.pool.partialAmountIn = '0';\n\n      let orderedHops = [firstHop, secondHop];\n      return orderedHops;\n    }\n  } else if (filteredNodeRoutes.length === 2) {\n    // two routes.\n    let lengthNodeRoutes = filteredNodeRoutes.map(nr => nr.length);\n    // sub cases:\n    // [2,2] -- parallel swap. (direct) -- case 2\n    // [2,3] -- direct swap in parallel with double hop.\n    // [3,2] -- double hop in parallel with direct swap.\n    // [3,3] -- double hop in parallel with double hop. -- case 4\n    let orderedHops = [];\n    if (arrayEquals(lengthNodeRoutes, [2, 2])) {\n      return hops;\n    } else if (arrayEquals(lengthNodeRoutes, [2, 3])) {\n      directNodeRoute = filteredNodeRoutes[0];\n      doubleNodeRoute = filteredNodeRoutes[1];\n      let firstHop = hops.filter(\n        hop =>\n          hop.inputToken === directNodeRoute[0] &&\n          hop.outputToken === directNodeRoute[1]\n      )[0];\n      let secondHop = hops.filter(\n        hop => hop.inputToken === doubleNodeRoute[0]\n      )[0];\n      let thirdHop = hops.filter(\n        hop => hop.outputToken === doubleNodeRoute[2]\n      )[0];\n      // set third hop amount in to 0 so that it will use whatever was generated by hop 2.\n      thirdHop.pool.partialAmountIn = '0';\n      orderedHops = [firstHop, secondHop, thirdHop];\n      return orderedHops;\n    } else if (arrayEquals(lengthNodeRoutes, [3, 2])) {\n      directNodeRoute = filteredNodeRoutes[1];\n      doubleNodeRoute = filteredNodeRoutes[0];\n      let firstHop = hops.filter(\n        hop =>\n          hop.inputToken === directNodeRoute[0] &&\n          hop.outputToken === directNodeRoute[1]\n      )[0];\n      let secondHop = hops.filter(\n        hop => hop.inputToken === doubleNodeRoute[0]\n      )[0];\n      let thirdHop = hops.filter(\n        hop => hop.outputToken === doubleNodeRoute[2]\n      )[0];\n      // set third hop amount in to 0 so that it will use whatever was generated by hop 2.\n      thirdHop.pool.partialAmountIn = '0';\n      orderedHops = [firstHop, secondHop, thirdHop];\n      return orderedHops;\n    } else if (arrayEquals(lengthNodeRoutes, [3, 3])) {\n      orderedHops = [];\n\n      for (var i in filteredNodeRoutes) {\n        let doubleNodeRoute = filteredNodeRoutes[i];\n        let doubleHopMiddleToken = doubleNodeRoute[1];\n        let firstHop = hops.filter(\n          hop =>\n            hop.inputToken === doubleNodeRoute[0] &&\n            hop.outputToken === doubleHopMiddleToken\n        )[0];\n        let secondHop = hops.filter(\n          hop =>\n            hop.inputToken === doubleHopMiddleToken &&\n            hop.outputToken === doubleNodeRoute[2]\n        )[0];\n        // set second hop amount in to 0 so that it will use whatever was generated by hop 1.\n        secondHop.pool.partialAmountIn = '0';\n        orderedHops.push(firstHop);\n        orderedHops.push(secondHop);\n      }\n      return orderedHops;\n    } else {\n      return hops;\n    }\n    for (var i in filteredNodeRoutes) {\n      let currentNodeRoute = filteredNodeRoutes[i];\n      if (currentNodeRoute.length === 2) {\n      }\n    }\n  }\n\n  return hops;\n}\n\n// function getActionListFromRoutesAndAllocationsORIG(\n//   routes,\n//   nodeRoutes,\n//   allocations,\n//   slippageTolerance\n// ) {\n//   let actions = [];\n//   for (var i in routes) {\n//     let route = routes[i];\n//     let nodeRoute = nodeRoutes[i];\n//     let allocation = new Big(allocations[i]);\n//     if (allocation.eq(new Big(0))) {\n//       continue;\n//     }\n//     if (!route.length) {\n//       route = [route];\n//     }\n//     if (route.length === 1) {\n//       //single hop. only one action.\n//       let pool = route[0];\n//       let poolId = pool.id;\n//       let inputToken = nodeRoute[0];\n//       let outputToken = nodeRoute[1];\n//       let expectedAmountOut = getOutputSingleHop(\n//         pool,\n//         inputToken,\n//         outputToken,\n//         allocation\n//       );\n//       let minimumAmountOut = expectedAmountOut\n//         .times(new Big(1).minus(new Big(slippageTolerance).div(100)))\n//         .round()\n//         .toString(); //Here, assume slippage tolerance is a percentage. So 1% would be 1.0\n//       let action = {\n//         pool_id: poolId,\n//         token_in: inputToken,\n//         token_out: outputToken,\n//         amount_in: allocation.round().toString(),\n//         min_amount_out: minimumAmountOut.toString(),\n//       };\n//       actions.push(action);\n//     } else if (route.length === 2) {\n//       // double hop. two actions.\n//       let pool1 = route[0];\n//       let pool2 = route[1];\n//       let pool1Id = pool1.id;\n//       let pool2Id = pool2.id;\n//       let inputToken = nodeRoute[0];\n//       let middleToken = nodeRoute[1];\n//       let outputToken = nodeRoute[2];\n//       let expectedAmountOutFirstHop = getOutputSingleHop(\n//         pool1,\n//         inputToken,\n//         middleToken,\n//         allocation\n//       );\n//       let minimumAmountOutFirstHop = expectedAmountOutFirstHop\n//         .times(new Big(1).minus(new Big(slippageTolerance).div(100)))\n//         .round()\n//         .toString(); //Here, assume slippage tolerance is a percentage. So 1% would be 1.0\n\n//       let action1 = {\n//         pool_id: pool1Id,\n//         token_in: inputToken,\n//         token_out: middleToken,\n//         amount_in: allocation.round().toString(),\n//         min_amount_out: minimumAmountOutFirstHop,\n//       };\n//       let expectedFinalAmountOut = getOutputSingleHop(\n//         pool2,\n//         middleToken,\n//         outputToken,\n//         minimumAmountOutFirstHop\n//       );\n//       let minimumAMountOutSecondHop = expectedFinalAmountOut\n//         .times(new Big(1).minus(new Big(slippageTolerance).div(100)))\n//         .round()\n//         .toString();\n//       let action2 = {\n//         pool_id: pool2Id,\n//         token_in: middleToken,\n//         token_out: outputToken,\n//         amount_in: minimumAmountOutFirstHop,\n//         min_amount_out: minimumAMountOutSecondHop,\n//       };\n//       actions.push(action1);\n//       actions.push(action2);\n//     }\n//   }\n//   return actions;\n// }\n\nfunction* range(start, end) {\n  for (; start <= end; ++start) {\n    yield start;\n  }\n}\n\nfunction last(arr) {\n  return arr[arr.length - 1];\n}\n\nfunction* numericCombinations(n, r, loc = []) {\n  var idx = loc.length;\n  if (idx === r) {\n    yield loc;\n    return;\n  }\n  for (let next of range(idx ? last(loc) + 1 : 0, n - r + idx)) {\n    yield* numericCombinations(n, r, loc.concat(next));\n  }\n}\n\nfunction* combinations(arr, r) {\n  for (let idxs of numericCombinations(arr.length, r)) {\n    yield idxs.map(i => arr[i]);\n  }\n}\n\n//     #middleTokenTotals = getMiddleTokenTotals(routes,nodeRoutes,allocations)\n//     #TODO: complete this function with middle token checks.\n\n//     #consider all routes of length 2 with non-zero allocation. (double-hops)\n//     # among these, check for parallel swaps. That is, check for common node routes\n//     # for first hop. Then check for common node routes on second hop.\n//     # when common node routes occur for the first hop:\n//     # 1. Calculate the total expected output of intermediate token.\n//     # 2.\n//     # when common node routes occur for the second hop:\n//     # 1. get a ratio of the input allocations of the full routes associated with\n//     # these common node routes. allocate the total intermediate token output\n//     # toward these 2nd hop routes in the same ratio as their route input allocations.\n\nexport async function getSmartRouteSwapActions(\n  pools,\n  inputToken,\n  outputToken,\n  totalInput,\n  maxPathLength = 3,\n  threshold = 0.001,\n  numberOfRoutesLimit = 2,\n  MAX_NUMBER_PARALLEL_POOLS = 4,\n  decimalsCulledPoolIds = []\n) {\n  if (!totalInput) {\n    return [];\n  }\n  var totalInput = new Big(totalInput);\n\n  // remove pools that have an id from the decimalCulledPoolIds\n  pools = pools.filter(p => !decimalsCulledPoolIds.includes(p.id));\n\n  let resDict = await getBestOptimalAllocationsAndOutputs(\n    pools,\n    inputToken,\n    outputToken,\n    totalInput,\n    maxPathLength,\n    threshold\n  );\n\n  let allocations = resDict.allocations;\n\n  // let outputs = resDict.outputs;\n  let routes = resDict.routes;\n  let nodeRoutes = resDict.nodeRoutes;\n\n  let sortedIndexValues = argsort(allocations);\n  let topIndices = sortedIndexValues.slice(0, 10);\n  var reducedRoutes = [];\n  var reducedNodeRoutes = [];\n  for (var ind of topIndices) {\n    reducedRoutes.push(routes[ind]);\n    reducedNodeRoutes.push(nodeRoutes[ind]);\n  }\n  routes = reducedRoutes;\n  nodeRoutes = reducedNodeRoutes;\n\n  // TODO: compare pairs of routes to get the best allocation pair-wise.\n  var currentBestOutput = new Big(0);\n  var bestResDict = { routes: [] };\n  var bestAllocations = resDict.allocations;\n  var bestNodeRoutes = resDict.nodeRoutes;\n  var bestRoutes = resDict.routes;\n  // first check parallel swap with 4 actions. store result.\n  var parallelNodeRoutes = [];\n  var parallelRoutes = [];\n  for (var n in bestRoutes) {\n    let currentNodeRoute = bestNodeRoutes[n];\n    if (currentNodeRoute.length == 2) {\n      parallelNodeRoutes.push(currentNodeRoute);\n      parallelRoutes.push(bestRoutes[n]);\n    }\n  }\n  // console.log(`${parallelNodeRoutes.length} parallel routes found...`);\n  var bestRoutesAreParallel = false;\n  if (parallelNodeRoutes.length > 0) {\n    // first calculate the expected result using only parallel routes.\n    // let filteredAllocationsAndOutputs = getOptOutputVecRefined(parallelRoutes, parallelNodeRoutes, totalInput);\n    let filteredAllocationsAndOutputs = getOptOutputVec(\n      parallelRoutes,\n      parallelNodeRoutes,\n      totalInput\n    );\n    let parallellAllocations = filteredAllocationsAndOutputs.allocations;\n    let parallelOutputs = filteredAllocationsAndOutputs.result;\n\n    if (parallellAllocations.length > MAX_NUMBER_PARALLEL_POOLS) {\n      // now sort by allocation value to the top 4 parallel swaps:\n      let sortIndices = argsort(parallellAllocations);\n\n      sortIndices = sortIndices.slice(0, MAX_NUMBER_PARALLEL_POOLS);\n      var filteredParallelRoutes = [];\n      var filteredParallelNodeRoutes = [];\n      for (var i in sortIndices) {\n        filteredParallelRoutes.push(parallelRoutes[sortIndices[i]]);\n        filteredParallelNodeRoutes.push(parallelNodeRoutes[sortIndices[i]]);\n      }\n      filteredAllocationsAndOutputs = getOptOutputVec(\n        filteredParallelRoutes,\n        filteredParallelNodeRoutes,\n        totalInput\n      );\n      parallellAllocations = filteredAllocationsAndOutputs.allocations;\n      parallelOutputs = filteredAllocationsAndOutputs.result;\n    }\n\n    let parallelOutput = parallelOutputs.reduce(\n      (a, b) => a.plus(b),\n      new Big(0)\n    );\n    if (new Big(parallelOutput).gt(currentBestOutput)) {\n      bestAllocations = parallellAllocations;\n      currentBestOutput = parallelOutput;\n      // console.log(\n      //   'BEST OUTPUT FROM PARALLEL SWAPS IS NOW... ',\n      //   currentBestOutput.toString()\n      // );\n      bestRoutes = parallelRoutes;\n      bestNodeRoutes = parallelNodeRoutes;\n      bestRoutesAreParallel = true;\n    }\n  }\n  var canHaveTwoRoutes = false;\n  // initialize this variable to check if we can have two routes, or if all routes share a pool for an edge case.\n  // console.log('THE NUMBER OF ROUTES IS...', routes.length);\n\n  for (var i in routes) {\n    for (var j in routes) {\n      if (j > i) {\n        var route1 = routes[i];\n        var route2 = routes[j];\n        var nodeRoute1 = nodeRoutes[i];\n        var nodeRoute2 = nodeRoutes[j];\n        // check if they share a pool.\n        let route1PoolIds = new Set(route1.map(r => r.id));\n        let route2PoolIds = new Set(route2.map(r => r.id));\n        var sharePool = false;\n        for (var route1PoolId of route1PoolIds) {\n          if (route2PoolIds.has(route1PoolId)) {\n            sharePool = true;\n          }\n        }\n        if (sharePool) {\n          // routes are not independent. skip this pair.\n          // console.log('skipping this pair because pool was shared.');\n          continue;\n        } else {\n          canHaveTwoRoutes = true;\n          let currentRoutes = [route1, route2];\n          let currentNodeRoutes = [nodeRoute1, nodeRoute2];\n\n          let filteredAllocationsAndOutputs = getOptOutputVec(\n            currentRoutes,\n            currentNodeRoutes,\n            totalInput\n          );\n\n          let filteredAllocations = filteredAllocationsAndOutputs.allocations;\n          let filteredOutputs = filteredAllocationsAndOutputs.result;\n          // console.log('FILTERED ALLOCATIONS:');\n          // console.log(filteredAllocations.map((i) => i.toString()));\n          // console.log(filteredOutputs);\n          let totalOutput = filteredOutputs.reduce(\n            (a, b) => a.plus(b),\n            new Big(0)\n          );\n          if (new Big(totalOutput).gt(currentBestOutput)) {\n            bestAllocations = filteredAllocations;\n            currentBestOutput = totalOutput;\n            // console.log('BEST OUTPUT IS NOW... ', currentBestOutput.toString());\n            bestRoutes = currentRoutes;\n            bestNodeRoutes = currentNodeRoutes;\n            bestRoutesAreParallel = false;\n            // bestResDict = currentResDict\n          }\n\n          // if (currentResDict.outputs.gt(currentBestOutput)) {\n          // console.log('DIFF IS...', currentResDict.outputs.minus(currentBestOutput).toString());\n          // bestResDict = currentResDict;\n          // currentBestOutput = bestResDict.outputs;\n          // console.log('BEST OUTPUT IS NOW... ', currentBestOutput.toString());\n          // console.log(bestResDict.routes);\n          // console.log(bestResDict.allocations.map((i) => i.toString()));\n          // console.log(bestResDict.outputs.toString());\n        }\n      }\n    }\n  }\n\n  if (!canHaveTwoRoutes) {\n    // now we need to check through the routes in single manner to find the best one:\n    for (var i in routes) {\n      let currentRoutes = [routes[i]];\n      let currentNodeRoutes = [nodeRoutes[i]];\n      // let filteredAllocationsAndOutputs = getOptOutputVecRefined(currentRoutes, currentNodeRoutes, totalInput);\n      let filteredAllocationsAndOutputs = getOptOutputVec(\n        currentRoutes,\n        currentNodeRoutes,\n        totalInput\n      );\n\n      let filteredAllocations = filteredAllocationsAndOutputs.allocations;\n      let filteredOutputs = filteredAllocationsAndOutputs.result;\n      // console.log('FILTERED ALLOCATIONS:');\n      // console.log(filteredAllocations.map((i) => i.toString()));\n      // console.log(filteredOutputs);\n      let totalOutput = filteredOutputs.reduce((a, b) => a.plus(b), new Big(0));\n      if (new Big(totalOutput).gt(currentBestOutput)) {\n        bestAllocations = filteredAllocations;\n        currentBestOutput = totalOutput;\n        // console.log('BEST OUTPUT IS NOW... ', currentBestOutput.toString());\n        bestRoutes = currentRoutes;\n        bestNodeRoutes = currentNodeRoutes;\n        bestRoutesAreParallel = false;\n        // bestResDict = currentResDict\n      }\n    }\n  }\n\n  // resDict = bestResDict;\n\n  allocations = bestAllocations;\n\n  // let outputs = resDict.outputs;\n  routes = bestRoutes;\n  nodeRoutes = bestNodeRoutes;\n\n  if (routes.length < 1) {\n    return [];\n  }\n\n  // check the top numberOfRoutesLimit\n  // console.log('initial allocations are...');\n  // console.log(allocations.map((a) => a.toString()));\n  // console.log('fixed allocations are...');\n  // console.log(allocations.map((a) => new Big(a).toFixed()));\n  //SORT BY ALLOCATIONS\n  let allSortedIndices = argsort(allocations.map(a => new Big(a)));\n  if (bestRoutesAreParallel) {\n    numberOfRoutesLimit = 4;\n  }\n  let sortedIndices = allSortedIndices.slice(0, numberOfRoutesLimit);\n\n  // console.log('sorted Indices are');\n  // console.log(sortedIndices);\n  var filteredRoutes = [];\n  var filteredNodeRoutes = [];\n  for (var i in sortedIndices) {\n    let index = sortedIndices[i];\n    filteredRoutes.push(routes[index]);\n    filteredNodeRoutes.push(nodeRoutes[index]);\n  }\n\n  // console.log('filteredRoutes are ...');\n  // console.log(filteredRoutes);\n  for (var i in filteredRoutes) {\n    if (!filteredRoutes[i].length) {\n      filteredRoutes[i] = [filteredRoutes[i]];\n    }\n  }\n  // console.log('filtered Node routes are...');\n  // console.log(filteredNodeRoutes);\n\n  // THE BELOW CODE WILL ENSURE THAT ROUTES ARE INDEPENDENT (e.g. THE ROUTES WILL NOT SHARE A POOL)\n\n  let route1PoolIds = filteredRoutes[0].map(pool => pool.id);\n  // console.log('route 1 pool ids:');\n  // console.log(route1PoolIds);\n  if (filteredRoutes.length > 1) {\n    let route2PoolIds = filteredRoutes[1].map(pool => pool.id);\n    // console.log('route 2 pool ids:');\n    // console.log(route2PoolIds);\n    var sharedRoute = false;\n    for (var i in route2PoolIds) {\n      if (route1PoolIds.includes(route2PoolIds[i])) {\n        // a pool was shared between routes. need to calculate a new second route.\n        // console.log(\n        //   'a pool was shared between routes. going to calculate a new second route'\n        // );\n        sharedRoute = true;\n        break;\n      }\n    }\n  }\n\n  // NOTE -- this is a much simpler solution than that below. Instead of choosing the next best second route that doesn't share a\n  // pool with the first route, we could just use the first route and allocate all inputs to it.\n  // but, for larger transactions, it would be better to have option of two independent routes to spread out slippage.\n\n  // if (sharedRoute) {\n  //   filteredRoutes = [filteredRoutes[0]];\n  //   filteredNodeRoutes = [filteredNodeRoutes[0]];\n  //   // TODO -- later can add in a second route that doesn't share a pool with first.\n  // }\n\n  // We're going to find the next-highest allocation route that doesn't share a pool with the first route.\n  if (sharedRoute) {\n    let allFilteredRoutes = [];\n    let allFilteredNodeRoutes = [];\n    for (var i in allSortedIndices) {\n      allFilteredRoutes.push(routes[allSortedIndices[i]]);\n      allFilteredNodeRoutes.push(nodeRoutes[allSortedIndices[i]]);\n    }\n    let firstRoute = allFilteredRoutes[0];\n    // console.log('first route is...');\n    // console.log(firstRoute);\n    let firstRoutePoolIds = firstRoute.map(pool => pool.id);\n    for (var i in allFilteredRoutes) {\n      if (!allFilteredRoutes[i].length) {\n        allFilteredRoutes[i] = [allFilteredRoutes[i]];\n      }\n    }\n    // console.log('FIRST ROUTE POOL IDS ARE');\n    // console.log(firstRoutePoolIds);\n    let allFilteredRouteIds = allFilteredRoutes.map(route =>\n      route.map(pool => pool.id)\n    );\n    // console.log('allFilteredRouteIds are ...');\n    // console.log(allFilteredRouteIds);\n    for (var i in allFilteredRouteIds) {\n      // console.log('i is', i);\n      // console.log('ALL FILTERED ROUTES [i] IS...');\n      // console.log(allFilteredRouteIds[i]);\n      for (var j in allFilteredRouteIds[i]) {\n        // console.log('j is', j);\n        // console.log('ALL FILTERED ROUTES [i][j] IS...');\n        // console.log(allFilteredRouteIds[i][j]);\n        if (firstRoutePoolIds.includes(allFilteredRouteIds[i][j])) {\n          break;\n        }\n\n        var secondRoute = allFilteredRoutes[i];\n        if (!secondRoute.length) {\n          secondRoute = [secondRoute];\n        }\n        filteredRoutes = [allFilteredRoutes[0], secondRoute];\n        filteredNodeRoutes = [\n          allFilteredNodeRoutes[0],\n          allFilteredNodeRoutes[i],\n        ];\n        break;\n      }\n    }\n    // console.log('new filteredRoutes are ...');\n    // console.log(filteredRoutes);\n    // console.log('new filtered Node routes are...');\n    // console.log(filteredNodeRoutes);\n  }\n\n  // let filteredAllocations_check = getBestOptInput(\n  //   filteredRoutes,\n  //   filteredNodeRoutes,\n  //   totalInput\n  // );\n  // let filteredAllocationsAndOutputs = getOptOutputVecRefined(filteredRoutes, filteredNodeRoutes, totalInput);\n  let filteredAllocationsAndOutputs = getOptOutputVec(\n    filteredRoutes,\n    filteredNodeRoutes,\n    totalInput\n  );\n\n  let filteredAllocations = filteredAllocationsAndOutputs.allocations;\n  let filteredOutputs = filteredAllocationsAndOutputs.result;\n\n  filteredAllocations = checkIntegerSumOfAllocations(\n    filteredAllocations,\n    totalInput\n  ).map(stringAllo => new Big(stringAllo));\n\n  let hops = getActionListFromRoutesAndAllocations(\n    filteredRoutes,\n    filteredNodeRoutes,\n    filteredAllocations\n  );\n\n  var actions = [];\n  // console.log('hops are...');\n  // console.log(hops);\n\n  for (var i in hops) {\n    let hopInputTokenMeta = await ftGetTokenMetadata(hops[i].inputToken);\n    let hopOutputTokenMeta = await ftGetTokenMetadata(hops[i].outputToken);\n    let hopOutputTokenDecimals = hopOutputTokenMeta.decimals;\n\n    let expectedHopOutput = getOutputSingleHop(\n      hops[i].pool,\n      hops[i].inputToken,\n      hops[i].outputToken,\n      hops[i].allocation\n    );\n    let decimalEstimate = new Big(expectedHopOutput)\n      .div(new Big(10).pow(hopOutputTokenDecimals))\n      .toString();\n\n    // Need to check if expected Hop Output is > 1. If not, then cull the corresponding pool and re-calculate.\n    if (new Big(expectedHopOutput).lt(new Big(1))) {\n      // purge the pool and recalculate.\n\n      decimalsCulledPoolIds.push(hops[i].pool.id);\n      return getSmartRouteSwapActions(\n        pools,\n        inputToken,\n        outputToken,\n        totalInput,\n        (maxPathLength = maxPathLength),\n        (threshold = threshold),\n        (numberOfRoutesLimit = numberOfRoutesLimit),\n        (MAX_NUMBER_PARALLEL_POOLS = MAX_NUMBER_PARALLEL_POOLS),\n        (decimalsCulledPoolIds = decimalsCulledPoolIds)\n      );\n    }\n\n    if (\n      hops[i].inputToken == inputToken &&\n      hops[i].outputToken == outputToken\n    ) {\n      var status = 'parallel swap';\n    } else {\n      var status = 'stableSmart';\n    }\n\n    let tokens = await Promise.all(\n      hops[i].nodeRoute.map(async t => await ftGetTokenMetadata(t))\n    );\n\n    actions[i] = {\n      estimate: decimalEstimate,\n      pool: {\n        fee: hops[i].pool.fee,\n        gamma_bps: new Big(10000).minus(new Big(hops[i].pool.fee)), //.div(new Big(10000)), //hops[i].pool.gamma, //new Big(10000).minus(new Big(hops[i].pool.fee)).div(new Big(10000));\n        id: hops[i].pool.id,\n        partialAmountIn: new Big(hops[i].allocation).round().toString(),\n        supplies: {\n          [hops[i].pool.token1Id]: hops[i].pool.token1Supply,\n          [hops[i].pool.token2Id]: hops[i].pool.token2Supply,\n        },\n        token0_ref_price: hops[i].pool.token0_price,\n        tokenIds: [hops[i].pool.token1Id, hops[i].pool.token2Id],\n        Dex: hops[i].pool.Dex,\n      },\n      status: status,\n      token: hopInputTokenMeta,\n      outputToken: hops[i].outputToken,\n      inputToken: hops[i].inputToken,\n      nodeRoute: hops[i].nodeRoute,\n      route: hops[i].route,\n      allRoutes: hops[i].allRoutes,\n      allNodeRoutes: hops[i].allNodeRoutes,\n      totalInputAmount: hops[i].totalInputAmount,\n      allAllocations: hops[i].allAllocations,\n      tokens: tokens,\n      routeInputToken: inputToken,\n      routeOutputToken: outputToken,\n      overallPriceImpact: '0',\n    };\n    // console.log('INPUT TOKEN IS...');\n    // console.log(hops[i].inputToken);\n    actions[i].pool.x = actions[i].pool.supplies[hops[i].inputToken];\n    actions[i].pool.y = actions[i].pool.supplies[hops[i].outputToken];\n  }\n  // now set partial amount in for second hops equal to zero:\n  // also, set the total price impact value.\n  let overallPriceImpact = await calculateSmartRouteV2PriceImpact(actions);\n  for (var i in actions) {\n    let action = actions[i];\n    action.overallPriceImpact = overallPriceImpact;\n    if (action.outputToken === outputToken && action.inputToken != inputToken) {\n      // only want to set second hop partial amount in to zero\n      action.pool.partialAmountIn = '0';\n    }\n  }\n\n  return actions;\n}\n\nasync function calculateSmartRouteV2PriceImpact(actions) {\n  // the goal is to take a weighted average of the price impact per route, treating each one at a time.\n  // for single hop (parallel swaps), the price impact is calculated as before.\n  // for double-hop, the market price, P, is determined using reserves of tokens in each pool in the route.\n  // in both cases, we compare the 'market price', P , determined solely by reserves in pools, and the actual\n  // average price, R,  expected to be paid in the transaction.\n  // the price impact is then defined as (P-R)/R * 100 and is a percentage number, returned as a string.\n\n  let deltaY = actions\n    .filter(a => a.outputToken == a.routeOutputToken)\n    .map(a => new Big(a.estimate))\n    .reduce((a, b) => a.plus(b), new Big(0));\n  // console.log('DELTA Y IS...');\n  // console.log(deltaY.toString());\n\n  let inputTokenMeta = actions[0].tokens[0];\n  let deltaX = new Big(actions[0].totalInputAmount).div(\n    new Big(10).pow(inputTokenMeta.decimals)\n  );\n  let R = deltaY.div(deltaX);\n  var P = new Big(0);\n  let routes = actions[0].allRoutes;\n  let nodeRoutes = actions[0].allNodeRoutes;\n  let allocations = actions[0].allAllocations.map(a => new Big(a));\n  let totalAllocations = allocations\n    .map(a => new Big(a))\n    .reduce((a, b) => a.plus(b), new Big(0));\n\n  let weights = allocations.map(a => a.div(totalAllocations));\n\n  for (var i in routes) {\n    let route = routes[i];\n    let nodeRoute = nodeRoutes[i];\n    let tokens = await Promise.all(\n      nodeRoute.map(async t => await ftGetTokenMetadata(t))\n    );\n    let weight = weights[i];\n    if (route.length == 1) {\n      let num = new Big(route[0].reserves[nodeRoute[0]]).div(\n        new Big(10).pow(tokens[0].decimals)\n      );\n      let denom = new Big(route[0].reserves[nodeRoute[1]]).div(\n        new Big(10).pow(tokens[1].decimals)\n      );\n      var routeMarketPrice = num.div(denom);\n    } else {\n      let num1 = new Big(route[0].reserves[nodeRoute[0]]).div(\n        new Big(10).pow(tokens[0].decimals)\n      );\n\n      let denom1 = new Big(route[0].reserves[nodeRoute[1]]).div(\n        new Big(10).pow(tokens[1].decimals)\n      );\n\n      let num2 = new Big(route[1].reserves[nodeRoute[1]]).div(\n        new Big(10).pow(tokens[1].decimals)\n      );\n\n      let denom2 = new Big(route[1].reserves[nodeRoute[2]]).div(\n        new Big(10).pow(tokens[2].decimals)\n      );\n\n      var routeMarketPrice = num1\n        .div(denom1)\n        .times(num2)\n        .div(denom2);\n    }\n    P = P.plus(weight.times(new Big(1).div(routeMarketPrice)));\n  }\n\n  let priceImpact = P.minus(R)\n    .div(R)\n    .times(new Big(100))\n    .toString();\n  return priceImpact;\n}\n\nfunction decor(arr) {\n  var res = [];\n  for (var i in arr) {\n    res.push([arr[i], i]);\n  }\n  return res;\n}\nfunction argsort(arr) {\n  let undecor = a => a[1]; // leave only index\n  let decorated = decor(arr);\n\n  return decorated\n    .sort((a, b) => new Big(b[0]).minus(new Big(a[0])))\n    .map(undecor);\n}\n\nfunction getPoolsByToken1ORToken2(pools, token1, token2) {\n  let filteredPools = pools.filter(\n    item =>\n      item.token1Id === token1 ||\n      item.token2Id === token1 ||\n      item.token1Id === token2 ||\n      item.token2Id === token2\n  );\n  return filteredPools;\n}\n\nfunction getPoolsByToken1ANDToken2(\n  pools,\n  token1,\n  token2,\n  cullZeroLiquidityPools = true\n) {\n  let filteredPools = pools.filter(\n    item =>\n      (item.token1Id === token1 && item.token2Id === token2) ||\n      (item.token1Id === token2 && item.token2Id === token1)\n  );\n  if (cullZeroLiquidityPools) {\n    filteredPools = filteredPools.filter(\n      item => item.token1Supply != '0' && item.token2Supply != '0'\n    );\n  }\n  return filteredPools;\n}\n\nfunction getLiqudityOfPoolsFromList(pools) {\n  let liquidities = [];\n  for (var poolInd in pools) {\n    let pool = pools[poolInd];\n    pool.amounts = [pool.token1Supply, pool.token2Supply];\n    let poolBigAmounts = pool.amounts.map(item => new Big(item));\n    let liquidity = poolBigAmounts[0].times(poolBigAmounts[1]);\n    liquidities.push(liquidity);\n  }\n  return liquidities;\n}\n\nfunction getNormalizedLiquiditiesFromList(pools) {\n  let liquidities = getLiqudityOfPoolsFromList(pools);\n  let maxLiq = bigMax(liquidities);\n  let normalizedLiquidities = liquidities.map(item => item.div(maxLiq));\n  return normalizedLiquidities;\n}\n\nfunction bigMax(arrayOfBigs) {\n  if (arrayOfBigs.length < 1) {\n    return null;\n  }\n  let maxElem = arrayOfBigs[0];\n  for (var ind in arrayOfBigs) {\n    let val = arrayOfBigs[ind];\n    if (val.gt(maxElem)) {\n      maxElem = val;\n    }\n  }\n  return maxElem;\n}\n\nfunction cullPoolsWithInsufficientLiquidity(pools, threshold = 0.0001) {\n  var thresh = new Big(threshold);\n  let normLiq = getNormalizedLiquiditiesFromList(pools);\n  let filteredPools = [];\n  for (var i = 0; i < normLiq.length; i++) {\n    if (normLiq[i] > thresh) {\n      filteredPools.push(pools[i]);\n    }\n  }\n  return filteredPools;\n}\n\nfunction cartesianProduct(a) {\n  let result = a.reduce((a, b) => a.flatMap(d => b.map(e => [d, e].flat())));\n  return result;\n}\n\nfunction addEdge(g, edge) {\n  let src = edge[0];\n  let dst = edge[1];\n  if (Object.keys(g).includes(src)) {\n    if (!Object.keys(g[src]).includes(dst)) {\n      g[src][dst] = 1;\n    }\n  } else {\n    g[src] = {};\n    g[src][dst] = 1;\n  }\n  if (Object.keys(g).includes(dst)) {\n    if (!Object.keys(g[dst]).includes(src)) {\n      g[dst][src] = 1;\n    }\n  } else {\n    g[dst] = {};\n    g[dst][src] = 1;\n  }\n}\n\nfunction addEdges(g, edgeList) {\n  for (var n in edgeList) {\n    let edge = edgeList[n];\n    addEdge(g, edge);\n  }\n}\n\nfunction deleteEdge(g, edge) {\n  let gNew = JSON.parse(JSON.stringify(g)); // using this to deep clone graph structure\n  let e1 = edge[0];\n  let e2 = edge[1];\n  if (Object.keys(gNew).includes(e1)) {\n    if (Object.keys(gNew[e1]).includes(e2)) {\n      delete gNew[e1][e2];\n    }\n  }\n  if (Object.keys(gNew).includes(e2)) {\n    if (Object.keys(gNew[e2]).includes(e1)) {\n      delete gNew[e2][e1];\n    }\n  }\n  return gNew;\n}\n\nfunction deleteNode(g, node) {\n  let gNew = JSON.parse(JSON.stringify(g)); // using this to deep clone graph structure\n  if (Object.keys(gNew).includes(node)) {\n    delete gNew[node];\n  }\n  let keys = Object.keys(gNew);\n  for (var nodeInd in keys) {\n    let nodeNow = keys[nodeInd];\n    if (Object.keys(gNew[nodeNow]).includes(node)) {\n      delete gNew[nodeNow][node];\n    }\n  }\n  return gNew;\n}\n\nfunction dijkstra(graph, s) {\n  var solutions = {};\n  solutions[s] = {};\n  solutions[s].path = [];\n  solutions[s].dist = 0;\n\n  while (true) {\n    var parent = null;\n    var nearest = null;\n    var dist = Infinity;\n\n    //for each existing solution\n    for (var n in solutions) {\n      if (!solutions[n]) {\n        solutions[n] = {};\n      }\n      if (!solutions[n].path) continue;\n      var ndist = solutions[n].dist;\n      var adj = graph[n];\n      //for each of its adjacent nodes...\n      for (var a in adj) {\n        //without a solution already...\n        if (!solutions[a]) {\n          solutions[a] = {};\n        }\n        if (solutions[a].path) continue;\n        //choose nearest node with lowest *total* cost\n        var d = adj[a] + ndist;\n        if (d < dist) {\n          //reference parent\n          parent = solutions[n].path;\n          nearest = a;\n          dist = d;\n        }\n      }\n    }\n\n    //no more solutions\n    if (dist === Infinity) {\n      break;\n    }\n\n    //extend parent's solution path\n    solutions[nearest].path = parent.concat(nearest);\n    //extend parent's cost\n    solutions[nearest].dist = dist;\n  }\n\n  return solutions;\n}\n\nfunction shortestPath(g, src, dst, ignore_nodes = [], ignore_edges = []) {\n  let gTemp = JSON.parse(JSON.stringify(g)); // using this to deep clone graph structure. If we can use lodash, could use  _.cloneDeep(obj)\n  // remove nodes\n  for (var nodeInd in ignore_nodes) {\n    let nodeNow = ignore_nodes[nodeInd];\n    gTemp = deleteNode(gTemp, nodeNow);\n  }\n  // remove edges\n  for (var edgeInd in ignore_edges) {\n    let edgeNow = ignore_edges[edgeInd];\n    gTemp = deleteEdge(gTemp, edgeNow);\n  }\n  let solution = dijkstra(gTemp, src)[dst];\n  solution.path.unshift(src); // original algorithm doesn't include source node in path\n  return solution;\n}\n\nfunction* count(firstval = 0, step = 1) {\n  let x = firstval;\n  while (true) {\n    yield x;\n    x = x + 1;\n  }\n}\n\nclass PathBuffer {\n  constructor() {\n    this.paths = [];\n    this.sortedpaths = [];\n    //this.counter = count();\n  }\n  len() {\n    return this.sortedpaths.length;\n  }\n\n  push(cost, path) {\n    if (path && !arrayContains(this.paths, path)) {\n      this.sortedpaths.push([cost, path]);\n      this.sortedpaths.sort(function(a, b) {\n        return a[0] - b[0];\n      });\n      //heappush(this.sortedpaths, (cost, this.counter.next().value,path));\n      this.paths.push(path);\n    }\n  }\n\n  pop() {\n    //let val = heappop(this.sortedpaths);\n    let val = this.sortedpaths.shift();\n    let cost = val[0];\n    let path = val[1];\n    this.paths.splice(this.paths.indexOf(path), 1);\n    return path;\n  }\n}\n\nfunction arrayEquals(a, b) {\n  return (\n    Array.isArray(a) &&\n    Array.isArray(b) &&\n    a.length === b.length &&\n    a.every((val, index) => val === b[index])\n  );\n}\n\nfunction arrayContains(arr, obj) {\n  // checks to see if the input array contains a reference object, obj, using\n  // JSON.stringify() .\n  let obj_json = JSON.stringify(obj);\n  for (var itemInd in arr) {\n    if (JSON.stringify(arr[itemInd]) == obj_json) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction* yenFromPy(g, source, target) {\n  //adapted from the python implementation in networkx.algorithms.simple_paths.shortest_simple_paths()\n  let listA = [];\n  let listB = new PathBuffer();\n  let prev_path = null;\n\n  while (true) {\n    if (!prev_path) {\n      let sol = shortestPath(g, source, target);\n      let length = sol.dist;\n      let path = sol.path;\n      listB.push(length, path);\n    } else {\n      let ignore_nodes = [];\n      let ignore_edges = [];\n      for (var i = 1; i < prev_path.length; i++) {\n        let root = prev_path.slice(0, i);\n        let root_length = root.length;\n        for (var pathInd in listA) {\n          let path = listA[pathInd];\n\n          if (arrayEquals(path.slice(0, i), root)) {\n            let edgeToIgnore = [path[i - 1], path[i]];\n            ignore_edges.push(edgeToIgnore);\n          }\n        }\n        try {\n          let sol = shortestPath(\n            g,\n            root[root.length - 1],\n            target,\n            (ignore_nodes = ignore_nodes),\n            (ignore_edges = ignore_edges)\n          );\n          let length = sol.dist;\n          let spur = sol.path;\n          let path = root.slice(0, root.length - 1).concat(spur);\n          listB.push(root_length + length, path);\n        } catch (e) {\n          //console.log(`yenFromPy error was... ${e}`)\n          //dont do anything.\n        }\n        ignore_nodes.push(root[root.length - 1]);\n      }\n    }\n    if (listB.sortedpaths) {\n      try {\n        let path = listB.pop();\n        yield path;\n        listA.push(path);\n        prev_path = path;\n      } catch (e) {\n        break;\n      }\n    } else {\n      break;\n    }\n  }\n}\n\nfunction getKShortestPaths(g, source, target, k, maxPathLength = 3) {\n  let paths = [];\n  if (maxPathLength < 2) {\n    var maxPathLength = 2;\n  }\n  let gen = yenFromPy(g, source, target);\n  for (var n = 1; n <= k; n++) {\n    try {\n      let res = gen.next().value;\n      if (res && !arrayContains(paths, res)) {\n        if (res.length > maxPathLength) {\n          // console.log(\n          //   `found all hops of length ${\n          //     maxPathLength - 1\n          //   } or less... breaking out of generator`\n          // );\n          break;\n        }\n        paths.push(res);\n      }\n    } catch (e) {\n      break;\n    }\n  }\n  return paths;\n}\n\nasync function getPathsFromPools(\n  pools,\n  inputToken,\n  outputToken,\n  maxPathLength = 3\n) {\n  let graph = getGraphFromPoolList(pools);\n  return getKShortestPaths(graph, inputToken, outputToken, 100, maxPathLength);\n}\n\nasync function getAllPathsBelowLengthN(g, source, target, N, limit = 100) {\n  // use Yen's algorithm to find the paths of length N or below between source and target nodes in graph g.\n\n  let paths = [];\n\n  let gen = await yenFromPy(g, source, target);\n  let currentPathLength = 0;\n  let count = 1;\n  while (currentPathLength <= N) {\n    //   console.log(`CURRENT PATH LENGTH IS ${currentPathLength}`)\n    try {\n      let res = await gen.next().value;\n      //   console.log(`RES IS ${res}`)\n      if (res && !arrayContains(paths, res)) {\n        if (res.length > currentPathLength) {\n          currentPathLength = res.length;\n          if (currentPathLength > N) {\n            break;\n          }\n        }\n        paths.push(res);\n      }\n      count = count + 1;\n      if (count > limit) {\n        break;\n      }\n    } catch (e) {\n      //   console.log(e)\n      break;\n    }\n  }\n  return paths;\n}\n\nfunction getGraphFromPoolList(poolList) {\n  let pools = poolList.filter(\n    item => item.token1Supply != '0' && item.token2Supply != '0'\n  );\n  let transitions = pools.map(item => [item.token1Id, item.token2Id]);\n  let g = {};\n  addEdges(g, transitions);\n  return g;\n}\n\n////////////////////////////////////\n\n// MAIN FUNCTION\n\n////////////////////////////////////\n\n// TODO -- incorporate the following integrated function, which tries to\n// account for stablecoins within the context of smart routing.\n\n//TODO -- need the right API / hooks for GETSTABLESWAPACTION function and GETPARALLELSWAPACTIONS functions.\n\n//TODO -- transform the actions generated in this function into tranaction to execute.\n\n//TRYING: GETSTABLESWAPACTION <==> instantSwapGetTransactions\n\nexport async function stableSmart(\n  pools,\n  inputToken,\n  outputToken,\n  totalInput,\n  slippageTolerance\n) {\n  let smartRouteActions = await getSmartRouteSwapActions(\n    pools,\n    inputToken,\n    outputToken,\n    totalInput,\n    slippageTolerance\n  );\n  return smartRouteActions;\n}\n\nexport function getExpectedOutputFromActionsORIG(actions, outputToken) {\n  return actions\n    .filter(item => item.outputToken === outputToken)\n    .map(item => new Big(item.estimate))\n    .reduce((a, b) => a.plus(b), new Big(0));\n}\n\nfunction getFeeForRoute(route) {\n  if (!route.length) {\n    route = [route];\n  }\n  if (route.length == 1) {\n    // Single Hop case\n    let p = route[0];\n    return p.fee;\n  } else if (route.length == 2) {\n    //Double Hop Case\n    let p1 = route[0];\n    let p2 = route[1];\n    let fee1 = p1.fee;\n    let fee2 = p2.fee;\n    return fee1 + fee2;\n  }\n}\n\nexport function getAverageFeeForRoutes(routes, nodeRoutes, totalInput) {\n  let normalizedAllocations = getOptimalAllocationForRoutes(\n    routes,\n    nodeRoutes,\n    totalInput\n  ).map(a => a.div(new Big(totalInput)));\n  let averageFee = 0;\n  for (var i in routes) {\n    averageFee += normalizedAllocations[i] * getFeeForRoute(routes[i]);\n  }\n  return averageFee;\n}\n","import { TokenMetadata, Pool, StablePool, EstimateSwapView } from './types';\nimport {\n  toReadableNumber,\n  toNonDivisibleNumber,\n  scientificNotationToString,\n} from './utils';\nimport Big from 'big.js';\nimport { SameInputTokenError, ZeroInputError, NoPoolError } from './error';\nimport { ONLY_ZEROS, toPrecision } from './utils';\nimport _ from 'lodash';\nimport { FEE_DIVISOR } from './constant';\nimport { getSwappedAmount } from './stable-swap';\nimport { ftGetTokenMetadata, ftGetTokensMetadata } from './ref';\nimport { isStablePool } from './utils';\nimport {\n  getStablePoolDecimal,\n  isStablePoolToken,\n  poolFormatter,\n} from './utils';\nimport {\n  stableSmart,\n  getExpectedOutputFromActionsORIG,\n  //@ts-ignore\n} from './smartRoutingLogic.js';\n\nexport interface SwapParams {\n  tokenIn: TokenMetadata;\n  tokenOut: TokenMetadata;\n  amountIn: string;\n  simplePools: Pool[];\n  options?: SwapOptions;\n}\n\nexport interface SwapOptions {\n  enableSmartRouting?: boolean;\n  stablePools?: Pool[];\n  stablePoolsDetail?: StablePool[];\n}\n\nexport const getSimplePoolEstimate = ({\n  tokenIn,\n  tokenOut,\n  pool,\n  amountIn,\n}: {\n  tokenIn: TokenMetadata;\n  tokenOut: TokenMetadata;\n  pool: Pool;\n  amountIn: string;\n}) => {\n  const amount_with_fee = Number(amountIn) * (FEE_DIVISOR - pool.fee);\n  const in_balance = toReadableNumber(\n    tokenIn.decimals,\n    pool.supplies[tokenIn.id]\n  );\n  const out_balance = toReadableNumber(\n    tokenOut.decimals,\n    pool.supplies[tokenOut.id]\n  );\n  const estimate = new Big(\n    (\n      (amount_with_fee * Number(out_balance)) /\n      (FEE_DIVISOR * Number(in_balance) + amount_with_fee)\n    ).toString()\n  ).toFixed();\n\n  return {\n    estimate,\n    pool,\n    outputToken: tokenOut.id,\n    inputToken: tokenIn.id,\n  };\n};\n\nexport const getStablePoolEstimate = ({\n  tokenIn,\n  tokenOut,\n  amountIn,\n  stablePool,\n}: {\n  tokenIn: TokenMetadata;\n  tokenOut: TokenMetadata;\n  amountIn: string;\n  stablePool: StablePool;\n}) => {\n  const STABLE_LP_TOKEN_DECIMALS = getStablePoolDecimal(stablePool);\n\n  const [amount_swapped, _, dy] = getSwappedAmount(\n    tokenIn.id,\n    tokenOut.id,\n    amountIn,\n    stablePool,\n    STABLE_LP_TOKEN_DECIMALS\n  );\n\n  const amountOut =\n    amount_swapped < 0 || isNaN(amount_swapped)\n      ? '0'\n      : toPrecision(scientificNotationToString(amount_swapped.toString()), 0);\n\n  const dyOut =\n    amount_swapped < 0 || isNaN(amount_swapped) || isNaN(dy)\n      ? '0'\n      : toPrecision(scientificNotationToString(dy.toString()), 0);\n\n  return {\n    estimate: toReadableNumber(STABLE_LP_TOKEN_DECIMALS, amountOut),\n    noFeeAmountOut: toReadableNumber(STABLE_LP_TOKEN_DECIMALS, dyOut),\n    pool: stablePool,\n    outputToken: tokenOut.id,\n    inputToken: tokenIn.id,\n  };\n};\n\n/**\n * @description Get the estimate of the amount of tokenOut that can be received\n *\n */\nexport const singlePoolSwap = ({\n  tokenIn,\n  tokenOut,\n  simplePools,\n  amountIn,\n  stablePools,\n}: {\n  tokenIn: TokenMetadata;\n  tokenOut: TokenMetadata;\n  simplePools: Pool[];\n  amountIn: string;\n  stablePools?: StablePool[];\n}) => {\n  if (!simplePools || simplePools.length === 0) {\n    throw NoPoolError;\n  }\n\n  // const pools = simplePools.concat(stablePools);\n\n  const simplePoolsThisPair = simplePools.filter(\n    p => p.tokenIds.includes(tokenIn.id) && p.tokenIds.includes(tokenOut.id)\n  );\n\n  const estimatesSimplePool = simplePoolsThisPair.map(pool =>\n    getSimplePoolEstimate({\n      tokenIn,\n      tokenOut,\n      pool,\n      amountIn,\n    })\n  );\n\n  const stablePoolThisPair = stablePools?.filter(\n    sp =>\n      sp.token_account_ids.includes(tokenIn.id) &&\n      sp.token_account_ids.includes(tokenOut.id)\n  );\n\n  // different stable lp token decimal for different type of pools\n  const estimatesStablePool = stablePoolThisPair?.map(stablePool =>\n    getStablePoolEstimate({\n      tokenIn,\n      tokenOut,\n      amountIn,\n      stablePool,\n    })\n  );\n\n  const maxSimplePoolEstimate =\n    estimatesSimplePool === undefined || estimatesSimplePool.length === 0\n      ? undefined\n      : estimatesSimplePool.length === 1\n      ? estimatesSimplePool[0]\n      : _.maxBy(estimatesSimplePool, estimate => Number(estimate.estimate));\n\n  const maxStablePoolEstimate =\n    estimatesStablePool === undefined || estimatesStablePool.length === 0\n      ? undefined\n      : estimatesStablePool.length === 1\n      ? estimatesStablePool[0]\n      : _.maxBy(estimatesStablePool, estimate => Number(estimate.estimate));\n\n  if (!maxStablePoolEstimate && !maxSimplePoolEstimate) throw NoPoolError;\n\n  if (!maxStablePoolEstimate) {\n    return maxSimplePoolEstimate;\n  } else if (!maxSimplePoolEstimate) return maxStablePoolEstimate;\n  else {\n    return Number(maxSimplePoolEstimate?.estimate) >\n      Number(maxStablePoolEstimate?.estimate)\n      ? maxSimplePoolEstimate\n      : maxStablePoolEstimate;\n  }\n};\n\nexport const getStablePoolsThisPair = ({\n  tokenInId,\n  tokenOutId,\n  stablePools,\n}: {\n  tokenInId: string;\n  tokenOutId: string;\n  stablePools: Pool[];\n}) => {\n  return stablePools.filter(\n    p =>\n      p.tokenIds.includes(tokenInId) &&\n      p.tokenIds.includes(tokenOutId) &&\n      tokenInId !== tokenOutId\n  );\n};\n\nexport const getPoolsByTokens = ({\n  pools,\n  tokenInId,\n  tokenOutId,\n}: {\n  pools: Pool[];\n  tokenInId: string;\n  tokenOutId: string;\n}) => {\n  if (tokenInId === tokenOutId) return [];\n\n  return pools.filter(\n    p => p.tokenIds.includes(tokenInId) && p.tokenIds.includes(tokenOutId)\n  );\n};\n\nexport const getPoolEstimate = async ({\n  tokenIn,\n  tokenOut,\n  amountIn,\n  stablePoolDetail,\n  pool,\n}: {\n  tokenIn: TokenMetadata;\n  tokenOut: TokenMetadata;\n  amountIn: string;\n  pool: Pool;\n  stablePoolDetail?: StablePool;\n}) => {\n  if (!!stablePoolDetail) {\n    return getStablePoolEstimate({\n      tokenIn,\n      tokenOut,\n      stablePool: stablePoolDetail,\n      amountIn,\n    });\n  } else {\n    return getSimplePoolEstimate({\n      tokenIn,\n      tokenOut,\n      pool,\n      amountIn,\n    });\n  }\n};\n\nexport async function getHybridStableSmart(\n  tokenIn: TokenMetadata,\n  tokenOut: TokenMetadata,\n  amountIn: string,\n  stablePools: Pool[],\n  stablePoolsDetail: StablePool[],\n  simplePools: Pool[]\n) {\n  if (\n    !isStablePoolToken(stablePoolsDetail, tokenIn.id) &&\n    !isStablePoolToken(stablePoolsDetail, tokenOut.id)\n  ) {\n    return { actions: [], estimate: '0' };\n  }\n\n  const stablePoolsDetailById = stablePoolsDetail.reduce((acc, cur) => {\n    return {\n      ...acc,\n      [cur.id]: cur,\n    };\n  }, {} as Record<string, StablePool>);\n\n  const parsedAmountIn = toNonDivisibleNumber(tokenIn.decimals, amountIn);\n\n  let pool1: Pool, pool2: Pool;\n\n  let pools1: Pool[] = [];\n  let pools2: Pool[] = [];\n\n  let pools1Right: Pool[] = [];\n  let pools2Right: Pool[] = [];\n\n  let candidatePools: Pool[][] = [];\n\n  /**\n   * find possible routes for this pair\n   *\n   *\n   */\n\n  if (isStablePoolToken(stablePoolsDetail, tokenIn.id)) {\n    // first hop will be through stable pool.\n    pools1 = stablePools.filter(pool => pool.tokenIds.includes(tokenIn.id));\n\n    const otherStables = pools1\n      .map(pool => pool.tokenIds.filter(id => id !== tokenIn.id))\n      .flat();\n\n    for (var otherStable of otherStables) {\n      let stablePoolsThisPair = getStablePoolsThisPair({\n        tokenInId: otherStable,\n        tokenOutId: tokenOut.id,\n        stablePools,\n      });\n\n      let tmpPools = getPoolsByTokens({\n        tokenInId: otherStable,\n        tokenOutId: tokenOut.id,\n        pools: simplePools,\n      });\n      const tobeAddedPools = tmpPools.concat(stablePoolsThisPair);\n      pools2.push(\n        ...tobeAddedPools.filter(p => {\n          const supplies = Object.values(p.supplies);\n          return new Big(supplies[0]).times(new Big(supplies[1])).gt(0);\n        })\n      );\n    }\n  }\n\n  if (isStablePoolToken(stablePoolsDetail, tokenOut.id)) {\n    // second hop will be through stable pool.\n    pools2Right = stablePools.filter(pool =>\n      pool.tokenIds.includes(tokenOut.id)\n    );\n\n    const otherStables = pools2Right\n      .map(pool => pool.tokenIds.filter(id => id !== tokenOut.id))\n      .flat();\n    for (let otherStable of otherStables) {\n      let stablePoolsThisPair = getStablePoolsThisPair({\n        tokenInId: tokenIn.id,\n        tokenOutId: otherStable,\n        stablePools,\n      });\n\n      let tmpPools = getPoolsByTokens({\n        tokenInId: tokenIn.id,\n        tokenOutId: otherStable,\n        pools: simplePools,\n      });\n\n      const tobeAddedPools = tmpPools.concat(stablePoolsThisPair);\n\n      pools1Right.push(\n        ...tobeAddedPools.filter(p => {\n          const supplies = Object.values(p.supplies);\n          return new Big(supplies[0]).times(new Big(supplies[1])).gt(0);\n        })\n      );\n    }\n  }\n\n  // find candidate pools\n\n  for (let p1 of pools1) {\n    let middleTokens = p1.tokenIds.filter((id: string) => id !== tokenIn.id);\n    for (let middleToken of middleTokens) {\n      let p2s = pools2.filter(\n        p =>\n          p.tokenIds.includes(middleToken) &&\n          p.tokenIds.includes(tokenOut.id) &&\n          middleToken !== tokenOut.id\n      );\n      let p2 = _.maxBy(p2s, p =>\n        Number(\n          new Big(toReadableNumber(tokenOut.decimals, p.supplies[tokenOut.id]))\n        )\n      );\n\n      if (middleToken === tokenOut.id) {\n        p2 = p1;\n      }\n\n      if (p1 && p2) {\n        if (p1.id === p2.id) candidatePools.push([p1]);\n        else candidatePools.push([p1, p2]);\n      }\n    }\n  }\n  for (let p1 of pools1Right) {\n    let middleTokens = p1.tokenIds.filter((id: string) => id !== tokenIn.id);\n    for (let middleToken of middleTokens) {\n      let p2s = pools2Right.filter(\n        p =>\n          p.tokenIds.includes(middleToken) &&\n          p.tokenIds.includes(tokenOut.id) &&\n          middleToken !== tokenOut.id\n      );\n      let p2 = _.maxBy(p2s, p =>\n        Number(\n          new Big(toReadableNumber(tokenOut.decimals, p.supplies[tokenOut.id]))\n        )\n      );\n\n      if (middleToken === tokenOut.id) {\n        p2 = p1;\n      }\n\n      if (p1 && p2) {\n        if (p1.id === p2.id) candidatePools.push([p1]);\n        else candidatePools.push([p1, p2]);\n      }\n    }\n  }\n\n  if (candidatePools.length > 0) {\n    const tokensMedata = await ftGetTokensMetadata(\n      candidatePools.map(cp => cp.map(p => p.tokenIds).flat()).flat()\n    );\n\n    const BestPoolPair =\n      candidatePools.length === 1\n        ? candidatePools[0]\n        : _.maxBy(candidatePools, poolPair => {\n            // only one pool case, only for stable tokens\n            if (poolPair.length === 1) {\n              if (isStablePool(stablePoolsDetail, poolPair[0].id)) {\n                const stablePoolThisPair = getStablePoolsThisPair({\n                  tokenInId: tokenIn.id,\n                  tokenOutId: tokenOut.id,\n                  stablePools,\n                })[0];\n\n                const stablePoolDetailThisPair = stablePoolsDetail.find(\n                  spd => spd.id === stablePoolThisPair.id\n                );\n\n                return Number(\n                  getStablePoolEstimate({\n                    tokenIn,\n                    tokenOut,\n                    stablePool: stablePoolDetailThisPair as StablePool,\n                    amountIn,\n                  }).estimate\n                );\n              } else {\n                return Number(\n                  getSimplePoolEstimate({\n                    tokenIn,\n                    tokenOut,\n                    amountIn,\n                    pool: poolPair[0],\n                  }).estimate\n                );\n              }\n            }\n\n            const [tmpPool1, tmpPool2] = poolPair;\n            const tokenMidId = poolPair[0].tokenIds.find((t: string) =>\n              poolPair[1].tokenIds.includes(t)\n            ) as string;\n\n            const tokenMidMeta = tokensMedata[tokenMidId];\n\n            const estimate1 = {\n              ...(isStablePool(stablePoolsDetail, tmpPool1.id)\n                ? getStablePoolEstimate({\n                    tokenIn,\n                    tokenOut: tokenMidMeta,\n                    amountIn,\n                    stablePool: stablePoolsDetailById[tmpPool1.id],\n                  })\n                : getSimplePoolEstimate({\n                    tokenIn,\n                    tokenOut: tokenMidMeta,\n                    amountIn,\n                    pool: tmpPool1,\n                  })),\n            };\n\n            const estimate2 = {\n              ...(isStablePool(stablePoolsDetail, tmpPool2.id)\n                ? getStablePoolEstimate({\n                    tokenIn: tokenMidMeta,\n                    tokenOut,\n                    amountIn: estimate1.estimate,\n                    stablePool: stablePoolsDetailById[tmpPool2.id],\n                  })\n                : getSimplePoolEstimate({\n                    tokenIn: tokenMidMeta,\n                    tokenOut,\n                    pool: tmpPool2,\n                    amountIn: estimate1.estimate,\n                  })),\n            };\n\n            return Number(estimate2.estimate);\n          });\n\n    // one pool case only get best price\n\n    if (!BestPoolPair) return { actions: [], estimate: '0' };\n\n    if (BestPoolPair.length === 1) {\n      const bestPool = BestPoolPair[0];\n      const estimate = await getPoolEstimate({\n        tokenIn,\n        tokenOut,\n        amountIn,\n        pool: bestPool,\n        stablePoolDetail: stablePoolsDetailById[bestPool.id],\n      });\n\n      return {\n        actions: [\n          {\n            ...estimate,\n            pool: { ...bestPool, parsedAmountIn: parsedAmountIn },\n            tokens: [tokenIn, tokenOut],\n            inputToken: tokenIn.id,\n            outputToken: tokenOut.id,\n            totalInputAmount: toNonDivisibleNumber(tokenIn.decimals, amountIn),\n          },\n        ],\n        estimate: estimate.estimate,\n      };\n    }\n\n    // two pool case get best price\n    [pool1, pool2] = BestPoolPair;\n\n    const tokenMidId = BestPoolPair[0].tokenIds.find((t: string) =>\n      BestPoolPair[1].tokenIds.includes(t)\n    ) as string;\n\n    const tokenMidMeta = await ftGetTokenMetadata(tokenMidId);\n\n    const estimate1 = {\n      ...(isStablePool(stablePoolsDetail, pool1.id)\n        ? getStablePoolEstimate({\n            tokenIn,\n            tokenOut: tokenMidMeta,\n            amountIn,\n            stablePool: stablePoolsDetailById[pool1.id],\n          })\n        : getSimplePoolEstimate({\n            tokenIn,\n            tokenOut: tokenMidMeta,\n            amountIn,\n            pool: pool1,\n          })),\n      tokens: [tokenIn, tokenMidMeta, tokenOut],\n      inputToken: tokenIn.id,\n      outputToken: tokenMidMeta.id,\n    };\n\n    estimate1.pool.partialAmountIn = parsedAmountIn;\n\n    const estimate2 = {\n      ...(isStablePool(stablePoolsDetail, pool2.id)\n        ? getStablePoolEstimate({\n            tokenIn: tokenMidMeta,\n            tokenOut,\n            amountIn: estimate1.estimate,\n            stablePool: stablePoolsDetailById[pool2.id],\n          })\n        : getSimplePoolEstimate({\n            tokenIn: tokenMidMeta,\n            tokenOut,\n            amountIn: estimate1.estimate,\n            pool: pool2,\n          })),\n\n      tokens: [tokenIn, tokenMidMeta, tokenOut],\n      inputToken: tokenMidMeta.id,\n      outputToken: tokenOut.id,\n    };\n\n    return { actions: [estimate1, estimate2], estimate: estimate2.estimate };\n  }\n\n  return { actions: [], estimate: '0' };\n}\n\n// simple pools and stable pools for this pair\nexport const estimateSwap = async ({\n  tokenIn,\n  tokenOut,\n  amountIn,\n  simplePools,\n  options,\n}: SwapParams) => {\n  if (tokenIn.id === tokenOut.id) throw SameInputTokenError;\n\n  if (ONLY_ZEROS.test(amountIn)) throw ZeroInputError;\n\n  const { enableSmartRouting, stablePools, stablePoolsDetail } = options || {};\n\n  const parsedAmountIn = toNonDivisibleNumber(tokenIn.decimals, amountIn);\n\n  if (!enableSmartRouting) {\n    const estimate = singlePoolSwap({\n      tokenIn,\n      tokenOut,\n      simplePools,\n      amountIn,\n      stablePools: stablePoolsDetail,\n    });\n\n    console.log(estimate, 'estimate');\n\n    return [\n      {\n        ...estimate,\n        pool: { ...estimate?.pool, partialAmountIn: parsedAmountIn },\n      },\n    ] as EstimateSwapView[];\n  } else {\n    const inputPools = simplePools.map(p => poolFormatter(p));\n\n    const simplePoolSmartRoutingActions = await stableSmart(\n      inputPools,\n      tokenIn.id,\n      tokenOut.id,\n      parsedAmountIn\n    );\n\n    const simplePoolSmartRoutingEstimate = getExpectedOutputFromActionsORIG(\n      simplePoolSmartRoutingActions,\n      tokenOut.id\n    ).toString();\n\n    const hybridSmartRoutingRes = await getHybridStableSmart(\n      tokenIn,\n      tokenOut,\n      amountIn,\n      stablePools || [],\n      stablePoolsDetail || [],\n      simplePools\n    );\n\n    const hybridSmartRoutingEstimate = hybridSmartRoutingRes.estimate.toString();\n\n    if (\n      new Big(simplePoolSmartRoutingEstimate || '0').gte(\n        hybridSmartRoutingEstimate || '0'\n      )\n    ) {\n      if (!simplePoolSmartRoutingActions?.length) throw NoPoolError;\n      return simplePoolSmartRoutingActions as EstimateSwapView[];\n    } else {\n      return hybridSmartRoutingRes.actions as EstimateSwapView[];\n    }\n  }\n};\n"],"names":["getConfig","env","process","NEAR_ENV","networkId","nodeUrl","walletUrl","WRAP_NEAR_CONTRACT_ID","REF_FI_CONTRACT_ID","config","formatError","msg","Error","unNamedError","SameInputTokenError","ZeroInputError","NoPoolError","NotLoginError","SwapRouteError","TokenNotExistError","NoPuiblicKeyError","NoLocalSignerError","InValidAccessKeyError","AccountIdMisMatch","NoCredential","parsePool","pool","id","Number","tokenIds","token_account_ids","supplies","amounts","reduce","acc","amount","i","fee","total_fee","shareSupply","shares_total_supply","tvl","token0_ref_price","pool_kind","poolFormatter","token1Id","token2Id","token1Supply","token2Supply","shares","token0_price","isStablePoolToken","stablePools","tokenId","map","p","flat","includes","toString","isStablePool","poolId","getStablePoolDecimal","stablePool","round","decimals","minAmountOut","isInteger","Math","ceil","pow","convertToPercentDecimal","percent","math","percentOf","num","percentLess","notation","getGas","gas","BN","ONLY_ZEROS","toReadableNumber","number","substring","length","padStart","replace","toNonDivisibleNumber","split","padEnd","slice","scientificNotationToString","strParam","test","sysbol","negative","index","match","_strParam$match","basis","_strParam$match2","wholeStr","fractionStr","ifFraction","formatWithCommas","value","pattern","toPrecision","precision","withCommas","atLeastOne","whole","decimal","str","n","lastIndexOf","transformTransactions","transactions","AccountId","t","signerId","receiverId","actions","functionCalls","fc","type","params","methodName","args","toNumber","toFixed","deposit","utils","format","parseNearAmount","getKeyStore","window","keyStores","InMemoryKeyStore","BrowserLocalStorageKeyStore","provider","providers","JsonRpcProvider","url","getMemorySigner","keyPath","_context","homedir","os","credentials","JSON","parse","fs","readFileSync","credentialAccountId","account_id","myKeyStore","setKey","KeyPair","fromString","private_key","signer","InMemorySigner","validateAccessKey","transaction","accessKey","permission","FunctionCall","method_names","receiver_id","every","action","parseFloat","getSignedTransactionsByMemoryKey","transactionsRef","_context2","block","finality","signedTransactions","getPublicKey","publicKey","query","request_type","public_key","tx","nearTransactions","createTransaction","PublicKey","from","nonce","functionCall","serialize","base_decode","header","hash","signTransaction","push","sendTransactionsByMemoryKey","_context3","results","sendTransaction","near","Near","keyStore","headers","refFiViewFunction","account","viewFunction","ftViewFunction","ftGetStorageBalance","getTotalPools","ftGetTokenMetadata","_context4","ftGetTokensMetadata","_context5","Promise","all","pre","cur","instantSwap","tokenIn","tokenOut","amountIn","slippageTolerance","swapTodos","at","outputToken","registerToken","token","registration_only","actionsList","allSwapsTokens","s","inputToken","swapTokens","pool_id","token_in","token_out","amount_in","partialAmountIn","min_amount_out","estimate","stringify","force","getRatedPoolDetail","then","pool_info","getUnRatedPoolDetail","rates","c_amounts","_","getStablePools","getRefPools","page","perPage","from_index","limit","rawPool","fetchAllPools","pages","Array","fill","pools","simplePools","filter","unRatedPools","ratedPools","calc_d","amp","token_num","sum_amounts","sum","d_prev","d","d_prod","ann","abs","calc_y","x_c_amount","current_c_amounts","index_x","index_y","c","b","y_prev","y","calc_swap","in_token_idx","in_c_amount","out_token_idx","old_c_amounts","trade_fee","dy","tradeFee","getSwappedAmount","tokenInId","tokenOutId","STABLE_LP_TOKEN_DECIMALS","findIndex","r","Big","times","checkIntegerSumOfAllocations","allocations","totalInput","alloSum","item","a","plus","offset","minus","currMax","currMaxInd","gt","newAllocations","j","RM","DP","NE","PE","yenFromPy","bisqrt","BigInt","newtonIteration","x0","x1","getBetaForRoute","route","path","beta","reserves","p2","getEpsilonForRoute","gamma","div","epsilon","p1","gamma1","gamma2","getAlphaForRoute","key2","val2","alpha","key12","val12","key22","val22","middleToken","alpha1","alpha2","getAllocationForRoute","phi","getNodeRoutesFromPathsAndPoolChains","paths","poolChains","multiplicity","mul","elem1","elem2","nodeRoutes","m","k","getPoolChainFromPaths","threshold","pathInd","chain","pairs","pairInd","pair","tokenPools","getPoolsByToken1ANDToken2","newChains","newPath","legInd","culledPath","cullPoolsWithInsufficientLiquidity","getCulledPoolChains","getRoutesFromPoolChain","routes","pci","newRoutes","flatMap","e","getOutputSingleHop","denom","getOutputFromRoute","nodeRoute","allocation","eq","output","poolIndex","c1","a1","c2","b2","getOutputDoubleHop","getOptOutputVec","getOptimalAllocationForRoutes","allocationVec","getAllocationVectorForRoutes","alphaSum","radical","getAlphaSumFromRoutes","betaSum","getBetaSumFromRoutes","getPhiFromRoutes","lt","some","goodIndices","newNodeRoutes","goodIndex","allocationDict","allocationVecNew","zeroAllocation","reduceRoutes","sumAllocations","result","getBestOptInputAndOutput","rawDict","outputRaw","inputRaw","input","v","bv1","bv2","getBestOptimalAllocationsAndOutputs","maxPathLength","_context6","getPathsFromPools","outputs","inputOutput","getActionListFromRoutesAndAllocations","hops","hop","allRoutes","allNodeRoutes","totalInputAmount","allAllocations","middleTokenAllocation","getHopActionsFromRoutes","getSmartRouteSwapActions","numberOfRoutesLimit","MAX_NUMBER_PARALLEL_POOLS","decimalsCulledPoolIds","_context9","resDict","sortedIndexValues","argsort","topIndices","reducedRoutes","reducedNodeRoutes","ind","currentBestOutput","bestAllocations","bestNodeRoutes","parallelNodeRoutes","parallelRoutes","bestRoutes","currentNodeRoute","bestRoutesAreParallel","filteredAllocationsAndOutputs","parallelOutputs","parallellAllocations","sortIndices","filteredParallelRoutes","filteredParallelNodeRoutes","parallelOutput","canHaveTwoRoutes","route1","route2","nodeRoute1","nodeRoute2","route1PoolIds","Set","route2PoolIds","sharePool","has","currentRoutes","currentNodeRoutes","filteredAllocations","totalOutput","allSortedIndices","sortedIndices","filteredRoutes","filteredNodeRoutes","sharedRoute","allFilteredRoutes","allFilteredNodeRoutes","firstRoutePoolIds","allFilteredRouteIds","secondRoute","stringAllo","hopInputTokenMeta","hopOutputTokenDecimals","expectedHopOutput","decimalEstimate","status","_context8","tokens","gamma_bps","Dex","routeInputToken","routeOutputToken","overallPriceImpact","x","calculateSmartRouteV2PriceImpact","deltaY","inputTokenMeta","deltaX","R","P","totalAllocations","weights","_context12","_context11","weight","routeMarketPrice","num1","denom1","num2","denom2","priceImpact","arr","res","decor","sort","token1","token2","cullZeroLiquidityPools","filteredPools","thresh","normLiq","liquidities","poolInd","poolBigAmounts","liquidity","getLiqudityOfPoolsFromList","maxLiq","arrayOfBigs","maxElem","val","bigMax","getNormalizedLiquiditiesFromList","addEdge","g","edge","src","dst","Object","keys","deleteEdge","gNew","e1","e2","deleteNode","node","nodeInd","nodeNow","shortestPath","ignore_nodes","ignore_edges","gTemp","edgeInd","solution","graph","solutions","dist","parent","nearest","Infinity","ndist","adj","concat","dijkstra","unshift","PathBuffer","this","sortedpaths","len","cost","arrayContains","pop","shift","splice","indexOf","arrayEquals","isArray","obj","obj_json","itemInd","source","target","listA","listB","prev_path","root","root_length","sol","spur","getKShortestPaths","gen","next","getGraphFromPoolList","poolList","edgeList","addEdges","stableSmart","_context15","getExpectedOutputFromActionsORIG","getSimplePoolEstimate","amount_with_fee","in_balance","out_balance","getStablePoolEstimate","amount_swapped","amountOut","isNaN","dyOut","noFeeAmountOut","singlePoolSwap","estimatesSimplePool","stablePoolThisPair","sp","estimatesStablePool","maxSimplePoolEstimate","undefined","maxBy","maxStablePoolEstimate","getStablePoolsThisPair","getPoolsByTokens","getPoolEstimate","stablePoolDetail","getHybridStableSmart","stablePoolsDetail","stablePoolsDetailById","parsedAmountIn","pools1","pools2","pools1Right","pools2Right","candidatePools","otherStables","stablePoolsThisPair","otherStable","tmpPools","tobeAddedPools","values","middleTokens","_loop2","p2s","_loop","cp","tokensMedata","BestPoolPair","poolPair","stablePoolDetailThisPair","find","spd","tmpPool1","tmpPool2","tokenMidId","tokenMidMeta","estimate1","estimate2","bestPool","pool1","pool2","estimateSwap","options","enableSmartRouting","_ref10","console","log","inputPools","simplePoolSmartRoutingEstimate","simplePoolSmartRoutingActions","hybridSmartRoutingEstimate","hybridSmartRoutingRes","gte"],"mappings":"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"}