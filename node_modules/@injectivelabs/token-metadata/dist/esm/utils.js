import { INJ_DENOM } from '@injectivelabs/utils';
import { TokenType, } from './types';
import { ibcBaseDenoms } from './tokens/tokens';
import { getChannelIdFromPath } from './ibc';
const getCw20Meta = (token) => {
    const denomToLowerCase = token.denom;
    const cw20MetaFromCw20s = token.cw20s?.find((meta) => denomToLowerCase.includes(meta.address));
    return cw20MetaFromCw20s || token.cw20 || undefined;
};
export const getIbcTokenMetaFromDenomTrace = ({ hash, path, decimals, baseDenom, }) => ({
    hash,
    path,
    baseDenom,
    decimals,
    channelId: getChannelIdFromPath(path),
    isNative: !baseDenom.startsWith('ibc'),
});
export const getTokenTypeFromDenom = (denom) => {
    if (denom === INJ_DENOM) {
        return TokenType.Native;
    }
    if (denom.startsWith('inj')) {
        return TokenType.Cw20;
    }
    if (denom.startsWith('ibc')) {
        return TokenType.Ibc;
    }
    if (denom.startsWith('factory/')) {
        return TokenType.TokenFactory;
    }
    if (denom.startsWith('peggy')) {
        return TokenType.Erc20;
    }
    if (denom.startsWith('share')) {
        return TokenType.InsuranceFund;
    }
    return TokenType.Cw20;
};
export const getTokenSymbol = (token) => {
    if (token.denom.startsWith('factory/')) {
        const meta = getCw20Meta(token);
        return meta?.symbol || token.symbol;
    }
    if (token.denom.startsWith('peggy')) {
        return token.erc20?.symbol || token.symbol;
    }
    if (token.denom.startsWith('ibc')) {
        return token.ibc?.symbol || token.symbol;
    }
    return token.symbol;
};
export const getTokenDecimals = (token) => {
    if (token.denom === INJ_DENOM) {
        return token.decimals;
    }
    if (token.denom.startsWith('inj')) {
        return token.cw20?.decimals || token.decimals;
    }
    if (token.denom.startsWith('factory/')) {
        const meta = getCw20Meta(token);
        return meta?.decimals || token.decimals;
    }
    if (token.denom.startsWith('ibc')) {
        return token.ibc?.decimals || token.decimals;
    }
    if (token.denom.startsWith('peggy')) {
        return token.erc20?.decimals || token.decimals;
    }
    if (token.denom.startsWith('share')) {
        return token.decimals;
    }
    return token.decimals;
};
export const getTokenAddress = (token) => {
    if (token.denom === INJ_DENOM) {
        return token.erc20?.address;
    }
    if (token.denom.startsWith('inj')) {
        return token.cw20?.address;
    }
    if (token.denom.startsWith('factory/')) {
        const [, , address] = token.denom;
        return address;
    }
    if (token.denom.startsWith('peggy')) {
        return token.erc20?.address;
    }
    if (token.denom.startsWith('share')) {
        return '';
    }
    return '';
};
/**
 * This function can be used to get a token with
 * cw20 information when we have multiple
 * cw20 variations of the same token based on the address/denom
 */
export const getCw20TokenSingle = (token, source) => {
    const { cw20, cw20s } = token;
    const denom = token.denom || '';
    if (!cw20 && !cw20s) {
        return;
    }
    if (cw20) {
        return {
            ...token,
            cw20,
            denom: cw20.address,
            tokenType: getTokenTypeFromDenom(cw20.address),
        };
    }
    if (cw20s) {
        if (denom) {
            const [cw20Address] = denom.startsWith('inj')
                ? [denom]
                : denom.split('/').reverse();
            const cw20 = cw20s.find((cw20) => cw20.address === cw20Address);
            return cw20
                ? {
                    ...token,
                    cw20,
                    denom: cw20.address,
                    symbol: cw20.symbol,
                    tokenType: getTokenTypeFromDenom(cw20.address),
                }
                : undefined;
        }
        if (source) {
            const cw20 = cw20s.find((cw20) => cw20.source === source);
            return cw20
                ? {
                    ...token,
                    cw20,
                    denom: cw20.address,
                    symbol: cw20.symbol,
                    tokenType: getTokenTypeFromDenom(cw20.address),
                }
                : undefined;
        }
    }
    return undefined;
};
export const getTokenFromMeta = (meta, denom) => {
    const isBaseIbcDenom = ibcBaseDenoms.includes(denom || '') || meta.ibc?.baseDenom === denom;
    const tokenType = isBaseIbcDenom
        ? TokenType.Ibc
        : getTokenTypeFromDenom(denom || '');
    const token = {
        ...meta,
        tokenType,
        denom: denom || '',
    };
    const tokenWithDecimalsAndSymbol = {
        ...token,
        tokenType,
        decimals: getTokenDecimals(token),
        symbol: getTokenSymbol(token),
    };
    if (![TokenType.TokenFactory, TokenType.Cw20].includes(tokenType)) {
        return tokenWithDecimalsAndSymbol;
    }
    /**
     * If there are multiple cw20 variations
     * of the token we find the one that corresponds
     * to the contract address and set it on the cw20 field
     *
     * If there is only one cw20 version then we use that one
     * as the default version
     */
    if (tokenWithDecimalsAndSymbol.cw20) {
        return {
            ...tokenWithDecimalsAndSymbol,
            cw20s: [],
        };
    }
    if (tokenWithDecimalsAndSymbol.cw20s) {
        return {
            ...tokenWithDecimalsAndSymbol,
            ...getCw20TokenSingle({
                ...tokenWithDecimalsAndSymbol,
                denom,
                tokenType: TokenType.Cw20,
            }),
            tokenType,
            denom: tokenWithDecimalsAndSymbol.denom,
        };
    }
    return tokenWithDecimalsAndSymbol;
};
export const getUnknownToken = (denom) => {
    return {
        name: denom,
        symbol: denom,
        decimals: 18,
        logo: 'untracked.svg',
        coinGeckoId: '',
        tokenType: TokenType.Unknown,
    };
};
export const getUntrackedToken = (denom) => {
    return {
        denom,
        name: denom,
        symbol: 'UNTRACKED',
        decimals: 0,
        logo: 'untracked.svg',
        coinGeckoId: '',
        tokenType: TokenType.Unknown,
    };
};
//# sourceMappingURL=utils.js.map