import { AccountBalance, BaseToken, ClearingHouse, ClearingHouseConfig, CollateralManager, Exchange, IERC20Metadata, MarketRegistry, Multicall2, OrderBook, PerpPortal, Quoter, UniswapV3Pool, Vault, ChainlinkPriceFeed, LimitOrderBook, DelegateApproval, AggregatorV3Interface } from "./type";
import { Metadata } from "../metadata";
import { Signer, Contract, providers } from "ethers";
export declare enum ContractName {
    VAULT = "Vault",
    CLEARINGHOUSE = "ClearingHouse",
    ORDERBOOK = "OrderBook",
    CLEARINGHOUSE_CONFIG = "ClearingHouseConfig",
    COLLATERAL_MANAGER = "CollateralManager",
    SETTLEMENT_TOKEN = "SettlementToken",
    COLLATERAL_TOKENS = "CollateralTokens",
    BASE_TOKEN = "BaseToken",
    CHAINLINK_PRICE_FEED = "ChainlinkPriceFeed",
    POOL = "Pool",
    QUOTER = "Quoter",
    EXCHANGE = "Exchange",
    ACCOUNT_BALANCE = "AccountBalance",
    MARKET_REGISTRY = "MarketRegistry",
    MULTICALL2 = "Multicall2",
    PerpPortal = "PerpPortal",
    Token0 = "Token0",
    Token1 = "Token1",
    LimitOrderBook = "LimitOrderBook",
    DelegateApproval = "DelegateApproval"
}
interface ContractsConfig {
    provider: providers.Provider;
    metadata: Metadata;
}
export declare class Contracts {
    hasSigner: boolean;
    vault: Vault;
    clearingHouse: ClearingHouse;
    orderBook: OrderBook;
    collateralManager: CollateralManager;
    settlementToken: IERC20Metadata;
    collateralTokenMap: Map<string, {
        contract: IERC20Metadata;
        priceFeedContract: Contract;
    }>;
    baseToken: BaseToken;
    baseTokenPriceFeed: ChainlinkPriceFeed;
    baseTokenPriceFeedAggregator: AggregatorV3Interface;
    pool: UniswapV3Pool;
    quoter: Quoter;
    exchange: Exchange;
    clearingHouseConfig: ClearingHouseConfig;
    marketRegistry: MarketRegistry;
    accountBalance: AccountBalance;
    multicall2: Multicall2;
    perpPortal: PerpPortal;
    limitOrderBook: LimitOrderBook;
    delegateApproval: DelegateApproval;
    private readonly _provider;
    constructor({ metadata, provider }: ContractsConfig);
    connect(signer: Signer): void;
    createIERC20Token(tokenAddress: string): IERC20Metadata;
    private _setCollateralTokenMap;
}
export {};
