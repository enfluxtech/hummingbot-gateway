import e from"big.js";import"../../constants/envVariables.js";import{BIG_ZERO as t}from"../../constants/numbers.js";import{ContractName as i}from"../../contracts/Contracts.js";import{Channel as r}from"../../internal/Channel.js";import{ChannelEventSource as a}from"../../internal/ChannelEventSource.js";import{createMemoizedFetcher as s}from"../../internal/createMemoizedFetcher.js";import{DEFAULT_PERIOD as c}from"../../internal/config.js";import{fromSqrtX96 as n,bigNumber2BigAndScaleDown as o}from"../../utils/formatters.js";import"../../utils/tick.js";import{poll as d}from"../../utils/poll.js";import{logger as p}from"../../utils/logger.js";import"ethers";import"../../errors/errors.js";import{MulticallReader as l}from"../contractReader/MulticallReader.js";import{Liquidity as u}from"./Liquidity.js";class m extends r{constructor(e){super(e.channelRegistry),this._perp=e,this._cache=new Map,this._fetchAndEmitUpdated=s((()=>this._fetchUpdateData()),(()=>{this.emit("updated",this)}),((e,t)=>!e||!t||this._compareUpdatedData(e,t)))}_compareUpdatedData(e,t){const i=Object.values(e.totalPendingFees),r=Object.values(t.totalPendingFees),a=Object.values(e.openLiquiditiesFromMarkets),s=Object.values(t.openLiquiditiesFromMarkets);return!!a.some(((e,t)=>e.length!==s[t].length))||(a.some(((e,t)=>e.some(((e,i)=>!u.same(e,s[t][i])))))||i.some(((e,t)=>!r[t].eq(e))))}_getEventSourceMap(){const e=new a({eventSourceStarter:()=>{var e,t;return d(this._fetchAndEmitUpdated,(null===(t=null===(e=this._perp.moduleConfigs)||void 0===e?void 0:e.orders)||void 0===t?void 0:t.period)||c).cancel},initEventEmitter:()=>this._fetchAndEmitUpdated(!1,!0)}),t=this.getLiquidityDataAll.bind(this);return{updated:e,updatedLiquidityDataAll:new a({eventSourceStarter:()=>{var e,i;return d(t,(null===(i=null===(e=this._perp.moduleConfigs)||void 0===e?void 0:e.orders)||void 0===i?void 0:i.period)||c).cancel},initEventEmitter:()=>t()})}}async _fetchUpdateData(){try{const e=await Promise.all([this.getOpenLiquiditiesFromMarkets({cache:!1}),this.getTotalPendingFees({cache:!1})]);return{openLiquiditiesFromMarkets:e[0],totalPendingFees:e[1]}}catch(e){this.emit("updateError")}}async getTotalLiquidities({cache:e=!0}={}){const i=await this.getOpenLiquiditiesFromMarkets({cache:e}),r=Object.values(i),a=Object.keys(i),s={};for(let e=0;e<r.length;e++){const i=r[e],c=a[e],n=await Promise.all(i.map((e=>e.getLiquidityValue())));s[c]=n.reduce(((e,t)=>e.add(t)),t)}return s}async getTotalLiquidityByMarket(e,{cache:i=!0}={}){const r=await this.getOpenLiquiditiesByMarket(e,{cache:i});return(await Promise.all(r.map((e=>e.getLiquidityValue())))).reduce(((e,t)=>e.add(t)),t)}async getTotalPendingFees({cache:e=!0}={}){const t=await this._fetch("totalTokenAmountInPoolAndPendingFeeOfAllMarkets",{cache:e});return Object.values(this._perp.markets.marketMap).reduce(((e,i)=>(e[i.baseAddress]=t[i.baseAddress].totalPendingFee,e)),{})}async getTotalPendingFeeByMarket(e,{cache:t=!0}={}){const i=await this.getTotalPendingFees({cache:t});return null==i?void 0:i[e]}async getOpenLiquiditiesFromMarkets({cache:e=!0}={}){const t=await this._fetch("openLiquidities",{cache:e});return Object.values(this._perp.markets.marketMap).reduce(((e,i,r)=>(e[i.baseAddress]=t[r].map((({liquidity:e,baseDebt:t,quoteDebt:r,lowerTick:a,upperTick:s})=>new u({perp:this._perp,id:`${i.baseAddress}-${a}-${s}`,liquidity:e,upperTick:s,lowerTick:a,baseDebt:t,quoteDebt:r,market:i},this._perp.channelRegistry))),e)),{})}async getOpenLiquiditiesByMarket(e,{cache:t=!0}={}){const i=await this._fetch("openLiquidities",{cache:t}),r=Object.values(this._perp.markets.marketMap).findIndex((t=>t.baseAddress===e));return-1===r?[]:i[r].map((({liquidity:t,baseDebt:i,quoteDebt:r,lowerTick:a,upperTick:s})=>new u({perp:this._perp,id:`${e}-${a}-${s}`,liquidity:t,upperTick:s,lowerTick:a,baseDebt:i,quoteDebt:r,market:this._perp.markets.getMarket({baseAddress:e})},this._perp.channelRegistry)))}async _fetch(e,{cache:t=!0}={}){if(this._cache.has(e)&&t)return this._cache.get(e);const i=[this._perp.markets.marketMap,this._perp.wallet.account];let r;switch(e){case"openLiquidities":r=await this._perp.contractReader.getOpenLiquidities(...i);break;case"totalTokenAmountInPoolAndPendingFeeOfAllMarkets":r=await this._perp.contractReader.getTotalTokenAmountInPoolAndPendingFeeOfAllMarkets(...i)}return this._cache.set(e,r),r}async getLiquidityDataAll(){try{p("getLiquidityDataAll");const t=this._perp.wallet.account,r=this._perp.markets.marketMap,a=this._perp.contracts,s=new l({contract:this._perp.contracts.multicall2}),c={};Object.entries(r).forEach((([e,r])=>{const s=r.baseAddress,n=[{contract:a.orderBook,contractName:i.ORDERBOOK,funcName:"getTotalTokenAmountInPoolAndPendingFee",funcParams:[t,s,!1]},{contract:a.orderBook,contractName:i.ORDERBOOK,funcName:"getOpenOrderIds",funcParams:[t,s]},{contract:a.pool.attach(r.poolAddress),contractName:i.POOL,funcName:"slot0",funcParams:[]}];c[e]=n}));const d=await s.execute(Object.values(c).flat(),{failFirstByContract:!1,failFirstByClient:!1}),m={};Object.entries(c).forEach((([e,t])=>{const i=d.splice(0,t.length),[r,a]=i[0],s=i[1],c=n(i[2].sqrtPriceX96);m[e]={totalPendingFee:o(a),openOrderIds:s,markPrice:c}}));const h=[];Object.values(m).forEach((e=>{e.openOrderIds.forEach((e=>{h.push({contract:a.orderBook,contractName:i.ORDERBOOK,funcName:"getOpenOrderById",funcParams:[e]})}))}));const k=await s.execute(h,{failFirstByContract:!1,failFirstByClient:!1}),g={};Object.entries(m).forEach((([t,i])=>{const a=r[t],s=k.splice(0,i.openOrderIds.length),c=[];let n=e(0);s.forEach((({liquidity:t,baseDebt:r,quoteDebt:s,lowerTick:d,upperTick:p})=>{const l=new u({perp:this._perp,id:`${a.baseAddress}-${d}-${p}`,liquidity:new e(t),upperTick:p,lowerTick:d,baseDebt:o(r),quoteDebt:o(s),market:a},this._perp.channelRegistry),m=u.getRangeTypeByMarkPrice(i.markPrice,l.lowerTickPrice,l.upperTickPrice),{amountQuote:h,amountBase:k}=u.getLiquidityAmounts({markPrice:i.markPrice,lowerTickPrice:l.lowerTickPrice,upperTickPrice:l.upperTickPrice,liquidity:l.liquidity,rangeType:m}),g=k.mul(i.markPrice);n=n.add(g.add(h)),c.push(l)})),g[t]={...i,totalLiquidityValue:n,openLiquidities:c}})),this.emit("updatedLiquidityDataAll",g)}catch(e){this.emit("updateError",{error:e})}}}export{m as Liquidities};
//# sourceMappingURL=Liquidities.js.map
