import{backOff as e}from"exponential-backoff";import{RpcTimeoutError as t,RpcMaxRetryError as r,ArgumentError as i}from"../errors/errors.js";import{providers as n,errors as o}from"ethers";import"big.js";import{invariant as s}from"../utils/errorChecker.js";import"../constants/envVariables.js";import"../constants/numbers.js";import"../utils/tick.js";function a(e){var r,i,n,s,a;return e.code===o.SERVER_ERROR||e.code===o.TIMEOUT||(null===(r=e.message)||void 0===r?void 0:r.includes("header not found"))||(null===(i=e.message)||void 0===i?void 0:i.includes("429"))&&(null===(n=e.message)||void 0===n?void 0:n.includes("status code"))||(null===(a=null===(s=e.data)||void 0===s?void 0:s.message)||void 0===a?void 0:a.includes("your node is running with state pruning"))||e instanceof t}class d extends n.BaseProvider{constructor(e,t=1){s(e.length>=1,(()=>new i({functionName:"RetryProvider Constructor",key:"providers",value:"empty"})));super(e[0].getNetwork()),this._providerConnectionList=e.map((e=>d.getInitialProviderConnection(e))),this.retryLoopLimit=t}get providerConnectionList(){return this._userProviderConnection?[...this._providerConnectionList,this._userProviderConnection]:this._providerConnectionList}addUserProvider(e){this._userProviderConnection=d.getInitialProviderConnection(e)}removeUserProvider(){this._userProviderConnection=void 0}detectNetwork(){return this._networkPromise}async getBlockNumber(){return this._iterateProviders((e=>e.getBlockNumber()))}async getChainStatus(){return this._iterateProviders((async e=>{const[t,r]=await Promise.all([e.getBlockNumber(),e.send("eth_syncing",[])]);return{blockNumber:t,isSyncing:r}}))}async perform(e,t){if("sendTransaction"===e){return await this._handleSendTransaction(t)}return this._iterateProviders((async r=>r.perform(e,t)))}async _handleSendTransaction(e){const t=await Promise.any(this.providerConnectionList.map((({provider:t})=>t.sendTransaction(e.signedTransaction).then((e=>e.hash),(e=>e)))));for(let e=0;e<t.length;e++){const r=t[e];if("string"==typeof r)return r}throw t[0]}_getCandidateProviderConnection(e){const t=(new Date).valueOf(),r=e.find((({nextRetryTimestamp:e})=>e<=t));if(r)return r;return e.reduce(((e,t)=>e.nextRetryTimestamp<=t.nextRetryTimestamp?e:t))}_updateProviderStatus(e,t){if(t)e.nextRetryTimestamp=0;else{const t=(new Date).valueOf();e.nextRetryTimestamp=t+3e5}}async _providerTimeoutBenchmark(){return new Promise(((e,r)=>{setTimeout((()=>r(new t)),1e4)}))}async _iterateProviders(e){const t=[];let r=0;for(;;){if(r>=this.retryLoopLimit*this.providerConnectionList.length)return this._retryWithBackoff(e,t);r++;const i=this._getCandidateProviderConnection(this.providerConnectionList);try{const t=await Promise.race([e(i.provider),this._providerTimeoutBenchmark()]);return this._updateProviderStatus(i,!0),t}catch(e){if(!a(e))throw e;this._updateProviderStatus(i,!1),t.push(e)}}}async _retryWithBackoff(t,i){const n=this._getCandidateProviderConnection(this.providerConnectionList);try{return await e((()=>t(n.provider)),{numOfAttempts:6,startingDelay:1e3,timeMultiple:2,retry:(e,t)=>a(e)})}catch(e){throw new r({rawErrors:[...i,e]})}}static getInitialProviderConnection(e){return{provider:e,nextRetryTimestamp:0}}}export{d as RetryProvider};
//# sourceMappingURL=RetryProvider.js.map
