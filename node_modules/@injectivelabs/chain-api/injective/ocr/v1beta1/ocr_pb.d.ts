// package: injective.ocr.v1beta1
// file: injective/ocr/v1beta1/ocr.proto

import * as jspb from "google-protobuf";
import * as gogoproto_gogo_pb from "../../../gogoproto/gogo_pb";
import * as google_protobuf_timestamp_pb from "google-protobuf/google/protobuf/timestamp_pb";
import * as cosmos_base_v1beta1_coin_pb from "../../../cosmos/base/v1beta1/coin_pb";

export class Params extends jspb.Message {
  getLinkDenom(): string;
  setLinkDenom(value: string): void;

  getPayoutBlockInterval(): number;
  setPayoutBlockInterval(value: number): void;

  getModuleAdmin(): string;
  setModuleAdmin(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Params.AsObject;
  static toObject(includeInstance: boolean, msg: Params): Params.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Params, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Params;
  static deserializeBinaryFromReader(message: Params, reader: jspb.BinaryReader): Params;
}

export namespace Params {
  export type AsObject = {
    linkDenom: string,
    payoutBlockInterval: number,
    moduleAdmin: string,
  }
}

export class FeedConfig extends jspb.Message {
  clearSignersList(): void;
  getSignersList(): Array<string>;
  setSignersList(value: Array<string>): void;
  addSigners(value: string, index?: number): string;

  clearTransmittersList(): void;
  getTransmittersList(): Array<string>;
  setTransmittersList(value: Array<string>): void;
  addTransmitters(value: string, index?: number): string;

  getF(): number;
  setF(value: number): void;

  getOnchainConfig(): Uint8Array | string;
  getOnchainConfig_asU8(): Uint8Array;
  getOnchainConfig_asB64(): string;
  setOnchainConfig(value: Uint8Array | string): void;

  getOffchainConfigVersion(): number;
  setOffchainConfigVersion(value: number): void;

  getOffchainConfig(): Uint8Array | string;
  getOffchainConfig_asU8(): Uint8Array;
  getOffchainConfig_asB64(): string;
  setOffchainConfig(value: Uint8Array | string): void;

  hasModuleParams(): boolean;
  clearModuleParams(): void;
  getModuleParams(): ModuleParams | undefined;
  setModuleParams(value?: ModuleParams): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): FeedConfig.AsObject;
  static toObject(includeInstance: boolean, msg: FeedConfig): FeedConfig.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: FeedConfig, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): FeedConfig;
  static deserializeBinaryFromReader(message: FeedConfig, reader: jspb.BinaryReader): FeedConfig;
}

export namespace FeedConfig {
  export type AsObject = {
    signersList: Array<string>,
    transmittersList: Array<string>,
    f: number,
    onchainConfig: Uint8Array | string,
    offchainConfigVersion: number,
    offchainConfig: Uint8Array | string,
    moduleParams?: ModuleParams.AsObject,
  }
}

export class FeedConfigInfo extends jspb.Message {
  getLatestConfigDigest(): Uint8Array | string;
  getLatestConfigDigest_asU8(): Uint8Array;
  getLatestConfigDigest_asB64(): string;
  setLatestConfigDigest(value: Uint8Array | string): void;

  getF(): number;
  setF(value: number): void;

  getN(): number;
  setN(value: number): void;

  getConfigCount(): number;
  setConfigCount(value: number): void;

  getLatestConfigBlockNumber(): number;
  setLatestConfigBlockNumber(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): FeedConfigInfo.AsObject;
  static toObject(includeInstance: boolean, msg: FeedConfigInfo): FeedConfigInfo.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: FeedConfigInfo, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): FeedConfigInfo;
  static deserializeBinaryFromReader(message: FeedConfigInfo, reader: jspb.BinaryReader): FeedConfigInfo;
}

export namespace FeedConfigInfo {
  export type AsObject = {
    latestConfigDigest: Uint8Array | string,
    f: number,
    n: number,
    configCount: number,
    latestConfigBlockNumber: number,
  }
}

export class ModuleParams extends jspb.Message {
  getFeedId(): string;
  setFeedId(value: string): void;

  getMinAnswer(): string;
  setMinAnswer(value: string): void;

  getMaxAnswer(): string;
  setMaxAnswer(value: string): void;

  getLinkPerObservation(): string;
  setLinkPerObservation(value: string): void;

  getLinkPerTransmission(): string;
  setLinkPerTransmission(value: string): void;

  getLinkDenom(): string;
  setLinkDenom(value: string): void;

  getUniqueReports(): boolean;
  setUniqueReports(value: boolean): void;

  getDescription(): string;
  setDescription(value: string): void;

  getFeedAdmin(): string;
  setFeedAdmin(value: string): void;

  getBillingAdmin(): string;
  setBillingAdmin(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ModuleParams.AsObject;
  static toObject(includeInstance: boolean, msg: ModuleParams): ModuleParams.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ModuleParams, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ModuleParams;
  static deserializeBinaryFromReader(message: ModuleParams, reader: jspb.BinaryReader): ModuleParams;
}

export namespace ModuleParams {
  export type AsObject = {
    feedId: string,
    minAnswer: string,
    maxAnswer: string,
    linkPerObservation: string,
    linkPerTransmission: string,
    linkDenom: string,
    uniqueReports: boolean,
    description: string,
    feedAdmin: string,
    billingAdmin: string,
  }
}

export class ContractConfig extends jspb.Message {
  getConfigCount(): number;
  setConfigCount(value: number): void;

  clearSignersList(): void;
  getSignersList(): Array<string>;
  setSignersList(value: Array<string>): void;
  addSigners(value: string, index?: number): string;

  clearTransmittersList(): void;
  getTransmittersList(): Array<string>;
  setTransmittersList(value: Array<string>): void;
  addTransmitters(value: string, index?: number): string;

  getF(): number;
  setF(value: number): void;

  getOnchainConfig(): Uint8Array | string;
  getOnchainConfig_asU8(): Uint8Array;
  getOnchainConfig_asB64(): string;
  setOnchainConfig(value: Uint8Array | string): void;

  getOffchainConfigVersion(): number;
  setOffchainConfigVersion(value: number): void;

  getOffchainConfig(): Uint8Array | string;
  getOffchainConfig_asU8(): Uint8Array;
  getOffchainConfig_asB64(): string;
  setOffchainConfig(value: Uint8Array | string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ContractConfig.AsObject;
  static toObject(includeInstance: boolean, msg: ContractConfig): ContractConfig.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ContractConfig, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ContractConfig;
  static deserializeBinaryFromReader(message: ContractConfig, reader: jspb.BinaryReader): ContractConfig;
}

export namespace ContractConfig {
  export type AsObject = {
    configCount: number,
    signersList: Array<string>,
    transmittersList: Array<string>,
    f: number,
    onchainConfig: Uint8Array | string,
    offchainConfigVersion: number,
    offchainConfig: Uint8Array | string,
  }
}

export class SetConfigProposal extends jspb.Message {
  getTitle(): string;
  setTitle(value: string): void;

  getDescription(): string;
  setDescription(value: string): void;

  hasConfig(): boolean;
  clearConfig(): void;
  getConfig(): FeedConfig | undefined;
  setConfig(value?: FeedConfig): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): SetConfigProposal.AsObject;
  static toObject(includeInstance: boolean, msg: SetConfigProposal): SetConfigProposal.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: SetConfigProposal, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): SetConfigProposal;
  static deserializeBinaryFromReader(message: SetConfigProposal, reader: jspb.BinaryReader): SetConfigProposal;
}

export namespace SetConfigProposal {
  export type AsObject = {
    title: string,
    description: string,
    config?: FeedConfig.AsObject,
  }
}

export class FeedProperties extends jspb.Message {
  getFeedId(): string;
  setFeedId(value: string): void;

  getF(): number;
  setF(value: number): void;

  getOnchainConfig(): Uint8Array | string;
  getOnchainConfig_asU8(): Uint8Array;
  getOnchainConfig_asB64(): string;
  setOnchainConfig(value: Uint8Array | string): void;

  getOffchainConfigVersion(): number;
  setOffchainConfigVersion(value: number): void;

  getOffchainConfig(): Uint8Array | string;
  getOffchainConfig_asU8(): Uint8Array;
  getOffchainConfig_asB64(): string;
  setOffchainConfig(value: Uint8Array | string): void;

  getMinAnswer(): string;
  setMinAnswer(value: string): void;

  getMaxAnswer(): string;
  setMaxAnswer(value: string): void;

  getLinkPerObservation(): string;
  setLinkPerObservation(value: string): void;

  getLinkPerTransmission(): string;
  setLinkPerTransmission(value: string): void;

  getUniqueReports(): boolean;
  setUniqueReports(value: boolean): void;

  getDescription(): string;
  setDescription(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): FeedProperties.AsObject;
  static toObject(includeInstance: boolean, msg: FeedProperties): FeedProperties.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: FeedProperties, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): FeedProperties;
  static deserializeBinaryFromReader(message: FeedProperties, reader: jspb.BinaryReader): FeedProperties;
}

export namespace FeedProperties {
  export type AsObject = {
    feedId: string,
    f: number,
    onchainConfig: Uint8Array | string,
    offchainConfigVersion: number,
    offchainConfig: Uint8Array | string,
    minAnswer: string,
    maxAnswer: string,
    linkPerObservation: string,
    linkPerTransmission: string,
    uniqueReports: boolean,
    description: string,
  }
}

export class SetBatchConfigProposal extends jspb.Message {
  getTitle(): string;
  setTitle(value: string): void;

  getDescription(): string;
  setDescription(value: string): void;

  clearSignersList(): void;
  getSignersList(): Array<string>;
  setSignersList(value: Array<string>): void;
  addSigners(value: string, index?: number): string;

  clearTransmittersList(): void;
  getTransmittersList(): Array<string>;
  setTransmittersList(value: Array<string>): void;
  addTransmitters(value: string, index?: number): string;

  getLinkDenom(): string;
  setLinkDenom(value: string): void;

  clearFeedPropertiesList(): void;
  getFeedPropertiesList(): Array<FeedProperties>;
  setFeedPropertiesList(value: Array<FeedProperties>): void;
  addFeedProperties(value?: FeedProperties, index?: number): FeedProperties;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): SetBatchConfigProposal.AsObject;
  static toObject(includeInstance: boolean, msg: SetBatchConfigProposal): SetBatchConfigProposal.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: SetBatchConfigProposal, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): SetBatchConfigProposal;
  static deserializeBinaryFromReader(message: SetBatchConfigProposal, reader: jspb.BinaryReader): SetBatchConfigProposal;
}

export namespace SetBatchConfigProposal {
  export type AsObject = {
    title: string,
    description: string,
    signersList: Array<string>,
    transmittersList: Array<string>,
    linkDenom: string,
    feedPropertiesList: Array<FeedProperties.AsObject>,
  }
}

export class OracleObservationsCounts extends jspb.Message {
  clearCountsList(): void;
  getCountsList(): Array<number>;
  setCountsList(value: Array<number>): void;
  addCounts(value: number, index?: number): number;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): OracleObservationsCounts.AsObject;
  static toObject(includeInstance: boolean, msg: OracleObservationsCounts): OracleObservationsCounts.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: OracleObservationsCounts, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): OracleObservationsCounts;
  static deserializeBinaryFromReader(message: OracleObservationsCounts, reader: jspb.BinaryReader): OracleObservationsCounts;
}

export namespace OracleObservationsCounts {
  export type AsObject = {
    countsList: Array<number>,
  }
}

export class GasReimbursements extends jspb.Message {
  clearReimbursementsList(): void;
  getReimbursementsList(): Array<cosmos_base_v1beta1_coin_pb.Coin>;
  setReimbursementsList(value: Array<cosmos_base_v1beta1_coin_pb.Coin>): void;
  addReimbursements(value?: cosmos_base_v1beta1_coin_pb.Coin, index?: number): cosmos_base_v1beta1_coin_pb.Coin;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): GasReimbursements.AsObject;
  static toObject(includeInstance: boolean, msg: GasReimbursements): GasReimbursements.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: GasReimbursements, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): GasReimbursements;
  static deserializeBinaryFromReader(message: GasReimbursements, reader: jspb.BinaryReader): GasReimbursements;
}

export namespace GasReimbursements {
  export type AsObject = {
    reimbursementsList: Array<cosmos_base_v1beta1_coin_pb.Coin.AsObject>,
  }
}

export class Payee extends jspb.Message {
  getTransmitterAddr(): string;
  setTransmitterAddr(value: string): void;

  getPaymentAddr(): string;
  setPaymentAddr(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Payee.AsObject;
  static toObject(includeInstance: boolean, msg: Payee): Payee.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Payee, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Payee;
  static deserializeBinaryFromReader(message: Payee, reader: jspb.BinaryReader): Payee;
}

export namespace Payee {
  export type AsObject = {
    transmitterAddr: string,
    paymentAddr: string,
  }
}

export class Transmission extends jspb.Message {
  getAnswer(): string;
  setAnswer(value: string): void;

  getObservationsTimestamp(): number;
  setObservationsTimestamp(value: number): void;

  getTransmissionTimestamp(): number;
  setTransmissionTimestamp(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Transmission.AsObject;
  static toObject(includeInstance: boolean, msg: Transmission): Transmission.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Transmission, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Transmission;
  static deserializeBinaryFromReader(message: Transmission, reader: jspb.BinaryReader): Transmission;
}

export namespace Transmission {
  export type AsObject = {
    answer: string,
    observationsTimestamp: number,
    transmissionTimestamp: number,
  }
}

export class EpochAndRound extends jspb.Message {
  getEpoch(): number;
  setEpoch(value: number): void;

  getRound(): number;
  setRound(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EpochAndRound.AsObject;
  static toObject(includeInstance: boolean, msg: EpochAndRound): EpochAndRound.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EpochAndRound, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EpochAndRound;
  static deserializeBinaryFromReader(message: EpochAndRound, reader: jspb.BinaryReader): EpochAndRound;
}

export namespace EpochAndRound {
  export type AsObject = {
    epoch: number,
    round: number,
  }
}

export class Report extends jspb.Message {
  getObservationsTimestamp(): number;
  setObservationsTimestamp(value: number): void;

  getObservers(): Uint8Array | string;
  getObservers_asU8(): Uint8Array;
  getObservers_asB64(): string;
  setObservers(value: Uint8Array | string): void;

  clearObservationsList(): void;
  getObservationsList(): Array<string>;
  setObservationsList(value: Array<string>): void;
  addObservations(value: string, index?: number): string;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Report.AsObject;
  static toObject(includeInstance: boolean, msg: Report): Report.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Report, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Report;
  static deserializeBinaryFromReader(message: Report, reader: jspb.BinaryReader): Report;
}

export namespace Report {
  export type AsObject = {
    observationsTimestamp: number,
    observers: Uint8Array | string,
    observationsList: Array<string>,
  }
}

export class ReportToSign extends jspb.Message {
  getConfigDigest(): Uint8Array | string;
  getConfigDigest_asU8(): Uint8Array;
  getConfigDigest_asB64(): string;
  setConfigDigest(value: Uint8Array | string): void;

  getEpoch(): number;
  setEpoch(value: number): void;

  getRound(): number;
  setRound(value: number): void;

  getExtraHash(): Uint8Array | string;
  getExtraHash_asU8(): Uint8Array;
  getExtraHash_asB64(): string;
  setExtraHash(value: Uint8Array | string): void;

  getReport(): Uint8Array | string;
  getReport_asU8(): Uint8Array;
  getReport_asB64(): string;
  setReport(value: Uint8Array | string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ReportToSign.AsObject;
  static toObject(includeInstance: boolean, msg: ReportToSign): ReportToSign.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ReportToSign, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ReportToSign;
  static deserializeBinaryFromReader(message: ReportToSign, reader: jspb.BinaryReader): ReportToSign;
}

export namespace ReportToSign {
  export type AsObject = {
    configDigest: Uint8Array | string,
    epoch: number,
    round: number,
    extraHash: Uint8Array | string,
    report: Uint8Array | string,
  }
}

export class EventOraclePaid extends jspb.Message {
  getTransmitterAddr(): string;
  setTransmitterAddr(value: string): void;

  getPayeeAddr(): string;
  setPayeeAddr(value: string): void;

  hasAmount(): boolean;
  clearAmount(): void;
  getAmount(): cosmos_base_v1beta1_coin_pb.Coin | undefined;
  setAmount(value?: cosmos_base_v1beta1_coin_pb.Coin): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventOraclePaid.AsObject;
  static toObject(includeInstance: boolean, msg: EventOraclePaid): EventOraclePaid.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventOraclePaid, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventOraclePaid;
  static deserializeBinaryFromReader(message: EventOraclePaid, reader: jspb.BinaryReader): EventOraclePaid;
}

export namespace EventOraclePaid {
  export type AsObject = {
    transmitterAddr: string,
    payeeAddr: string,
    amount?: cosmos_base_v1beta1_coin_pb.Coin.AsObject,
  }
}

export class EventAnswerUpdated extends jspb.Message {
  getCurrent(): string;
  setCurrent(value: string): void;

  getRoundId(): string;
  setRoundId(value: string): void;

  hasUpdatedAt(): boolean;
  clearUpdatedAt(): void;
  getUpdatedAt(): google_protobuf_timestamp_pb.Timestamp | undefined;
  setUpdatedAt(value?: google_protobuf_timestamp_pb.Timestamp): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventAnswerUpdated.AsObject;
  static toObject(includeInstance: boolean, msg: EventAnswerUpdated): EventAnswerUpdated.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventAnswerUpdated, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventAnswerUpdated;
  static deserializeBinaryFromReader(message: EventAnswerUpdated, reader: jspb.BinaryReader): EventAnswerUpdated;
}

export namespace EventAnswerUpdated {
  export type AsObject = {
    current: string,
    roundId: string,
    updatedAt?: google_protobuf_timestamp_pb.Timestamp.AsObject,
  }
}

export class EventNewRound extends jspb.Message {
  getRoundId(): string;
  setRoundId(value: string): void;

  getStartedBy(): string;
  setStartedBy(value: string): void;

  hasStartedAt(): boolean;
  clearStartedAt(): void;
  getStartedAt(): google_protobuf_timestamp_pb.Timestamp | undefined;
  setStartedAt(value?: google_protobuf_timestamp_pb.Timestamp): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventNewRound.AsObject;
  static toObject(includeInstance: boolean, msg: EventNewRound): EventNewRound.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventNewRound, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventNewRound;
  static deserializeBinaryFromReader(message: EventNewRound, reader: jspb.BinaryReader): EventNewRound;
}

export namespace EventNewRound {
  export type AsObject = {
    roundId: string,
    startedBy: string,
    startedAt?: google_protobuf_timestamp_pb.Timestamp.AsObject,
  }
}

export class EventTransmitted extends jspb.Message {
  getConfigDigest(): Uint8Array | string;
  getConfigDigest_asU8(): Uint8Array;
  getConfigDigest_asB64(): string;
  setConfigDigest(value: Uint8Array | string): void;

  getEpoch(): number;
  setEpoch(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventTransmitted.AsObject;
  static toObject(includeInstance: boolean, msg: EventTransmitted): EventTransmitted.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventTransmitted, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventTransmitted;
  static deserializeBinaryFromReader(message: EventTransmitted, reader: jspb.BinaryReader): EventTransmitted;
}

export namespace EventTransmitted {
  export type AsObject = {
    configDigest: Uint8Array | string,
    epoch: number,
  }
}

export class EventNewTransmission extends jspb.Message {
  getFeedId(): string;
  setFeedId(value: string): void;

  getAggregatorRoundId(): number;
  setAggregatorRoundId(value: number): void;

  getAnswer(): string;
  setAnswer(value: string): void;

  getTransmitter(): string;
  setTransmitter(value: string): void;

  getObservationsTimestamp(): number;
  setObservationsTimestamp(value: number): void;

  clearObservationsList(): void;
  getObservationsList(): Array<string>;
  setObservationsList(value: Array<string>): void;
  addObservations(value: string, index?: number): string;

  getObservers(): Uint8Array | string;
  getObservers_asU8(): Uint8Array;
  getObservers_asB64(): string;
  setObservers(value: Uint8Array | string): void;

  getConfigDigest(): Uint8Array | string;
  getConfigDigest_asU8(): Uint8Array;
  getConfigDigest_asB64(): string;
  setConfigDigest(value: Uint8Array | string): void;

  hasEpochAndRound(): boolean;
  clearEpochAndRound(): void;
  getEpochAndRound(): EpochAndRound | undefined;
  setEpochAndRound(value?: EpochAndRound): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventNewTransmission.AsObject;
  static toObject(includeInstance: boolean, msg: EventNewTransmission): EventNewTransmission.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventNewTransmission, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventNewTransmission;
  static deserializeBinaryFromReader(message: EventNewTransmission, reader: jspb.BinaryReader): EventNewTransmission;
}

export namespace EventNewTransmission {
  export type AsObject = {
    feedId: string,
    aggregatorRoundId: number,
    answer: string,
    transmitter: string,
    observationsTimestamp: number,
    observationsList: Array<string>,
    observers: Uint8Array | string,
    configDigest: Uint8Array | string,
    epochAndRound?: EpochAndRound.AsObject,
  }
}

export class EventConfigSet extends jspb.Message {
  getConfigDigest(): Uint8Array | string;
  getConfigDigest_asU8(): Uint8Array;
  getConfigDigest_asB64(): string;
  setConfigDigest(value: Uint8Array | string): void;

  getPreviousConfigBlockNumber(): number;
  setPreviousConfigBlockNumber(value: number): void;

  hasConfig(): boolean;
  clearConfig(): void;
  getConfig(): FeedConfig | undefined;
  setConfig(value?: FeedConfig): void;

  hasConfigInfo(): boolean;
  clearConfigInfo(): void;
  getConfigInfo(): FeedConfigInfo | undefined;
  setConfigInfo(value?: FeedConfigInfo): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventConfigSet.AsObject;
  static toObject(includeInstance: boolean, msg: EventConfigSet): EventConfigSet.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventConfigSet, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventConfigSet;
  static deserializeBinaryFromReader(message: EventConfigSet, reader: jspb.BinaryReader): EventConfigSet;
}

export namespace EventConfigSet {
  export type AsObject = {
    configDigest: Uint8Array | string,
    previousConfigBlockNumber: number,
    config?: FeedConfig.AsObject,
    configInfo?: FeedConfigInfo.AsObject,
  }
}

