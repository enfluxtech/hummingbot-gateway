"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.removeColor = exports.compareBytecode = exports.shallowCopyStack = exports.parseMemory = exports.parseAddress = exports.parseUint = exports.parseNumber = exports.parseHex = exports.findNextStructLogInDepth = exports.getFromNameTags = exports.isOnlyLogs = exports.applyCliArgsToTracer = exports.addCliParams = exports.getTracerEnvFromUserInput = void 0;
const ethers_1 = require("ethers");
const utils_1 = require("ethers/lib/utils");
function getTracerEnvFromUserInput(userInput) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    return {
        enabled: (_a = userInput === null || userInput === void 0 ? void 0 : userInput.enabled) !== null && _a !== void 0 ? _a : false,
        logs: (_b = userInput === null || userInput === void 0 ? void 0 : userInput.logs) !== null && _b !== void 0 ? _b : false,
        calls: (_c = userInput === null || userInput === void 0 ? void 0 : userInput.calls) !== null && _c !== void 0 ? _c : false,
        sstores: (_d = userInput === null || userInput === void 0 ? void 0 : userInput.sstores) !== null && _d !== void 0 ? _d : false,
        sloads: (_e = userInput === null || userInput === void 0 ? void 0 : userInput.sloads) !== null && _e !== void 0 ? _e : false,
        gasCost: (_f = userInput === null || userInput === void 0 ? void 0 : userInput.gasCost) !== null && _f !== void 0 ? _f : false,
        opcodes: (_g = userInput === null || userInput === void 0 ? void 0 : userInput.opcodes) !== null && _g !== void 0 ? _g : [],
        nameTags: (_h = userInput === null || userInput === void 0 ? void 0 : userInput.nameTags) !== null && _h !== void 0 ? _h : {},
        _internal: {
            printNameTagTip: undefined,
        },
    };
}
exports.getTracerEnvFromUserInput = getTracerEnvFromUserInput;
function addCliParams(task) {
    return (task
        // params
        .addOptionalParam("opcodes", "specify more opcodes to print")
        // feature flags
        .addFlag("logs", "print logs emitted during transactions")
        .addFlag("calls", "print calls during transactions")
        .addFlag("sloads", "print SLOADs during calls")
        .addFlag("sstores", "print SSTOREs during transactions")
        .addFlag("gascost", "display gas cost")
        .addFlag("disabletracer", "do not enable tracer at the start (for inline enabling tracer)")
        // feature group flags
        .addFlag("trace", "trace logs and calls in transactions")
        .addFlag("fulltrace", "trace logs, calls and storage writes in transactions")
        // aliases
        .addFlag("tracefull", "alias for fulltrace")
        .addFlag("gas", "alias for gascost"));
}
exports.addCliParams = addCliParams;
function applyCliArgsToTracer(args, hre) {
    // populating aliases
    const fulltrace = args.fulltrace || args.tracefull;
    const gascost = args.gascost || args.gas;
    // if any flag is present, then enable tracer
    if (args.logs || args.trace || fulltrace || args.disabletracer === true) {
        hre.tracer.enabled = true;
    }
    // enabling config by flags passed
    if (args.logs) {
        hre.tracer.logs = true;
    }
    if (args.calls) {
        hre.tracer.calls = true;
    }
    if (args.sloads) {
        hre.tracer.sloads = true;
    }
    if (args.sstores) {
        hre.tracer.sstores = true;
    }
    if (args.opcodes) {
        hre.tracer.opcodes = [...args.opcodes.split(",")];
    }
    // enabling config by mode of operation
    if (args.trace) {
        hre.tracer.logs = true;
        hre.tracer.calls = true;
    }
    if (fulltrace) {
        hre.tracer.logs = true;
        hre.tracer.calls = true;
        hre.tracer.sloads = true;
        hre.tracer.sstores = true;
    }
    if (gascost) {
        hre.tracer.gasCost = true;
    }
}
exports.applyCliArgsToTracer = applyCliArgsToTracer;
function isOnlyLogs(env) {
    return env.logs && !env.calls && !env.sstores && !env.sloads && !env.gasCost;
}
exports.isOnlyLogs = isOnlyLogs;
function getFromNameTags(address, dependencies) {
    return (dependencies.nameTags[address] ||
        dependencies.nameTags[address.toLowerCase()] ||
        dependencies.nameTags[address.toUpperCase()] ||
        dependencies.nameTags[ethers_1.ethers.utils.getAddress(address)]);
}
exports.getFromNameTags = getFromNameTags;
function replaceIfExists(key, value, dependencies) {
    if (dependencies.nameTags[key] &&
        !dependencies.nameTags[key].split(" / ").includes(value)) {
        dependencies.nameTags[key] = `${value} / ${dependencies.nameTags[key]}`;
        return true;
    }
    else {
        return false;
    }
}
function findNextStructLogInDepth(structLogs, depth, startIndex) {
    for (let i = startIndex; i < structLogs.length; i++) {
        if (structLogs[i].depth === depth) {
            return [structLogs[i], structLogs[i + 1]];
        }
    }
    throw new Error("Could not find next StructLog in depth");
}
exports.findNextStructLogInDepth = findNextStructLogInDepth;
function parseHex(str) {
    return !str.startsWith("0x") ? "0x" + str : str;
}
exports.parseHex = parseHex;
function parseNumber(str) {
    return parseUint(str).toNumber();
}
exports.parseNumber = parseNumber;
function parseUint(str) {
    return ethers_1.BigNumber.from(parseHex(str));
}
exports.parseUint = parseUint;
function parseAddress(str) {
    return (0, utils_1.hexZeroPad)((0, utils_1.hexStripZeros)(parseHex(str)), 20);
}
exports.parseAddress = parseAddress;
function parseMemory(strArr) {
    return (0, utils_1.arrayify)(parseHex(strArr.join("")));
}
exports.parseMemory = parseMemory;
function shallowCopyStack(stack) {
    return [...stack];
}
exports.shallowCopyStack = shallowCopyStack;
function compareBytecode(artifactBytecode, contractBytecode) {
    if (artifactBytecode.length <= 2 || contractBytecode.length <= 2)
        return 0;
    if (typeof artifactBytecode === "string")
        artifactBytecode = artifactBytecode
            .replace(/\_\_\$/g, "000")
            .replace(/\$\_\_/g, "000");
    let matchedBytes = 0;
    for (let i = 0; i < artifactBytecode.length; i++) {
        if (artifactBytecode[i] === contractBytecode[i])
            matchedBytes++;
    }
    if (isNaN(matchedBytes / artifactBytecode.length))
        console.log(matchedBytes, artifactBytecode.length);
    return matchedBytes / artifactBytecode.length;
}
exports.compareBytecode = compareBytecode;
function removeColor(str) {
    return str.replace(/[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g, "");
}
exports.removeColor = removeColor;
//# sourceMappingURL=utils.js.map