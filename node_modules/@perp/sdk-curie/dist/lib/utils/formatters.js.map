{"version":3,"file":"formatters.js","sources":["../../../src/utils/formatters.ts"],"sourcesContent":["import { ERC20_DECIMAL_DIGITS, Q96 } from \"../constants\"\n\nimport Big from \"big.js\"\nimport { BigNumber } from \"ethers\"\n\nexport function bigNumber2Big(value: BigNumber): Big {\n    return new Big(value.toString())\n}\n\nexport function bigNumber2BigAndScaleDown(value: BigNumber, decimals: number = ERC20_DECIMAL_DIGITS): Big {\n    return scaleDownDecimals(bigNumber2Big(value), decimals)\n}\n\nexport function big2BigNumberAndScaleUp(value: Big, decimals: number = ERC20_DECIMAL_DIGITS): BigNumber {\n    return BigNumber.from(scaleUpDecimals(value, decimals).toFixed(0))\n}\n\nexport function fromSqrtX96(value: BigNumber) {\n    return bigNumber2Big(value).div(Q96).pow(2)\n}\n\nexport function toSqrtX96(value: Big) {\n    return value.sqrt().mul(Q96)\n}\n\nexport function encodePriceSqrt(amount1: Big, amount0: Big) {\n    return BigNumber.from(amount1.div(amount0).sqrt().mul(Q96).round().toString())\n}\n\nexport function scaleDownDecimals(number: Big, decimals: number) {\n    return number.div(new Big(10).pow(decimals))\n}\n\nexport function scaleUpDecimals(number: Big, decimals: number) {\n    return number.mul(new Big(10).pow(decimals))\n}\n\n/**\n * get how many decimals need to be shown.\n * @example getLeastSignificantDigit(new Big(123.123456)) -> 3 (123.123)\n * @example getLeastSignificantDigit(new Big(12345.12345)) -> 1 (12345.1)\n * @example getLeastSignificantDigit(new Big(12345)) -> 1 (12345.0)\n * @example getLeastSignificantDigit(new Big(0.12345678)) -> 6 (0.123456)\n * @example getLeastSignificantDigit(new Big(0.000012345678)) -> 10 (0.0000123456)\n * @param value the quote asset amount\n * @returns how many decimals need to be shown\n */\nexport function getLeastSignificantDigit(value: string | number | Big, displayLength = 6, minimal = 1): number {\n    const number = Number(value)\n    if (isNaN(number)) {\n        return minimal\n    }\n\n    const big = new Big(number || 0)\n    const fixed = big.toFixed()\n    const firstNonZeroMatched = fixed.match(/[1-9]/)\n    let dotIndex = fixed.indexOf(\".\")\n\n    if (dotIndex === -1) {\n        // the number is an integer, set the dotIndex to last char\n        dotIndex = fixed.length\n    }\n\n    if (!firstNonZeroMatched) {\n        return minimal\n    }\n\n    if (big.gt(1)) {\n        return Math.max(displayLength - dotIndex, minimal)\n    } else {\n        // -2 is for \"0.\" these two chars\n        return displayLength + (firstNonZeroMatched?.index ?? 0 - 2)\n    }\n}\n"],"names":["bigNumber2Big","value","Big","toString","scaleDownDecimals","number","decimals","div","pow","scaleUpDecimals","mul","ERC20_DECIMAL_DIGITS","BigNumber","from","toFixed","amount1","amount0","sqrt","Q96","round","displayLength","minimal","Number","isNaN","big","fixed","firstNonZeroMatched","match","dotIndex","indexOf","length","gt","Math","max","_a","index"],"mappings":"gRAKM,SAAUA,EAAcC,GAC1B,OAAO,IAAIC,EAAG,QAACD,EAAME,WACzB,CAsBgB,SAAAC,EAAkBC,EAAaC,GAC3C,OAAOD,EAAOE,IAAI,IAAIL,EAAG,QAAC,IAAIM,IAAIF,GACtC,CAEgB,SAAAG,EAAgBJ,EAAaC,GACzC,OAAOD,EAAOK,IAAI,IAAIR,EAAG,QAAC,IAAIM,IAAIF,GACtC,0CAtBwCL,EAAYK,EAAmBK,wBACnE,OAAOC,EAASA,UAACC,KAAKJ,EAAgBR,EAAOK,GAAUQ,QAAQ,GACnE,qEAN0Cb,EAAkBK,EAAmBK,wBAC3E,OAAOP,EAAkBJ,EAAcC,GAAQK,EACnD,0BAcgB,SAAgBS,EAAcC,GAC1C,OAAOJ,EAASA,UAACC,KAAKE,EAAQR,IAAIS,GAASC,OAAOP,IAAIQ,EAAAA,KAAKC,QAAQhB,WACvE,sBAVM,SAAsBF,GACxB,OAAOD,EAAcC,GAAOM,IAAIW,EAAAA,KAAKV,IAAI,EAC7C,mCA4BM,SAAmCP,EAA8BmB,EAAgB,EAAGC,EAAU,SAChG,MAAMhB,EAASiB,OAAOrB,GACtB,GAAIsB,MAAMlB,GACN,OAAOgB,EAGX,MAAMG,EAAM,IAAItB,EAAAA,QAAIG,GAAU,GACxBoB,EAAQD,EAAIV,UACZY,EAAsBD,EAAME,MAAM,SACxC,IAAIC,EAAWH,EAAMI,QAAQ,KAO7B,OALkB,IAAdD,IAEAA,EAAWH,EAAMK,QAGhBJ,EAIDF,EAAIO,GAAG,GACAC,KAAKC,IAAIb,EAAgBQ,EAAUP,GAGnCD,GAA+C,QAA9Bc,EAAAR,aAAmB,EAAnBA,EAAqBS,aAAS,IAAAD,EAAAA,GAAA,GAP/Cb,CASf,0EApDM,SAAoBpB,GACtB,OAAOA,EAAMgB,OAAOP,IAAIQ,EAAGA,IAC/B"}