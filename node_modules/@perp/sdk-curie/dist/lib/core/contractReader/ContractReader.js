"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("ethers");require("../../constants/envVariables.js");var t=require("../../constants/numbers.js"),r=require("../../contracts/Contracts.js"),a=require("../../errors/errors.js"),n=require("../../errors/extractErrorCode.js"),o=require("big.js"),c=require("../../utils/errorChecker.js"),s=require("../../utils/formatters.js");require("../../utils/tick.js");var i=require("../../utils/logger.js"),u=require("./MulticallReader.js"),l=require("./utils.js");function g(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var d=g(o);exports.ContractReader=class{constructor({contracts:e,provider:t,metadata:r}){this.contracts=e,this._provider=t,this._metadata=r,this._multicallReader=new u.MulticallReader({contract:e.multicall2})}async getNativeBalance(e){return c.errorGuardAsync((async()=>{i.logger("getNativeBalance");const t=await this._provider.getBalance(e);return s.bigNumber2BigAndScaleDown(t)}),(t=>new a.ContractReadError({contractName:"ethers",contractFunctionName:"getNativeBalance",args:{account:e},rawError:t})))}async getAccountValue(e){return c.errorGuardAsync((async()=>{i.logger("getAccountValue");const r=await this.contracts.vault.getAccountValue(e);return s.bigNumber2BigAndScaleDown(r,t.SETTLEMENT_TOKEN_DECIMAL)}),(t=>new a.ContractReadError({contractName:r.ContractName.VAULT,contractFunctionName:"getAccountValue",args:{account:e},rawError:t})))}async getFreeCollateral(e){return c.errorGuardAsync((async()=>{i.logger("getFreeCollateral");const r=await this.contracts.vault.getFreeCollateral(e);return s.bigNumber2BigAndScaleDown(r,t.COLLATERAL_TOKEN_DECIMAL)}),(t=>new a.ContractReadError({contractName:r.ContractName.VAULT,contractFunctionName:"getFreeCollateral",args:{account:e},rawError:t})))}async getFreeCollateralByToken(e,t){return c.errorGuardAsync((async()=>{i.logger("getFreeCollateralByToken::token::decimals"),i.logger("getFreeCollateralByToken::vault::GetFreeCollateralByToken");const r=t.address,a=await t.decimals(),n=await this.contracts.vault.getFreeCollateralByToken(e,r);return s.bigNumber2BigAndScaleDown(n,a)}),(n=>new a.ContractReadError({contractName:r.ContractName.VAULT,contractFunctionName:"getFreeCollateralByToken",args:{account:e,tokenAddress:t.address},rawError:n})))}async getVaultBalanceOfSettlementToken(e){return c.errorGuardAsync((async()=>{i.logger("getVaultBalanceOfSettlementToken");const r=await this.contracts.vault.getSettlementTokenValue(e);return s.bigNumber2BigAndScaleDown(r,t.SETTLEMENT_TOKEN_DECIMAL)}),(t=>new a.ContractReadError({contractName:r.ContractName.VAULT,contractFunctionName:"getSettlementTokenValue",args:{account:e},rawError:t})))}async getVaultBalanceByToken(e,t){return c.errorGuardAsync((async()=>{i.logger("getVaultBalanceByToken::token::decimals"),i.logger("getVaultBalanceByToken::vault::GetBalanceByToken");const r=t.address,a=await t.decimals(),n=await this.contracts.vault.getBalanceByToken(e,r);return s.bigNumber2BigAndScaleDown(n,a)}),(n=>new a.ContractReadError({contractName:r.ContractName.VAULT,contractFunctionName:"getBalanceByToken",args:{account:e,tokenAddress:t.address},rawError:n})))}async getCollateralConfig(e){return c.errorGuardAsync((async()=>{i.logger("getCollateralConfig::collateralManager::getCollateralConfig"),i.logger("getCollateralConfig::collateralToken::decimals");const r=this.contracts.collateralManager,a=await r.getCollateralConfig(e),n=a.priceFeed,o=a.collateralRatio,c=a.discountRatio,u=a.depositCap,l=this.contracts.collateralTokenMap.get(e),g=await(null==l?void 0:l.contract.decimals());return{priceFeed:n,collateralRatio:s.scaleDownDecimals(d.default(o),t.RATIO_DECIMAL).toNumber(),discountRatio:s.scaleDownDecimals(d.default(c),t.RATIO_DECIMAL).toNumber(),depositCap:s.bigNumber2BigAndScaleDown(u,g)}}),(t=>new a.ContractReadError({contractName:r.ContractName.COLLATERAL_MANAGER,contractFunctionName:"getCollateralConfig",args:{tokenAddress:e},rawError:t})))}async getAllowanceByToken(e,t,n){return c.errorGuardAsync((async()=>{var r;i.logger("getAllowanceByToken:token::allowance"),i.logger("getAllowanceByToken:token::decimals");const a=null===(r=this.contracts.collateralTokenMap.get(n))||void 0===r?void 0:r.contract;if(!a)throw new Error(`Collateral token ${n} not found`);const[o,c]=await Promise.all([a.allowance(e,t),a.decimals()]);return s.bigNumber2BigAndScaleDown(o,c)}),(o=>new a.ContractReadError({contractName:r.ContractName.COLLATERAL_TOKENS,contractFunctionName:"allowance",args:{account:e,spender:t,tokenAddress:n},rawError:o})))}async getAllowanceOfSettlementToken(e,n){return c.errorGuardAsync((async()=>{i.logger("getAllowanceOfSettlementToken");const r=this.contracts.settlementToken,a=await r.allowance(e,n);return s.bigNumber2BigAndScaleDown(a,t.SETTLEMENT_TOKEN_DECIMAL)}),(t=>new a.ContractReadError({contractName:r.ContractName.SETTLEMENT_TOKEN,contractFunctionName:"allowance",args:{account:e,spender:n},rawError:t})))}async getBalanceByToken(e,t,n){return c.errorGuardAsync((async()=>{var r;i.logger("getBalanceByToken");const a=null===(r=this.contracts.collateralTokenMap.get(t))||void 0===r?void 0:r.contract;if(!a)throw new Error(`Collateral token ${t} not found`);const o=await a.balanceOf(e);return s.bigNumber2BigAndScaleDown(o,n)}),(o=>new a.ContractReadError({contractName:r.ContractName.COLLATERAL_TOKENS,contractFunctionName:"balanceOf",args:{account:e,tokenAddress:t,decimals:n},rawError:o})))}async getBalanceOfSettlementToken(e){return c.errorGuardAsync((async()=>{i.logger("getBalanceOfSettlementToken");const r=this.contracts.settlementToken,a=await r.balanceOf(e);return s.bigNumber2BigAndScaleDown(a,t.SETTLEMENT_TOKEN_DECIMAL)}),(t=>new a.ContractReadError({contractName:r.ContractName.SETTLEMENT_TOKEN,contractFunctionName:"balanceOf",args:{account:e},rawError:t})))}async getPriceFeedAggregator(e){return c.errorGuardAsync((async()=>{i.logger("getPriceFeedAggregator::contractBaseToken::getPriceFeed"),i.logger("getPriceFeedAggregator::contractPriceFeed::getAggregator");const t=this.contracts.baseToken.attach(e),n=await t.getPriceFeed(),o=this.contracts.baseTokenPriceFeed.attach(n);return c.errorGuardAsync((async()=>{const e=await o.getAggregator();return{address:e,contract:this.contracts.baseTokenPriceFeedAggregator.attach(e)}}),(t=>new a.ContractReadError({contractName:r.ContractName.CHAINLINK_PRICE_FEED,contractFunctionName:"getAggregator",context:{baseTokenAddress:e},rawError:t})))}),(t=>new a.ContractReadError({contractName:r.ContractName.BASE_TOKEN,contractFunctionName:"getPriceFeed",context:{baseTokenAddress:e},rawError:t})))}async isMarketPaused(e){return c.errorGuardAsync((async()=>{i.logger("isMarketPaused");const t=this.contracts.baseToken.attach(e);return await t.isPaused()}),(t=>new a.ContractReadError({contractName:r.ContractName.BASE_TOKEN,contractFunctionName:"isPaused",context:{baseTokenAddress:e},rawError:t})))}async isMarketClosed(e){return c.errorGuardAsync((async()=>{i.logger("isMarketClosed");const t=this.contracts.baseToken.attach(e);return await t.isClosed()}),(t=>new a.ContractReadError({contractName:r.ContractName.BASE_TOKEN,contractFunctionName:"isClosed",context:{baseTokenAddress:e},rawError:t})))}async getMarketStatus(e){const t=[{contract:this.contracts.baseToken.attach(e),contractName:r.ContractName.BASE_TOKEN,funcName:"isPaused",funcParams:[]},{contract:this.contracts.baseToken.attach(e),contractName:r.ContractName.BASE_TOKEN,funcName:"isClosed",funcParams:[]}];return c.errorGuardAsync((async()=>{i.logger("getMarketStatus");const[e,r]=await this._multicallReader.execute(t);return{isPaused:e,isClosed:r}}),(e=>new a.ContractReadError({contractName:r.ContractName.MULTICALL2,contractFunctionName:"tryAggregate",args:l.contractCallsParserForErrorHandling(t),rawError:e})))}async getClosedPrice(e){return c.errorGuardAsync((async()=>{i.logger("getClosedPrice");const t=this.contracts.baseToken.attach(e),r=await t.getClosedPrice();return s.bigNumber2BigAndScaleDown(r)}),(t=>new a.ContractReadError({contractName:r.ContractName.BASE_TOKEN,contractFunctionName:"getClosedPrice",context:{baseTokenAddress:e},rawError:t})))}async getIndexPrice(e,t=0){return c.errorGuardAsync((async()=>{i.logger("getIndexPrice");const r=this.contracts.baseToken.attach(e),a=await r.getIndexPrice(t);return s.bigNumber2BigAndScaleDown(a)}),(n=>new a.ContractReadError({contractName:r.ContractName.BASE_TOKEN,contractFunctionName:"getIndexPrice",args:{interval:t},context:{baseTokenAddress:e},rawError:n})))}async getSlot0(e){return c.errorGuardAsync((async()=>(i.logger("getSlot0"),await this.contracts.pool.attach(e).slot0())),(e=>new a.ContractReadError({contractName:r.ContractName.POOL,contractFunctionName:"slot0",rawError:e})))}async getQuoterSwap({baseTokenAddress:t,isBaseToQuote:n,isExactInput:o,amount:u}){return c.errorGuardAsync((async()=>{i.logger("getQuoterSwap");const{deltaAvailableBase:e,deltaAvailableQuote:r,exchangedPositionNotional:a,exchangedPositionSize:c}=await this.contracts.quoter.callStatic.swap({baseToken:t,isBaseToQuote:n,isExactInput:o,amount:s.big2BigNumberAndScaleUp(u),sqrtPriceLimitX96:0}),l=s.bigNumber2BigAndScaleDown(e),g=s.bigNumber2BigAndScaleDown(r);return{deltaAvailableBase:l,deltaAvailableQuote:g,exchangedPositionNotional:s.bigNumber2BigAndScaleDown(a),exchangedPositionSize:s.bigNumber2BigAndScaleDown(c),output:n===o?g:l}}),(c=>{const i={contractName:r.ContractName.QUOTER,contractFunctionName:"swap",args:{baseToken:t,isBaseToQuote:n,isExactInput:o,amount:s.big2BigNumberAndScaleUp(u),sqrtPriceLimitX96:0},rawError:c};return c.code===e.errors.CALL_EXCEPTION&&c.reason===a.ContractErrorCode.QUOTER_INSUFFICIENT_LIQUIDITY?new a.InsufficientLiquidityError(i):new a.ContractReadError(i)}))}async getLiquidityPendingFee({trader:e,baseTokenAddress:t,lowerTick:n,upperTick:o}){return c.errorGuardAsync((async()=>{i.logger("getLiquidityPendingFee");const r=await this.contracts.orderBook.getPendingFee(e,t,n,o);return s.bigNumber2BigAndScaleDown(r)}),(c=>new a.ContractReadError({contractName:r.ContractName.ORDERBOOK,contractFunctionName:"getPendingFee",args:{trader:e,baseTokenAddress:t,lowerTick:n,upperTick:o},rawError:c})))}async getOpenLiquidityIdsByMarket({trader:e,baseTokenAddress:t}){return c.errorGuardAsync((async()=>(i.logger("getOpenLiquidityIdsByMarket"),this.contracts.orderBook.getOpenOrderIds(e,t))),(n=>new a.ContractReadError({contractName:r.ContractName.ORDERBOOK,contractFunctionName:"getOpenOrderIds",args:{trader:e,baseTokenAddress:t},rawError:n})))}async getOpenLiquidityIds(e,t){const n=Object.values(e).map((({baseAddress:e})=>({contract:this.contracts.orderBook,contractName:r.ContractName.ORDERBOOK,funcName:"getOpenOrderIds",funcParams:[t,e]})));return c.errorGuardAsync((async()=>{i.logger("getOpenLiquidityIds");return await this._multicallReader.execute([...n])}),(e=>new a.ContractReadError({contractName:r.ContractName.MULTICALL2,contractFunctionName:"tryAggregate",args:l.contractCallsParserForErrorHandling(n),rawError:e})))}async getOpenLiquidities(e,t){const n=await this.getOpenLiquidityIds(e,t),o=[];return Object.values(e).forEach((({baseAddress:e},t)=>{o.push(...n[t].map((e=>({contract:this.contracts.orderBook,contractName:r.ContractName.ORDERBOOK,funcName:"getOpenOrderById",funcParams:[e]}))))})),c.errorGuardAsync((async()=>{i.logger("getOpenLiquidities");const e=await this._multicallReader.execute([...o]);let t=0;return n.map(((r,a)=>{const o=n[a].length,c=e.slice(t,t+o);return t+=o,c.map((({baseDebt:e,quoteDebt:t,liquidity:r,lowerTick:a,upperTick:n})=>({baseDebt:s.bigNumber2BigAndScaleDown(e),quoteDebt:s.bigNumber2BigAndScaleDown(t),liquidity:new d.default(r),lowerTick:a,upperTick:n})))}))}),(e=>new a.ContractReadError({contractName:r.ContractName.MULTICALL2,contractFunctionName:"tryAggregate",args:l.contractCallsParserForErrorHandling(o),rawError:e})))}async getOpenLiquiditiesByMarket({trader:e,baseTokenAddress:t}){const n=(await this.getOpenLiquidityIdsByMarket({trader:e,baseTokenAddress:t})).map((e=>({contract:this.contracts.orderBook,contractName:r.ContractName.ORDERBOOK,funcName:"getOpenOrderById",funcParams:[e]})));return c.errorGuardAsync((async()=>{i.logger("getOpenLiquiditiesByMarket");return(await this._multicallReader.execute(n)).map((({baseDebt:e,quoteDebt:t,liquidity:r,lowerTick:a,upperTick:n})=>({baseDebt:s.bigNumber2BigAndScaleDown(e),quoteDebt:s.bigNumber2BigAndScaleDown(t),liquidity:s.bigNumber2BigAndScaleDown(r),lowerTick:a,upperTick:n})))}),(e=>new a.ContractReadError({contractName:r.ContractName.MULTICALL2,contractFunctionName:"tryAggregate",args:l.contractCallsParserForErrorHandling(n),rawError:e})))}async getOpenOrder({trader:e,baseTokenAddress:t,lowerTick:n,upperTick:o}){return c.errorGuardAsync((async()=>{i.logger("getOpenOrder");const r=await this.contracts.orderBook.getOpenOrder(e,t,n,o);return{baseDebt:s.bigNumber2BigAndScaleDown(r.baseDebt),quoteDebt:s.bigNumber2BigAndScaleDown(r.quoteDebt),liquidity:s.bigNumber2BigAndScaleDown(r.liquidity),lowerTick:r.lowerTick,upperTick:r.upperTick}}),(c=>new a.ContractReadError({contractName:r.ContractName.ORDERBOOK,contractFunctionName:"getOpenOrder",args:{trader:e,baseTokenAddress:t,lowerTick:n,upperTick:o},rawError:c})))}async getTotalTokenAmountInPoolAndPendingFeeOfAllMarkets(e,t){const n=Object.values(e).map((({baseAddress:e})=>({contract:this.contracts.orderBook,contractName:r.ContractName.ORDERBOOK,funcName:"getTotalTokenAmountInPoolAndPendingFee",funcParams:[t,e,!1]})));return c.errorGuardAsync((async()=>{i.logger("getTotalTokenAmountInPoolAndPendingFeeOfAllMarkets");const t=await this._multicallReader.execute([...n]);return Object.values(e).reduce(((e,r,a)=>{const[n,o]=t[a];return{...e,[r.baseAddress]:{totalTokenAmount:s.bigNumber2BigAndScaleDown(n),totalPendingFee:s.bigNumber2BigAndScaleDown(o)}}}),{})}),(e=>new a.ContractReadError({contractName:r.ContractName.MULTICALL2,contractFunctionName:"tryAggregate",args:l.contractCallsParserForErrorHandling(n),rawError:e})))}async simulateOpenPosition({baseTokenAddress:t,isBaseToQuote:o,isExactInput:u,amount:l,oppositeAmountBound:g}){const d={baseToken:t,isBaseToQuote:o,isExactInput:u,amount:s.big2BigNumberAndScaleUp(l),oppositeAmountBound:s.big2BigNumberAndScaleUp(g),sqrtPriceLimitX96:0,deadline:e.constants.MaxUint256,referralCode:e.constants.HashZero};return c.errorGuardAsync((async()=>{i.logger("simulateOpenPosition");const{base:e,quote:t}=await this.contracts.clearingHouse.callStatic.openPosition(d);return{deltaBase:s.bigNumber2BigAndScaleDown(e),deltaQuote:s.bigNumber2BigAndScaleDown(t)}}),(e=>{const t={contractName:r.ContractName.CLEARINGHOUSE,contractFunctionName:"openPosition",args:d,rawError:e},o=n.extractContractErrorCode(e);return o===a.ContractErrorCode.NOT_ENOUGH_FREE_COLLATERAL?new a.NotEnoughFreeCollateralError({...t,contractErrorCode:o}):o===a.ContractErrorCode.UNISWAP_BROKER_INSUFFICIENT_LIQUIDITY?new a.UniswapBrokerInsufficientLiquidityError({...t,contractErrorCode:o}):o===a.ContractErrorCode.OVER_PRICE_LIMIT_AFTER_SWAP?new a.OverPriceLimitAfterSwapError({contractName:r.ContractName.CLEARINGHOUSE,contractFunctionName:"swap",contractErrorCode:o,rawError:e}):o===a.ContractErrorCode.MARKET_NUMBER_EXCEEDS?new a.MarketNumberExceedsError({contractName:r.ContractName.ACCOUNT_BALANCE,contractFunctionName:"registerBaseToken",contractErrorCode:o,rawError:e}):new a.ContractReadError(t)}))}async getMarketsBaseTokenAndQuoteTokenAmount(e){const t=e.map((e=>{const{baseToken:t,pool:a}=e;return{contract:this.contracts.createIERC20Token(t),contractName:r.ContractName.Token0,funcName:"balanceOf",funcParams:[a]}})),n=e.map((e=>{const{quoteToken:t,pool:a}=e;return{contract:this.contracts.createIERC20Token(t),contractName:r.ContractName.Token1,funcName:"balanceOf",funcParams:[a]}})),o=[...t,...n];return c.errorGuardAsync((async()=>{i.logger("getMarketsBaseTokenAndQuoteTokenAmount");const r=await this._multicallReader.execute(o,{returnByContractAndFuncName:!0}),a=r[l.genKeyFromContractAndFuncName(n[0])],c=r[l.genKeyFromContractAndFuncName(t[0])];return e.reduce(((e,t,r)=>{const{pool:n}=t;return{...e,[n]:{quoteAmount:s.bigNumber2BigAndScaleDown(a[r]).toString(),baseAmount:s.bigNumber2BigAndScaleDown(c[r]).toString()}}}),{})}),(e=>new a.ContractReadError({contractName:r.ContractName.MULTICALL2,contractFunctionName:"tryAggregate",args:l.contractCallsParserForErrorHandling(o),rawError:e})))}async getClearingHouseMetadata(){const e={contract:this.contracts.clearingHouseConfig,contractName:r.ContractName.CLEARINGHOUSE_CONFIG,funcName:"getMmRatio",funcParams:[]},n={contract:this.contracts.clearingHouseConfig,contractName:r.ContractName.CLEARINGHOUSE_CONFIG,funcName:"getImRatio",funcParams:[]},o={contract:this.contracts.clearingHouseConfig,contractName:r.ContractName.CLEARINGHOUSE_CONFIG,funcName:"getMaxFundingRate",funcParams:[]},u={contract:this.contracts.clearingHouseConfig,contractName:r.ContractName.CLEARINGHOUSE_CONFIG,funcName:"getTwapInterval",funcParams:[]},g=this._metadata.pools.map((e=>e.baseAddress)),m=g.map((e=>({contract:this.contracts.marketRegistry,contractName:r.ContractName.MARKET_REGISTRY,funcName:"getMarketInfo",funcParams:[e]}))),N=this._metadata.pools.map((e=>e.address)),A=N.map((e=>({contract:this.contracts.pool.attach(e),contractName:r.ContractName.POOL,funcName:"tickSpacing",funcParams:[]}))),C=[e,n,o,u,...m,...A];return c.errorGuardAsync((async()=>{i.logger("getClearingHouseMetadata");const r=await this._multicallReader.execute(C,{returnByContractAndFuncName:!0}),[a]=r[l.genKeyFromContractAndFuncName(e)],[c]=r[l.genKeyFromContractAndFuncName(n)],[E]=r[l.genKeyFromContractAndFuncName(o)],[w]=r[l.genKeyFromContractAndFuncName(u)],T=r[l.genKeyFromContractAndFuncName(m[0])],b=r[l.genKeyFromContractAndFuncName(A[0])],y=g.reduce(((e,r,a)=>(e[r]=s.scaleDownDecimals(new d.default(T[a].exchangeFeeRatio),t.RATIO_DECIMAL),e)),{}),B=g.reduce(((e,r,a)=>(e[r]=s.scaleDownDecimals(new d.default(T[a].insuranceFundFeeRatio),t.RATIO_DECIMAL),e)),{}),P=N.reduce(((e,t,r)=>(e[t]=b[r],e)),{});return{mmRatio:new d.default(a),imRatio:new d.default(c),maxFundingRate:new d.default(E),twapInterval:new d.default(w),exchangeFeeRatios:y,insuranceFundFeeRatios:B,tickSpacings:P}}),(e=>new a.ContractReadError({contractName:r.ContractName.MULTICALL2,contractFunctionName:"tryAggregate",args:l.contractCallsParserForErrorHandling(C),rawError:e})))}async getTakerPositionSizeList(e,t){const n=Object.values(e).map((({baseAddress:e})=>({contract:this.contracts.accountBalance,contractName:r.ContractName.ACCOUNT_BALANCE,funcName:"getTakerPositionSize",funcParams:[t,e]})));return c.errorGuardAsync((async()=>{i.logger("getTakerPositionSizeList");return(await this._multicallReader.execute([...n])).map((e=>s.bigNumber2BigAndScaleDown(e)))}),(e=>new a.ContractReadError({contractName:r.ContractName.MULTICALL2,contractFunctionName:"tryAggregate",args:l.contractCallsParserForErrorHandling(n),rawError:e})))}async getTotalPositionSizeList(e,t){const n=Object.values(e).map((({baseAddress:e})=>({contract:this.contracts.accountBalance,contractName:r.ContractName.ACCOUNT_BALANCE,funcName:"getTotalPositionSize",funcParams:[t,e]})));return c.errorGuardAsync((async()=>{i.logger("getTotalPositionSizeList");return(await this._multicallReader.execute([...n])).map((e=>s.bigNumber2BigAndScaleDown(e)))}),(e=>new a.ContractReadError({contractName:r.ContractName.MULTICALL2,contractFunctionName:"tryAggregate",args:l.contractCallsParserForErrorHandling(n),rawError:e})))}async getTakerOpenNotionalList(e,t){const n=Object.values(e).map((({baseAddress:e})=>({contract:this.contracts.accountBalance,contractName:r.ContractName.ACCOUNT_BALANCE,funcName:"getTakerOpenNotional",funcParams:[t,e]})));return c.errorGuardAsync((async()=>{i.logger("getTakerOpenNotionalList");return(await this._multicallReader.execute([...n])).map((e=>s.bigNumber2BigAndScaleDown(e)))}),(e=>new a.ContractReadError({contractName:r.ContractName.MULTICALL2,contractFunctionName:"tryAggregate",args:l.contractCallsParserForErrorHandling(n),rawError:e})))}async getTotalOpenNotionalList(e,t){const n=Object.values(e).map((({baseAddress:e})=>({contract:this.contracts.accountBalance,contractName:r.ContractName.ACCOUNT_BALANCE,funcName:"getTotalOpenNotional",funcParams:[t,e]})));return c.errorGuardAsync((async()=>{i.logger("getTotalOpenNotionalList");return(await this._multicallReader.execute([...n])).map((e=>s.bigNumber2BigAndScaleDown(e)))}),(e=>new a.ContractReadError({contractName:r.ContractName.MULTICALL2,contractFunctionName:"tryAggregate",args:l.contractCallsParserForErrorHandling(n),rawError:e})))}async getTotalPositionValueList(e,t){const n=Object.values(e).map((({baseAddress:e})=>({contract:this.contracts.accountBalance,contractName:r.ContractName.ACCOUNT_BALANCE,funcName:"getTotalPositionValue",funcParams:[t,e]})));return c.errorGuardAsync((async()=>{i.logger("getTotalPositionValueList");return(await this._multicallReader.execute([...n])).map((e=>s.bigNumber2BigAndScaleDown(e)))}),(e=>new a.ContractReadError({contractName:r.ContractName.MULTICALL2,contractFunctionName:"tryAggregate",args:l.contractCallsParserForErrorHandling(n),rawError:e})))}async getPendingFundingPayments(e,t){const n=Object.values(e).map((({baseAddress:e})=>({contract:this.contracts.exchange,contractName:r.ContractName.EXCHANGE,funcName:"getPendingFundingPayment",funcParams:[t,e]})));return c.errorGuardAsync((async()=>{i.logger("getPendingFundingPayments");const t=await this._multicallReader.execute([...n]);return Object.values(e).reduce(((e,r,a)=>({...e,[r.tickerSymbol]:s.bigNumber2BigAndScaleDown(t[a])})),{})}),(e=>new a.ContractReadError({contractName:r.ContractName.MULTICALL2,contractFunctionName:"tryAggregate",args:l.contractCallsParserForErrorHandling(n),rawError:e})))}async getMarketData(e){const t=[{contract:this.contracts.pool.attach(e.poolAddress),contractName:r.ContractName.POOL,funcName:"slot0",funcParams:[]},{contract:this.contracts.baseToken.attach(e.baseAddress),contractName:r.ContractName.BASE_TOKEN,funcName:"getIndexPrice",funcParams:[0]},{contract:this.contracts.baseToken.attach(e.baseAddress),contractName:r.ContractName.BASE_TOKEN,funcName:"getIndexPrice",funcParams:[e.twapTimeRange]}];return c.errorGuardAsync((async()=>{i.logger("getMarketData");const e=await this._multicallReader.execute(t),[r,a,n]=e.map(((e,t)=>{if(0===t){const{sqrtPriceX96:t}=e;return s.fromSqrtX96(t)}return s.bigNumber2BigAndScaleDown(e)}));return{markPrice:r,indexPrice:a,indexTwapPrice:n}}),(e=>new a.ContractReadError({contractName:r.ContractName.MULTICALL2,contractFunctionName:"tryAggregate",args:l.contractCallsParserForErrorHandling(t),rawError:e})))}async getPositionDraftRelatedData({trader:t,marketBaseAddresses:n,currentMarketBaseSize:o,currentMarketBaseAddress:u}){const g={contract:this.contracts.quoter,contractName:r.ContractName.QUOTER,funcName:"swap",funcParams:[{baseToken:u,isBaseToQuote:!0,isExactInput:!0,amount:s.big2BigNumberAndScaleUp(o),sqrtPriceLimitX96:0}]},d={contract:this.contracts.accountBalance,contractName:r.ContractName.ACCOUNT_BALANCE,funcName:"getPnlAndPendingFee",funcParams:[t]},m=n.filter((e=>e!==u)),N=m.map((e=>({contract:this.contracts.accountBalance,contractName:r.ContractName.ACCOUNT_BALANCE,funcName:"getBase",funcParams:[t,e]}))),A=m.map((e=>({contract:this.contracts.baseToken.attach(e),contractName:r.ContractName.BASE_TOKEN,funcName:"getIndexPrice",funcParams:[0]}))),C=n.map((e=>({contract:this.contracts.accountBalance,contractName:r.ContractName.ACCOUNT_BALANCE,funcName:"getQuote",funcParams:[t,e]}))),E=[g,d,...N,...A,...C];return c.errorGuardAsync((async()=>{i.logger("getPositionDraftRelatedData");const e=await this._multicallReader.execute(E,{returnByContractAndFuncName:!0,failFirstByClient:!1,failFirstByContract:!1}),[{deltaAvailableBase:t,deltaAvailableQuote:r,exchangedPositionNotional:a,exchangedPositionSize:n}]=e[l.genKeyFromContractAndFuncName(g)],[[o,c,u]]=e[l.genKeyFromContractAndFuncName(d)],m=e[l.genKeyFromContractAndFuncName(N[0])],w=e[l.genKeyFromContractAndFuncName(A[0])],T=e[l.genKeyFromContractAndFuncName(C[0])],b=t&&s.bigNumber2BigAndScaleDown(t),y=r&&s.bigNumber2BigAndScaleDown(r);return{swap:{deltaAvailableBase:b,deltaAvailableQuote:y,exchangedPositionNotional:a&&s.bigNumber2BigAndScaleDown(a),exchangedPositionSize:n&&s.bigNumber2BigAndScaleDown(n),output:y},getPnlAndPendingFee:{owedPNL:s.bigNumber2BigAndScaleDown(o),unrealizedPNL:s.bigNumber2BigAndScaleDown(c),pendingFee:s.bigNumber2BigAndScaleDown(u)},otherBaseDebts:m.map((e=>s.bigNumber2BigAndScaleDown(e))),otherMarketIndexPrices:w.map((e=>s.bigNumber2BigAndScaleDown(e))),quoteDebts:T.map((e=>s.bigNumber2BigAndScaleDown(e)))}}),(t=>{if(t.code===e.errors.CALL_EXCEPTION&&t.reason===a.ContractErrorCode.QUOTER_INSUFFICIENT_LIQUIDITY){const e={contractName:r.ContractName.QUOTER,contractFunctionName:"swap",args:g.funcParams[0],rawError:t};return new a.InsufficientLiquidityError(e)}return new a.ContractReadError({contractName:r.ContractName.MULTICALL2,contractFunctionName:"tryAggregate",args:l.contractCallsParserForErrorHandling(E),rawError:t})}))}async getAccountValues(e){const n=[{contract:this.contracts.vault,contractName:r.ContractName.VAULT,funcName:"getFreeCollateral",funcParams:[e]},{contract:this.contracts.clearingHouse,contractName:r.ContractName.CLEARINGHOUSE,funcName:"getAccountValue",funcParams:[e]}];return c.errorGuardAsync((async()=>{i.logger("getAccountValues");const e=await this._multicallReader.execute(n);return{freeCollateral:s.bigNumber2BigAndScaleDown(e[0],t.COLLATERAL_TOKEN_DECIMAL),accountValue:s.bigNumber2BigAndScaleDown(e[1])}}),(e=>new a.ContractReadError({contractName:r.ContractName.MULTICALL2,contractFunctionName:"tryAggregate",args:l.contractCallsParserForErrorHandling(n),rawError:e})))}async getTotalPositionValue(e,t){return c.errorGuardAsync((async()=>{i.logger("getTotalPositionValue");const r=await this.contracts.accountBalance.getTotalPositionValue(e,t);return s.bigNumber2BigAndScaleDown(r)}),(n=>new a.ContractReadError({contractName:r.ContractName.ACCOUNT_BALANCE,contractFunctionName:"getTotalPositionValue",args:{trader:e,baseToken:t},rawError:n})))}async getTotalAbsPositionValue(e){return c.errorGuardAsync((async()=>{i.logger("getTotalAbsPositionValue");const t=await this.contracts.accountBalance.getTotalAbsPositionValue(e);return s.bigNumber2BigAndScaleDown(t)}),(t=>new a.ContractReadError({contractName:r.ContractName.ACCOUNT_BALANCE,contractFunctionName:"getTotalAbsPositionValue",args:{trader:e},rawError:t})))}async getLiquidationPrice(e,t){return c.errorGuardAsync((async()=>{i.logger("getLiquidationPrice");const r=await this.contracts.perpPortal.getLiquidationPrice(e,t);return s.bigNumber2BigAndScaleDown(r)}),(n=>new a.ContractReadError({contractName:r.ContractName.PerpPortal,contractFunctionName:"getLiquidationPrice",args:{trader:e,baseToken:t},rawError:n})))}async getLiquidationPriceList(e,t){const n=Object.values(e).map((({baseAddress:e})=>({contract:this.contracts.perpPortal,contractName:r.ContractName.PerpPortal,funcName:"getLiquidationPrice",funcParams:[t,e]})));return c.errorGuardAsync((async()=>{i.logger("getLiquidationPriceList");return(await this._multicallReader.execute([...n])).map((e=>s.bigNumber2BigAndScaleDown(e)))}),(e=>new a.ContractReadError({contractName:r.ContractName.MULTICALL2,contractFunctionName:"tryAggregate",args:l.contractCallsParserForErrorHandling(n),rawError:e})))}async getClearingHouseOpenPositionAction(){return c.errorGuardAsync((async()=>(i.logger("getClearingHouseOpenPositionAction"),await this.contracts.delegateApproval.getClearingHouseOpenPositionAction())),(e=>new a.ContractReadError({contractName:r.ContractName.DelegateApproval,contractFunctionName:"getClearingHouseOpenPositionAction",rawError:e})))}async canOpenPositionFor(e,t){return c.errorGuardAsync((async()=>(i.logger("canOpenPositionFor"),await this.contracts.delegateApproval.canOpenPositionFor(e,t))),(e=>new a.ContractReadError({contractName:r.ContractName.DelegateApproval,contractFunctionName:"canOpenPositionFor",rawError:e})))}};
//# sourceMappingURL=ContractReader.js.map
