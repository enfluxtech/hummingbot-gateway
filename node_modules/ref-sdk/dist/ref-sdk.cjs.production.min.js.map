{"version":3,"file":"ref-sdk.cjs.production.min.js","sources":["../src/constant.ts","../src/error.ts","../src/utils.ts","../src/instantSwap.ts","../src/ref.ts","../src/pool.ts","../src/stable-swap.ts","../src/parallelSwapLogic.ts","../src/smartRoutingLogic.js","../src/swap.ts","../src/sendTransactions.ts"],"sourcesContent":["export const FEE_DIVISOR = 10000;\n\nexport const STABLE_LP_TOKEN_DECIMALS = 18;\nexport const RATED_POOL_LP_TOKEN_DECIMALS = 24;\n\nexport function getConfig(env: string | undefined = process.env.NEAR_ENV) {\n  switch (env) {\n    case 'mainnet':\n      return {\n        networkId: 'mainnet',\n        nodeUrl: 'https://rpc.mainnet.near.org',\n        walletUrl: 'https://wallet.near.org',\n        WRAP_NEAR_CONTRACT_ID: 'wrap.near',\n        REF_FI_CONTRACT_ID: 'v2.ref-finance.near',\n      };\n    case 'testnet':\n      return {\n        networkId: 'testnet',\n        nodeUrl: 'https://rpc.testnet.near.org',\n        walletUrl: 'https://wallet.testnet.near.org',\n        WRAP_NEAR_CONTRACT_ID: 'wrap.testnet',\n        REF_FI_CONTRACT_ID: 'ref-finance-101.testnet',\n      };\n    default:\n      return {\n        networkId: 'mainnet',\n        nodeUrl: 'https://rpc.mainnet.near.org',\n        walletUrl: 'https://wallet.near.org',\n        REF_FI_CONTRACT_ID: 'v2.ref-finance.near',\n        WRAP_NEAR_CONTRACT_ID: 'wrap.near',\n      };\n  }\n}\n\nexport const config = getConfig();\n\nexport const REF_FI_CONTRACT_ID = config.REF_FI_CONTRACT_ID;\n\nexport const STORAGE_TO_REGISTER_WITH_MFT = '0.1';\n\nexport const ONE_YOCTO_NEAR = '0.000000000000000000000001';\n\n// export const REF_FI_CONTRACT_ID = 'exchange.ref-dev.testnet';\n\n// export const config = {\n//   networkId: 'testnet',\n//   nodeUrl: 'https://rpc.testnet.near.org',\n//   walletUrl: 'https://wallet.testnet.near.org',\n// };\n","import { getConfig } from './constant';\n\nexport const formatError = (msg: string) => {\n  return new Error(msg);\n};\n\nexport const unNamedError = formatError('Something wrong happened');\n\nexport const SameInputTokenError = formatError(\n  'Input token should be different with output token'\n);\n\nexport const ZeroInputError = formatError(\n  'Input amount should be greater than 0'\n);\n\nexport const NoPoolError = formatError('No pool found for the input tokens');\n\nexport const NotLoginError = formatError('Please login in first');\n\nexport const SwapRouteError = formatError(\n  \"Something wrong happened, we don't get correct routes corrreponding to current input\"\n);\n\nexport const TokenNotExistError = formatError(\n  `This token doesn't exist in ${getConfig().networkId}`\n);\n","import { Pool, PoolRPCView, StablePool, SmartRoutingInputPool } from './types';\nimport {\n  RATED_POOL_LP_TOKEN_DECIMALS,\n  STABLE_LP_TOKEN_DECIMALS,\n} from './constant';\n\nimport { utils } from 'near-api-js';\n\nimport BN from 'bn.js';\n\nimport * as math from 'mathjs';\n\nexport const parsePool = (pool: PoolRPCView, id?: number): Pool => ({\n  id: Number(id && id >= 0 ? id : pool.id),\n  tokenIds: pool.token_account_ids,\n  supplies: pool.amounts.reduce(\n    (acc: { [tokenId: string]: string }, amount: string, i: number) => {\n      acc[pool.token_account_ids[i]] = amount;\n      return acc;\n    },\n    {}\n  ),\n  fee: pool.total_fee,\n  shareSupply: pool.shares_total_supply,\n  tvl: pool.tvl,\n  token0_ref_price: pool.token0_ref_price,\n  pool_kind: pool.pool_kind,\n});\n\nexport const poolFormatter = (pool: Pool) => {\n  return {\n    id: pool.id,\n    token1Id: pool.tokenIds[0],\n    token2Id: pool.tokenIds[1],\n    token1Supply: pool.supplies[pool.tokenIds[0]],\n    token2Supply: pool.supplies[pool.tokenIds[1]],\n    fee: pool.fee,\n    shares: pool.shareSupply,\n    token0_price: pool.token0_ref_price || '0',\n  } as SmartRoutingInputPool;\n};\n\nexport const isStablePoolToken = (\n  stablePools: StablePool[],\n  tokenId: string | Number\n) => {\n  return stablePools\n    .map(p => p.token_account_ids)\n    .flat()\n    .includes(tokenId.toString());\n};\n\nexport const isStablePool = (\n  stablePools: StablePool[],\n  poolId: string | number\n) => {\n  return stablePools.map(p => p.id.toString()).includes(poolId.toString());\n};\n\nexport const getStablePoolDecimal = (stablePool: StablePool) => {\n  return stablePool.pool_kind === 'RATED_SWAP'\n    ? RATED_POOL_LP_TOKEN_DECIMALS\n    : STABLE_LP_TOKEN_DECIMALS;\n};\n\nexport const round = (decimals: number, minAmountOut: string) => {\n  return Number.isInteger(Number(minAmountOut))\n    ? minAmountOut\n    : Math.ceil(\n        Math.round(Number(minAmountOut) * Math.pow(10, decimals)) /\n          Math.pow(10, decimals)\n      ).toString();\n};\n\nexport const convertToPercentDecimal = (percent: number) => {\n  return math.divide(percent, 100);\n};\n\nexport const percentOf = (percent: number, num: number | string) => {\n  return math.evaluate(`${convertToPercentDecimal(percent)} * ${num}`);\n};\n\nexport const percentLess = (percent: number, num: number | string) => {\n  return math.format(math.evaluate(`${num} - ${percentOf(percent, num)}`), {\n    notation: 'fixed',\n  });\n};\n\nexport const getGas = (gas: string) =>\n  gas ? new BN(gas) : new BN('100000000000000');\n\nexport const getAmount = (amount: string) =>\n  amount ? new BN(utils.format.parseNearAmount(amount) || '0') : new BN('0');\n\nexport const ONLY_ZEROS = /^0*\\.?0*$/;\n\nexport const toReadableNumber = (\n  decimals: number,\n  number: string = '0'\n): string => {\n  if (!decimals) return number;\n\n  const wholeStr = number.substring(0, number.length - decimals) || '0';\n  const fractionStr = number\n    .substring(number.length - decimals)\n    .padStart(decimals, '0')\n    .substring(0, decimals);\n\n  return `${wholeStr}.${fractionStr}`.replace(/\\.?0+$/, '');\n};\n\nexport const toNonDivisibleNumber = (\n  decimals: number,\n  number: string\n): string => {\n  if (decimals === null || decimals === undefined) return number;\n  const [wholePart, fracPart = ''] = number.split('.');\n\n  return `${wholePart}${fracPart.padEnd(decimals, '0').slice(0, decimals)}`\n    .replace(/^0+/, '')\n    .padStart(1, '0');\n};\n\nexport const scientificNotationToString = (strParam: string) => {\n  let flag = /e/.test(strParam);\n  if (!flag || !strParam) return strParam;\n\n  let sysbol = true;\n  if (/e-/.test(strParam)) {\n    sysbol = false;\n  }\n\n  const negative = Number(strParam) < 0 ? '-' : '';\n\n  let index = Number(strParam.match(/\\d+$/)?.[0]);\n\n  let basis = strParam.match(/[\\d\\.]+/)?.[0];\n\n  if (!index || !basis) return strParam;\n\n  const ifFraction = basis.includes('.');\n\n  let wholeStr;\n  let fractionStr;\n\n  if (ifFraction) {\n    wholeStr = basis.split('.')[0];\n    fractionStr = basis.split('.')[1];\n  } else {\n    wholeStr = basis;\n    fractionStr = '';\n  }\n\n  if (sysbol) {\n    if (!ifFraction) {\n      return negative + wholeStr.padEnd(index + wholeStr.length, '0');\n    } else {\n      if (fractionStr.length <= index) {\n        return negative + wholeStr + fractionStr.padEnd(index, '0');\n      } else {\n        return (\n          negative +\n          wholeStr +\n          fractionStr.substring(0, index) +\n          '.' +\n          fractionStr.substring(index)\n        );\n      }\n    }\n  } else {\n    if (!ifFraction)\n      return (\n        negative +\n        wholeStr.padStart(index + wholeStr.length, '0').replace(/^0/, '0.')\n      );\n    else {\n      return (\n        negative +\n        wholeStr.padStart(index + wholeStr.length, '0').replace(/^0/, '0.') +\n        fractionStr\n      );\n    }\n  }\n};\n\nexport const formatWithCommas = (value: string) => {\n  const pattern = /(-?\\d+)(\\d{3})/;\n  while (pattern.test(value)) {\n    value = value.replace(pattern, '$1,$2');\n  }\n  return value;\n};\n\nexport const toPrecision = (\n  number: string,\n  precision: number,\n  withCommas: boolean = false,\n  atLeastOne: boolean = true\n): string => {\n  const [whole, decimal = ''] = number.split('.');\n\n  let str = `${withCommas ? formatWithCommas(whole) : whole}.${decimal.slice(\n    0,\n    precision\n  )}`.replace(/\\.$/, '');\n  if (atLeastOne && Number(str) === 0 && str.length > 1) {\n    var n = str.lastIndexOf('0');\n    str = str.slice(0, n) + str.slice(n).replace('0', '1');\n  }\n\n  return str;\n};\n","import { TokenMetadata, EstimateSwapView, Transaction } from './types';\nimport { wallet, ftGetStorageBalance } from './ref';\nimport {\n  STORAGE_TO_REGISTER_WITH_MFT,\n  REF_FI_CONTRACT_ID,\n  ONE_YOCTO_NEAR,\n} from './constant';\nimport { round, percentLess } from './utils';\nimport { toNonDivisibleNumber } from './utils';\nimport { config } from './constant';\nimport { SwapRouteError } from './error';\n\nexport const instantSwap = async ({\n  tokenIn,\n  tokenOut,\n  amountIn,\n  slippageTolerance,\n  swapTodos,\n}: {\n  tokenIn: TokenMetadata;\n  tokenOut: TokenMetadata;\n  amountIn: string;\n  slippageTolerance: number;\n  swapTodos: EstimateSwapView[];\n}) => {\n  const transactions: Transaction[] = [];\n\n  if (swapTodos.at(-1)?.outputToken !== tokenOut.id) throw SwapRouteError;\n\n  // const registerToken = async (token: TokenMetadata) => {\n  //   const tokenRegistered = await ftGetStorageBalance(token.id).catch(() => {\n  //     throw new Error(`${token.id} doesn't exist.`);\n  //   });\n\n  //   if (tokenRegistered === null) {\n  //     transactions.push({\n  //       receiverId: token.id,\n  //       functionCalls: [\n  //         {\n  //           methodName: 'storage_deposit',\n  //           args: {\n  //             registration_only: true,\n  //             account_id: wallet.getAccountId(),\n  //           },\n  //           gas: '30000000000000',\n  //           amount: STORAGE_TO_REGISTER_WITH_MFT,\n  //         },\n  //       ],\n  //     });\n  //   }\n  // };\n\n  // await registerToken(tokenOut);\n  let actionsList: any = [];\n  let allSwapsTokens = swapTodos.map(s => [s.inputToken, s.outputToken]); // to get the hop tokens\n  for (let i in allSwapsTokens) {\n    let swapTokens = allSwapsTokens[i];\n    if (swapTokens[0] === tokenIn.id && swapTokens[1] === tokenOut.id) {\n      // parallel, direct hop route.\n      actionsList.push({\n        pool_id: swapTodos[i].pool.id,\n        token_in: tokenIn.id,\n        token_out: tokenOut.id,\n        amount_in: swapTodos[i].pool.partialAmountIn,\n        min_amount_out: round(\n          tokenOut.decimals,\n          toNonDivisibleNumber(\n            tokenOut.decimals,\n            percentLess(slippageTolerance, swapTodos[i].estimate)\n          )\n        ),\n      });\n    } else if (swapTokens[0] === tokenIn.id) {\n      // first hop in double hop route\n      //TODO -- put in a check to make sure this first hop matches with the next (i+1) hop as a second hop.\n      actionsList.push({\n        pool_id: swapTodos[i].pool.id,\n        token_in: swapTokens[0],\n        token_out: swapTokens[1],\n        amount_in: swapTodos[i].pool.partialAmountIn,\n        min_amount_out: '0',\n      });\n    } else {\n      // second hop in double hop route.\n      //TODO -- put in a check to make sure this second hop matches with the previous (i-1) hop as a first hop.\n      actionsList.push({\n        pool_id: swapTodos[i].pool.id,\n        token_in: swapTokens[0],\n        token_out: swapTokens[1],\n        min_amount_out: round(\n          tokenOut.decimals,\n          toNonDivisibleNumber(\n            tokenOut.decimals,\n            percentLess(slippageTolerance, swapTodos[i].estimate)\n          )\n        ),\n      });\n    }\n  }\n\n  transactions.push({\n    receiverId: tokenIn.id,\n    functionCalls: [\n      {\n        methodName: 'ft_transfer_call',\n        args: {\n          receiver_id: REF_FI_CONTRACT_ID,\n          amount: toNonDivisibleNumber(tokenIn.decimals, amountIn),\n          msg: JSON.stringify({\n            force: 0,\n            actions: actionsList,\n          }),\n        },\n        gas: '180000000000000',\n        amount: ONE_YOCTO_NEAR,\n      },\n    ],\n  });\n\n  // if (tokenIn.id === config.WRAP_NEAR_CONTRACT_ID) {\n  //   const registered = await ftGetStorageBalance(config.WRAP_NEAR_CONTRACT_ID);\n  //   if (registered === null) {\n  //     await registerToken(tokenIn);\n  //   }\n  // }\n\n  return transactions;\n};\n","import { REF_FI_CONTRACT_ID, config } from './constant';\nimport { keyStores, Near, WalletConnection } from 'near-api-js';\nimport { TokenNotExistError } from './error';\n\nimport {\n  TokenMetadata,\n  FTStorageBalance,\n  RefFiViewFunctionOptions,\n} from './types';\n\nexport const keyStore = new keyStores.BrowserLocalStorageKeyStore();\n\nexport const near = new Near({\n  keyStore,\n  headers: {},\n  ...config,\n});\n\nexport const wallet = new WalletConnection(near, REF_FI_CONTRACT_ID);\n\nexport const refFiViewFunction = ({\n  methodName,\n  args,\n}: RefFiViewFunctionOptions) => {\n  return wallet.account().viewFunction(REF_FI_CONTRACT_ID, methodName, args);\n};\n\nexport const ftViewFunction = (\n  tokenId: string,\n  { methodName, args }: RefFiViewFunctionOptions\n) => {\n  return wallet.account().viewFunction(tokenId, methodName, args);\n};\n\nexport const ftGetStorageBalance = (\n  tokenId: string,\n  accountId: string = wallet.getAccountId()\n): Promise<FTStorageBalance | null> => {\n  return ftViewFunction(tokenId, {\n    methodName: 'storage_balance_of',\n    args: { account_id: accountId },\n  });\n};\n\nexport const getTotalPools = async () => {\n  return refFiViewFunction({\n    methodName: 'get_number_of_pools',\n  });\n};\n\nexport const ftGetTokenMetadata = async (\n  id: string\n): Promise<TokenMetadata> => {\n  const metadata = await ftViewFunction(id, {\n    methodName: 'ft_metadata',\n  }).catch(() => {\n    throw TokenNotExistError;\n  });\n\n  return { ...metadata, id };\n};\n\nexport const ftGetTokensMetadata = async (tokenIds: string[]) => {\n  const tokensMetadata = await Promise.all(\n    tokenIds.map((id: string) => ftGetTokenMetadata(id))\n  );\n\n  return tokensMetadata.reduce((pre, cur, i) => {\n    return {\n      ...pre,\n      [tokenIds[i]]: cur,\n    };\n  }, {}) as Record<string, TokenMetadata>;\n};\n\n// export const executeMultipleTransactions = async (\n//   transactions: Transaction[],\n//   callbackUrl?: string\n// ) => {\n//   const currentTransactions = await Promise.all(\n//     transactions.map((t, i) => {\n//       return wallet.createTransaction({\n//         receiverId: t.receiverId,\n//         nonceOffset: i + 1,\n//         actions: t.functionCalls.map(fc =>\n//           functionCall(\n//             fc.methodName,\n//             fc.args as object,\n//             getGas(fc.gas || ''),\n//             getAmount(fc.amount || '')\n//           )\n//         ),\n//       });\n//     })\n//   );\n\n//   return wallet.requestSignTransactions(currentTransactions, callbackUrl);\n// };\n","import { getTotalPools, refFiViewFunction } from './ref';\nimport { Pool, PoolRPCView } from './types';\nimport { parsePool, toNonDivisibleNumber } from './utils';\nimport { unNamedError } from './error';\nimport { STABLE_LP_TOKEN_DECIMALS } from './constant';\n\nexport const DEFAULT_PAGE_LIMIT = 100;\n\nexport const getRatedPoolDetail = async ({ id }: { id: string | number }) => {\n  return refFiViewFunction({\n    methodName: 'get_rated_pool',\n    args: { pool_id: Number(id) },\n  })\n    .then(pool_info => ({\n      ...pool_info,\n      id: Number(id),\n      pool_kind: 'RATED_SWAP',\n    }))\n    .catch(() => {\n      throw unNamedError;\n    });\n};\n\nexport const getUnRatedPoolDetail = async ({ id }: { id: string | number }) => {\n  return refFiViewFunction({\n    methodName: 'get_stable_pool',\n    args: { pool_id: Number(id) },\n  })\n    .then(pool_info => ({\n      ...pool_info,\n      id: Number(id),\n      pool_kind: 'STABLE_SWAP',\n      rates: pool_info.c_amounts.map((_: any) =>\n        toNonDivisibleNumber(STABLE_LP_TOKEN_DECIMALS, '1')\n      ),\n    }))\n    .catch(() => {\n      throw unNamedError;\n    });\n};\n\nexport const getStablePoolsDetail = async (stablePools: Pool[]) => {\n  return Promise.all(\n    stablePools.map(pool =>\n      pool.pool_kind === 'RATED_SWAP'\n        ? getRatedPoolDetail({ id: pool.id })\n        : getUnRatedPoolDetail({ id: pool.id })\n    )\n  );\n};\n\nexport const getRefPools = async (\n  page: number = 1,\n  perPage: number = DEFAULT_PAGE_LIMIT\n): Promise<Pool[]> => {\n  const index = (page - 1) * perPage;\n\n  const poolData: PoolRPCView[] = await refFiViewFunction({\n    methodName: 'get_pools',\n    args: { from_index: index, limit: perPage },\n  });\n\n  return poolData.map((rawPool, i) => parsePool(rawPool, i + index));\n};\n\n// TODO: differentiate by network, include simple pools and stable pools\nexport const fetchAllRefPools = async () => {\n  const totalPools = await getTotalPools();\n  const pages = Math.ceil(totalPools / DEFAULT_PAGE_LIMIT);\n\n  const pools = (\n    await Promise.all([...Array(pages)].map((_, i) => getRefPools(i + 1)))\n  ).flat() as Pool[];\n\n  return {\n    simplePools: pools.filter(\n      p => p.pool_kind && p.pool_kind === 'SIMPLE_POOL'\n    ),\n    unRatedPools: pools.filter(\n      p => p.pool_kind && p.pool_kind === 'STABLE_SWAP'\n    ),\n    ratedPools: pools.filter(p => p.pool_kind && p.pool_kind === 'RATED_SWAP'),\n  };\n};\n","import { StablePool } from './types';\nimport { FEE_DIVISOR } from './constant';\nimport {\n  toReadableNumber,\n  toNonDivisibleNumber,\n  scientificNotationToString,\n} from './utils';\n\nimport Big from 'big.js';\n\nimport _ from 'lodash';\n\nconst tradeFee = (amount: number, trade_fee: number) => {\n  return (amount * trade_fee) / FEE_DIVISOR;\n};\n\nexport const calc_d = (amp: number, c_amounts: number[]) => {\n  const token_num = c_amounts.length;\n  const sum_amounts = _.sum(c_amounts);\n  let d_prev = 0;\n  let d = sum_amounts;\n  for (let i = 0; i < 256; i++) {\n    let d_prod = d;\n    for (let c_amount of c_amounts) {\n      d_prod = (d_prod * d) / (c_amount * token_num);\n    }\n    d_prev = d;\n    const ann = amp * token_num ** token_num;\n    const numerator = d_prev * (d_prod * token_num + ann * sum_amounts);\n    const denominator = d_prev * (ann - 1) + d_prod * (token_num + 1);\n    d = numerator / denominator;\n    if (Math.abs(d - d_prev) <= 1) break;\n  }\n  return d;\n};\n\nexport const calc_y = (\n  amp: number,\n  x_c_amount: number,\n  current_c_amounts: number[],\n  index_x: number,\n  index_y: number\n) => {\n  const token_num = current_c_amounts.length;\n  const ann = amp * token_num ** token_num;\n  const d = calc_d(amp, current_c_amounts);\n  let s = x_c_amount;\n  let c = (d * d) / x_c_amount;\n  for (let i = 0; i < token_num; i++) {\n    if (i != index_x && i != index_y) {\n      s += current_c_amounts[i];\n      c = (c * d) / current_c_amounts[i];\n    }\n  }\n  c = (c * d) / (ann * token_num ** token_num);\n  const b = d / ann + s;\n  let y_prev = 0;\n  let y = d;\n  for (let i = 0; i < 256; i++) {\n    y_prev = y;\n    const y_numerator = y ** 2 + c;\n    const y_denominator = 2 * y + b - d;\n    y = y_numerator / y_denominator;\n    if (Math.abs(y - y_prev) <= 1) break;\n  }\n\n  return y;\n};\n\nexport const calc_swap = (\n  amp: number,\n  in_token_idx: number,\n  in_c_amount: number,\n  out_token_idx: number,\n  old_c_amounts: number[],\n  trade_fee: number\n) => {\n  const y = calc_y(\n    amp,\n    in_c_amount + old_c_amounts[in_token_idx],\n    old_c_amounts,\n    in_token_idx,\n    out_token_idx\n  );\n  const dy = old_c_amounts[out_token_idx] - y;\n  const fee = tradeFee(dy, trade_fee);\n  const amount_swapped = dy - fee;\n  return [amount_swapped, fee, dy];\n};\n\nexport const getSwappedAmount = (\n  tokenInId: string,\n  tokenOutId: string,\n  amountIn: string,\n  stablePool: StablePool,\n  STABLE_LP_TOKEN_DECIMALS: number\n) => {\n  const amp = stablePool.amp;\n  const trade_fee = stablePool.total_fee;\n\n  // depended on pools\n  const in_token_idx = stablePool.token_account_ids.findIndex(\n    id => id === tokenInId\n  );\n  const out_token_idx = stablePool.token_account_ids.findIndex(\n    id => id === tokenOutId\n  );\n\n  const rates = stablePool.rates.map(r =>\n    toReadableNumber(STABLE_LP_TOKEN_DECIMALS, r)\n  );\n\n  const base_old_c_amounts = stablePool.c_amounts.map(amount =>\n    toReadableNumber(STABLE_LP_TOKEN_DECIMALS, amount)\n  );\n\n  const old_c_amounts = base_old_c_amounts\n    .map((amount, i) =>\n      toNonDivisibleNumber(\n        STABLE_LP_TOKEN_DECIMALS,\n        scientificNotationToString(\n          new Big(amount || 0).times(new Big(rates[i])).toString()\n        )\n      )\n    )\n    .map(amount => Number(amount));\n\n  const in_c_amount = Number(\n    toNonDivisibleNumber(\n      STABLE_LP_TOKEN_DECIMALS,\n      scientificNotationToString(\n        new Big(amountIn).times(new Big(rates[in_token_idx])).toString()\n      )\n    )\n  );\n\n  const [amount_swapped, fee, dy] = calc_swap(\n    amp,\n    in_token_idx,\n    in_c_amount,\n    out_token_idx,\n    old_c_amounts,\n    trade_fee\n  );\n\n  return [\n    amount_swapped / Number(rates[out_token_idx]),\n    fee,\n    dy / Number(rates[out_token_idx]),\n  ];\n};\n","//@ts-nocheck\nimport Big from 'big.js';\n\nimport { Pool } from './types';\n\nBig.RM = 0;\nBig.DP = 40;\nBig.NE = -40;\nBig.PE = 40;\n\ninterface FormatedPool extends Pool {\n  x?: string;\n  y?: string;\n  gamma_bps?: Big;\n}\n\n///////////////////////////////\n// Parallel Swap Logic Below //\n///////////////////////////////\n\n/** formatPoolNew\n * This function appends to the existing standard Pool struct and adds attributes that simplify the parallel swap algorithms.\n * Adds attributes \"x\" (for input token reserves in pool), \"y\" (for output token reserves in pool), and \"gamma_bps\" (for 1- fee in bps)\n * Our convention for our algorithm has been to use \"x\" as the input token and \"y\" as the output token.\n * @param pool    AMM structure containing reserves of inputToken and outputToken\n * @param inputToken the name of the inputToken being traded in.\n * @param outputToken the name of the outputToken being traded out.\n * @returns newFormatPool\n */\nexport function formatPoolNew(\n  pool: Pool,\n  inputToken: string,\n  outputToken: string\n) {\n  let p: FormatedPool = pool;\n  let x = p.supplies[inputToken];\n  let y = p.supplies[outputToken];\n  p['gamma_bps'] = new Big(10000).minus(p.fee);\n  p['x'] = x;\n  p['y'] = y;\n  return p;\n}\n\n/** solveForMuFloat\n * This function takes the set of token pools, the total input of inputToken, and the names of inputToken and outputToken and\n * solves for the Lagrange Multiplier \"mu\". Note that mu must be allowed to be aritrary precision floating point number. Mu will\n * be used in subsequent function calls to determine the best allocations of intputToken to be made per pool.\n * For more detailed math on how this function was derived, please see the white paper:\n * https://github.com/giddyphysicist/ParallelSwapForRefFinance/blob/main/ParallelSwapWhitePaper.pdf\n * @param pools   list of pools that contain inputToken and outputToken\n * @param totalDeltaX  total allocation (among all pools) being input of inputToken\n * @param inputToken   the name of the inputToken being traded in.\n * @param outputToken   the name of the outputToken being traded out.\n * @returns mu   the lagrange multiplier value calculated for a set of pools and inputToken amount.\n */\nexport function solveForMuFloat(\n  pools: Pool[],\n  totalDeltaX: string,\n  inputToken: string,\n  outputToken: string\n) {\n  if (pools.length > 0) {\n    let numerator = new Big(totalDeltaX);\n    let denominator = new Big(0);\n\n    for (var i = 0; i < pools.length; i++) {\n      let p = formatPoolNew(pools[i], inputToken, outputToken);\n      let numAdd = new Big(p.x).times(10000).div(p.gamma_bps);\n      numerator = numerator.plus(numAdd);\n      let denomAdd = new Big(p.x)\n        .times(p.y)\n        .div(p.gamma_bps)\n        .sqrt()\n        .times(100);\n      denominator = denominator.plus(denomAdd);\n    }\n\n    const mu = new Big(numerator).div(denominator);\n    return mu;\n  } else {\n    // console.log('ERROR - could not find pools that satisfy token pair');\n    const mu = NaN;\n    return mu;\n  }\n}\n\n/** calculate_dx_float\n * Once mu has been calculated for a set of pools and total input amount, the next step is\n * determining the total allocation per pool. This function evaluates the amount of input Token to be\n * allocated to the given pool. Note, in our original algorithmic convention, the 'x' variable was for the input token,\n * and the 'y' variable was for the output token. Here, the value dx is the part of the full amount of input token X.\n * Again, the detailed formulae for these operations can be found in the white paper referenced above.\n * @param mu   the lagrange multiplier value calculated for a set of pools and inputToken amount.\n * @param pool   AMM structure containing reserves of inputToken and outputToken\n * @param inputToken the name of the inputToken being traded in.\n * @param outputToken  the name of the outputToken being traded out.\n * @returns dxFloat   the allocation amount determined for the given pool\n */\nexport function calculate_dx_float(\n  mu: number | Big,\n  pool: FormatedPool,\n  inputToken: string,\n  outputToken: string\n) {\n  let p = formatPoolNew(pool, inputToken, outputToken);\n  let radical = new Big(p.x).times(p.y).div(p.gamma_bps);\n  let dxFloat = new Big(mu)\n    .times(100)\n    .times(radical.sqrt())\n    .minus(new Big(p.x).times(10000).div(p.gamma_bps));\n  return dxFloat;\n}\n\n/** calculate_dy_float\n * Once you have an allocation amount for a given pool, you can use the AMM constant-product formula to determine\n * the expected output amount of output Token.\n * Note, here, as earlier, our algorithmic convention uses \"y\" as the output token, and so \"dy\" is the fraction of\n * the total output of output Token, assuming there could be dy contributions from other parallel pools as well.\n * @param dx_float  input allocation amount of inputToken for the given pool\n * @param pool   a structure representing the reserves and fees for a given pool.\n * @param inputToken  the name of the inputToken being traded in.\n * @param outputToken  the name of the outputToken being traded out.\n * @returns dyFloat  the expected trade out amount out of outputToken\n */\nexport function calculate_dy_float(\n  dx_float: number,\n  pool: FormatedPool,\n  inputToken: string,\n  outputToken: string\n) {\n  if (dx_float <= 0) {\n    return new Big(0);\n  }\n  let p = formatPoolNew(pool, inputToken, outputToken);\n  let dx = new Big(dx_float);\n  let denom = new Big(10000).times(p.x).plus(new Big(p.gamma_bps).times(dx));\n  let numerator = new Big(p.y).times(dx).times(p.gamma_bps);\n  let dyFloat = numerator.div(denom).round();\n  return dyFloat;\n}\n\n/** calculateOptimalOutput\n * This is the main function, which calculates optimal values of inputToken to swap into each pool.\n * @param pools  list of relevant AMM pools containing inputToken and outputToken\n * @param inputAmount   the numeric total amount of inputToken to be traded into the group of swap pools.\n * @param inputToken   the name of the inputToken being traded in.\n * @param outputToken  the name of the outputToken being traded out.\n * @returns normalizedDxArray an array containing the amount allocations of inputToken per pool in the list of pools.\n */\nexport function calculateOptimalOutput(\n  pools: Pool[],\n  inputAmount: string,\n  inputToken: string,\n  outputToken: string\n) {\n  let mu = solveForMuFloat(pools, inputAmount, inputToken, outputToken);\n  let dxArray: Big[] = new Array();\n  let negativeDxValsFlag = false;\n  for (var i = 0; i < pools.length; i++) {\n    let pool = formatPoolNew(pools[i], inputToken, outputToken);\n    let dx = calculate_dx_float(mu, pool, inputToken, outputToken);\n    if (dx.lt(0)) {\n      negativeDxValsFlag = true;\n    }\n    let dxInt = new Big(dx).round();\n    dxArray.push(dxInt);\n  }\n  if (negativeDxValsFlag) {\n    dxArray = reducePools(pools, dxArray, inputAmount, inputToken, outputToken);\n  }\n  let dxArraySum = new Big(0);\n  for (var i = 0; i < dxArray.length; i++) {\n    dxArraySum = dxArraySum.plus(dxArray[i]);\n  }\n  let tempAllocationsArray = [];\n  for (var i = 0; i < dxArray.length; i++) {\n    let ndx = new Big(dxArray[i])\n      .times(inputAmount)\n      .div(dxArraySum)\n      .round();\n    tempAllocationsArray.push(ndx);\n  }\n  let allocationsArray = checkIntegerSumOfAllocations(\n    tempAllocationsArray,\n    inputAmount\n  );\n  let normalizedDxArray = [];\n  for (var i = 0; i < allocationsArray.length; i++) {\n    let ndx = allocationsArray[i];\n    normalizedDxArray.push(BigInt(ndx));\n    pools[i]['partialAmountIn'] = ndx.toString();\n  }\n  return normalizedDxArray;\n}\n\n/** reducePools\n * This function is used to implement part of the non-linear slack variables in the lagrange - multiplier\n * solution for parallel swap. Part of what comes out of the math is that sometimes, the optimal allocation for a pool\n * can be negative, which makes no physical sense. When this occurs, that particular pool needs to be flagged and the\n * lagrange constraint applied to force the allocation to be zero.\n * This function takes an already-solved set of pools, input allocation per pool, the total input amount, and the\n * inputToken name and outputToken name, and determines which, if any, allocations need to be set to zero.\n * However, when this occurs, and a pool is essentially ignored from the list, then the calculation for mu must be re-done.\n * So the calculateOptimalOutput function is then called on the reduced set of pools, and if no negative allocation values remain,\n * then the allocations on the reduced set is determined, and values of zero are put in for the 'failed' pools.\n * @param pools  list of pools that contain inputToken and outputToken\n * @param dxArray  list of input allocation per pool\n * @param inputAmount   total amount of inputToken to be traded among the pools\n * @param inputToken    the name of the inputToken\n * @param outputToken   the name of the outputToken\n * @returns newFullDxVec  the new full list of input allocations the same length as dxArray, containing zeros for failed pools.\n */\nexport function reducePools(\n  pools: Pool[],\n  dxArray: Big[],\n  inputAmount: string,\n  inputToken: string,\n  outputToken: string\n) {\n  let goodIndices = [];\n  for (var i = 0; i < dxArray.length; i++) {\n    let dx = dxArray[i];\n    if (dx.gte(0)) {\n      goodIndices.push(i);\n    }\n  }\n  if (goodIndices.length < 1) {\n    // console.log(\"ERROR OCCURRED -- ALL DX VALUES WERE NEGATIVE\")\n    return dxArray;\n  }\n  let newPools = [];\n  for (var j = 0; j < dxArray.length; j++) {\n    if (goodIndices.includes(j)) {\n      newPools.push(pools[j]);\n    }\n  }\n  let newDxVec = calculateOptimalOutput(\n    newPools,\n    inputAmount,\n    inputToken,\n    outputToken\n  );\n  let goodInd2newdx = {};\n  for (var k = 0; k < newDxVec.length; k++) {\n    goodInd2newdx[goodIndices[k]] = newDxVec[k];\n  }\n  let newFullDxVec = [];\n  for (var ii = 0; ii < pools.length; ii++) {\n    if (goodIndices.includes(ii)) {\n      newFullDxVec.push(goodInd2newdx[ii]);\n    } else {\n      newFullDxVec.push(0);\n    }\n  }\n  return newFullDxVec;\n}\n\nexport function checkIntegerSumOfAllocations(\n  allocations: Big[] | string[] | BigInt[],\n  totalInput: Big | string | BigInt\n) {\n  var totalInput = new Big(totalInput);\n  var allocations:\n    | Big[]\n    | string[]\n    | BigInt[] = allocations.map((item: Big | string | BigInt) =>\n    new Big(item).round()\n  );\n  let alloSum = allocations\n    .map(item => new Big(item))\n    .reduce((a, b) => a.plus(b), new Big(0));\n  let offset = totalInput.minus(alloSum);\n  //get largest allocation.\n  let currMax = new Big(0);\n  let currMaxInd = 0;\n  for (var i = 0; i < allocations.length; i++) {\n    if (allocations[i].gt(currMax)) {\n      currMaxInd = i;\n      currMax = allocations[i];\n    }\n  }\n  let newAllocations = [];\n  for (var j = 0; j < allocations.length; j++) {\n    if (j === currMaxInd) {\n      newAllocations.push(allocations[j].plus(offset).toString());\n    } else {\n      newAllocations.push(allocations[j].toString());\n    }\n  }\n  return newAllocations;\n}\n","/* eslint-disable no-undef */\n////////////////////////////////////////////////////////////////////////////\n// SMART ROUTE SWAP LOGIC\n////////////////////////////////////////////////////////////////////////////\nimport Big from 'big.js';\nimport { checkIntegerSumOfAllocations } from './parallelSwapLogic';\n\nimport { TokenMetadata } from './types';\n\nimport { ftGetTokenMetadata } from './ref';\n\nimport { percentLess, toNonDivisibleNumber } from './utils';\n\nBig.RM = 0;\nBig.DP = 40;\nBig.NE = -40;\nBig.PE = 40;\n\nfunction bisqrt(value) {\n  // For some ridiculous reason, the .sqrt() method for Big decimals is extremely slow (~10-20ms),\n  // which isn't so bad until you need to use it a bunch of times.\n  // Since we're dealing with super large numbers anyway, we can convert the Big decimal number into a BigInt,\n  // then run this BigInt Newton iteration square root function instead, and then convert back into a\n  // Big number. And it speeds up the operation by a crazy factor, ~10x faster.\n  if (value < BigInt(0)) {\n    throw 'square root of negative numbers is not supported';\n  }\n\n  if (value < BigInt(2)) {\n    return value;\n  }\n\n  function newtonIteration(n, x0) {\n    const x1 = (n / x0 + x0) >> BigInt(1);\n    if (x0 === x1 || x0 === x1 - BigInt(1)) {\n      return x0;\n    }\n    return newtonIteration(n, x1);\n  }\n\n  return newtonIteration(value, BigInt(1));\n}\n\nfunction getBetaForRoute(route, path) {\n  if (!route.length) {\n    route = [route];\n  }\n  if (route.length == 1) {\n    let p = route[0];\n    var beta = new Big(p.reserves[path[0]]);\n  } else if (route.length == 2) {\n    let p1 = route[0];\n    let p2 = route[1];\n    var beta = new Big(p1.reserves[path[0]]).times(\n      new Big(p2.reserves[path[1]])\n    );\n  }\n  return beta;\n}\n\nfunction getEpsilonForRoute(route, path) {\n  if (!route.length) {\n    route = [route];\n  }\n  if (route.length == 1) {\n    // Single Hop case\n    let p = route[0];\n    let gamma = new Big(10000).minus(new Big(p.fee)).div(new Big(10000));\n    var epsilon = Big(gamma);\n  } else if (route.length == 2) {\n    //Double Hop Case\n    let p1 = route[0];\n    let p2 = route[1];\n    let gamma1 = new Big(10000).minus(new Big(p1.fee)).div(new Big(10000));\n    let gamma2 = new Big(10000).minus(new Big(p2.fee)).div(Big(10000));\n    var epsilon = new Big(p2.reserves[path[1]])\n      .times(new Big(gamma1))\n      .plus(new Big(p1.reserves[path[1]]).times(gamma1).times(gamma2));\n  }\n  return epsilon;\n}\n\nfunction getAlphaForRoute(route, path) {\n  if (!route.length) {\n    route = [route];\n  }\n  if (route.length == 1) {\n    //console.log('single hop')\n    let p = route[0];\n    let inputToken = path[0];\n    let outputToken = path[1];\n    let gamma = new Big(10000).minus(new Big(p.fee)).div(new Big(10000));\n    let key1 = p.token1Id;\n    let key2 = p.token2Id;\n    let val1 = p.token1Supply;\n    let val2 = p.token2Supply;\n    p['reserves'] = { [key1]: val1, [key2]: val2 };\n    var alpha = new Big(p.reserves[inputToken]).times(\n      new Big(p.reserves[outputToken]).times(new Big(gamma))\n    );\n  } else if (route.length == 2) {\n    //console.log('double hop')\n    let p1 = route[0];\n    let p2 = route[1];\n    let key11 = p1.token1Id;\n    let key12 = p1.token2Id;\n    let val11 = p1.token1Supply;\n    let val12 = p1.token2Supply;\n    p1['reserves'] = { [key11]: val11, [key12]: val12 };\n    let key21 = p2.token1Id;\n    let key22 = p2.token2Id;\n    let val21 = p2.token1Supply;\n    let val22 = p2.token2Supply;\n    p2['reserves'] = { [key21]: val21, [key22]: val22 };\n    let inputToken = path[0];\n    let middleToken = path[1];\n    let outputToken = path[2];\n    let gamma1 = new Big(10000).minus(Big(p1.fee)).div(new Big(10000));\n    let gamma2 = new Big(10000).minus(new Big(p2.fee)).div(new Big(10000));\n    let alpha1 = new Big(p1.reserves[inputToken])\n      .times(new Big(p1.reserves[middleToken]))\n      .times(gamma1);\n    let alpha2 = new Big(p2.reserves[middleToken])\n      .times(new Big(p2.reserves[outputToken]))\n      .times(gamma2);\n    var alpha = alpha1.times(alpha2);\n  }\n  return alpha;\n}\n\nfunction getAlphaSumFromRoutes(routes, nodeRoutes) {\n  let alphaSum = new Big(0);\n  for (var i in routes) {\n    let route = routes[i];\n    let nodeRoute = nodeRoutes[i];\n    let alpha = getAlphaForRoute(route, nodeRoute);\n    // console.log('alpha is...');\n    // console.log(alpha.toString());\n    // below, we are replacing the built-in Big sqrt() method with a\n    // newton-iteration BigInt sqrt function, to speed it up by 10x.\n    let radical = new Big(bisqrt(BigInt(new Big(alpha).round().toFixed())));\n    // let radical = new Big(alpha).sqrt();\n    let epsilon = getEpsilonForRoute(route, nodeRoute);\n    let denom = new Big(epsilon);\n    alphaSum = alphaSum.plus(radical.div(denom));\n  }\n  return alphaSum;\n}\n\nfunction getBetaSumFromRoutes(routes, nodeRoutes) {\n  let betaSum = new Big(0);\n  for (var i in routes) {\n    let route = routes[i];\n    let nodeRoute = nodeRoutes[i];\n    let num = new Big(getBetaForRoute(route, nodeRoute));\n    let denom = new Big(getEpsilonForRoute(route, nodeRoute));\n    betaSum = betaSum.plus(num.div(denom));\n  }\n  return betaSum;\n}\n\nfunction getPhiFromRoutes(routes, nodeRoutes, totalInput) {\n  let alphaSum = getAlphaSumFromRoutes(routes, nodeRoutes);\n  let betaSum = getBetaSumFromRoutes(routes, nodeRoutes);\n  let phi = new Big(totalInput).plus(betaSum).div(alphaSum);\n  return phi;\n}\n\nfunction getAllocationForRoute(phi, route, path) {\n  let alpha = getAlphaForRoute(route, path);\n  let beta = getBetaForRoute(route, path);\n  let epsilon = getEpsilonForRoute(route, path);\n  // below, we are replacing the built-in Big sqrt() method with a\n  // newton-iteration BigInt sqrt function, to speed it up by 10x.\n  let allocation = new Big(phi)\n    .abs()\n    .times(new Big(bisqrt(BigInt(new Big(alpha).round().toFixed()))))\n    .minus(beta)\n    .div(epsilon);\n  return allocation;\n}\n\nfunction getAllocationVectorForRoutes(phi, routes, nodeRoutes) {\n  let allocationVec = [];\n  for (var i in routes) {\n    allocationVec.push(getAllocationForRoute(phi, routes[i], nodeRoutes[i]));\n  }\n  return allocationVec;\n}\n\nfunction getOptimalAllocationForRoutes(routes, nodeRoutes, totalInput) {\n  // console.log(\"CALLING GET OPTIMAL ALLOCATION FOR ROUTES:\")\n  // console.log(routes)\n  var totalInput = new Big(totalInput);\n  let phi = getPhiFromRoutes(routes, nodeRoutes, totalInput);\n  // console.log('PHI CALCULATED TO BE...')\n  // console.log(phi.toString())\n  let allocations = getAllocationVectorForRoutes(phi, routes, nodeRoutes);\n  if (allocations.every(item => item.lt(new Big(0)))) {\n    allocations = allocations.map(item => item.times(new Big(-1.0)));\n  }\n  if (allocations.some(item => item.lt(new Big(0)))) {\n    allocations = reduceRoutes(routes, nodeRoutes, allocations, totalInput);\n  }\n  let sumAllocations = allocations.reduce((a, b) => a.plus(b), new Big(0));\n  let normalizedAllocations = allocations.map(a =>\n    a.div(sumAllocations).times(new Big(totalInput))\n  );\n  return normalizedAllocations;\n}\n\nfunction reduceRoutes(routes, nodeRoutes, allocationVec, totalInput) {\n  // console.log(\"RUNNING REDUCE ROUTES\")\n  var totalInput = new Big(totalInput);\n  let goodIndices = [];\n  for (var i in allocationVec) {\n    let dx = allocationVec[i];\n    // console.log('DX IS...')\n    // console.log(dx.toString())\n    if (dx.gt(new Big(0))) {\n      goodIndices.push(i);\n    }\n  }\n  // console.log('GOOD INDICES ARE...');\n  // console.log(goodIndices);\n  let newRoutes = [];\n  let newNodeRoutes = [];\n  for (var i in goodIndices) {\n    let goodIndex = goodIndices[i];\n    newRoutes.push(routes[goodIndex]);\n    newNodeRoutes.push(nodeRoutes[goodIndex]);\n  }\n  allocationVec = getOptimalAllocationForRoutes(\n    newRoutes,\n    newNodeRoutes,\n    totalInput\n  );\n  let allocationDict = {};\n  for (var i in goodIndices) {\n    allocationDict[goodIndices[i]] = allocationVec[i];\n  }\n  var allocationVecNew = [];\n  for (var i in routes) {\n    if (goodIndices.includes(i)) {\n      allocationVecNew.push(allocationDict[i]);\n    } else {\n      let zeroAllocation = new Big(0);\n      allocationVecNew.push(zeroAllocation);\n    }\n  }\n  return allocationVecNew;\n}\n\nfunction getNodeRoutesFromPathsAndPoolChains(paths, poolChains) {\n  let multiplicity = [];\n  for (var i in poolChains) {\n    let pc = poolChains[i];\n    let mul = pc\n      .map(item => item.length)\n      .reduce((elem1, elem2) => elem1 * elem2, 1);\n    multiplicity.push(mul);\n  }\n  let nodeRoutes = [];\n  for (var j in paths) {\n    let path = paths[j];\n    let m = multiplicity[j];\n    for (var k = 0; k < m; k++) {\n      nodeRoutes.push(path);\n    }\n  }\n  return nodeRoutes;\n}\n\nfunction getPoolChainFromPaths(paths, pools, threshold = 0.001) {\n  let poolChains = [];\n  for (var pathInd in paths) {\n    let path = paths[pathInd];\n    let chain = [];\n    let pairs = [];\n    for (var i = 0; i < path.length - 1; i++) {\n      pairs.push([path[i], path[i + 1]]);\n    }\n    for (var pairInd in pairs) {\n      let pair = pairs[pairInd];\n      // console.log(pair);\n      let tokenPools = getPoolsByToken1ANDToken2(pools, pair[0], pair[1]);\n      chain.push(tokenPools);\n    }\n    poolChains.push(chain);\n  }\n  // return poolChains;\n  let culledPoolChains = getCulledPoolChains(poolChains, threshold);\n\n  return culledPoolChains;\n}\n\nfunction getCulledPoolChains(poolChains, threshold = 0.001) {\n  let newChains = [];\n  for (var pathInd in poolChains) {\n    let path = poolChains[pathInd];\n    let newPath = [];\n    for (var legInd in path) {\n      let leg = path[legInd];\n      let culledPath = cullPoolsWithInsufficientLiquidity(leg, threshold);\n      newPath.push(culledPath);\n    }\n    newChains.push(newPath);\n  }\n  return newChains;\n}\n\nfunction getRoutesFromPoolChain(poolChains) {\n  let routes = [];\n  for (var pci in poolChains) {\n    let poolChain = poolChains[pci];\n    //get cartesian product of each pool chain to get the list of routes.\n    let newRoutes = cartesianProduct(poolChain);\n    routes.push(...newRoutes);\n  }\n  for (var i in routes) {\n    if (!routes[i].length) {\n      routes[i] = [routes[i]];\n    }\n  }\n  return routes;\n}\n\nfunction getOutputSingleHop(pool, inputToken, outputToken, totalInput) {\n  var totalInput = new Big(totalInput);\n  // check if pool is forward or backward for inputToken/outputToken cf. token1Id/token2Id\n  if (inputToken === pool.token1Id && outputToken === pool.token2Id) {\n    // forward Pool\n    var reserves = {\n      [inputToken]: new Big(pool.token1Supply),\n      [outputToken]: new Big(pool.token2Supply),\n    };\n  } else if (inputToken === pool.token2Id && outputToken === pool.token1Id) {\n    // reverse pool\n    var reserves = {\n      [outputToken]: new Big(pool.token1Supply),\n      [inputToken]: new Big(pool.token2Supply),\n    };\n  } else {\n    return new Big(0);\n  }\n  let gamma = new Big(10000).minus(new Big(pool.fee)).div(new Big(10000));\n  // console.log(totalInput)\n  // console.log(gamma)\n  // console.log(reserves)\n  let num = totalInput.times(gamma).times(reserves[outputToken]);\n  let denom = reserves[inputToken].plus(gamma.times(totalInput));\n  return num.div(denom);\n}\n\nfunction getOutputDoubleHop(\n  pools,\n  inputToken,\n  middleToken,\n  outputToken,\n  totalInput\n) {\n  var totalInput = new Big(totalInput);\n  for (var poolIndex in pools) {\n    let p = pools[poolIndex];\n    p['gamma'] = new Big(10000).minus(new Big(p.fee)).div(new Big(10000));\n  }\n  let p1 = pools[0];\n  let p2 = pools[1];\n\n  if (inputToken === p1.token1Id && middleToken === p1.token2Id) {\n    // forward Pool\n    p1['reserves'] = {\n      [inputToken]: new Big(p1.token1Supply),\n      [middleToken]: new Big(p1.token2Supply),\n    };\n  } else if (middleToken === p1.token1Id && inputToken === p1.token2Id) {\n    //reverse pool\n    p1['reserves'] = {\n      [middleToken]: new Big(p1.token1Supply),\n      [inputToken]: new Big(p1.token2Supply),\n    };\n  }\n\n  if (middleToken === p2.token1Id && outputToken === p2.token2Id) {\n    // forward Pool\n    p2['reserves'] = {\n      [middleToken]: new Big(p2.token1Supply),\n      [outputToken]: new Big(p2.token2Supply),\n    };\n  } else if (outputToken === p2.token1Id && middleToken === p2.token2Id) {\n    //reverse pool\n    p2['reserves'] = {\n      [outputToken]: new Big(p2.token1Supply),\n      [middleToken]: new Big(p2.token2Supply),\n    };\n  }\n\n  let c1 = new Big(p1.reserves[middleToken]);\n  let a1 = new Big(p1.reserves[inputToken]);\n  let c2 = new Big(p2.reserves[middleToken]);\n  let b2 = new Big(p2.reserves[outputToken]);\n  let gamma1 = p1.gamma;\n  let gamma2 = p2.gamma;\n  let num = totalInput\n    .times(c1)\n    .times(b2)\n    .times(gamma1)\n    .times(gamma2);\n  let denom = c2\n    .times(a1)\n    .plus(\n      totalInput.times(c2.times(gamma1).plus(c1.times(gamma1).times(gamma2)))\n    );\n  // denom = c2*a1 + totalInput * (c2*gamma1 + c1*gamma1*gamma2)\n\n  return num.div(denom);\n}\n\nfunction getOutputFromRoute(route, nodeRoute, allocation) {\n  if (new Big(allocation).eq(new Big(0))) {\n    return new Big(0);\n  } else {\n    var allocation = new Big(allocation);\n  }\n  if (!route.length) {\n    route = [route];\n  }\n  if (route.length == 1) {\n    // single hop\n    let inputToken = nodeRoute[0];\n    let outputToken = nodeRoute[1];\n    let pool = route[0];\n    var output = getOutputSingleHop(pool, inputToken, outputToken, allocation);\n  } else if (route.length == 2) {\n    // DOUBLE HOP\n    let inputToken = nodeRoute[0];\n    let middleToken = nodeRoute[1];\n    let outputToken = nodeRoute[2];\n    let pools = route;\n    var output = getOutputDoubleHop(\n      pools,\n      inputToken,\n      middleToken,\n      outputToken,\n      allocation\n    );\n  }\n  return output;\n}\n\nfunction getOptOutputVec(routes, nodeRoutes, totalInput) {\n  let allocations = getOptimalAllocationForRoutes(\n    routes,\n    nodeRoutes,\n    totalInput\n  );\n  let result = [];\n  for (var i in routes) {\n    let route = routes[i];\n    let nodeRoute = nodeRoutes[i];\n    let allocation = allocations[i];\n    let output = getOutputFromRoute(route, nodeRoute, allocation);\n    result.push(output);\n  }\n  return {\n    result: result,\n    allocations: allocations,\n  };\n  //NOTE -- I made this return an object instead of the tuple returned in python. need to check the places it is called, and specify\n  // result field instead of tuple 0 position, and allocations field instead of tuple 1 position.\n}\n\nfunction getBestOptInputAndOutputSlower(routes, nodeRoutes, totalInput) {\n  let refDict = getOptOutputVecRefined(routes, nodeRoutes, totalInput);\n  let outputRefined = refDict.result;\n  let inputRefined = refDict.allocations;\n  inputRefined = checkIntegerSumOfAllocations(inputRefined, totalInput);\n  let rawDict = getOptOutputVec(routes, nodeRoutes, totalInput);\n  let outputRaw = rawDict.result;\n  let inputRaw = rawDict.allocations;\n  inputRaw = checkIntegerSumOfAllocations(inputRaw, totalInput);\n  let res1 = new Big(0);\n  let res2 = new Big(0);\n\n  for (var n in outputRefined) {\n    res1 = res1.plus(outputRefined[n]);\n  }\n  for (var nn in outputRaw) {\n    res2 = res2.plus(outputRaw[nn]);\n  }\n  // console.log('COMPARING SINGLE HOPS VS DOUBLE')\n  // console.log(res1.toString())\n  // console.log(res2.toString())\n  if (res1.gt(res2)) {\n    return { input: inputRefined, output: res1 };\n  } else {\n    return { input: inputRaw, output: res2 };\n  }\n}\n\nfunction getBestOptInputAndOutput(routes, nodeRoutes, totalInput) {\n  // let refDict = getOptOutputVecRefined(routes, nodeRoutes, totalInput);\n  // let outputRefined = refDict.result;\n  // let inputRefined = refDict.allocations;\n  // inputRefined = checkIntegerSumOfAllocations(inputRefined, totalInput);\n  let rawDict = getOptOutputVec(routes, nodeRoutes, totalInput);\n  let outputRaw = rawDict.result;\n  let inputRaw = rawDict.allocations;\n  inputRaw = checkIntegerSumOfAllocations(inputRaw, totalInput);\n  let res1 = new Big(0);\n  let res2 = new Big(0);\n\n  let res = outputRaw\n    .map(v => new Big(v))\n    .reduce((bv1, bv2) => bv1.plus(bv2), new Big(0));\n\n  return {\n    input: inputRaw,\n    output: res,\n  };\n}\n\nfunction getBestOptOutput(routes, nodeRoutes, totalInput) {\n  let outputRefined = getOptOutputVecRefined(routes, nodeRoutes, totalInput)\n    .result;\n  let outputRaw = getOptOutputVec(routes, nodeRoutes, totalInput).result;\n  let res1 = new Big(0);\n  let res2 = new Big(0);\n\n  for (var n in outputRefined) {\n    res1 = res1.plus(outputRefined[n]);\n  }\n  for (var nn in outputRaw) {\n    res2 = res2.plus(outputRaw[nn]);\n  }\n  if (res1.gt(res2)) {\n    return res1;\n  } else {\n    return res2;\n  }\n}\n\nfunction getBestOptInput(routes, nodeRoutes, totalInput) {\n  let refDict = getOptOutputVecRefined(routes, nodeRoutes, totalInput);\n  let outputRefined = refDict.result;\n  let inputRefined = refDict.allocations;\n  inputRefined = checkIntegerSumOfAllocations(inputRefined, totalInput);\n  let rawDict = getOptOutputVec(routes, nodeRoutes, totalInput);\n  let outputRaw = rawDict.result;\n  let inputRaw = rawDict.allocations;\n  inputRaw = checkIntegerSumOfAllocations(inputRaw, totalInput);\n  let res1 = new Big(0);\n  let res2 = new Big(0);\n\n  for (var n in outputRefined) {\n    res1 = res1.plus(outputRefined[n]);\n  }\n  for (var nn in outputRaw) {\n    res2 = res2.plus(outputRaw[nn]);\n  }\n  // console.log('COMPARING SINGLE HOPS VS DOUBLE')\n  // console.log(res1.toString())\n  // console.log(res2.toString())\n  if (res1.gt(res2)) {\n    return inputRefined;\n  } else {\n    return inputRaw;\n  }\n}\n\nfunction getOptOutputVecRefined(routes, nodeRoutes, totalInput) {\n  // need to calculate full result.\n  // if direct pools exist, need to calculate parallel result. if not, this portion is set to zero output.\n\n  // need to compare between outputs of the two results above.\n\n  let initLengthRoutes = routes.length;\n  let directRouteInds = [];\n  for (var routeInd in routes) {\n    let route = routes[routeInd];\n    if (!route.length) {\n      route = [route];\n    }\n    if (route.length == 1) {\n      directRouteInds.push(routeInd);\n    }\n  }\n  // console.log('DIRECT ROUTE INDS ARE')\n  // console.log(directRouteInds)\n  // if (directRouteInds.length < 1) {\n  var fullResultAllocations = getOptimalAllocationForRoutes(\n    routes,\n    nodeRoutes,\n    totalInput\n  );\n  var fullResult = [];\n  for (var i in routes) {\n    let r = routes[i];\n    let nr = nodeRoutes[i];\n    let a = fullResultAllocations[i];\n    let output = getOutputFromRoute(r, nr, a);\n    fullResult.push(output);\n  }\n  var fullResultTotal = fullResult.reduce((a, b) => a.plus(b), new Big(0));\n\n  // } else {\n  if (directRouteInds.length > 0) {\n    // console.log('DOING SINGLE HOP ONLY')\n    let droutes = [];\n    let dnodeRoutes = [];\n    for (var dri in directRouteInds) {\n      let ind = directRouteInds[dri];\n      droutes.push(routes[ind]);\n      dnodeRoutes.push(nodeRoutes[ind]);\n    }\n    let dallocations = getOptimalAllocationForRoutes(\n      droutes,\n      dnodeRoutes,\n      totalInput\n    );\n    let dallocDict = {};\n    for (var dd in dallocations) {\n      dallocDict[directRouteInds[dd]] = dallocations[dd];\n    }\n    var pallocations = [];\n\n    for (var ii = 0; ii < initLengthRoutes; ii++) {\n      if (directRouteInds.includes(ii.toString())) {\n        //console.log('ADDING ALLOCATION FOR SINGLE ROUTE')\n        pallocations.push(dallocDict[ii]);\n      } else {\n        pallocations.push(new Big(0));\n      }\n    }\n    var presult = [];\n    for (var j in routes) {\n      let route = routes[j];\n      let nodeRoute = nodeRoutes[j];\n      let allocation = pallocations[j];\n      let output = getOutputFromRoute(route, nodeRoute, allocation);\n      presult.push(output);\n    }\n    var presultTotal = presult.reduce((a, b) => a.plus(b), new Big(0));\n  } else {\n    var presultTotal = new Big(0);\n  }\n  if (presultTotal.gt(fullResultTotal)) {\n    var result = presult;\n    var allocations = pallocations;\n  } else {\n    var result = fullResult;\n    var allocations = fullResultAllocations;\n  }\n  // NEED TO COMPARE BETWEEEN DIRECT AND MULTI HOP TO GET BEST OUTPUT\n  return {\n    result: result,\n    allocations: allocations,\n  };\n}\n\nasync function getBestOptimalAllocationsAndOutputs(\n  pools,\n  inputToken,\n  outputToken,\n  totalInput,\n  maxPathLength = 3,\n  threshold = 0.001\n) {\n  var totalInput = new Big(totalInput);\n  let paths = await getPathsFromPools(\n    pools,\n    inputToken,\n    outputToken,\n    maxPathLength\n  );\n  if (!paths.length) {\n    return {\n      allocations: [],\n      outputs: new Big(0),\n      routes: [],\n      nodeRoutes: [],\n    };\n  }\n  let poolChains = await getPoolChainFromPaths(paths, pools, threshold);\n\n  let routes = await getRoutesFromPoolChain(poolChains);\n  let nodeRoutes = await getNodeRoutesFromPathsAndPoolChains(paths, poolChains);\n  // let allocations = await getBestOptInput(routes, nodeRoutes, totalInput);\n  // // fix integer rounding for allocations:\n  // allocations = checkIntegerSumOfAllocations(allocations, totalInput);\n  // let outputs = getBestOptOutput(routes, nodeRoutes, totalInput);\n  let inputOutput = await getBestOptInputAndOutput(\n    routes,\n    nodeRoutes,\n    totalInput\n  );\n  let allocations = inputOutput.input;\n  let outputs = inputOutput.output;\n\n  return {\n    allocations: allocations,\n    outputs: outputs,\n    routes: routes,\n    nodeRoutes: nodeRoutes,\n  };\n}\n\nfunction getHopsFromRoutes(routes, nodeRoutes, allocations) {\n  let hops = [];\n  for (var i in routes) {\n    var route = routes[i];\n    var nodeRoute = nodeRoutes[i];\n    var allocation = allocations[i];\n    if (!route.length) {\n      route = [route];\n    }\n    if (!route[0]) {\n      continue;\n    }\n    let hop = {\n      pool: route[0],\n      allocation: allocation,\n      inputToken: nodeRoute[0],\n      outputToken: nodeRoute[1],\n    };\n    hops.push(hop);\n  }\n  return hops;\n}\n\nfunction distillHopsByPool(hops) {\n  // console.log('some HOPS =');\n  // console.log(hops);\n  let distilledHops = [];\n  let poolIds = [];\n  let poolId2allocation = {};\n  for (var i in hops) {\n    let hop = hops[i];\n    if (hop.allocation === '0') {\n      continue;\n    }\n    // console.log(`HOP ${i} IS...`);\n    // console.log(hop);\n    let poolId = hop.pool['id'];\n    if (poolIds.includes(poolId)) {\n      poolId2allocation[poolId] = new Big(poolId2allocation[poolId])\n        .plus(new Big(hop.allocation))\n        .toString();\n    } else {\n      poolId2allocation[poolId] = new Big(hop.allocation).toString();\n      poolIds.push(poolId);\n    }\n  }\n  // let poolsWithOrder = [...new Set(...hops.map((item) => item.pool))]\n  let keys = Object.keys(poolId2allocation);\n  for (var j in keys) {\n    var poolId = keys[j];\n    let hop = hops.filter(\n      item => item.pool.id.toString() === poolId.toString()\n    )[0];\n    let distilledHop = {\n      pool: hop.pool,\n      allocation: poolId2allocation[poolId],\n      inputToken: hop.inputToken,\n      outputToken: hop.outputToken,\n    };\n    distilledHops.push(distilledHop);\n  }\n  return distilledHops;\n}\n\nfunction getDistilledHopActions(distilledHops, slippageTolerance) {\n  let actions = [];\n  for (var i in distilledHops) {\n    let hop = distilledHops[i];\n    let expectedAmountOut = getOutputSingleHop(\n      hop.pool,\n      hop.inputToken,\n      hop.outputToken,\n      hop.allocation\n    );\n    let minimumAmountOut = new Big(expectedAmountOut)\n      .times(new Big(1).minus(new Big(slippageTolerance).div(100)))\n      .round()\n      .toString(); //Here, assume slippage tolerance is a percentage. So 1% would be 1.0\n    let action = {\n      pool_id: hop.pool.id,\n      token_in: hop.inputToken,\n      token_out: hop.outputToken,\n      amount_in: hop.allocation,\n      min_amount_out: minimumAmountOut,\n    };\n    actions.push(action);\n  }\n  return actions;\n}\nfunction getMiddleTokenTotalsFromFirstHopActions(firstHopActions) {\n  let middleTokens = [...new Set(firstHopActions.map(item => item.token_out))];\n  let middleTokenTotals = {};\n  for (var i in middleTokens) {\n    let middleToken = middleTokens[i];\n    let mtActions = firstHopActions.filter(\n      item => item.token_out === middleToken\n    );\n    let mtTotal = mtActions\n      .map(item => new Big(item.min_amount_out))\n      .reduce((a, b) => a.plus(b), new Big(0))\n      .toString();\n    middleTokenTotals[middleToken] = mtTotal;\n  }\n  return middleTokenTotals;\n}\nfunction getRoutesAndAllocationsForMiddleToken(\n  routes,\n  nodeRoutes,\n  allocations,\n  middleToken,\n  middleTokenTotal\n) {\n  // get routes that use middle token.\n  // (input route alloction) /sum(input allocations of routes with middle token) * (total_middleToken)\n  let mask = [];\n  for (var i in nodeRoutes) {\n    if (nodeRoutes[i][1] === middleToken) {\n      mask.push(true);\n    } else {\n      mask.push(false);\n    }\n  }\n  let froutes = [];\n  let fallocations = [];\n  let fnoderoutes = [];\n  for (var i in routes) {\n    if (mask[i]) {\n      froutes.push(routes[i]);\n      fallocations.push(allocations[i]);\n      fnoderoutes.push(nodeRoutes[i]);\n    }\n  }\n  let sumfallocations = fallocations.reduce(\n    (a, b) => new Big(a).plus(new Big(b)),\n    new Big(0)\n  );\n  let middleAllocations = fallocations.map(item =>\n    new Big(item).div(sumfallocations).times(new Big(middleTokenTotal))\n  );\n  let secondHopRoutes = froutes.map(item => [item[1]]);\n  let secondHopNodeRoutes = fnoderoutes.map(item => [item[1], item[2]]);\n  middleAllocations = checkIntegerSumOfAllocations(\n    middleAllocations,\n    middleTokenTotal\n  );\n  return {\n    routes: secondHopRoutes,\n    nodeRoutes: secondHopNodeRoutes,\n    allocations: middleAllocations,\n  };\n}\n\nfunction getHopActionsFromRoutes(routes, nodeRoutes, allocations) {\n  // console.log('INSIDE GET HOP ACTIONS FROM ROUTES');\n  // console.log('ROUTES ARE...');\n  // console.log(routes);\n  // console.log('NODE ROUTES ARE...');\n  // console.log(nodeRoutes);\n  // console.log('ALLOCATIONS ARE...');\n  // console.log(allocations);\n  let totalInput = allocations\n    .map(a => new Big(a))\n    .reduce((a, b) => a.plus(b), new Big(0))\n    .toString();\n  let hops = [];\n  for (var i in routes) {\n    var route = routes[i];\n    var nodeRoute = nodeRoutes[i];\n    var allocation = allocations[i];\n    if (new Big(allocation).eq(new Big(0))) {\n      continue;\n    }\n    if (!route.length) {\n      route = [route];\n    }\n    if (!route[0]) {\n      continue;\n    }\n    for (var j in route) {\n      let pool = route[j];\n      // console.log('J IS...');\n      // console.log(j);\n      // console.log('NODE ROUTE IS...');\n      // console.log(nodeRoute);\n      if (j == 0) {\n        //first hop.\n        // console.log(nodeRoute[0]);\n        // console.log(nodeRoute[1]);\n        var hop = {\n          pool: pool,\n          allocation: allocation.toString(),\n          inputToken: nodeRoute[0],\n          outputToken: nodeRoute[1],\n          nodeRoute: nodeRoute,\n          route: route,\n          allRoutes: routes,\n          allNodeRoutes: nodeRoutes,\n          totalInputAmount: totalInput,\n          allAllocations: allocations,\n        };\n        // console.log('FIRST HOP IS...');\n        // console.log(hop);\n        hops.push(hop);\n        if (nodeRoute.length > 2) {\n          var middleTokenAllocation = getOutputSingleHop(\n            pool,\n            nodeRoute[0],\n            nodeRoute[1],\n            allocation\n          );\n        }\n      } else {\n        // second hop\n        var hop = {\n          pool: pool,\n          allocation: middleTokenAllocation.toString(),\n          inputToken: nodeRoute[1],\n          outputToken: nodeRoute[2],\n          nodeRoute: nodeRoute,\n          route: route,\n          allRoutes: routes,\n          allNodeRoutes: nodeRoutes,\n          totalInputAmount: totalInput,\n          allAllocations: allocations,\n        };\n        // console.log('SECOND HOP IS...');\n        // console.log(hop);\n        hops.push(hop);\n      }\n    }\n  }\n  // console.log('HOP ACTIONS FOUND TO BE');\n  // console.log(hops);\n  return hops;\n}\n\n// TODO: Clean this function. I don't need all the \"actions\" just the hops.\n// TODO: re-order actions to ensure each route is complete with zero input for second hop before starting next route.\nfunction getActionListFromRoutesAndAllocations(\n  routes,\n  nodeRoutes,\n  allocations\n) {\n  // REPLACE THE CODE BELOW WITH THE FUNCTION HERE.\n  return getHopActionsFromRoutes(routes, nodeRoutes, allocations);\n  var actions = [];\n  var all_hops = [];\n  let firstHops = getHopsFromRoutes(routes, nodeRoutes, allocations);\n\n  firstHops = firstHops.filter(hop => new Big(hop.allocation).gt(new Big(0)));\n  all_hops.push(...firstHops);\n  let distilledFirstHops = distillHopsByPool(firstHops);\n  let firstHopActions = getDistilledHopActions(\n    distilledFirstHops,\n    slippageTolerance\n  );\n  actions.push(...firstHopActions);\n  let middleTokenTotals = getMiddleTokenTotalsFromFirstHopActions(\n    firstHopActions\n  );\n  // console.log('first hop actions are...');\n  // console.log(firstHopActions);\n  let middleTokens = Object.keys(middleTokenTotals);\n  // console.log('middle token totals are...');\n  // console.log(middleTokenTotals);\n  // console.log('middle tokens are...');\n  // console.log(middleTokens);\n  for (var tokenIndex in middleTokens) {\n    var secondHops = [];\n    let middleToken = middleTokens[tokenIndex];\n    // console.log('current middle token is ');\n    // console.log(middleToken);\n    let middleTokenTotal = middleTokenTotals[middleToken];\n    // console.log('current middle token total is...');\n    // console.log(middleTokenTotal);\n    let middleTokenRoutesWithAllocations = getRoutesAndAllocationsForMiddleToken(\n      routes,\n      nodeRoutes,\n      allocations,\n      middleToken,\n      middleTokenTotal\n    );\n    // console.log('current middle tokens routes with allocations are...');\n    // console.log(middleTokenRoutesWithAllocations);\n    let middleTokenRoutes = middleTokenRoutesWithAllocations.routes;\n    let middleTokenAllocations = middleTokenRoutesWithAllocations.allocations;\n    let middleTokenNodeRoutes = middleTokenRoutesWithAllocations.nodeRoutes;\n    // console.log('middle token routes are...');\n    // console.log(middleTokenRoutes);\n    // console.log('middle token allocations are...');\n    // console.log(middleTokenAllocations);\n    // console.log('middle token node routes are...');\n    // console.log(middleTokenNodeRoutes);\n    secondHops.push(\n      ...getHopsFromRoutes(\n        middleTokenRoutes,\n        middleTokenNodeRoutes,\n        middleTokenAllocations\n      )\n    );\n    // console.log('CURRENT SECOND HOPS', secondHops);\n    // console.log(secondHops.length);\n    // console.log(secondHops.map((hop) => hop.allocation));\n    // console.log('filter out zero allocation 2nd hops:');\n    secondHops = secondHops.filter(hop =>\n      new Big(hop.allocation).gt(new Big(0))\n    );\n    // console.log(secondHops);\n    all_hops.push(...secondHops);\n    // console.log('second hops are currently...');\n    // console.log(secondHops);\n    let distilledSecondHopsForToken = distillHopsByPool(secondHops);\n    // console.log('distilled second hops are...');\n    let secondHopActionsForToken = getDistilledHopActions(\n      distilledSecondHopsForToken,\n      slippageTolerance\n    );\n    // console.log(secondHopActionsForToken);\n    actions.push(...secondHopActionsForToken);\n  }\n\n  //TODO: NEED TO RUN INTEGER ROUNDING FUNCTION ON MIDDLE TOKEN ALLOCATIONS\n\n  // TODO: check the node routes. for double-hop cases, find the hop action for each hop.\n  // For now, we are assuming no parallel swaps if there is a double-hop.\n\n  // Possible cases:\n  //  (1) 1 single-hop.\n  //  (2) Parallel single-hop ?\n  //  (3) 1 double-hop\n  //  (4) 2 double-hops\n\n  // We only have to worry about re-ordering the actions for cases (3) and (4).\n\n  let orderedHops = orderHops(all_hops, routes, nodeRoutes, allocations);\n\n  // console.log('ALL HOPS', all_hops);\n  return orderedHops;\n  // return actions;\n}\n\nfunction orderHops(hops, routes, nodeRoutes, allocations) {\n  // first get rid of zero allocation routes\n  // console.log('NODE ROUTES ARE...');\n  // console.log(nodeRoutes);\n  let filteredRoutes = [];\n  let filteredNodeRoutes = [];\n  let filteredAllocations = [];\n  for (var i in routes) {\n    // remove zero-allocation routes.\n    let allocation = new Big(allocations[i]);\n    if (allocation.gt(new Big(0))) {\n      filteredAllocations.push(allocation);\n      filteredRoutes.push(routes[i]);\n      filteredNodeRoutes.push(nodeRoutes[i]);\n    }\n    // console.log('FILTERED NODE ROUTES ARE...');\n    // console.log(filteredNodeRoutes);\n  }\n  // next check node routes to see if it is case 1, 2, 3, or 4.\n  // Possible cases:\n  //  (1) 1 single-hop.\n  //  (2) Parallel single-hop ?\n  //  (3) 1 double-hop\n  //  (4) 2 double-hops\n\n  if (filteredNodeRoutes.length === 1) {\n    // only one route.\n    let currentNodeRoute = filteredNodeRoutes[0];\n    if (currentNodeRoute.length === 2) {\n      // case 1.\n      return hops;\n    } else {\n      // case 3. assume there are only 3 nodes (double-hop)\n      //make sure order of hops is such that input token precedes output token.\n      //make sure the amount_in for second hop is zero (which will grab all of output of first hop to use.)\n      let firstHop = hops.filter(\n        hop => hop.inputToken === currentNodeRoute[0]\n      )[0];\n      let secondHop = hops.filter(\n        hop => hop.inputToken === currentNodeRoute[1]\n      )[0];\n      // set second hop amount in to 0 so that it will use whatever was generated by hop 1.\n      secondHop.pool.partialAmountIn = '0';\n\n      let orderedHops = [firstHop, secondHop];\n      return orderedHops;\n    }\n  } else if (filteredNodeRoutes.length === 2) {\n    // two routes.\n    let lengthNodeRoutes = filteredNodeRoutes.map(nr => nr.length);\n    // sub cases:\n    // [2,2] -- parallel swap. (direct) -- case 2\n    // [2,3] -- direct swap in parallel with double hop.\n    // [3,2] -- double hop in parallel with direct swap.\n    // [3,3] -- double hop in parallel with double hop. -- case 4\n    let orderedHops = [];\n    if (arrayEquals(lengthNodeRoutes, [2, 2])) {\n      return hops;\n    } else if (arrayEquals(lengthNodeRoutes, [2, 3])) {\n      directNodeRoute = filteredNodeRoutes[0];\n      doubleNodeRoute = filteredNodeRoutes[1];\n      let firstHop = hops.filter(\n        hop =>\n          hop.inputToken === directNodeRoute[0] &&\n          hop.outputToken === directNodeRoute[1]\n      )[0];\n      let secondHop = hops.filter(\n        hop => hop.inputToken === doubleNodeRoute[0]\n      )[0];\n      let thirdHop = hops.filter(\n        hop => hop.outputToken === doubleNodeRoute[2]\n      )[0];\n      // set third hop amount in to 0 so that it will use whatever was generated by hop 2.\n      thirdHop.pool.partialAmountIn = '0';\n      orderedHops = [firstHop, secondHop, thirdHop];\n      return orderedHops;\n    } else if (arrayEquals(lengthNodeRoutes, [3, 2])) {\n      directNodeRoute = filteredNodeRoutes[1];\n      doubleNodeRoute = filteredNodeRoutes[0];\n      let firstHop = hops.filter(\n        hop =>\n          hop.inputToken === directNodeRoute[0] &&\n          hop.outputToken === directNodeRoute[1]\n      )[0];\n      let secondHop = hops.filter(\n        hop => hop.inputToken === doubleNodeRoute[0]\n      )[0];\n      let thirdHop = hops.filter(\n        hop => hop.outputToken === doubleNodeRoute[2]\n      )[0];\n      // set third hop amount in to 0 so that it will use whatever was generated by hop 2.\n      thirdHop.pool.partialAmountIn = '0';\n      orderedHops = [firstHop, secondHop, thirdHop];\n      return orderedHops;\n    } else if (arrayEquals(lengthNodeRoutes, [3, 3])) {\n      orderedHops = [];\n\n      for (var i in filteredNodeRoutes) {\n        let doubleNodeRoute = filteredNodeRoutes[i];\n        let doubleHopMiddleToken = doubleNodeRoute[1];\n        let firstHop = hops.filter(\n          hop =>\n            hop.inputToken === doubleNodeRoute[0] &&\n            hop.outputToken === doubleHopMiddleToken\n        )[0];\n        let secondHop = hops.filter(\n          hop =>\n            hop.inputToken === doubleHopMiddleToken &&\n            hop.outputToken === doubleNodeRoute[2]\n        )[0];\n        // set second hop amount in to 0 so that it will use whatever was generated by hop 1.\n        secondHop.pool.partialAmountIn = '0';\n        orderedHops.push(firstHop);\n        orderedHops.push(secondHop);\n      }\n      return orderedHops;\n    } else {\n      return hops;\n    }\n    for (var i in filteredNodeRoutes) {\n      let currentNodeRoute = filteredNodeRoutes[i];\n      if (currentNodeRoute.length === 2) {\n      }\n    }\n  }\n\n  return hops;\n}\n\n// function getActionListFromRoutesAndAllocationsORIG(\n//   routes,\n//   nodeRoutes,\n//   allocations,\n//   slippageTolerance\n// ) {\n//   let actions = [];\n//   for (var i in routes) {\n//     let route = routes[i];\n//     let nodeRoute = nodeRoutes[i];\n//     let allocation = new Big(allocations[i]);\n//     if (allocation.eq(new Big(0))) {\n//       continue;\n//     }\n//     if (!route.length) {\n//       route = [route];\n//     }\n//     if (route.length === 1) {\n//       //single hop. only one action.\n//       let pool = route[0];\n//       let poolId = pool.id;\n//       let inputToken = nodeRoute[0];\n//       let outputToken = nodeRoute[1];\n//       let expectedAmountOut = getOutputSingleHop(\n//         pool,\n//         inputToken,\n//         outputToken,\n//         allocation\n//       );\n//       let minimumAmountOut = expectedAmountOut\n//         .times(new Big(1).minus(new Big(slippageTolerance).div(100)))\n//         .round()\n//         .toString(); //Here, assume slippage tolerance is a percentage. So 1% would be 1.0\n//       let action = {\n//         pool_id: poolId,\n//         token_in: inputToken,\n//         token_out: outputToken,\n//         amount_in: allocation.round().toString(),\n//         min_amount_out: minimumAmountOut.toString(),\n//       };\n//       actions.push(action);\n//     } else if (route.length === 2) {\n//       // double hop. two actions.\n//       let pool1 = route[0];\n//       let pool2 = route[1];\n//       let pool1Id = pool1.id;\n//       let pool2Id = pool2.id;\n//       let inputToken = nodeRoute[0];\n//       let middleToken = nodeRoute[1];\n//       let outputToken = nodeRoute[2];\n//       let expectedAmountOutFirstHop = getOutputSingleHop(\n//         pool1,\n//         inputToken,\n//         middleToken,\n//         allocation\n//       );\n//       let minimumAmountOutFirstHop = expectedAmountOutFirstHop\n//         .times(new Big(1).minus(new Big(slippageTolerance).div(100)))\n//         .round()\n//         .toString(); //Here, assume slippage tolerance is a percentage. So 1% would be 1.0\n\n//       let action1 = {\n//         pool_id: pool1Id,\n//         token_in: inputToken,\n//         token_out: middleToken,\n//         amount_in: allocation.round().toString(),\n//         min_amount_out: minimumAmountOutFirstHop,\n//       };\n//       let expectedFinalAmountOut = getOutputSingleHop(\n//         pool2,\n//         middleToken,\n//         outputToken,\n//         minimumAmountOutFirstHop\n//       );\n//       let minimumAMountOutSecondHop = expectedFinalAmountOut\n//         .times(new Big(1).minus(new Big(slippageTolerance).div(100)))\n//         .round()\n//         .toString();\n//       let action2 = {\n//         pool_id: pool2Id,\n//         token_in: middleToken,\n//         token_out: outputToken,\n//         amount_in: minimumAmountOutFirstHop,\n//         min_amount_out: minimumAMountOutSecondHop,\n//       };\n//       actions.push(action1);\n//       actions.push(action2);\n//     }\n//   }\n//   return actions;\n// }\n\nfunction* range(start, end) {\n  for (; start <= end; ++start) {\n    yield start;\n  }\n}\n\nfunction last(arr) {\n  return arr[arr.length - 1];\n}\n\nfunction* numericCombinations(n, r, loc = []) {\n  var idx = loc.length;\n  if (idx === r) {\n    yield loc;\n    return;\n  }\n  for (let next of range(idx ? last(loc) + 1 : 0, n - r + idx)) {\n    yield* numericCombinations(n, r, loc.concat(next));\n  }\n}\n\nfunction* combinations(arr, r) {\n  for (let idxs of numericCombinations(arr.length, r)) {\n    yield idxs.map(i => arr[i]);\n  }\n}\n\n//     #middleTokenTotals = getMiddleTokenTotals(routes,nodeRoutes,allocations)\n//     #TODO: complete this function with middle token checks.\n\n//     #consider all routes of length 2 with non-zero allocation. (double-hops)\n//     # among these, check for parallel swaps. That is, check for common node routes\n//     # for first hop. Then check for common node routes on second hop.\n//     # when common node routes occur for the first hop:\n//     # 1. Calculate the total expected output of intermediate token.\n//     # 2.\n//     # when common node routes occur for the second hop:\n//     # 1. get a ratio of the input allocations of the full routes associated with\n//     # these common node routes. allocate the total intermediate token output\n//     # toward these 2nd hop routes in the same ratio as their route input allocations.\n\nexport async function getSmartRouteSwapActions(\n  pools,\n  inputToken,\n  outputToken,\n  totalInput,\n  maxPathLength = 3,\n  threshold = 0.001,\n  numberOfRoutesLimit = 2,\n  MAX_NUMBER_PARALLEL_POOLS = 4,\n  decimalsCulledPoolIds = []\n) {\n  if (!totalInput) {\n    return [];\n  }\n  var totalInput = new Big(totalInput);\n\n  // remove pools that have an id from the decimalCulledPoolIds\n  pools = pools.filter(p => !decimalsCulledPoolIds.includes(p.id));\n\n  let resDict = await getBestOptimalAllocationsAndOutputs(\n    pools,\n    inputToken,\n    outputToken,\n    totalInput,\n    maxPathLength,\n    threshold\n  );\n\n  let allocations = resDict.allocations;\n\n  // let outputs = resDict.outputs;\n  let routes = resDict.routes;\n  let nodeRoutes = resDict.nodeRoutes;\n\n  let sortedIndexValues = argsort(allocations);\n  let topIndices = sortedIndexValues.slice(0, 10);\n  var reducedRoutes = [];\n  var reducedNodeRoutes = [];\n  for (var ind of topIndices) {\n    reducedRoutes.push(routes[ind]);\n    reducedNodeRoutes.push(nodeRoutes[ind]);\n  }\n  routes = reducedRoutes;\n  nodeRoutes = reducedNodeRoutes;\n\n  // TODO: compare pairs of routes to get the best allocation pair-wise.\n  var currentBestOutput = new Big(0);\n  var bestResDict = { routes: [] };\n  var bestAllocations = resDict.allocations;\n  var bestNodeRoutes = resDict.nodeRoutes;\n  var bestRoutes = resDict.routes;\n  // first check parallel swap with 4 actions. store result.\n  var parallelNodeRoutes = [];\n  var parallelRoutes = [];\n  for (var n in bestRoutes) {\n    let currentNodeRoute = bestNodeRoutes[n];\n    if (currentNodeRoute.length == 2) {\n      parallelNodeRoutes.push(currentNodeRoute);\n      parallelRoutes.push(bestRoutes[n]);\n    }\n  }\n  // console.log(`${parallelNodeRoutes.length} parallel routes found...`);\n  var bestRoutesAreParallel = false;\n  if (parallelNodeRoutes.length > 0) {\n    // first calculate the expected result using only parallel routes.\n    // let filteredAllocationsAndOutputs = getOptOutputVecRefined(parallelRoutes, parallelNodeRoutes, totalInput);\n    let filteredAllocationsAndOutputs = getOptOutputVec(\n      parallelRoutes,\n      parallelNodeRoutes,\n      totalInput\n    );\n    let parallellAllocations = filteredAllocationsAndOutputs.allocations;\n    let parallelOutputs = filteredAllocationsAndOutputs.result;\n\n    if (parallellAllocations.length > MAX_NUMBER_PARALLEL_POOLS) {\n      // now sort by allocation value to the top 4 parallel swaps:\n      let sortIndices = argsort(parallellAllocations);\n\n      sortIndices = sortIndices.slice(0, MAX_NUMBER_PARALLEL_POOLS);\n      var filteredParallelRoutes = [];\n      var filteredParallelNodeRoutes = [];\n      for (var i in sortIndices) {\n        filteredParallelRoutes.push(parallelRoutes[sortIndices[i]]);\n        filteredParallelNodeRoutes.push(parallelNodeRoutes[sortIndices[i]]);\n      }\n      filteredAllocationsAndOutputs = getOptOutputVec(\n        filteredParallelRoutes,\n        filteredParallelNodeRoutes,\n        totalInput\n      );\n      parallellAllocations = filteredAllocationsAndOutputs.allocations;\n      parallelOutputs = filteredAllocationsAndOutputs.result;\n    }\n\n    let parallelOutput = parallelOutputs.reduce(\n      (a, b) => a.plus(b),\n      new Big(0)\n    );\n    if (new Big(parallelOutput).gt(currentBestOutput)) {\n      bestAllocations = parallellAllocations;\n      currentBestOutput = parallelOutput;\n      // console.log(\n      //   'BEST OUTPUT FROM PARALLEL SWAPS IS NOW... ',\n      //   currentBestOutput.toString()\n      // );\n      bestRoutes = parallelRoutes;\n      bestNodeRoutes = parallelNodeRoutes;\n      bestRoutesAreParallel = true;\n    }\n  }\n  var canHaveTwoRoutes = false;\n  // initialize this variable to check if we can have two routes, or if all routes share a pool for an edge case.\n  // console.log('THE NUMBER OF ROUTES IS...', routes.length);\n\n  for (var i in routes) {\n    for (var j in routes) {\n      if (j > i) {\n        var route1 = routes[i];\n        var route2 = routes[j];\n        var nodeRoute1 = nodeRoutes[i];\n        var nodeRoute2 = nodeRoutes[j];\n        // check if they share a pool.\n        let route1PoolIds = new Set(route1.map(r => r.id));\n        let route2PoolIds = new Set(route2.map(r => r.id));\n        var sharePool = false;\n        for (var route1PoolId of route1PoolIds) {\n          if (route2PoolIds.has(route1PoolId)) {\n            sharePool = true;\n          }\n        }\n        if (sharePool) {\n          // routes are not independent. skip this pair.\n          // console.log('skipping this pair because pool was shared.');\n          continue;\n        } else {\n          canHaveTwoRoutes = true;\n          let currentRoutes = [route1, route2];\n          let currentNodeRoutes = [nodeRoute1, nodeRoute2];\n\n          let filteredAllocationsAndOutputs = getOptOutputVec(\n            currentRoutes,\n            currentNodeRoutes,\n            totalInput\n          );\n\n          let filteredAllocations = filteredAllocationsAndOutputs.allocations;\n          let filteredOutputs = filteredAllocationsAndOutputs.result;\n          // console.log('FILTERED ALLOCATIONS:');\n          // console.log(filteredAllocations.map((i) => i.toString()));\n          // console.log(filteredOutputs);\n          let totalOutput = filteredOutputs.reduce(\n            (a, b) => a.plus(b),\n            new Big(0)\n          );\n          if (new Big(totalOutput).gt(currentBestOutput)) {\n            bestAllocations = filteredAllocations;\n            currentBestOutput = totalOutput;\n            // console.log('BEST OUTPUT IS NOW... ', currentBestOutput.toString());\n            bestRoutes = currentRoutes;\n            bestNodeRoutes = currentNodeRoutes;\n            bestRoutesAreParallel = false;\n            // bestResDict = currentResDict\n          }\n\n          // if (currentResDict.outputs.gt(currentBestOutput)) {\n          // console.log('DIFF IS...', currentResDict.outputs.minus(currentBestOutput).toString());\n          // bestResDict = currentResDict;\n          // currentBestOutput = bestResDict.outputs;\n          // console.log('BEST OUTPUT IS NOW... ', currentBestOutput.toString());\n          // console.log(bestResDict.routes);\n          // console.log(bestResDict.allocations.map((i) => i.toString()));\n          // console.log(bestResDict.outputs.toString());\n        }\n      }\n    }\n  }\n\n  if (!canHaveTwoRoutes) {\n    // now we need to check through the routes in single manner to find the best one:\n    for (var i in routes) {\n      let currentRoutes = [routes[i]];\n      let currentNodeRoutes = [nodeRoutes[i]];\n      // let filteredAllocationsAndOutputs = getOptOutputVecRefined(currentRoutes, currentNodeRoutes, totalInput);\n      let filteredAllocationsAndOutputs = getOptOutputVec(\n        currentRoutes,\n        currentNodeRoutes,\n        totalInput\n      );\n\n      let filteredAllocations = filteredAllocationsAndOutputs.allocations;\n      let filteredOutputs = filteredAllocationsAndOutputs.result;\n      // console.log('FILTERED ALLOCATIONS:');\n      // console.log(filteredAllocations.map((i) => i.toString()));\n      // console.log(filteredOutputs);\n      let totalOutput = filteredOutputs.reduce((a, b) => a.plus(b), new Big(0));\n      if (new Big(totalOutput).gt(currentBestOutput)) {\n        bestAllocations = filteredAllocations;\n        currentBestOutput = totalOutput;\n        // console.log('BEST OUTPUT IS NOW... ', currentBestOutput.toString());\n        bestRoutes = currentRoutes;\n        bestNodeRoutes = currentNodeRoutes;\n        bestRoutesAreParallel = false;\n        // bestResDict = currentResDict\n      }\n    }\n  }\n\n  // resDict = bestResDict;\n\n  allocations = bestAllocations;\n\n  // let outputs = resDict.outputs;\n  routes = bestRoutes;\n  nodeRoutes = bestNodeRoutes;\n\n  if (routes.length < 1) {\n    return [];\n  }\n\n  // check the top numberOfRoutesLimit\n  // console.log('initial allocations are...');\n  // console.log(allocations.map((a) => a.toString()));\n  // console.log('fixed allocations are...');\n  // console.log(allocations.map((a) => new Big(a).toFixed()));\n  //SORT BY ALLOCATIONS\n  let allSortedIndices = argsort(allocations.map(a => new Big(a)));\n  if (bestRoutesAreParallel) {\n    numberOfRoutesLimit = 4;\n  }\n  let sortedIndices = allSortedIndices.slice(0, numberOfRoutesLimit);\n\n  // console.log('sorted Indices are');\n  // console.log(sortedIndices);\n  var filteredRoutes = [];\n  var filteredNodeRoutes = [];\n  for (var i in sortedIndices) {\n    let index = sortedIndices[i];\n    filteredRoutes.push(routes[index]);\n    filteredNodeRoutes.push(nodeRoutes[index]);\n  }\n\n  // console.log('filteredRoutes are ...');\n  // console.log(filteredRoutes);\n  for (var i in filteredRoutes) {\n    if (!filteredRoutes[i].length) {\n      filteredRoutes[i] = [filteredRoutes[i]];\n    }\n  }\n  // console.log('filtered Node routes are...');\n  // console.log(filteredNodeRoutes);\n\n  // THE BELOW CODE WILL ENSURE THAT ROUTES ARE INDEPENDENT (e.g. THE ROUTES WILL NOT SHARE A POOL)\n\n  let route1PoolIds = filteredRoutes[0].map(pool => pool.id);\n  // console.log('route 1 pool ids:');\n  // console.log(route1PoolIds);\n  if (filteredRoutes.length > 1) {\n    let route2PoolIds = filteredRoutes[1].map(pool => pool.id);\n    // console.log('route 2 pool ids:');\n    // console.log(route2PoolIds);\n    var sharedRoute = false;\n    for (var i in route2PoolIds) {\n      if (route1PoolIds.includes(route2PoolIds[i])) {\n        // a pool was shared between routes. need to calculate a new second route.\n        // console.log(\n        //   'a pool was shared between routes. going to calculate a new second route'\n        // );\n        sharedRoute = true;\n        break;\n      }\n    }\n  }\n\n  // NOTE -- this is a much simpler solution than that below. Instead of choosing the next best second route that doesn't share a\n  // pool with the first route, we could just use the first route and allocate all inputs to it.\n  // but, for larger transactions, it would be better to have option of two independent routes to spread out slippage.\n\n  // if (sharedRoute) {\n  //   filteredRoutes = [filteredRoutes[0]];\n  //   filteredNodeRoutes = [filteredNodeRoutes[0]];\n  //   // TODO -- later can add in a second route that doesn't share a pool with first.\n  // }\n\n  // We're going to find the next-highest allocation route that doesn't share a pool with the first route.\n  if (sharedRoute) {\n    let allFilteredRoutes = [];\n    let allFilteredNodeRoutes = [];\n    for (var i in allSortedIndices) {\n      allFilteredRoutes.push(routes[allSortedIndices[i]]);\n      allFilteredNodeRoutes.push(nodeRoutes[allSortedIndices[i]]);\n    }\n    let firstRoute = allFilteredRoutes[0];\n    // console.log('first route is...');\n    // console.log(firstRoute);\n    let firstRoutePoolIds = firstRoute.map(pool => pool.id);\n    for (var i in allFilteredRoutes) {\n      if (!allFilteredRoutes[i].length) {\n        allFilteredRoutes[i] = [allFilteredRoutes[i]];\n      }\n    }\n    // console.log('FIRST ROUTE POOL IDS ARE');\n    // console.log(firstRoutePoolIds);\n    let allFilteredRouteIds = allFilteredRoutes.map(route =>\n      route.map(pool => pool.id)\n    );\n    // console.log('allFilteredRouteIds are ...');\n    // console.log(allFilteredRouteIds);\n    for (var i in allFilteredRouteIds) {\n      // console.log('i is', i);\n      // console.log('ALL FILTERED ROUTES [i] IS...');\n      // console.log(allFilteredRouteIds[i]);\n      for (var j in allFilteredRouteIds[i]) {\n        // console.log('j is', j);\n        // console.log('ALL FILTERED ROUTES [i][j] IS...');\n        // console.log(allFilteredRouteIds[i][j]);\n        if (firstRoutePoolIds.includes(allFilteredRouteIds[i][j])) {\n          break;\n        }\n\n        var secondRoute = allFilteredRoutes[i];\n        if (!secondRoute.length) {\n          secondRoute = [secondRoute];\n        }\n        filteredRoutes = [allFilteredRoutes[0], secondRoute];\n        filteredNodeRoutes = [\n          allFilteredNodeRoutes[0],\n          allFilteredNodeRoutes[i],\n        ];\n        break;\n      }\n    }\n    // console.log('new filteredRoutes are ...');\n    // console.log(filteredRoutes);\n    // console.log('new filtered Node routes are...');\n    // console.log(filteredNodeRoutes);\n  }\n\n  // let filteredAllocations_check = getBestOptInput(\n  //   filteredRoutes,\n  //   filteredNodeRoutes,\n  //   totalInput\n  // );\n  // let filteredAllocationsAndOutputs = getOptOutputVecRefined(filteredRoutes, filteredNodeRoutes, totalInput);\n  let filteredAllocationsAndOutputs = getOptOutputVec(\n    filteredRoutes,\n    filteredNodeRoutes,\n    totalInput\n  );\n\n  let filteredAllocations = filteredAllocationsAndOutputs.allocations;\n  let filteredOutputs = filteredAllocationsAndOutputs.result;\n\n  filteredAllocations = checkIntegerSumOfAllocations(\n    filteredAllocations,\n    totalInput\n  ).map(stringAllo => new Big(stringAllo));\n\n  let hops = getActionListFromRoutesAndAllocations(\n    filteredRoutes,\n    filteredNodeRoutes,\n    filteredAllocations\n  );\n\n  var actions = [];\n  // console.log('hops are...');\n  // console.log(hops);\n\n  for (var i in hops) {\n    let hopInputTokenMeta = await ftGetTokenMetadata(hops[i].inputToken);\n    let hopOutputTokenMeta = await ftGetTokenMetadata(hops[i].outputToken);\n    let hopOutputTokenDecimals = hopOutputTokenMeta.decimals;\n\n    let expectedHopOutput = getOutputSingleHop(\n      hops[i].pool,\n      hops[i].inputToken,\n      hops[i].outputToken,\n      hops[i].allocation\n    );\n    let decimalEstimate = new Big(expectedHopOutput)\n      .div(new Big(10).pow(hopOutputTokenDecimals))\n      .toString();\n\n    // Need to check if expected Hop Output is > 1. If not, then cull the corresponding pool and re-calculate.\n    if (new Big(expectedHopOutput).lt(new Big(1))) {\n      // purge the pool and recalculate.\n\n      decimalsCulledPoolIds.push(hops[i].pool.id);\n      return getSmartRouteSwapActions(\n        pools,\n        inputToken,\n        outputToken,\n        totalInput,\n        (maxPathLength = maxPathLength),\n        (threshold = threshold),\n        (numberOfRoutesLimit = numberOfRoutesLimit),\n        (MAX_NUMBER_PARALLEL_POOLS = MAX_NUMBER_PARALLEL_POOLS),\n        (decimalsCulledPoolIds = decimalsCulledPoolIds)\n      );\n    }\n\n    if (\n      hops[i].inputToken == inputToken &&\n      hops[i].outputToken == outputToken\n    ) {\n      var status = 'parallel swap';\n    } else {\n      var status = 'stableSmart';\n    }\n\n    let tokens = await Promise.all(\n      hops[i].nodeRoute.map(async t => await ftGetTokenMetadata(t))\n    );\n\n    actions[i] = {\n      estimate: decimalEstimate,\n      pool: {\n        fee: hops[i].pool.fee,\n        gamma_bps: new Big(10000).minus(new Big(hops[i].pool.fee)), //.div(new Big(10000)), //hops[i].pool.gamma, //new Big(10000).minus(new Big(hops[i].pool.fee)).div(new Big(10000));\n        id: hops[i].pool.id,\n        partialAmountIn: new Big(hops[i].allocation).round().toString(),\n        supplies: {\n          [hops[i].pool.token1Id]: hops[i].pool.token1Supply,\n          [hops[i].pool.token2Id]: hops[i].pool.token2Supply,\n        },\n        token0_ref_price: hops[i].pool.token0_price,\n        tokenIds: [hops[i].pool.token1Id, hops[i].pool.token2Id],\n        Dex: hops[i].pool.Dex,\n      },\n      status: status,\n      token: hopInputTokenMeta,\n      outputToken: hops[i].outputToken,\n      inputToken: hops[i].inputToken,\n      nodeRoute: hops[i].nodeRoute,\n      route: hops[i].route,\n      allRoutes: hops[i].allRoutes,\n      allNodeRoutes: hops[i].allNodeRoutes,\n      totalInputAmount: hops[i].totalInputAmount,\n      allAllocations: hops[i].allAllocations,\n      tokens: tokens,\n      routeInputToken: inputToken,\n      routeOutputToken: outputToken,\n      overallPriceImpact: '0',\n    };\n    // console.log('INPUT TOKEN IS...');\n    // console.log(hops[i].inputToken);\n    actions[i].pool.x = actions[i].pool.supplies[hops[i].inputToken];\n    actions[i].pool.y = actions[i].pool.supplies[hops[i].outputToken];\n  }\n  // now set partial amount in for second hops equal to zero:\n  // also, set the total price impact value.\n  let overallPriceImpact = await calculateSmartRouteV2PriceImpact(actions);\n  for (var i in actions) {\n    let action = actions[i];\n    action.overallPriceImpact = overallPriceImpact;\n    if (action.outputToken === outputToken && action.inputToken != inputToken) {\n      // only want to set second hop partial amount in to zero\n      action.pool.partialAmountIn = '0';\n    }\n  }\n\n  return actions;\n}\n\nasync function calculateSmartRouteV2PriceImpact(actions) {\n  // the goal is to take a weighted average of the price impact per route, treating each one at a time.\n  // for single hop (parallel swaps), the price impact is calculated as before.\n  // for double-hop, the market price, P, is determined using reserves of tokens in each pool in the route.\n  // in both cases, we compare the 'market price', P , determined solely by reserves in pools, and the actual\n  // average price, R,  expected to be paid in the transaction.\n  // the price impact is then defined as (P-R)/R * 100 and is a percentage number, returned as a string.\n\n  let deltaY = actions\n    .filter(a => a.outputToken == a.routeOutputToken)\n    .map(a => new Big(a.estimate))\n    .reduce((a, b) => a.plus(b), new Big(0));\n  // console.log('DELTA Y IS...');\n  // console.log(deltaY.toString());\n\n  let inputTokenMeta = actions[0].tokens[0];\n  let deltaX = new Big(actions[0].totalInputAmount).div(\n    new Big(10).pow(inputTokenMeta.decimals)\n  );\n  let R = deltaY.div(deltaX);\n  var P = new Big(0);\n  let routes = actions[0].allRoutes;\n  let nodeRoutes = actions[0].allNodeRoutes;\n  let allocations = actions[0].allAllocations.map(a => new Big(a));\n  let totalAllocations = allocations\n    .map(a => new Big(a))\n    .reduce((a, b) => a.plus(b), new Big(0));\n\n  let weights = allocations.map(a => a.div(totalAllocations));\n\n  for (var i in routes) {\n    let route = routes[i];\n    let nodeRoute = nodeRoutes[i];\n    let tokens = await Promise.all(\n      nodeRoute.map(async t => await ftGetTokenMetadata(t))\n    );\n    let weight = weights[i];\n    if (route.length == 1) {\n      let num = new Big(route[0].reserves[nodeRoute[0]]).div(\n        new Big(10).pow(tokens[0].decimals)\n      );\n      let denom = new Big(route[0].reserves[nodeRoute[1]]).div(\n        new Big(10).pow(tokens[1].decimals)\n      );\n      var routeMarketPrice = num.div(denom);\n    } else {\n      let num1 = new Big(route[0].reserves[nodeRoute[0]]).div(\n        new Big(10).pow(tokens[0].decimals)\n      );\n\n      let denom1 = new Big(route[0].reserves[nodeRoute[1]]).div(\n        new Big(10).pow(tokens[1].decimals)\n      );\n\n      let num2 = new Big(route[1].reserves[nodeRoute[1]]).div(\n        new Big(10).pow(tokens[1].decimals)\n      );\n\n      let denom2 = new Big(route[1].reserves[nodeRoute[2]]).div(\n        new Big(10).pow(tokens[2].decimals)\n      );\n\n      var routeMarketPrice = num1\n        .div(denom1)\n        .times(num2)\n        .div(denom2);\n    }\n    P = P.plus(weight.times(new Big(1).div(routeMarketPrice)));\n  }\n\n  let priceImpact = P.minus(R)\n    .div(R)\n    .times(new Big(100))\n    .toString();\n  return priceImpact;\n}\n\nfunction decor(arr) {\n  var res = [];\n  for (var i in arr) {\n    res.push([arr[i], i]);\n  }\n  return res;\n}\nfunction argsort(arr) {\n  let undecor = a => a[1]; // leave only index\n  let decorated = decor(arr);\n\n  return decorated\n    .sort((a, b) => new Big(b[0]).minus(new Big(a[0])))\n    .map(undecor);\n}\n\nfunction getPoolsByToken1ORToken2(pools, token1, token2) {\n  let filteredPools = pools.filter(\n    item =>\n      item.token1Id === token1 ||\n      item.token2Id === token1 ||\n      item.token1Id === token2 ||\n      item.token2Id === token2\n  );\n  return filteredPools;\n}\n\nfunction getPoolsByToken1ANDToken2(\n  pools,\n  token1,\n  token2,\n  cullZeroLiquidityPools = true\n) {\n  let filteredPools = pools.filter(\n    item =>\n      (item.token1Id === token1 && item.token2Id === token2) ||\n      (item.token1Id === token2 && item.token2Id === token1)\n  );\n  if (cullZeroLiquidityPools) {\n    filteredPools = filteredPools.filter(\n      item => item.token1Supply != '0' && item.token2Supply != '0'\n    );\n  }\n  return filteredPools;\n}\n\nfunction getLiqudityOfPoolsFromList(pools) {\n  let liquidities = [];\n  for (var poolInd in pools) {\n    let pool = pools[poolInd];\n    pool.amounts = [pool.token1Supply, pool.token2Supply];\n    let poolBigAmounts = pool.amounts.map(item => new Big(item));\n    let liquidity = poolBigAmounts[0].times(poolBigAmounts[1]);\n    liquidities.push(liquidity);\n  }\n  return liquidities;\n}\n\nfunction getNormalizedLiquiditiesFromList(pools) {\n  let liquidities = getLiqudityOfPoolsFromList(pools);\n  let maxLiq = bigMax(liquidities);\n  let normalizedLiquidities = liquidities.map(item => item.div(maxLiq));\n  return normalizedLiquidities;\n}\n\nfunction bigMax(arrayOfBigs) {\n  if (arrayOfBigs.length < 1) {\n    return null;\n  }\n  let maxElem = arrayOfBigs[0];\n  for (var ind in arrayOfBigs) {\n    let val = arrayOfBigs[ind];\n    if (val.gt(maxElem)) {\n      maxElem = val;\n    }\n  }\n  return maxElem;\n}\n\nfunction cullPoolsWithInsufficientLiquidity(pools, threshold = 0.0001) {\n  var thresh = new Big(threshold);\n  let normLiq = getNormalizedLiquiditiesFromList(pools);\n  let filteredPools = [];\n  for (var i = 0; i < normLiq.length; i++) {\n    if (normLiq[i] > thresh) {\n      filteredPools.push(pools[i]);\n    }\n  }\n  return filteredPools;\n}\n\nfunction cartesianProduct(a) {\n  let result = a.reduce((a, b) => a.flatMap(d => b.map(e => [d, e].flat())));\n  return result;\n}\n\nfunction addEdge(g, edge) {\n  let src = edge[0];\n  let dst = edge[1];\n  if (Object.keys(g).includes(src)) {\n    if (!Object.keys(g[src]).includes(dst)) {\n      g[src][dst] = 1;\n    }\n  } else {\n    g[src] = {};\n    g[src][dst] = 1;\n  }\n  if (Object.keys(g).includes(dst)) {\n    if (!Object.keys(g[dst]).includes(src)) {\n      g[dst][src] = 1;\n    }\n  } else {\n    g[dst] = {};\n    g[dst][src] = 1;\n  }\n}\n\nfunction addEdges(g, edgeList) {\n  for (var n in edgeList) {\n    let edge = edgeList[n];\n    addEdge(g, edge);\n  }\n}\n\nfunction deleteEdge(g, edge) {\n  let gNew = JSON.parse(JSON.stringify(g)); // using this to deep clone graph structure\n  let e1 = edge[0];\n  let e2 = edge[1];\n  if (Object.keys(gNew).includes(e1)) {\n    if (Object.keys(gNew[e1]).includes(e2)) {\n      delete gNew[e1][e2];\n    }\n  }\n  if (Object.keys(gNew).includes(e2)) {\n    if (Object.keys(gNew[e2]).includes(e1)) {\n      delete gNew[e2][e1];\n    }\n  }\n  return gNew;\n}\n\nfunction deleteNode(g, node) {\n  let gNew = JSON.parse(JSON.stringify(g)); // using this to deep clone graph structure\n  if (Object.keys(gNew).includes(node)) {\n    delete gNew[node];\n  }\n  let keys = Object.keys(gNew);\n  for (var nodeInd in keys) {\n    let nodeNow = keys[nodeInd];\n    if (Object.keys(gNew[nodeNow]).includes(node)) {\n      delete gNew[nodeNow][node];\n    }\n  }\n  return gNew;\n}\n\nfunction dijkstra(graph, s) {\n  var solutions = {};\n  solutions[s] = {};\n  solutions[s].path = [];\n  solutions[s].dist = 0;\n\n  while (true) {\n    var parent = null;\n    var nearest = null;\n    var dist = Infinity;\n\n    //for each existing solution\n    for (var n in solutions) {\n      if (!solutions[n]) {\n        solutions[n] = {};\n      }\n      if (!solutions[n].path) continue;\n      var ndist = solutions[n].dist;\n      var adj = graph[n];\n      //for each of its adjacent nodes...\n      for (var a in adj) {\n        //without a solution already...\n        if (!solutions[a]) {\n          solutions[a] = {};\n        }\n        if (solutions[a].path) continue;\n        //choose nearest node with lowest *total* cost\n        var d = adj[a] + ndist;\n        if (d < dist) {\n          //reference parent\n          parent = solutions[n].path;\n          nearest = a;\n          dist = d;\n        }\n      }\n    }\n\n    //no more solutions\n    if (dist === Infinity) {\n      break;\n    }\n\n    //extend parent's solution path\n    solutions[nearest].path = parent.concat(nearest);\n    //extend parent's cost\n    solutions[nearest].dist = dist;\n  }\n\n  return solutions;\n}\n\nfunction shortestPath(g, src, dst, ignore_nodes = [], ignore_edges = []) {\n  let gTemp = JSON.parse(JSON.stringify(g)); // using this to deep clone graph structure. If we can use lodash, could use  _.cloneDeep(obj)\n  // remove nodes\n  for (var nodeInd in ignore_nodes) {\n    let nodeNow = ignore_nodes[nodeInd];\n    gTemp = deleteNode(gTemp, nodeNow);\n  }\n  // remove edges\n  for (var edgeInd in ignore_edges) {\n    let edgeNow = ignore_edges[edgeInd];\n    gTemp = deleteEdge(gTemp, edgeNow);\n  }\n  let solution = dijkstra(gTemp, src)[dst];\n  solution.path.unshift(src); // original algorithm doesn't include source node in path\n  return solution;\n}\n\nfunction* count(firstval = 0, step = 1) {\n  let x = firstval;\n  while (true) {\n    yield x;\n    x = x + 1;\n  }\n}\n\nclass PathBuffer {\n  constructor() {\n    this.paths = [];\n    this.sortedpaths = [];\n    //this.counter = count();\n  }\n  len() {\n    return this.sortedpaths.length;\n  }\n\n  push(cost, path) {\n    if (path && !arrayContains(this.paths, path)) {\n      this.sortedpaths.push([cost, path]);\n      this.sortedpaths.sort(function(a, b) {\n        return a[0] - b[0];\n      });\n      //heappush(this.sortedpaths, (cost, this.counter.next().value,path));\n      this.paths.push(path);\n    }\n  }\n\n  pop() {\n    //let val = heappop(this.sortedpaths);\n    let val = this.sortedpaths.shift();\n    let cost = val[0];\n    let path = val[1];\n    this.paths.splice(this.paths.indexOf(path), 1);\n    return path;\n  }\n}\n\nfunction arrayEquals(a, b) {\n  return (\n    Array.isArray(a) &&\n    Array.isArray(b) &&\n    a.length === b.length &&\n    a.every((val, index) => val === b[index])\n  );\n}\n\nfunction arrayContains(arr, obj) {\n  // checks to see if the input array contains a reference object, obj, using\n  // JSON.stringify() .\n  let obj_json = JSON.stringify(obj);\n  for (var itemInd in arr) {\n    if (JSON.stringify(arr[itemInd]) == obj_json) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction* yenFromPy(g, source, target) {\n  //adapted from the python implementation in networkx.algorithms.simple_paths.shortest_simple_paths()\n  let listA = [];\n  let listB = new PathBuffer();\n  let prev_path = null;\n\n  while (true) {\n    if (!prev_path) {\n      let sol = shortestPath(g, source, target);\n      let length = sol.dist;\n      let path = sol.path;\n      listB.push(length, path);\n    } else {\n      let ignore_nodes = [];\n      let ignore_edges = [];\n      for (var i = 1; i < prev_path.length; i++) {\n        let root = prev_path.slice(0, i);\n        let root_length = root.length;\n        for (var pathInd in listA) {\n          let path = listA[pathInd];\n\n          if (arrayEquals(path.slice(0, i), root)) {\n            let edgeToIgnore = [path[i - 1], path[i]];\n            ignore_edges.push(edgeToIgnore);\n          }\n        }\n        try {\n          let sol = shortestPath(\n            g,\n            root[root.length - 1],\n            target,\n            (ignore_nodes = ignore_nodes),\n            (ignore_edges = ignore_edges)\n          );\n          let length = sol.dist;\n          let spur = sol.path;\n          let path = root.slice(0, root.length - 1).concat(spur);\n          listB.push(root_length + length, path);\n        } catch (e) {\n          //console.log(`yenFromPy error was... ${e}`)\n          //dont do anything.\n        }\n        ignore_nodes.push(root[root.length - 1]);\n      }\n    }\n    if (listB.sortedpaths) {\n      try {\n        let path = listB.pop();\n        yield path;\n        listA.push(path);\n        prev_path = path;\n      } catch (e) {\n        break;\n      }\n    } else {\n      break;\n    }\n  }\n}\n\nfunction getKShortestPaths(g, source, target, k, maxPathLength = 3) {\n  let paths = [];\n  if (maxPathLength < 2) {\n    var maxPathLength = 2;\n  }\n  let gen = yenFromPy(g, source, target);\n  for (var n = 1; n <= k; n++) {\n    try {\n      let res = gen.next().value;\n      if (res && !arrayContains(paths, res)) {\n        if (res.length > maxPathLength) {\n          // console.log(\n          //   `found all hops of length ${\n          //     maxPathLength - 1\n          //   } or less... breaking out of generator`\n          // );\n          break;\n        }\n        paths.push(res);\n      }\n    } catch (e) {\n      break;\n    }\n  }\n  return paths;\n}\n\nasync function getPathsFromPools(\n  pools,\n  inputToken,\n  outputToken,\n  maxPathLength = 3\n) {\n  let graph = getGraphFromPoolList(pools);\n  return getKShortestPaths(graph, inputToken, outputToken, 100, maxPathLength);\n}\n\nasync function getAllPathsBelowLengthN(g, source, target, N, limit = 100) {\n  // use Yen's algorithm to find the paths of length N or below between source and target nodes in graph g.\n\n  let paths = [];\n\n  let gen = await yenFromPy(g, source, target);\n  let currentPathLength = 0;\n  let count = 1;\n  while (currentPathLength <= N) {\n    //   console.log(`CURRENT PATH LENGTH IS ${currentPathLength}`)\n    try {\n      let res = await gen.next().value;\n      //   console.log(`RES IS ${res}`)\n      if (res && !arrayContains(paths, res)) {\n        if (res.length > currentPathLength) {\n          currentPathLength = res.length;\n          if (currentPathLength > N) {\n            break;\n          }\n        }\n        paths.push(res);\n      }\n      count = count + 1;\n      if (count > limit) {\n        break;\n      }\n    } catch (e) {\n      //   console.log(e)\n      break;\n    }\n  }\n  return paths;\n}\n\nfunction getGraphFromPoolList(poolList) {\n  let pools = poolList.filter(\n    item => item.token1Supply != '0' && item.token2Supply != '0'\n  );\n  let transitions = pools.map(item => [item.token1Id, item.token2Id]);\n  let g = {};\n  addEdges(g, transitions);\n  return g;\n}\n\n////////////////////////////////////\n\n// MAIN FUNCTION\n\n////////////////////////////////////\n\n// TODO -- incorporate the following integrated function, which tries to\n// account for stablecoins within the context of smart routing.\n\n//TODO -- need the right API / hooks for GETSTABLESWAPACTION function and GETPARALLELSWAPACTIONS functions.\n\n//TODO -- transform the actions generated in this function into tranaction to execute.\n\n//TRYING: GETSTABLESWAPACTION <==> instantSwapGetTransactions\n\nexport async function stableSmart(\n  pools,\n  inputToken,\n  outputToken,\n  totalInput,\n  slippageTolerance\n) {\n  let smartRouteActions = await getSmartRouteSwapActions(\n    pools,\n    inputToken,\n    outputToken,\n    totalInput,\n    slippageTolerance\n  );\n  return smartRouteActions;\n}\n\nexport function getExpectedOutputFromActionsORIG(actions, outputToken) {\n  return actions\n    .filter(item => item.outputToken === outputToken)\n    .map(item => new Big(item.estimate))\n    .reduce((a, b) => a.plus(b), new Big(0));\n}\n\nfunction getFeeForRoute(route) {\n  if (!route.length) {\n    route = [route];\n  }\n  if (route.length == 1) {\n    // Single Hop case\n    let p = route[0];\n    return p.fee;\n  } else if (route.length == 2) {\n    //Double Hop Case\n    let p1 = route[0];\n    let p2 = route[1];\n    let fee1 = p1.fee;\n    let fee2 = p2.fee;\n    return fee1 + fee2;\n  }\n}\n\nexport function getAverageFeeForRoutes(routes, nodeRoutes, totalInput) {\n  let normalizedAllocations = getOptimalAllocationForRoutes(\n    routes,\n    nodeRoutes,\n    totalInput\n  ).map(a => a.div(new Big(totalInput)));\n  let averageFee = 0;\n  for (var i in routes) {\n    averageFee += normalizedAllocations[i] * getFeeForRoute(routes[i]);\n  }\n  return averageFee;\n}\n","import { TokenMetadata, Pool, StablePool, EstimateSwapView } from './types';\nimport {\n  toReadableNumber,\n  toNonDivisibleNumber,\n  scientificNotationToString,\n} from './utils';\nimport Big from 'big.js';\nimport { SameInputTokenError, ZeroInputError, NoPoolError } from './error';\nimport { ONLY_ZEROS, toPrecision } from './utils';\nimport _ from 'lodash';\nimport { FEE_DIVISOR } from './constant';\nimport { getSwappedAmount } from './stable-swap';\nimport { ftGetTokenMetadata, ftGetTokensMetadata } from './ref';\nimport { isStablePool } from './utils';\nimport {\n  getStablePoolDecimal,\n  isStablePoolToken,\n  poolFormatter,\n} from './utils';\nimport {\n  stableSmart,\n  getExpectedOutputFromActionsORIG,\n  //@ts-ignore\n} from './smartRoutingLogic.js';\n\nexport interface SwapParams {\n  tokenIn: TokenMetadata;\n  tokenOut: TokenMetadata;\n  amountIn: string;\n  simplePools: Pool[];\n  options?: SwapOptions;\n}\n\nexport interface SwapOptions {\n  enableSmartRouting?: boolean;\n  stablePools?: Pool[];\n  stablePoolsDetail?: StablePool[];\n}\n\nexport const getSimplePoolEstimate = ({\n  tokenIn,\n  tokenOut,\n  pool,\n  amountIn,\n}: {\n  tokenIn: TokenMetadata;\n  tokenOut: TokenMetadata;\n  pool: Pool;\n  amountIn: string;\n}) => {\n  const amount_with_fee = Number(amountIn) * (FEE_DIVISOR - pool.fee);\n  const in_balance = toReadableNumber(\n    tokenIn.decimals,\n    pool.supplies[tokenIn.id]\n  );\n  const out_balance = toReadableNumber(\n    tokenOut.decimals,\n    pool.supplies[tokenOut.id]\n  );\n  const estimate = new Big(\n    (\n      (amount_with_fee * Number(out_balance)) /\n      (FEE_DIVISOR * Number(in_balance) + amount_with_fee)\n    ).toString()\n  ).toFixed();\n\n  return {\n    token: tokenIn,\n    estimate,\n    pool,\n    outputToken: tokenOut.id,\n    inputToken: tokenIn.id,\n  };\n};\n\nexport const getStablePoolEstimate = ({\n  tokenIn,\n  tokenOut,\n  amountIn,\n  stablePool,\n}: {\n  tokenIn: TokenMetadata;\n  tokenOut: TokenMetadata;\n  amountIn: string;\n  stablePool: StablePool;\n}) => {\n  const STABLE_LP_TOKEN_DECIMALS = getStablePoolDecimal(stablePool);\n\n  const [amount_swapped, _, dy] = getSwappedAmount(\n    tokenIn.id,\n    tokenOut.id,\n    amountIn,\n    stablePool,\n    STABLE_LP_TOKEN_DECIMALS\n  );\n\n  const amountOut =\n    amount_swapped < 0 || isNaN(amount_swapped)\n      ? '0'\n      : toPrecision(scientificNotationToString(amount_swapped.toString()), 0);\n\n  const dyOut =\n    amount_swapped < 0 || isNaN(amount_swapped) || isNaN(dy)\n      ? '0'\n      : toPrecision(scientificNotationToString(dy.toString()), 0);\n\n  return {\n    estimate: toReadableNumber(STABLE_LP_TOKEN_DECIMALS, amountOut),\n    noFeeAmountOut: toReadableNumber(STABLE_LP_TOKEN_DECIMALS, dyOut),\n    pool: stablePool,\n    token: tokenIn,\n    outputToken: tokenOut.id,\n    inputToken: tokenIn.id,\n  };\n};\n\n/**\n * @description Get the estimate of the amount of tokenOut that can be received\n *\n */\nexport const singlePoolSwap = ({\n  tokenIn,\n  tokenOut,\n  simplePools,\n  amountIn,\n  stablePools,\n}: {\n  tokenIn: TokenMetadata;\n  tokenOut: TokenMetadata;\n  simplePools: Pool[];\n  amountIn: string;\n  stablePools?: StablePool[];\n}) => {\n  if (!simplePools || simplePools.length === 0) {\n    throw NoPoolError;\n  }\n\n  // const pools = simplePools.concat(stablePools);\n\n  const simplePoolsThisPair = simplePools.filter(\n    p => p.tokenIds.includes(tokenIn.id) && p.tokenIds.includes(tokenOut.id)\n  );\n\n  const estimatesSimplePool = simplePoolsThisPair.map(pool =>\n    getSimplePoolEstimate({\n      tokenIn,\n      tokenOut,\n      pool,\n      amountIn,\n    })\n  );\n\n  const stablePoolThisPair = stablePools?.filter(\n    sp =>\n      sp.token_account_ids.includes(tokenIn.id) &&\n      sp.token_account_ids.includes(tokenOut.id)\n  );\n\n  // different stable lp token decimal for different type of pools\n  const estimatesStablePool = stablePoolThisPair?.map(stablePool =>\n    getStablePoolEstimate({\n      tokenIn,\n      tokenOut,\n      amountIn,\n      stablePool,\n    })\n  );\n\n  const maxSimplePoolEstimate =\n    estimatesSimplePool.length === 1\n      ? estimatesSimplePool[0]\n      : _.maxBy(estimatesSimplePool, estimate => Number(estimate.estimate));\n\n  if (!estimatesStablePool) return maxSimplePoolEstimate;\n\n  const maxStablePoolEstimate =\n    estimatesStablePool.length === 1\n      ? estimatesStablePool[0]\n      : _.maxBy(estimatesStablePool, estimate => Number(estimate.estimate));\n\n  return Number(maxSimplePoolEstimate?.estimate) >\n    Number(maxStablePoolEstimate?.estimate)\n    ? maxSimplePoolEstimate\n    : maxStablePoolEstimate;\n};\n\nexport const getStablePoolsThisPair = ({\n  tokenInId,\n  tokenOutId,\n  stablePools,\n}: {\n  tokenInId: string;\n  tokenOutId: string;\n  stablePools: Pool[];\n}) => {\n  return stablePools.filter(\n    p =>\n      p.tokenIds.includes(tokenInId) &&\n      p.tokenIds.includes(tokenOutId) &&\n      tokenInId !== tokenOutId\n  );\n};\n\nexport const getPoolsByTokens = ({\n  pools,\n  tokenInId,\n  tokenOutId,\n}: {\n  pools: Pool[];\n  tokenInId: string;\n  tokenOutId: string;\n}) => {\n  if (tokenInId === tokenOutId) return [];\n\n  return pools.filter(\n    p => p.tokenIds.includes(tokenInId) && p.tokenIds.includes(tokenOutId)\n  );\n};\n\nexport const getPoolEstimate = async ({\n  tokenIn,\n  tokenOut,\n  amountIn,\n  stablePoolDetail,\n  pool,\n}: {\n  tokenIn: TokenMetadata;\n  tokenOut: TokenMetadata;\n  amountIn: string;\n  pool: Pool;\n  stablePoolDetail?: StablePool;\n}) => {\n  if (!!stablePoolDetail) {\n    return getStablePoolEstimate({\n      tokenIn,\n      tokenOut,\n      stablePool: stablePoolDetail,\n      amountIn,\n    });\n  } else {\n    return getSimplePoolEstimate({\n      tokenIn,\n      tokenOut,\n      pool,\n      amountIn,\n    });\n  }\n};\n\nexport async function getHybridStableSmart(\n  tokenIn: TokenMetadata,\n  tokenOut: TokenMetadata,\n  amountIn: string,\n  stablePools: Pool[],\n  stablePoolsDetail: StablePool[],\n  simplePools: Pool[]\n) {\n  if (\n    !isStablePoolToken(stablePoolsDetail, tokenIn.id) &&\n    !isStablePoolToken(stablePoolsDetail, tokenOut.id)\n  ) {\n    return { actions: [], estimate: '0' };\n  }\n\n  const stablePoolsDetailById = stablePoolsDetail.reduce((acc, cur) => {\n    return {\n      ...acc,\n      [cur.id]: cur,\n    };\n  }, {} as Record<string, StablePool>);\n\n  const parsedAmountIn = toNonDivisibleNumber(tokenIn.decimals, amountIn);\n\n  let pool1: Pool, pool2: Pool;\n\n  let pools1: Pool[] = [];\n  let pools2: Pool[] = [];\n\n  let pools1Right: Pool[] = [];\n  let pools2Right: Pool[] = [];\n\n  let candidatePools: Pool[][] = [];\n\n  /**\n   * find possible routes for this pair\n   *\n   *\n   */\n\n  if (isStablePoolToken(stablePoolsDetail, tokenIn.id)) {\n    // first hop will be through stable pool.\n    pools1 = stablePools.filter(pool => pool.tokenIds.includes(tokenIn.id));\n\n    const otherStables = pools1\n      .map(pool => pool.tokenIds.filter(id => id !== tokenIn.id))\n      .flat();\n\n    for (var otherStable of otherStables) {\n      let stablePoolsThisPair = getStablePoolsThisPair({\n        tokenInId: otherStable,\n        tokenOutId: tokenOut.id,\n        stablePools,\n      });\n\n      let tmpPools = getPoolsByTokens({\n        tokenInId: otherStable,\n        tokenOutId: tokenOut.id,\n        pools: simplePools,\n      });\n      const tobeAddedPools = tmpPools.concat(stablePoolsThisPair);\n      pools2.push(\n        ...tobeAddedPools.filter(p => {\n          const supplies = Object.values(p.supplies);\n          return new Big(supplies[0]).times(new Big(supplies[1])).gt(0);\n        })\n      );\n    }\n  }\n\n  if (isStablePoolToken(stablePoolsDetail, tokenOut.id)) {\n    // second hop will be through stable pool.\n    pools2Right = stablePools.filter(pool =>\n      pool.tokenIds.includes(tokenOut.id)\n    );\n\n    const otherStables = pools2Right\n      .map(pool => pool.tokenIds.filter(id => id !== tokenOut.id))\n      .flat();\n    for (let otherStable of otherStables) {\n      let stablePoolsThisPair = getStablePoolsThisPair({\n        tokenInId: tokenIn.id,\n        tokenOutId: otherStable,\n        stablePools,\n      });\n\n      let tmpPools = getPoolsByTokens({\n        tokenInId: tokenIn.id,\n        tokenOutId: otherStable,\n        pools: simplePools,\n      });\n\n      const tobeAddedPools = tmpPools.concat(stablePoolsThisPair);\n\n      pools1Right.push(\n        ...tobeAddedPools.filter(p => {\n          const supplies = Object.values(p.supplies);\n          return new Big(supplies[0]).times(new Big(supplies[1])).gt(0);\n        })\n      );\n    }\n  }\n\n  // find candidate pools\n\n  for (let p1 of pools1) {\n    let middleTokens = p1.tokenIds.filter((id: string) => id !== tokenIn.id);\n    for (let middleToken of middleTokens) {\n      let p2s = pools2.filter(\n        p =>\n          p.tokenIds.includes(middleToken) &&\n          p.tokenIds.includes(tokenOut.id) &&\n          middleToken !== tokenOut.id\n      );\n      let p2 = _.maxBy(p2s, p =>\n        Number(\n          new Big(toReadableNumber(tokenOut.decimals, p.supplies[tokenOut.id]))\n        )\n      );\n\n      if (middleToken === tokenOut.id) {\n        p2 = p1;\n      }\n\n      if (p1 && p2) {\n        if (p1.id === p2.id) candidatePools.push([p1]);\n        else candidatePools.push([p1, p2]);\n      }\n    }\n  }\n  for (let p1 of pools1Right) {\n    let middleTokens = p1.tokenIds.filter((id: string) => id !== tokenIn.id);\n    for (let middleToken of middleTokens) {\n      let p2s = pools2Right.filter(\n        p =>\n          p.tokenIds.includes(middleToken) &&\n          p.tokenIds.includes(tokenOut.id) &&\n          middleToken !== tokenOut.id\n      );\n      let p2 = _.maxBy(p2s, p =>\n        Number(\n          new Big(toReadableNumber(tokenOut.decimals, p.supplies[tokenOut.id]))\n        )\n      );\n\n      if (middleToken === tokenOut.id) {\n        p2 = p1;\n      }\n\n      if (p1 && p2) {\n        if (p1.id === p2.id) candidatePools.push([p1]);\n        else candidatePools.push([p1, p2]);\n      }\n    }\n  }\n\n  if (candidatePools.length > 0) {\n    const tokensMedata = await ftGetTokensMetadata(\n      candidatePools.map(cp => cp.map(p => p.tokenIds).flat()).flat()\n    );\n\n    const BestPoolPair =\n      candidatePools.length === 1\n        ? candidatePools[0]\n        : _.maxBy(candidatePools, poolPair => {\n            // only one pool case, only for stable tokens\n            if (poolPair.length === 1) {\n              if (isStablePool(stablePoolsDetail, poolPair[0].id)) {\n                const stablePoolThisPair = getStablePoolsThisPair({\n                  tokenInId: tokenIn.id,\n                  tokenOutId: tokenOut.id,\n                  stablePools,\n                })[0];\n\n                const stablePoolDetailThisPair = stablePoolsDetail.find(\n                  spd => spd.id === stablePoolThisPair.id\n                );\n\n                return Number(\n                  getStablePoolEstimate({\n                    tokenIn,\n                    tokenOut,\n                    stablePool: stablePoolDetailThisPair as StablePool,\n                    amountIn,\n                  }).estimate\n                );\n              } else {\n                return Number(\n                  getSimplePoolEstimate({\n                    tokenIn,\n                    tokenOut,\n                    amountIn,\n                    pool: poolPair[0],\n                  }).estimate\n                );\n              }\n            }\n\n            const [tmpPool1, tmpPool2] = poolPair;\n            const tokenMidId = poolPair[0].tokenIds.find((t: string) =>\n              poolPair[1].tokenIds.includes(t)\n            ) as string;\n\n            const tokenMidMeta = tokensMedata[tokenMidId];\n\n            const estimate1 = {\n              ...(isStablePool(stablePoolsDetail, tmpPool1.id)\n                ? getStablePoolEstimate({\n                    tokenIn,\n                    tokenOut: tokenMidMeta,\n                    amountIn,\n                    stablePool: stablePoolsDetailById[tmpPool1.id],\n                  })\n                : getSimplePoolEstimate({\n                    tokenIn,\n                    tokenOut: tokenMidMeta,\n                    amountIn,\n                    pool: tmpPool1,\n                  })),\n            };\n\n            const estimate2 = {\n              ...(isStablePool(stablePoolsDetail, tmpPool2.id)\n                ? getStablePoolEstimate({\n                    tokenIn: tokenMidMeta,\n                    tokenOut,\n                    amountIn: estimate1.estimate,\n                    stablePool: stablePoolsDetailById[tmpPool2.id],\n                  })\n                : getSimplePoolEstimate({\n                    tokenIn: tokenMidMeta,\n                    tokenOut,\n                    pool: tmpPool2,\n                    amountIn: estimate1.estimate,\n                  })),\n            };\n\n            return Number(estimate2.estimate);\n          });\n\n    // one pool case only get best price\n\n    if (!BestPoolPair) return { actions: [], estimate: '0' };\n\n    if (BestPoolPair.length === 1) {\n      const bestPool = BestPoolPair[0];\n      const estimate = await getPoolEstimate({\n        tokenIn,\n        tokenOut,\n        amountIn,\n        pool: bestPool,\n        stablePoolDetail: stablePoolsDetailById[bestPool.id],\n      });\n\n      return {\n        actions: [\n          {\n            ...estimate,\n            pool: { ...bestPool, parsedAmountIn: parsedAmountIn },\n            tokens: [tokenIn, tokenOut],\n            inputToken: tokenIn.id,\n            outputToken: tokenOut.id,\n            totalInputAmount: toNonDivisibleNumber(tokenIn.decimals, amountIn),\n          },\n        ],\n        estimate: estimate.estimate,\n      };\n    }\n\n    // two pool case get best price\n    [pool1, pool2] = BestPoolPair;\n\n    const tokenMidId = BestPoolPair[0].tokenIds.find((t: string) =>\n      BestPoolPair[1].tokenIds.includes(t)\n    ) as string;\n\n    const tokenMidMeta = await ftGetTokenMetadata(tokenMidId);\n\n    const estimate1 = {\n      ...(isStablePool(stablePoolsDetail, pool1.id)\n        ? getStablePoolEstimate({\n            tokenIn,\n            tokenOut: tokenMidMeta,\n            amountIn,\n            stablePool: stablePoolsDetailById[pool1.id],\n          })\n        : getSimplePoolEstimate({\n            tokenIn,\n            tokenOut: tokenMidMeta,\n            amountIn,\n            pool: pool1,\n          })),\n      tokens: [tokenIn, tokenMidMeta, tokenOut],\n      inputToken: tokenIn.id,\n      outputToken: tokenMidMeta.id,\n    };\n\n    estimate1.pool.partialAmountIn = parsedAmountIn;\n\n    const estimate2 = {\n      ...(isStablePool(stablePoolsDetail, pool2.id)\n        ? getStablePoolEstimate({\n            tokenIn: tokenMidMeta,\n            tokenOut,\n            amountIn: estimate1.estimate,\n            stablePool: stablePoolsDetailById[pool2.id],\n          })\n        : getSimplePoolEstimate({\n            tokenIn: tokenMidMeta,\n            tokenOut,\n            amountIn: estimate1.estimate,\n            pool: pool2,\n          })),\n\n      tokens: [tokenIn, tokenMidMeta, tokenOut],\n      inputToken: tokenMidMeta.id,\n      outputToken: tokenOut.id,\n    };\n\n    return { actions: [estimate1, estimate2], estimate: estimate2.estimate };\n  }\n\n  return { actions: [], estimate: '0' };\n}\n\n// simple pools and stable pools for this pair\nexport const estimateSwap = async ({\n  tokenIn,\n  tokenOut,\n  amountIn,\n  simplePools,\n  options,\n}: SwapParams) => {\n  if (tokenIn.id === tokenOut.id) throw SameInputTokenError;\n\n  if (ONLY_ZEROS.test(amountIn)) throw ZeroInputError;\n\n  const { enableSmartRouting, stablePools, stablePoolsDetail } = options || {};\n\n  const parsedAmountIn = toNonDivisibleNumber(tokenIn.decimals, amountIn);\n\n  if (!enableSmartRouting) {\n    const estimate = singlePoolSwap({\n      tokenIn,\n      tokenOut,\n      simplePools,\n      amountIn,\n      stablePools: stablePoolsDetail,\n    });\n\n    return [\n      {\n        ...estimate,\n        pool: { ...estimate?.pool, partialAmountIn: parsedAmountIn },\n      },\n    ] as EstimateSwapView[];\n  } else {\n    const inputPools = simplePools.map(p => poolFormatter(p));\n\n    const simplePoolSmartRoutingActions = await stableSmart(\n      inputPools,\n      tokenIn.id,\n      tokenOut.id,\n      parsedAmountIn\n    );\n\n    const simplePoolSmartRoutingEstimate = getExpectedOutputFromActionsORIG(\n      simplePoolSmartRoutingActions,\n      tokenOut.id\n    ).toString();\n\n    const hybridSmartRoutingRes = await getHybridStableSmart(\n      tokenIn,\n      tokenOut,\n      amountIn,\n      stablePools || [],\n      stablePoolsDetail || [],\n      simplePools\n    );\n\n    const hybridSmartRoutingEstimate = hybridSmartRoutingRes.estimate.toString();\n\n    if (\n      new Big(simplePoolSmartRoutingEstimate || '0').gte(\n        hybridSmartRoutingEstimate || '0'\n      )\n    ) {\n      if (!simplePoolSmartRoutingActions?.length) throw NoPoolError;\n      return simplePoolSmartRoutingActions as EstimateSwapView[];\n    } else {\n      return hybridSmartRoutingRes.actions as EstimateSwapView[];\n    }\n  }\n};\n","import {\n  keyStores,\n  KeyPair,\n  InMemorySigner,\n  providers,\n  transactions as nearTransactions,\n} from 'near-api-js';\nimport { InMemoryKeyStore } from 'near-api-js/lib/key_stores';\nimport { getConfig } from './constant';\nimport { keyStore } from './ref';\n\n// const KEY_PATH = `/.near-credentials/testnet/juaner.testnet.json`;\n\nexport const provider = new providers.JsonRpcProvider({\n  url: getConfig().nodeUrl,\n});\n\nexport const getMemorySigner = ({\n  AccountId,\n  keyPath,\n}: {\n  AccountId: string;\n  keyPath: string;\n}) => {\n  const homedir = require('os').homedir();\n  const CREDENTIALS_DIR = '.near-credentials';\n  const credentialsPath = require('path').join(homedir, CREDENTIALS_DIR);\n  const myKeyStore = new keyStores.UnencryptedFileSystemKeyStore(\n    credentialsPath\n  );\n  // myKeyStore.setKey(\n  //   getConfig().networkId,\n  //   AccountId,\n  //   KeyPair.fromString(credentials.private_key)\n  // );\n\n  const signer = new InMemorySigner(myKeyStore);\n\n  console.log(signer);\n\n  // return signer;\n};\n\n// export const getSignedTransactions = async () => {\n//   const block = await provider.block({ finality: 'final' });\n\n//   for (let i = 0; i < transactions.length; i += 1) {\n//     const transaction = transactions[i];\n//     const publicKey = await signer.getPublicKey(\n//       transaction.signerId,\n//       getConfig().networkId\n//     );\n\n//     if (!publicKey) {\n//       throw new Error('No public key found');\n//     }\n\n//     const accessKey = await provider.query<AccessKeyView>({\n//       request_type: 'view_access_key',\n//       finality: 'final',\n//       account_id: transaction.signerId,\n//       public_key: publicKey.toString(),\n//     });\n\n//     if (!validateAccessKey(transaction, accessKey)) {\n//       throw new Error('Invalid access key');\n//     }\n\n//     const tx = nearTransactions.createTransaction(\n//       transactions[i].signerId,\n//       utils.PublicKey.from(publicKey.toString()),\n//       transactions[i].receiverId,\n//       accessKey.nonce + i + 1,\n//       transaction.actions.map(action => createAction(action)),\n//       utils.serialize.base_decode(block.header.hash)\n//     );\n\n//     const [, signedTx] = await nearTransactions.signTransaction(\n//       tx,\n//       signer,\n//       transactions[i].signerId,\n//       options.network.networkId\n//     );\n\n//     signedTransactions.push(signedTx);\n//   }\n// };\n"],"names":["getConfig","env","process","NEAR_ENV","networkId","nodeUrl","walletUrl","WRAP_NEAR_CONTRACT_ID","REF_FI_CONTRACT_ID","config","formatError","msg","Error","unNamedError","SameInputTokenError","ZeroInputError","NoPoolError","NotLoginError","SwapRouteError","TokenNotExistError","parsePool","pool","id","Number","tokenIds","token_account_ids","supplies","amounts","reduce","acc","amount","i","fee","total_fee","shareSupply","shares_total_supply","tvl","token0_ref_price","pool_kind","poolFormatter","token1Id","token2Id","token1Supply","token2Supply","shares","token0_price","isStablePoolToken","stablePools","tokenId","map","p","flat","includes","toString","isStablePool","poolId","getStablePoolDecimal","stablePool","round","decimals","minAmountOut","isInteger","Math","ceil","pow","convertToPercentDecimal","percent","math","percentOf","num","percentLess","notation","ONLY_ZEROS","toReadableNumber","number","substring","length","padStart","replace","toNonDivisibleNumber","split","padEnd","slice","scientificNotationToString","strParam","test","sysbol","negative","index","match","_strParam$match","basis","_strParam$match2","wholeStr","fractionStr","ifFraction","formatWithCommas","value","pattern","toPrecision","precision","withCommas","atLeastOne","whole","decimal","str","n","lastIndexOf","instantSwap","tokenIn","tokenOut","amountIn","slippageTolerance","transactions","swapTodos","at","outputToken","_context","actionsList","allSwapsTokens","s","inputToken","push","swapTokens","pool_id","token_in","token_out","amount_in","partialAmountIn","min_amount_out","estimate","receiverId","functionCalls","methodName","args","receiver_id","JSON","stringify","force","actions","gas","keyStore","keyStores","BrowserLocalStorageKeyStore","near","Near","headers","wallet","WalletConnection","refFiViewFunction","account","viewFunction","ftViewFunction","getTotalPools","ftGetTokenMetadata","_context2","ftGetTokensMetadata","_context3","Promise","all","pre","cur","getRatedPoolDetail","then","pool_info","getUnRatedPoolDetail","rates","c_amounts","_","getStablePoolsDetail","getRefPools","page","perPage","_context4","from_index","limit","rawPool","fetchAllRefPools","_context5","pages","Array","pools","simplePools","filter","unRatedPools","ratedPools","calc_d","amp","token_num","sum_amounts","sum","d_prev","d","d_prod","ann","abs","calc_y","x_c_amount","current_c_amounts","index_x","index_y","c","b","y_prev","y","calc_swap","in_token_idx","in_c_amount","out_token_idx","old_c_amounts","trade_fee","dy","tradeFee","getSwappedAmount","tokenInId","tokenOutId","STABLE_LP_TOKEN_DECIMALS","findIndex","r","Big","times","checkIntegerSumOfAllocations","allocations","totalInput","alloSum","item","a","plus","offset","minus","currMax","currMaxInd","gt","newAllocations","j","RM","DP","NE","PE","yenFromPy","bisqrt","BigInt","newtonIteration","x0","x1","getBetaForRoute","route","path","beta","reserves","p2","getEpsilonForRoute","gamma","div","epsilon","p1","gamma1","gamma2","getAlphaForRoute","key2","val2","alpha","key12","val12","key22","val22","middleToken","alpha1","alpha2","getAllocationForRoute","phi","toFixed","getNodeRoutesFromPathsAndPoolChains","paths","poolChains","multiplicity","mul","elem1","elem2","nodeRoutes","m","k","getPoolChainFromPaths","threshold","pathInd","chain","pairs","pairInd","pair","tokenPools","getPoolsByToken1ANDToken2","newChains","newPath","legInd","culledPath","cullPoolsWithInsufficientLiquidity","getCulledPoolChains","getRoutesFromPoolChain","routes","pci","newRoutes","flatMap","e","getOutputSingleHop","denom","getOutputFromRoute","nodeRoute","allocation","eq","output","poolIndex","c1","a1","c2","b2","getOutputDoubleHop","getOptOutputVec","getOptimalAllocationForRoutes","allocationVec","getAllocationVectorForRoutes","alphaSum","radical","getAlphaSumFromRoutes","betaSum","getBetaSumFromRoutes","getPhiFromRoutes","every","lt","some","goodIndices","newNodeRoutes","goodIndex","allocationDict","allocationVecNew","zeroAllocation","reduceRoutes","sumAllocations","result","getBestOptInputAndOutput","rawDict","outputRaw","inputRaw","input","v","bv1","bv2","getBestOptimalAllocationsAndOutputs","maxPathLength","_context6","getPathsFromPools","outputs","inputOutput","getActionListFromRoutesAndAllocations","hops","hop","allRoutes","allNodeRoutes","totalInputAmount","allAllocations","middleTokenAllocation","getHopActionsFromRoutes","getSmartRouteSwapActions","numberOfRoutesLimit","MAX_NUMBER_PARALLEL_POOLS","decimalsCulledPoolIds","_context9","resDict","sortedIndexValues","argsort","topIndices","reducedRoutes","reducedNodeRoutes","ind","currentBestOutput","bestAllocations","bestNodeRoutes","parallelNodeRoutes","parallelRoutes","bestRoutes","currentNodeRoute","bestRoutesAreParallel","filteredAllocationsAndOutputs","parallelOutputs","parallellAllocations","sortIndices","filteredParallelRoutes","filteredParallelNodeRoutes","parallelOutput","canHaveTwoRoutes","route1","route2","nodeRoute1","nodeRoute2","route1PoolIds","Set","route2PoolIds","sharePool","has","currentRoutes","currentNodeRoutes","filteredAllocations","totalOutput","allSortedIndices","sortedIndices","filteredRoutes","filteredNodeRoutes","sharedRoute","allFilteredRoutes","allFilteredNodeRoutes","firstRoutePoolIds","allFilteredRouteIds","secondRoute","stringAllo","hopInputTokenMeta","hopOutputTokenDecimals","expectedHopOutput","decimalEstimate","status","t","_context8","tokens","gamma_bps","Dex","token","routeInputToken","routeOutputToken","overallPriceImpact","x","calculateSmartRouteV2PriceImpact","action","deltaY","inputTokenMeta","deltaX","R","P","totalAllocations","weights","_context12","_context11","weight","routeMarketPrice","num1","denom1","num2","denom2","priceImpact","arr","res","decor","sort","token1","token2","cullZeroLiquidityPools","filteredPools","thresh","normLiq","liquidities","poolInd","poolBigAmounts","liquidity","getLiqudityOfPoolsFromList","maxLiq","arrayOfBigs","maxElem","val","bigMax","getNormalizedLiquiditiesFromList","addEdge","g","edge","src","dst","Object","keys","deleteEdge","gNew","parse","e1","e2","deleteNode","node","nodeInd","nodeNow","shortestPath","ignore_nodes","ignore_edges","gTemp","edgeInd","solution","graph","solutions","dist","parent","nearest","Infinity","ndist","adj","concat","dijkstra","unshift","PathBuffer","this","sortedpaths","len","cost","arrayContains","pop","shift","splice","indexOf","arrayEquals","isArray","obj","obj_json","itemInd","source","target","listA","listB","prev_path","root","root_length","sol","spur","getKShortestPaths","gen","next","getGraphFromPoolList","poolList","edgeList","addEdges","stableSmart","_context15","getExpectedOutputFromActionsORIG","getSimplePoolEstimate","amount_with_fee","in_balance","out_balance","getStablePoolEstimate","amount_swapped","amountOut","isNaN","dyOut","noFeeAmountOut","singlePoolSwap","estimatesSimplePool","stablePoolThisPair","sp","estimatesStablePool","maxSimplePoolEstimate","maxBy","maxStablePoolEstimate","getStablePoolsThisPair","getPoolsByTokens","getPoolEstimate","stablePoolDetail","getHybridStableSmart","stablePoolsDetail","stablePoolsDetailById","parsedAmountIn","pools1","pools2","pools1Right","pools2Right","candidatePools","otherStables","stablePoolsThisPair","otherStable","tmpPools","tobeAddedPools","values","middleTokens","_loop2","p2s","_loop","cp","tokensMedata","BestPoolPair","poolPair","stablePoolDetailThisPair","find","spd","tmpPool1","tmpPool2","tokenMidId","tokenMidMeta","estimate1","estimate2","bestPool","pool1","pool2","estimateSwap","options","enableSmartRouting","_ref10","inputPools","simplePoolSmartRoutingEstimate","simplePoolSmartRoutingActions","hybridSmartRoutingEstimate","hybridSmartRoutingRes","gte","provider","providers","JsonRpcProvider","url","accountId","getAccountId","account_id","BN","utils","format","parseNearAmount","homedir","require","credentialsPath","join","myKeyStore","UnencryptedFileSystemKeyStore","signer","InMemorySigner","console","log"],"mappings":"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"}