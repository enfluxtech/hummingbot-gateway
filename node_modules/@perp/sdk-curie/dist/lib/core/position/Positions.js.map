{"version":3,"file":"Positions.js","sources":["../../../../src/core/position/Positions.ts"],"sourcesContent":["import { BIG_ONE, BIG_ZERO, SETTLEMENT_TOKEN_DECIMAL } from \"../../constants\"\nimport { Channel, ChannelEventSource, DEFAULT_PERIOD, MemoizedFetcher, createMemoizedFetcher } from \"../../internal\"\nimport { Position, PositionType } from \"./Position\"\nimport { big2BigNumberAndScaleUp, bigNumber2BigAndScaleDown, fromSqrtX96, invariant, logger, poll } from \"../../utils\"\n\nimport Big from \"big.js\"\nimport { MarketMap } from \"../market\"\nimport { PerpetualProtocolConnected } from \"../PerpetualProtocol\"\nimport { PositionSide } from \"./types\"\nimport { UnauthorizedError } from \"../../errors\"\nimport { ContractCall, MulticallReader } from \"../contractReader\"\nimport { ContractName } from \"../../contracts\"\nimport { getPriceImpact, getSwapRate, getTransactionFee, getUnrealizedPnl } from \"../clearingHouse/utils\"\n\nexport interface FetchPositionsReturn {\n    takerPositions: Position[]\n    makerPositions: Position[]\n}\n\ntype PositionsEventName = \"updated\" | \"updateError\"\n\ntype ByMarketTickerSymbol<Value> = { [tickerSymbol: string]: Value }\n\ntype CacheKey =\n    | \"takerPositionSizeList\"\n    | \"takerOpenNotionalList\"\n    | \"totalPositionSizeList\"\n    | \"totalOpenNotionalList\"\n    | \"pendingFundingPayments\"\n    | \"liquidationPriceList\"\n    | \"totalPositionValueList\"\n    | \"totalAbsPositionValue\"\n\ntype CacheValue = Big[] | Big | ByMarketTickerSymbol<Big>\n\nexport class Positions extends Channel<PositionsEventName> {\n    private _cache: Map<CacheKey, CacheValue> = new Map()\n\n    constructor(private readonly _perp: PerpetualProtocolConnected) {\n        super(_perp.channelRegistry)\n    }\n\n    protected _getEventSourceMap() {\n        const fetchAndEmitUpdated = this.getPositionDataAll.bind(this)\n        const updateDataEventSource = new ChannelEventSource<PositionsEventName>({\n            eventSourceStarter: () => {\n                return poll(fetchAndEmitUpdated, this._perp.moduleConfigs?.positions?.period || DEFAULT_PERIOD).cancel\n            },\n            initEventEmitter: () => fetchAndEmitUpdated(),\n        })\n\n        // TODO: eventName typing protection, should error when invalid eventName is provided\n        return {\n            updated: updateDataEventSource,\n        }\n    }\n\n    async getTakerPositions({ cache = true } = {}) {\n        const marketMap = this._perp.markets.marketMap\n        const takerPositions: Position[] = []\n        const [takerPositionSizeList, takerOpenNotionalList, liquidationPriceList] = await Promise.all([\n            this._fetch(\"takerPositionSizeList\", { cache }),\n            this._fetch(\"takerOpenNotionalList\", { cache }),\n            this._fetch(\"liquidationPriceList\", { cache }),\n        ])\n        Object.values(marketMap).forEach((market, index) => {\n            const takerSizeOriginal = takerPositionSizeList[index]\n            const takerOpenNotionalOriginal = takerOpenNotionalList[index]\n            const liquidationPriceOriginal = liquidationPriceList[index]\n\n            if (!takerSizeOriginal.eq(0)) {\n                takerPositions.push(\n                    new Position({\n                        perp: this._perp,\n                        type: PositionType.TAKER,\n                        market,\n                        side: takerSizeOriginal.gte(0) ? PositionSide.LONG : PositionSide.SHORT,\n                        sizeAbs: takerSizeOriginal.abs(),\n                        openNotionalAbs: takerOpenNotionalOriginal.abs(),\n                        entryPrice: takerOpenNotionalOriginal.div(takerSizeOriginal).abs(),\n                        liquidationPrice: liquidationPriceOriginal,\n                    }),\n                )\n            }\n        })\n\n        return takerPositions\n    }\n\n    async getMakerPositions({ cache = true } = {}) {\n        const marketMap = this._perp.markets.marketMap\n        const [totalPositionSizeList, totalOpenNotionalList] = await Promise.all([\n            this._fetch(\"totalPositionSizeList\", { cache }),\n            this._fetch(\"totalOpenNotionalList\", { cache }),\n        ])\n        const takerPositions = await this.getTakerPositions({ cache })\n        const makerPositions: Position[] = []\n        Object.values(marketMap).forEach((market, index) => {\n            const takerPosition = takerPositions.find(\n                takerPosition => takerPosition.market.baseSymbol === market.baseSymbol,\n            )\n            const takerPositionSizeOriginal = takerPosition?.sizeOriginal || BIG_ZERO\n            const takerOpenNotionalOriginal = takerPosition?.openNotionalOriginal || BIG_ZERO\n\n            const totalPositionSizeOriginal = totalPositionSizeList[index]\n            const makerPositionSizeOriginal = totalPositionSizeOriginal.sub(takerPositionSizeOriginal)\n\n            const totalOpenNotionalOriginal = totalOpenNotionalList[index]\n            const makerOpenNotionalOriginal = totalOpenNotionalOriginal.sub(takerOpenNotionalOriginal)\n            if (!makerPositionSizeOriginal.eq(0)) {\n                makerPositions.push(\n                    new Position({\n                        perp: this._perp,\n                        type: PositionType.MAKER,\n                        market,\n                        side: makerPositionSizeOriginal.gte(0) ? PositionSide.LONG : PositionSide.SHORT,\n                        sizeAbs: makerPositionSizeOriginal.abs(),\n                        openNotionalAbs: makerOpenNotionalOriginal.abs(),\n                        entryPrice: makerOpenNotionalOriginal.div(makerPositionSizeOriginal).abs(),\n                    }),\n                )\n            }\n        })\n\n        return makerPositions\n    }\n\n    async getTakerPositionByTickerSymbol(tickerSymbol: string, { cache = true } = {}) {\n        const positions = await this.getTakerPositions({ cache })\n        return positions.find(position => position.market.tickerSymbol === tickerSymbol)\n    }\n\n    async getMakerPositionByTickerSymbol(tickerSymbol: string, { cache = true } = {}) {\n        const positions = await this.getMakerPositions({ cache })\n        return positions.find(position => position.market.tickerSymbol === tickerSymbol)\n    }\n\n    async getTakerPosition(baseAddress: string, { cache = true } = {}) {\n        const positions = await this.getTakerPositions({ cache })\n        return positions.find(position => position.market.baseAddress === baseAddress)\n    }\n\n    async getMakerPosition(baseAddress: string, { cache = true } = {}) {\n        const positions = await this.getMakerPositions({ cache })\n        return positions.find(position => position.market.baseAddress === baseAddress)\n    }\n\n    async getTotalPositionValue(baseAddress: string, { cache = true } = {}) {\n        const totalPositionValueList = await this._fetch(\"totalPositionValueList\", { cache })\n        const index = Object.values(this._perp.markets.marketMap).findIndex(\n            market => market.baseAddress === baseAddress,\n        )\n        if (index === -1) {\n            return BIG_ZERO\n        }\n        return totalPositionValueList[index]\n    }\n\n    async getTotalPositionValueFromAllMarkets({ cache = true } = {}) {\n        const totalMakerPositionValue = await this.getTotalMakerPositionValueFromAllMarkets({ cache })\n        const totalTakerPositionValue = await this.getTotalTakerPositionValueFromAllMarkets()\n        return totalMakerPositionValue.add(totalTakerPositionValue)\n    }\n\n    async getTotalTakerPositionValueFromAllMarkets({ cache = true } = {}) {\n        const takerPositions = await this.getTakerPositions({ cache })\n        let total = BIG_ZERO\n        for (const position of takerPositions) {\n            const sizeOriginal = position.sizeOriginal\n            const { indexPrice } = await position.market.getPrices({ cache })\n            total = total.add(sizeOriginal.mul(indexPrice))\n        }\n        return total\n    }\n\n    async getTotalMakerPositionValueFromAllMarkets({ cache = true } = {}) {\n        const makerPositions = await this.getMakerPositions({ cache })\n        let total = BIG_ZERO\n        for (const position of makerPositions) {\n            const sizeOriginal = position.sizeOriginal\n            const { indexPrice } = await position.market.getPrices({ cache })\n            total = total.add(sizeOriginal.mul(indexPrice))\n        }\n        return total\n    }\n\n    async getTotalUnrealizedPnlFromAllMarkets({ cache = true } = {}) {\n        const makerUnrealizedPnl = await this.getTotalMakerUnrealizedPnlFromAllMarkets({ cache })\n        const takerUnrealizedPnl = await this.getTotalTakerUnrealizedPnlFromAllMarkets({ cache })\n        const totalUnrealizedPnl = makerUnrealizedPnl.add(takerUnrealizedPnl)\n\n        return totalUnrealizedPnl\n    }\n\n    async getTotalTakerUnrealizedPnlFromAllMarkets({ cache = true } = {}) {\n        const takerPositions = await this.getTakerPositions({ cache })\n        let totalUnrealizedPnl = BIG_ZERO\n        for (const position of takerPositions) {\n            totalUnrealizedPnl = totalUnrealizedPnl.add(await position.getUnrealizedPnl())\n        }\n        return totalUnrealizedPnl\n    }\n\n    async getTotalMakerUnrealizedPnlFromAllMarkets({ cache = true } = {}) {\n        const makerPositions = await this.getMakerPositions({ cache })\n        let totalUnrealizedPnl = BIG_ZERO\n        for (const position of makerPositions) {\n            totalUnrealizedPnl = totalUnrealizedPnl.add(await position.getUnrealizedPnl())\n        }\n        return totalUnrealizedPnl\n    }\n\n    async getTotalPendingFundingPayments({ cache = true } = {}) {\n        return this._fetch(\"pendingFundingPayments\", { cache })\n    }\n\n    async getAccountMarginRatio({ cache = true } = {}) {\n        invariant(this._perp.hasConnected(), () => new UnauthorizedError({ functionName: \"getMarginRatio\" }))\n        const totalAbsPositionValue = await this._fetch(\"totalAbsPositionValue\", { cache })\n\n        if (totalAbsPositionValue.eq(0)) {\n            return\n        }\n\n        const accountValue = await this._perp.vault.getAccountValue({ cache })\n\n        return accountValue.div(totalAbsPositionValue)\n    }\n\n    async getAccountLeverage({ cache = true } = {}) {\n        const marginRatio = await this.getAccountMarginRatio({ cache })\n\n        if (!marginRatio || marginRatio?.eq(0)) {\n            return\n        }\n\n        return BIG_ONE.div(marginRatio)\n    }\n\n    private async _fetch(key: \"totalAbsPositionValue\", obj?: { cache: boolean }): Promise<Big>\n    private async _fetch(key: \"pendingFundingPayments\", obj?: { cache: boolean }): Promise<ByMarketTickerSymbol<Big>>\n    private async _fetch(\n        key: Exclude<CacheKey, \"totalAbsPositionValue\" | \"pendingFundingPayments\">,\n        obj?: { cache: boolean },\n    ): Promise<Big[]> // TODO: return ByMarketTickerSymbol<Big> instead of Big[]\n    private async _fetch(key: CacheKey, { cache = true } = {}) {\n        if (this._cache.has(key) && cache) {\n            return this._cache.get(key)\n        }\n\n        const marketMap = this._perp.markets.marketMap\n        const trader = this._perp.wallet.account\n        const args: [MarketMap, string] = [marketMap, trader]\n\n        let result\n        switch (key) {\n            case \"takerPositionSizeList\": {\n                result = await this._perp.contractReader.getTakerPositionSizeList(...args)\n                break\n            }\n            case \"takerOpenNotionalList\": {\n                result = await this._perp.contractReader.getTakerOpenNotionalList(...args)\n                break\n            }\n            case \"totalPositionSizeList\": {\n                result = await this._perp.contractReader.getTotalPositionSizeList(...args)\n                break\n            }\n            case \"totalOpenNotionalList\": {\n                result = await this._perp.contractReader.getTotalOpenNotionalList(...args)\n                break\n            }\n            case \"pendingFundingPayments\": {\n                result = await this._perp.contractReader.getPendingFundingPayments(...args)\n                break\n            }\n            case \"liquidationPriceList\": {\n                result = await this._perp.contractReader.getLiquidationPriceList(...args)\n                break\n            }\n            case \"totalPositionValueList\": {\n                result = await this._perp.contractReader.getTotalPositionValueList(...args)\n                break\n            }\n            case \"totalAbsPositionValue\": {\n                result = await this._perp.contractReader.getTotalAbsPositionValue(trader)\n                break\n            }\n        }\n\n        this._cache.set(key, result)\n\n        return result\n    }\n\n    protected async getPositionDataAll() {\n        try {\n            logger(\"getPositionDataAll\")\n            const marketMap = this._perp.markets.marketMap\n            const contracts = this._perp.contracts\n            const account = this._perp.wallet.account\n            const multicall2 = new MulticallReader({ contract: contracts.multicall2 })\n\n            // NOTE: prepare first batch multicall data\n            const callsMap: { [key: string]: ContractCall[] } = {}\n            Object.entries(marketMap).forEach(([tickerSymbol, market]) => {\n                const baseAddress = market.baseAddress\n                const poolAddress = market.poolAddress\n                const calls = [\n                    // NOTE: get taker position size\n                    {\n                        contract: contracts.accountBalance,\n                        contractName: ContractName.ACCOUNT_BALANCE,\n                        funcName: \"getTakerPositionSize\",\n                        funcParams: [account, baseAddress],\n                    },\n                    // NOTE: get taker open notional\n                    {\n                        contract: contracts.accountBalance,\n                        contractName: ContractName.ACCOUNT_BALANCE,\n                        funcName: \"getTakerOpenNotional\",\n                        funcParams: [account, baseAddress],\n                    },\n                    // NOTE: get liquidation price\n                    {\n                        contract: contracts.perpPortal,\n                        contractName: ContractName.PerpPortal,\n                        funcName: \"getLiquidationPrice\",\n                        funcParams: [account, baseAddress],\n                    },\n                    // NOTE: get total position size\n                    {\n                        contract: contracts.accountBalance,\n                        contractName: ContractName.ACCOUNT_BALANCE,\n                        funcName: \"getTotalPositionSize\",\n                        funcParams: [account, baseAddress],\n                    },\n                    // NOTE: get total open notional\n                    {\n                        contract: contracts.accountBalance,\n                        contractName: ContractName.ACCOUNT_BALANCE,\n                        funcName: \"getTotalOpenNotional\",\n                        funcParams: [account, baseAddress],\n                    },\n                    // NOTE: get funding payment\n                    {\n                        contract: contracts.exchange,\n                        contractName: ContractName.EXCHANGE,\n                        funcName: \"getPendingFundingPayment\",\n                        funcParams: [account, baseAddress],\n                    },\n                    // NOTE: get market index price\n                    {\n                        contract: contracts.baseToken.attach(baseAddress),\n                        contractName: ContractName.BASE_TOKEN,\n                        funcName: \"getIndexPrice\",\n                        funcParams: [0],\n                    },\n                    // NOTE: get market price\n                    {\n                        contract: contracts.pool.attach(poolAddress),\n                        contractName: ContractName.POOL,\n                        funcName: \"slot0\",\n                        funcParams: [],\n                    },\n                ]\n                callsMap[`${tickerSymbol}`] = calls\n            })\n\n            // NOTE: execute first batch multicall\n            const dataBatch1 = await multicall2.execute(Object.values(callsMap).flat(), {\n                failFirstByContract: false,\n                failFirstByClient: false,\n            })\n\n            // NOTE: analysis first batch multicall\n            const positionDataAllByMarket: PositionDataAllByMarket = {}\n            Object.entries(callsMap).forEach(([tickerSymbol, calls]) => {\n                const dataChunk = dataBatch1.splice(0, calls.length)\n                const takerPosSize = bigNumber2BigAndScaleDown(dataChunk[0])\n                const takerPosOpenNotional = bigNumber2BigAndScaleDown(dataChunk[1])\n                const takerPosLiquidationPrice = bigNumber2BigAndScaleDown(dataChunk[2])\n                const totalPosSize = bigNumber2BigAndScaleDown(dataChunk[3])\n                const totalPosOpenNotional = bigNumber2BigAndScaleDown(dataChunk[4])\n                const pendingFundingPayment = bigNumber2BigAndScaleDown(dataChunk[5])\n                const indexPrice = bigNumber2BigAndScaleDown(dataChunk[6])\n                const markPrice = fromSqrtX96(dataChunk[7].sqrtPriceX96)\n                let takerPosition: Position | undefined\n                let takerPositionValue: Big | undefined\n                if (!takerPosSize.eq(0)) {\n                    takerPosition = new Position({\n                        perp: this._perp,\n                        type: PositionType.TAKER,\n                        market: marketMap[`${tickerSymbol}`],\n                        side: takerPosSize.gte(0) ? PositionSide.LONG : PositionSide.SHORT,\n                        sizeAbs: takerPosSize.abs(),\n                        openNotionalAbs: takerPosOpenNotional.abs(),\n                        entryPrice: takerPosOpenNotional.div(takerPosSize).abs(),\n                        liquidationPrice: takerPosLiquidationPrice,\n                    })\n                    takerPositionValue = takerPosSize.mul(indexPrice)\n                }\n                const makerPosSize = totalPosSize.minus(takerPosSize)\n                const makerPosOpenNotional = totalPosOpenNotional.minus(takerPosOpenNotional)\n                let makerPosition: Position | undefined\n                let makerPositionValue: Big | undefined\n                if (!makerPosSize.eq(0)) {\n                    makerPosition = new Position({\n                        perp: this._perp,\n                        type: PositionType.MAKER,\n                        market: marketMap[`${tickerSymbol}`],\n                        side: makerPosSize.gte(0) ? PositionSide.LONG : PositionSide.SHORT,\n                        sizeAbs: makerPosSize.abs(),\n                        openNotionalAbs: makerPosOpenNotional.abs(),\n                        entryPrice: makerPosOpenNotional.div(makerPosSize).abs(),\n                    })\n                    makerPositionValue = makerPosSize.mul(indexPrice)\n                }\n                positionDataAllByMarket[`${tickerSymbol}`] = {\n                    takerPosition,\n                    takerPositionValue,\n                    makerPosition,\n                    makerPositionValue,\n                    pendingFundingPayment,\n                    indexPrice,\n                    markPrice,\n                }\n            })\n\n            // NOTE: multicall second batch\n            // NOTE: include the calls which depends on the first call batch result or the call we need only once, ex. position size and account value\n            const callsBatch2: ContractCall[] = []\n            const takerPosMap: { [key: string]: TakerPositionExist } = {}\n            const makerPosMap: { [key: string]: MakerPositionExist } = {}\n            Object.entries(positionDataAllByMarket).forEach(([tickerSymbol, posData]) => {\n                if (isTakerPositionExist(posData)) {\n                    takerPosMap[`${tickerSymbol}`] = posData\n                }\n                if (isMakerPositionExist(posData)) {\n                    makerPosMap[`${tickerSymbol}`] = posData\n                }\n            })\n            // NOTE: get taker pos swap result\n            Object.values(takerPosMap).forEach(posData => {\n                const call = {\n                    contract: contracts.quoter,\n                    contractName: ContractName.QUOTER,\n                    funcName: \"swap\",\n                    funcParams: [\n                        {\n                            baseToken: posData.takerPosition.market.baseAddress,\n                            isBaseToQuote: posData.takerPosition.isBaseToQuote,\n                            isExactInput: posData.takerPosition.isExactInput,\n                            amount: big2BigNumberAndScaleUp(posData.takerPosition.sizeAbs),\n                            sqrtPriceLimitX96: 0,\n                        },\n                    ],\n                }\n                callsBatch2.push(call)\n            })\n            // NOTE: get maker pos swap result\n            Object.values(makerPosMap).forEach(posData => {\n                const call = {\n                    contract: contracts.quoter,\n                    contractName: ContractName.QUOTER,\n                    funcName: \"swap\",\n                    funcParams: [\n                        {\n                            baseToken: posData.makerPosition.market.baseAddress,\n                            isBaseToQuote: posData.makerPosition.isBaseToQuote,\n                            isExactInput: posData.makerPosition.isExactInput,\n                            amount: big2BigNumberAndScaleUp(posData.makerPosition.sizeAbs),\n                            sqrtPriceLimitX96: 0,\n                        },\n                    ],\n                }\n                callsBatch2.push(call)\n            })\n            // NOTE: get total abs pos value\n            callsBatch2.push({\n                contract: contracts.accountBalance,\n                contractName: ContractName.ACCOUNT_BALANCE,\n                funcName: \"getTotalAbsPositionValue\",\n                funcParams: [account],\n            })\n            // NOTE: get vault account value\n            callsBatch2.push({\n                contract: contracts.vault,\n                contractName: ContractName.VAULT,\n                funcName: \"getAccountValue\",\n                funcParams: [account],\n            })\n\n            // NOTE: execute second batch multicall\n            const dataBatch2 = await multicall2.execute(callsBatch2)\n\n            // NOTE: analysis batch 2 result\n            const dataChunkTakerPosSwap = dataBatch2.splice(0, Object.keys(takerPosMap).length)\n            const dataChunkMakerPosSwap = dataBatch2.splice(0, Object.keys(makerPosMap).length)\n            const accountPosValueAbs = bigNumber2BigAndScaleDown(dataBatch2.shift())\n            const accountValue = bigNumber2BigAndScaleDown(dataBatch2.shift(), SETTLEMENT_TOKEN_DECIMAL)\n            const accountMarginRatio = !accountPosValueAbs.eq(0) ? accountValue.div(accountPosValueAbs) : undefined\n            const accountLeverage = accountMarginRatio ? Big(1).div(accountMarginRatio) : undefined\n\n            const totalTakerPositionValue = Object.values(takerPosMap).reduce((acc, cur) => {\n                return acc.add(cur.takerPositionValue)\n            }, Big(0))\n            const totalMakerPositionValue = Object.values(makerPosMap).reduce((acc, cur) => {\n                return acc.add(cur.makerPositionValue)\n            }, Big(0))\n\n            // NOTE: get taker unrealized pnl and assign back to positionDataAllByMarket\n            let totalTakerUnrealizedPnl = Big(0)\n            Object.values(takerPosMap).forEach((posData, index) => {\n                const { deltaAvailableQuote, exchangedPositionSize, exchangedPositionNotional } =\n                    dataChunkTakerPosSwap[index]\n                const isLong = posData.takerPosition.side === PositionSide.LONG\n                const deltaAvailableQuoteParsed = bigNumber2BigAndScaleDown(deltaAvailableQuote)\n                const exchangedPositionNotionalParsed = bigNumber2BigAndScaleDown(exchangedPositionNotional)\n                const exchangedPositionSizeParsed = bigNumber2BigAndScaleDown(exchangedPositionSize)\n                const unrealizedPnl = getUnrealizedPnl({\n                    isLong,\n                    deltaAvailableQuote: deltaAvailableQuoteParsed,\n                    openNotionalAbs: posData.takerPosition.openNotionalAbs,\n                })\n                const exitPrice = getSwapRate({\n                    amountBase: exchangedPositionSizeParsed,\n                    amountQuote: exchangedPositionNotionalParsed,\n                })\n                const exitPriceImpact = getPriceImpact({\n                    price: exitPrice,\n                    markPrice: posData.markPrice,\n                })\n                const feeRatio =\n                    this._perp.clearingHouseConfig.marketExchangeFeeRatios[posData.takerPosition.market.baseAddress]\n                const exitTxFee = getTransactionFee({\n                    isBaseToQuote: posData.takerPosition.isBaseToQuote,\n                    exchangedPositionNotional: exchangedPositionNotionalParsed,\n                    deltaAvailableQuote: deltaAvailableQuoteParsed,\n                    feeRatio,\n                })\n                posData.takerPosUnrealizedPnl = unrealizedPnl\n                posData.takerPosExitPrice = exitPrice\n                posData.takerPosExitPriceImpact = exitPriceImpact\n                posData.takerPosExitTxFee = exitTxFee\n                totalTakerUnrealizedPnl = totalTakerUnrealizedPnl.add(unrealizedPnl)\n            })\n\n            // NOTE: get maker unrealized pnl and assign back to positionDataAllByMarket\n            let totalMakerUnrealizedPnl = Big(0)\n            Object.values(makerPosMap).forEach((posData, index) => {\n                const { deltaAvailableQuote, exchangedPositionSize, exchangedPositionNotional } =\n                    dataChunkMakerPosSwap[index]\n                const isLong = posData.makerPosition.side === PositionSide.LONG\n                const deltaAvailableQuoteParsed = bigNumber2BigAndScaleDown(deltaAvailableQuote)\n                const exchangedPositionNotionalParsed = bigNumber2BigAndScaleDown(exchangedPositionNotional)\n                const exchangedPositionSizeParsed = bigNumber2BigAndScaleDown(exchangedPositionSize)\n                const unrealizedPnl = getUnrealizedPnl({\n                    isLong,\n                    deltaAvailableQuote: deltaAvailableQuoteParsed,\n                    openNotionalAbs: posData.makerPosition.openNotionalAbs,\n                })\n                const exitPrice = getSwapRate({\n                    amountBase: exchangedPositionSizeParsed,\n                    amountQuote: exchangedPositionNotionalParsed,\n                })\n                const exitPriceImpact = getPriceImpact({\n                    price: exitPrice,\n                    markPrice: posData.markPrice,\n                })\n                const feeRatio =\n                    this._perp.clearingHouseConfig.marketExchangeFeeRatios[posData.makerPosition.market.baseAddress]\n                const exitTxFee = getTransactionFee({\n                    isBaseToQuote: posData.makerPosition.isBaseToQuote,\n                    exchangedPositionNotional: exchangedPositionNotionalParsed,\n                    deltaAvailableQuote: deltaAvailableQuoteParsed,\n                    feeRatio,\n                })\n                posData.makerPosUnrealizedPnl = unrealizedPnl\n                posData.makerPosExitPrice = exitPrice\n                posData.makerPosExitPriceImpact = exitPriceImpact\n                posData.makerPosExitTxFee = exitTxFee\n                totalMakerUnrealizedPnl = totalMakerUnrealizedPnl.add(unrealizedPnl)\n            })\n\n            const positionDataAllCrossMarket: PositionDataAllCrossMarket = {\n                totalTakerPositionValue,\n                totalMakerPositionValue,\n                totalTakerUnrealizedPnl,\n                totalMakerUnrealizedPnl,\n                totalUnrealizedPnl: totalTakerUnrealizedPnl.add(totalMakerUnrealizedPnl),\n                accountPosValueAbs,\n                accountMarginRatio,\n                accountLeverage,\n            }\n\n            // NOTE: emit position data all\n            this.emit(\"updated\", { positionDataAllByMarket, positionDataAllCrossMarket })\n        } catch (error) {\n            this.emit(\"updateError\", { error })\n        }\n    }\n}\n\nexport interface PositionDataAllCrossMarket {\n    totalTakerPositionValue: Big\n    totalMakerPositionValue: Big\n    totalTakerUnrealizedPnl: Big\n    totalMakerUnrealizedPnl: Big\n    totalUnrealizedPnl: Big\n    accountPosValueAbs: Big\n    accountMarginRatio?: Big\n    accountLeverage?: Big\n}\n\nexport interface PositionDataAllByMarket {\n    [key: string]: {\n        takerPosition?: Position\n        takerPositionValue?: Big\n        takerPosUnrealizedPnl?: Big\n        takerPosExitPrice?: Big\n        takerPosExitPriceImpact?: Big\n        takerPosExitTxFee?: Big\n        makerPosition?: Position\n        makerPositionValue?: Big\n        makerPosUnrealizedPnl?: Big\n        makerPosExitPrice?: Big\n        makerPosExitPriceImpact?: Big\n        makerPosExitTxFee?: Big\n        pendingFundingPayment: Big\n        indexPrice: Big\n        markPrice: Big\n    }\n}\n\nexport interface PositionDataAll {\n    positionDataAllByMarket: PositionDataAllByMarket\n    positionDataAllCrossMarket: PositionDataAllCrossMarket\n}\n\ntype RequireKeys<T extends object, K extends keyof T> = Required<Pick<T, K>> & Omit<T, K>\ntype TakerPositionExist = RequireKeys<\n    PositionDataAllByMarket[keyof PositionDataAllByMarket],\n    | \"takerPosition\"\n    | \"takerPositionValue\"\n    | \"takerPosUnrealizedPnl\"\n    | \"takerPosExitPrice\"\n    | \"takerPosExitPriceImpact\"\n    | \"takerPosExitTxFee\"\n>\ntype MakerPositionExist = RequireKeys<\n    PositionDataAllByMarket[keyof PositionDataAllByMarket],\n    | \"makerPosition\"\n    | \"makerPositionValue\"\n    | \"makerPosUnrealizedPnl\"\n    | \"makerPosExitPrice\"\n    | \"makerPosExitPriceImpact\"\n    | \"makerPosExitTxFee\"\n>\nfunction isTakerPositionExist(\n    posData: PositionDataAllByMarket[keyof PositionDataAllByMarket],\n): posData is TakerPositionExist {\n    return posData.takerPosition !== undefined\n}\nfunction isMakerPositionExist(\n    posData: PositionDataAllByMarket[keyof PositionDataAllByMarket],\n): posData is MakerPositionExist {\n    return posData.makerPosition !== undefined\n}\n"],"names":["Positions","Channel","constructor","_perp","super","channelRegistry","this","_cache","Map","_getEventSourceMap","fetchAndEmitUpdated","getPositionDataAll","bind","updated","ChannelEventSource","eventSourceStarter","poll","_b","_a","moduleConfigs","positions","period","DEFAULT_PERIOD","cancel","initEventEmitter","async","cache","marketMap","markets","takerPositions","takerPositionSizeList","takerOpenNotionalList","liquidationPriceList","Promise","all","_fetch","Object","values","forEach","market","index","takerSizeOriginal","takerOpenNotionalOriginal","liquidationPriceOriginal","eq","push","Position","perp","type","PositionType","TAKER","side","gte","PositionSide","LONG","SHORT","sizeAbs","abs","openNotionalAbs","entryPrice","div","liquidationPrice","totalPositionSizeList","totalOpenNotionalList","getTakerPositions","makerPositions","takerPosition","find","baseSymbol","takerPositionSizeOriginal","sizeOriginal","BIG_ZERO","openNotionalOriginal","makerPositionSizeOriginal","sub","makerOpenNotionalOriginal","MAKER","tickerSymbol","position","getMakerPositions","baseAddress","totalPositionValueList","findIndex","totalMakerPositionValue","getTotalMakerPositionValueFromAllMarkets","totalTakerPositionValue","getTotalTakerPositionValueFromAllMarkets","add","total","indexPrice","getPrices","mul","makerUnrealizedPnl","getTotalMakerUnrealizedPnlFromAllMarkets","takerUnrealizedPnl","getTotalTakerUnrealizedPnlFromAllMarkets","totalUnrealizedPnl","getUnrealizedPnl","invariant","hasConnected","UnauthorizedError","functionName","totalAbsPositionValue","vault","getAccountValue","marginRatio","getAccountMarginRatio","BIG_ONE","key","has","get","trader","wallet","account","args","result","contractReader","getTakerPositionSizeList","getTakerOpenNotionalList","getTotalPositionSizeList","getTotalOpenNotionalList","getPendingFundingPayments","getLiquidationPriceList","getTotalPositionValueList","getTotalAbsPositionValue","set","logger","contracts","multicall2","MulticallReader","contract","callsMap","entries","poolAddress","calls","accountBalance","contractName","ContractName","ACCOUNT_BALANCE","funcName","funcParams","perpPortal","PerpPortal","exchange","EXCHANGE","baseToken","attach","BASE_TOKEN","pool","POOL","dataBatch1","execute","flat","failFirstByContract","failFirstByClient","positionDataAllByMarket","dataChunk","splice","length","takerPosSize","bigNumber2BigAndScaleDown","takerPosOpenNotional","takerPosLiquidationPrice","totalPosSize","totalPosOpenNotional","pendingFundingPayment","markPrice","fromSqrtX96","sqrtPriceX96","takerPositionValue","makerPosSize","minus","makerPosOpenNotional","makerPosition","makerPositionValue","callsBatch2","takerPosMap","makerPosMap","posData","undefined","isTakerPositionExist","isMakerPositionExist","call","quoter","QUOTER","isBaseToQuote","isExactInput","amount","big2BigNumberAndScaleUp","sqrtPriceLimitX96","VAULT","dataBatch2","dataChunkTakerPosSwap","keys","dataChunkMakerPosSwap","accountPosValueAbs","shift","accountValue","SETTLEMENT_TOKEN_DECIMAL","accountMarginRatio","accountLeverage","Big","reduce","acc","cur","totalTakerUnrealizedPnl","deltaAvailableQuote","exchangedPositionSize","exchangedPositionNotional","isLong","deltaAvailableQuoteParsed","exchangedPositionNotionalParsed","exchangedPositionSizeParsed","unrealizedPnl","exitPrice","getSwapRate","amountBase","amountQuote","exitPriceImpact","getPriceImpact","price","feeRatio","clearingHouseConfig","marketExchangeFeeRatios","exitTxFee","getTransactionFee","takerPosUnrealizedPnl","takerPosExitPrice","takerPosExitPriceImpact","takerPosExitTxFee","totalMakerUnrealizedPnl","makerPosUnrealizedPnl","makerPosExitPrice","makerPosExitPriceImpact","makerPosExitTxFee","positionDataAllCrossMarket","emit","error"],"mappings":"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"}