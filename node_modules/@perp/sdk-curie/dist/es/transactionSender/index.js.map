{"version":3,"file":"index.js","sources":["../../../src/transactionSender/index.ts"],"sourcesContent":["import { ContractTransaction, Contract as EthersContract, BigNumber } from \"ethers\"\n\nimport { ContractName } from \"../contracts\"\nimport { ArgumentError } from \"../errors\"\nimport { invariant } from \"../utils\"\nimport { getTransactionErrorFactory } from \"./errorFactory\"\n\ntype Transaction = ContractTransaction // NOTE: Extensible for more transaction types in the future.\n\ntype ContractFunction = (...args: any[]) => Promise<Transaction>\n\nexport interface TransactionMetadata<\n    Contract extends EthersContract = EthersContract,\n    ContractFunctionName extends keyof Contract = keyof Contract,\n> {\n    contractName: ContractName\n    contractFunctionName: ContractFunctionName\n    args: Parameters<Contract[ContractFunctionName]>\n    txPayload?: {\n        from?: string\n        to?: string\n        inputData?: string\n    }\n}\n\ninterface IGetTransactionParams<\n    Contract extends EthersContract = EthersContract,\n    ContractFunctionName extends keyof Contract = keyof Contract,\n> extends TransactionMetadata<Contract, ContractFunctionName> {\n    account: string\n    contract: Contract\n    bypassGasEstimation?: boolean\n    value?: BigNumber\n}\n\n// TODO: make this a Transaction class?\n//  Approach 1: choose one of ContractTX | MetaTx | CrossChainTx class to use\n//  Approach 2: new a UniversalTx and pass config to set the type\n\n// TODO: [FUTURE] to also support meta transaction & cross chain transaction (besides contract transaction), do:\n// const crossChainTx = new UniversalTransaction(tx)\n\nconst DEFAULT_GAS = 16000000\nconst GAS_LIMIT_RATIO = 1.1\n\nexport async function getTransaction<Contract extends EthersContract, ContractFunctionName extends keyof Contract>({\n    value,\n    account,\n    contract,\n    bypassGasEstimation = false, // NOTE: easily to debug\n    ...metadata\n}: IGetTransactionParams<Contract, ContractFunctionName>) {\n    const { contractFunctionName, args } = metadata\n    const txPayload = {\n        from: account,\n        to: contract.address,\n        value,\n        inputData: contract.interface.encodeFunctionData(contractFunctionName as string, args),\n    }\n    const castedMetadata = {\n        ...metadata,\n        txPayload,\n    } as TransactionMetadata // NOTE: metadata should be strictly typed when calling this function by specifying `Contract` & `ContractFunctionName` but should be generic when passing out.\n\n    let gasLimitStr\n    try {\n        const contractFunction: ContractFunction = contract[contractFunctionName]\n        invariant(\n            !!contractFunction,\n            () =>\n                new ArgumentError({\n                    functionName: \"getTransaction\",\n                    key: \"contract[functionName]\",\n                    value: { contractAddress: contract.address, functionName: contractFunctionName },\n                }),\n        )\n\n        const overrides = { from: account, value }\n        const getEstimateGas = () => contract.estimateGas[contractFunctionName as string](...args, overrides)\n        const estimateGas = bypassGasEstimation ? BigNumber.from(DEFAULT_GAS) : await getEstimateGas()\n        const gasLimit = estimateGas.mul(BigNumber.from(GAS_LIMIT_RATIO * 10)).div(10)\n\n        gasLimitStr = gasLimit.toString()\n\n        const transaction = await contractFunction(...args, { gasLimit: gasLimitStr, ...overrides })\n        return { transaction, metadata: { txPayload, ...castedMetadata }, gasLimit: gasLimitStr }\n    } catch (error) {\n        throw getTransactionErrorFactory({\n            error: error as Error,\n            metadata: castedMetadata,\n            ...(gasLimitStr && { gasLimit: gasLimitStr }),\n        })\n    }\n}\n"],"names":["async","getTransaction","value","account","contract","bypassGasEstimation","metadata","contractFunctionName","args","txPayload","from","to","address","inputData","interface","encodeFunctionData","castedMetadata","gasLimitStr","contractFunction","invariant","ArgumentError","functionName","key","contractAddress","overrides","getEstimateGas","estimateGas","BigNumber","mul","GAS_LIMIT_RATIO","div","toString","transaction","gasLimit","error","getTransactionErrorFactory"],"mappings":"wTA6COA,eAAeC,GAA6FC,MAC/GA,EAAKC,QACLA,EAAOC,SACPA,EAAQC,oBACRA,GAAsB,KACnBC,IAEH,MAAMC,qBAAEA,EAAoBC,KAAEA,GAASF,EACjCG,EAAY,CACdC,KAAMP,EACNQ,GAAIP,EAASQ,QACbV,QACAW,UAAWT,EAASU,UAAUC,mBAAmBR,EAAgCC,IAE/EQ,EAAiB,IAChBV,EACHG,aAGJ,IAAIQ,EACJ,IACI,MAAMC,EAAqCd,EAASG,GACpDY,IACMD,GACF,IACI,IAAIE,EAAc,CACdC,aAAc,iBACdC,IAAK,yBACLpB,MAAO,CAAEqB,gBAAiBnB,EAASQ,QAASS,aAAcd,OAItE,MAAMiB,EAAY,CAAEd,KAAMP,EAASD,SAC7BuB,EAAiB,IAAMrB,EAASsB,YAAYnB,MAAmCC,EAAMgB,GACrFE,EAAcrB,EAAsBsB,EAAUjB,KArCxC,YAqCkEe,IAG9ER,EAFiBS,EAAYE,IAAID,EAAUjB,KAAKmB,KAAuBC,IAAI,IAEpDC,WAGvB,MAAO,CAAEC,kBADiBd,KAAoBV,EAAM,CAAEyB,SAAUhB,KAAgBO,IAC1DlB,SAAU,CAAEG,eAAcO,GAAkBiB,SAAUhB,EAO/E,CANC,MAAOiB,GACL,MAAMC,EAA2B,CAC7BD,MAAOA,EACP5B,SAAUU,KACNC,GAAe,CAAEgB,SAAUhB,IAEtC,CACL"}