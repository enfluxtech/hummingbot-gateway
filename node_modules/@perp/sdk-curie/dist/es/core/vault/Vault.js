import"../../constants/envVariables.js";import{ETH_DECIMAL_DIGITS as t,COLLATERAL_TOKEN_DECIMAL as e,SETTLEMENT_TOKEN_DECIMAL as a}from"../../constants/numbers.js";import{ContractName as c}from"../../contracts/Contracts.js";import{UnauthorizedError as r}from"../../errors/errors.js";import{Channel as n}from"../../internal/Channel.js";import{ChannelEventSource as o}from"../../internal/ChannelEventSource.js";import{createMemoizedFetcher as i,hasNumberChange as l,hasNumberArrChange as s}from"../../internal/createMemoizedFetcher.js";import{DEFAULT_PERIOD as u}from"../../internal/config.js";import{getTransaction as h}from"../../transactionSender/index.js";import"big.js";import{invariant as d}from"../../utils/errorChecker.js";import{big2BigNumberAndScaleUp as m,bigNumber2BigAndScaleDown as p}from"../../utils/formatters.js";import"../../utils/tick.js";import{poll as f}from"../../utils/poll.js";import{logger as v}from"../../utils/logger.js";import"ethers";import{MulticallReader as _}from"../contractReader/MulticallReader.js";import{SettlementToken as w}from"../wallet/SettlementToken.js";class g extends n{constructor(t,e){super(t.channelRegistry),this._perp=t,this.account=e,this._cache=new Map,this._contractReader=t.contractReader,this._contract=this._contractReader.contracts.vault}async getAccountValue({cache:t=!0}={}){return await this._fetch("accountValue",{cache:t})}async getBalanceList({cache:t=!0}={}){return await this._fetch("balanceList",{cache:t})}async getFreeCollateral({cache:t=!0}={}){return await this._fetch("freeCollateral",{cache:t})}async getFreeCollateralList({cache:t=!0}={}){return await this._fetch("freeCollateralList",{cache:t})}async deposit(t,e){const a=t.address,r=await t.decimals();return h({account:this.account,contract:this._contract,contractName:c.VAULT,contractFunctionName:"deposit",args:[a,m(e,r)]})}async depositETH(e){return h({value:m(e,t),account:this.account,contract:this._contract,contractName:c.VAULT,contractFunctionName:"depositEther",args:[]})}async withdraw(t,e){const a=t.address,r=await t.decimals();return h({account:this.account,contract:this._contract,contractName:c.VAULT,contractFunctionName:"withdraw",args:[a,m(e,r)]})}async withdrawETH(e){return h({account:this.account,contract:this._contract,contractName:c.VAULT,contractFunctionName:"withdrawEther",args:[m(e,t)]})}async withdrawAll(t){const e=t.address;return h({account:this.account,contract:this._contract,contractName:c.VAULT,contractFunctionName:"withdrawAll",args:[e]})}async withdrawAllEther(){return h({account:this.account,contract:this._contract,contractName:c.VAULT,contractFunctionName:"withdrawAllEther",args:[]})}_getEventSourceMap(){const t=this._createFetchAndEmitAccountValueUpdated(),e=new o({eventSourceStarter:()=>{var e,a;return f(t,(null===(a=null===(e=this._perp.moduleConfigs)||void 0===e?void 0:e.vault)||void 0===a?void 0:a.period)||u).cancel},initEventEmitter:()=>t(!0,!0)}),a=this._createFetchAndEmitBalanceListUpdated(),c=new o({eventSourceStarter:()=>{var t,e;return f(a,(null===(e=null===(t=this._perp.moduleConfigs)||void 0===t?void 0:t.vault)||void 0===e?void 0:e.period)||u).cancel},initEventEmitter:()=>a(!0,!0)}),r=this._createFetchAndEmitFreeCollateralUpdated(),n=new o({eventSourceStarter:()=>{var t,e;return f(r,(null===(e=null===(t=this._perp.moduleConfigs)||void 0===t?void 0:t.vault)||void 0===e?void 0:e.period)||u).cancel},initEventEmitter:()=>r(!0,!0)}),i=this._createFetchAndEmitFreeCollateralListUpdated(),l=new o({eventSourceStarter:()=>{var t,e;return f(i,(null===(e=null===(t=this._perp.moduleConfigs)||void 0===t?void 0:t.vault)||void 0===e?void 0:e.period)||u).cancel},initEventEmitter:()=>i(!0,!0)}),s=this.getVaultDataAll.bind(this);return{accountValueUpdated:e,balanceListUpdated:c,freeCollateralUpdated:n,freeCollateralListUpdated:l,updatedVaultDataAll:new o({eventSourceStarter:()=>{var t,e;return f(s,(null===(e=null===(t=this._perp.moduleConfigs)||void 0===t?void 0:t.vault)||void 0===e?void 0:e.period)||u).cancel},initEventEmitter:()=>s()})}}async _fetchUpdateData(t){try{return await t()}catch(t){this.emit("updateError",{error:t})}}async _fetch(t,{cache:e=!0}={}){if(this._cache.has(t)&&e)return this._cache.get(t);let a;switch(t){case"accountValue":a=await this._contractReader.getAccountValue(this.account);break;case"balanceList":d(this._perp.hasConnected(),(()=>new r({functionName:"balanceList"}))),a=await Promise.all(this._perp.wallet.collateralTokenList.map((t=>t instanceof w?this._contractReader.getVaultBalanceOfSettlementToken(this.account):this._contractReader.getVaultBalanceByToken(this.account,t))));break;case"freeCollateral":a=await this._contractReader.getFreeCollateral(this.account);break;case"freeCollateralList":d(this._perp.hasConnected(),(()=>new r({functionName:"freeCollateralList"}))),a=await Promise.all(this._perp.wallet.collateralTokenList.map((t=>this._contractReader.getFreeCollateralByToken(this.account,t))))}return this._cache.set(t,a),a}_createFetchAndEmitAccountValueUpdated(){return i((()=>this._fetchUpdateData((()=>this.getAccountValue({cache:!1})))),(()=>{this.emit("accountValueUpdated",this),this.emit("updated",this)}),((t,e)=>!t||!e||l(t,e)))}_createFetchAndEmitBalanceListUpdated(){return i((()=>this._fetchUpdateData((()=>this.getBalanceList({cache:!1})))),(()=>{this.emit("balanceListUpdated",this)}),((t,e)=>!t||!e||s(t,e)))}_createFetchAndEmitFreeCollateralUpdated(){return i((()=>this._fetchUpdateData((()=>this.getFreeCollateral({cache:!1})))),(()=>{this.emit("freeCollateralUpdated",this),this.emit("updated",this)}),((t,e)=>!t||!e||l(t,e)))}_createFetchAndEmitFreeCollateralListUpdated(){return i((()=>this._fetchUpdateData((()=>this.getFreeCollateralList({cache:!1})))),(()=>{this.emit("freeCollateralListUpdated",this)}),((t,e)=>!t||!e||s(t,e)))}async getVaultDataAll(){try{d(this._perp.hasConnected(),(()=>new r({functionName:"getVaultDataAll"}))),v("getVaultDataAll");const t=this._perp.wallet.account,n=this._perp.contracts,o=this._perp.wallet.collateralTokenList,i=new _({contract:n.multicall2}),l={};null==o||o.forEach((e=>{const a=e instanceof w,r=e.contract,o=e.address,i=a?{contract:n.vault,contractName:c.VAULT,funcName:"getSettlementTokenValue",funcParams:[t]}:{contract:n.vault,contractName:c.VAULT,funcName:"getBalanceByToken",funcParams:[t,o]},s=a?{contract:r,contractName:c.SETTLEMENT_TOKEN,funcName:"decimals",funcParams:[]}:{contract:r,contractName:c.COLLATERAL_TOKENS,funcName:"decimals",funcParams:[]},u=[{contract:n.vault,contractName:c.VAULT,funcName:"getFreeCollateralByToken",funcParams:[t,o]},s,i];l[`${e.address}`]=u}));const s=[{contract:n.vault,contractName:c.VAULT,funcName:"getFreeCollateral",funcParams:[t]},{contract:n.vault,contractName:c.VAULT,funcName:"getAccountValue",funcParams:[t]}],u=await i.execute(Object.values(l).flat().concat(s),{failFirstByContract:!1,failFirstByClient:!1}),h={};Object.entries(l).forEach((([t,e])=>{const a=u.splice(0,e.length),c=a[0],r=a[1],n=a[2];h[`${t}`]={freeCollateral:p(c,r),balance:p(n,r)}}));const m=p(u[0],e),f={accountBalance:p(u[1],a),accountFreeCollateral:m};this.emit("updatedVaultDataAll",{vaultDataAllByCollateral:h,vaultDataAllCrossCollateral:f})}catch(t){this.emit("updateError",{error:t})}}}export{g as Vault};
//# sourceMappingURL=Vault.js.map
