import{Channel as e}from"../../internal/Channel.js";import{ChannelEventSource as t}from"../../internal/ChannelEventSource.js";import{createMemoizedFetcher as r,hasNumbersChange as s}from"../../internal/createMemoizedFetcher.js";import{DEFAULT_PERIOD as i}from"../../internal/config.js";import"big.js";import{fromSqrtX96 as a}from"../../utils/formatters.js";import{getMaxTickByTickSpacing as c,getMinTickByTickSpacing as n,getTickFromPrice as o,tickToPrice as d}from"../../utils/tick.js";import{poll as h}from"../../utils/poll.js";import"../../constants/envVariables.js";import"../../constants/numbers.js";var p;!function(e){e.ACTIVE="ACTIVE",e.PAUSED="PAUSED",e.CLOSED="CLOSED"}(p||(p={}));class u extends e{constructor(e,t,r,s,i,a,c){super(e.channelRegistry),this._perp=e,this.tickerSymbol=t,this.poolAddress=r,this.baseSymbol=s,this.baseAddress=i,this.quoteSymbol=a,this.quoteAddress=c,this._cache=new Map,this._perp=e,this.poolAddress=r,this.baseAddress=i,this.quoteAddress=c,this._contractReader=this._perp.contractReader}get tickSpacing(){return this._perp.clearingHouseConfig.marketTickSpacings[this.poolAddress]}get maxTick(){return c(this.tickSpacing)}get minTick(){return n(this.tickSpacing)}getTickFromPrice(e,t){return o(e,this.tickSpacing,t)}getPriceFromTick(e){return d(e)}getPriceFeedAggregator(){return this._contractReader.getPriceFeedAggregator(this.baseAddress)}_getEventSourceMap(){const e=this._createFetchUpdateData(),r=new t({eventSourceStarter:()=>{var t,r;const{cancel:s}=h(e,(null===(r=null===(t=this._perp.moduleConfigs)||void 0===t?void 0:t.market)||void 0===r?void 0:r.period)||i);return s},initEventEmitter:()=>e(!0,!0)});return{updated:r,updateError:r}}_createFetchUpdateData(){return r((async()=>{try{const e=this._perp.clearingHouseConfig.twapInterval.toNumber(),t=await this._contractReader.getMarketData({poolAddress:this.poolAddress,baseAddress:this.baseAddress,twapTimeRange:e}),{markPrice:r,indexPrice:s,indexTwapPrice:i}=t;return this._cache.set("markPrice",r),this._cache.set("indexPrice",s),this._cache.set("indexTwapPrice",i),t}catch(e){this.emit("updateError",{error:e})}}).bind(this),(()=>{this.emit("updated",this)}),((e,t)=>!e||!t||s(e,t)))}async getStatus(){const{isPaused:e,isClosed:t}=await this._fetch("marketStatus",{cache:!1});return t?p.CLOSED:e?p.PAUSED:p.ACTIVE}async getClosedPrice(){return await this._fetch("closedPrice")}async getPrices({cache:e=!0}={}){const[t,r,s]=await Promise.all([this._fetch("markPrice",{cache:e}),this._fetch("indexPrice",{cache:e}),this._fetch("indexTwapPrice",{cache:e})]);return{markPrice:t,indexPrice:r,indexTwapPrice:s}}async _fetch(e,{cache:t=!0}={}){if(this._cache.has(e)&&t)return this._cache.get(e);let r;switch(e){case"indexPrice":r=await this._contractReader.getIndexPrice(this.baseAddress);break;case"markPrice":{const{sqrtPriceX96:e}=await this._contractReader.getSlot0(this.poolAddress);r=a(e);break}case"indexTwapPrice":{const e=this._perp.clearingHouseConfig.twapInterval.toNumber();r=await this._contractReader.getIndexPrice(this.baseAddress,e);break}case"isMarketPaused":r=await this._contractReader.isMarketPaused(this.baseAddress);break;case"isMarketClosed":r=await this._contractReader.isMarketClosed(this.baseAddress);break;case"marketStatus":r=await this._contractReader.getMarketStatus(this.baseAddress);break;case"closedPrice":r=await this._contractReader.getClosedPrice(this.baseAddress)}return this._cache.set(e,r),r}}export{u as Market,p as MarketStatus};
//# sourceMappingURL=Market.js.map
