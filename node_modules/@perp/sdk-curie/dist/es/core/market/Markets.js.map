{"version":3,"file":"Markets.js","sources":["../../../../src/core/market/Markets.ts"],"sourcesContent":["import Big from \"big.js\"\n\nimport { ContractName } from \"../../contracts\"\nimport { ArgumentError, TypeError } from \"../../errors\"\nimport { Channel, ChannelEventSource, DEFAULT_PERIOD } from \"../../internal\"\nimport { Pool } from \"../../metadata\"\nimport {\n    assertExist,\n    bigNumber2BigAndScaleDown,\n    fromSqrtX96,\n    getTickerSymbol,\n    invariant,\n    isEmptyObject,\n    logger,\n    poll,\n} from \"../../utils\"\nimport { ContractCall, MulticallReader } from \"../contractReader/MulticallReader\"\nimport { Market, MarketStatus } from \"./Market\"\n\nimport type { PerpetualProtocol } from \"../PerpetualProtocol\"\nexport interface MarketMap {\n    [key: string]: Market\n}\n\nexport type GetMarketParams =\n    | { tickerSymbol: string; baseAddress?: never }\n    | { tickerSymbol?: never; baseAddress: string }\n\nexport interface marketInfo {\n    id: string\n    pool: string // NOTE: address\n    baseToken: string\n    quoteToken: string\n    tradingVolume: string // NOTE: Total accumulated from day 1.\n    tradingFee: string // NOTE: Total accumulated from day 1.\n}\n\ntype MarketsEventName = \"updateError\" | \"updated\"\n\nexport interface MarketDataAll {\n    [key: string]: {\n        status: MarketStatus\n        markPrice: Big\n        indexPrice: Big\n        indexTwapPrice: Big\n    }\n}\n\nclass Markets extends Channel<MarketsEventName> {\n    private readonly _perp: PerpetualProtocol\n    private readonly _marketMap: MarketMap\n\n    constructor(perp: PerpetualProtocol) {\n        super(perp.channelRegistry)\n        this._perp = perp\n        this._marketMap = this._getMarketMap()\n    }\n\n    get marketMap() {\n        return this._marketMap\n    }\n\n    private _getMarketMap(): MarketMap {\n        if (isEmptyObject(this._perp.metadata.pools)) {\n            console.warn(\"Metadata pools is empty!\")\n            return {}\n        }\n        return this._perp.metadata.pools.reduce(\n            (poolMap, { address, baseSymbol, baseAddress, quoteSymbol, quoteAddress }) => {\n                const tickerSymbol = getTickerSymbol(baseSymbol, quoteSymbol)\n                return {\n                    ...poolMap,\n                    [tickerSymbol]: new Market(\n                        this._perp,\n                        tickerSymbol,\n                        address,\n                        baseSymbol,\n                        baseAddress,\n                        quoteSymbol,\n                        quoteAddress,\n                    ),\n                }\n            },\n            {},\n        )\n    }\n\n    getMarket({ tickerSymbol, baseAddress }: GetMarketParams): Market {\n        let market: Market | undefined\n        if (tickerSymbol) {\n            market = this._marketMap[tickerSymbol]\n        } else {\n            market = Object.values(this._marketMap).find(market => market.baseAddress === baseAddress)\n        }\n\n        invariant(\n            !!market,\n            () =>\n                new ArgumentError({\n                    functionName: \"getMarket\",\n                    key: tickerSymbol ? \"tickerSymbol\" : \"baseAddress\",\n                    value: tickerSymbol ? tickerSymbol : baseAddress,\n                }),\n        )\n        assertExist<Pool>(\n            market,\n            () =>\n                new TypeError({\n                    functionName: \"getMarket\",\n                    variableName: \"market\",\n                    variableValue: market,\n                    type: \"market\",\n                }),\n        )\n\n        return market\n    }\n\n    async getMarketsBaseQuoteAmount(marketsInfo: marketInfo[]): Promise<any> {\n        return this._perp.contractReader.getMarketsBaseTokenAndQuoteTokenAmount(marketsInfo)\n    }\n\n    // NOTE: call by Channel -> constructor\n    protected _getEventSourceMap() {\n        const fetchAndEmitUpdated = this.getMarketDataAll.bind(this)\n        const updateDataEventSource = new ChannelEventSource<MarketsEventName>({\n            eventSourceStarter: () => {\n                const { cancel } = poll(fetchAndEmitUpdated, this._perp.moduleConfigs?.market?.period || DEFAULT_PERIOD)\n                return cancel\n            },\n            initEventEmitter: () => fetchAndEmitUpdated(),\n        })\n\n        // TODO: eventName typing protection, should error when invalid eventName is provided\n        return {\n            updated: updateDataEventSource,\n        }\n    }\n\n    protected async getMarketDataAll() {\n        try {\n            logger(\"getMarketDataAll\")\n            const twapInterval = this._perp.clearingHouseConfig.twapInterval.toNumber()\n            const contracts = this._perp.contracts\n            const multicallReader = new MulticallReader({ contract: this._perp.contracts.multicall2 })\n            const callsMap: { [key: string]: ContractCall[] } = {}\n            Object.entries(this._marketMap).forEach(([tickerSymbol, market]) => {\n                const contractBaseToken = contracts.baseToken.attach(market.baseAddress)\n                const contractPool = contracts.pool.attach(market.poolAddress)\n                const calls: ContractCall[] = [\n                    // NOTE: get index price\n                    {\n                        contract: contractBaseToken,\n                        contractName: ContractName.BASE_TOKEN,\n                        funcName: \"getIndexPrice\",\n                        funcParams: [0],\n                    },\n                    // NOTE: get index twap price\n                    {\n                        contract: contractBaseToken,\n                        contractName: ContractName.BASE_TOKEN,\n                        funcName: \"getIndexPrice\",\n                        funcParams: [twapInterval],\n                    },\n                    // NOTE: get market price\n                    {\n                        contract: contractPool,\n                        contractName: ContractName.POOL,\n                        funcName: \"slot0\",\n                        funcParams: [],\n                    },\n                    // NOTE: get if the base token paused\n                    {\n                        contract: contractBaseToken,\n                        contractName: ContractName.BASE_TOKEN,\n                        funcName: \"isPaused\",\n                        funcParams: [],\n                    },\n                    // NOTE: get if the base token closed\n                    {\n                        contract: contractBaseToken,\n                        contractName: ContractName.BASE_TOKEN,\n                        funcName: \"isClosed\",\n                        funcParams: [],\n                    },\n                ]\n                callsMap[`${tickerSymbol}`] = calls\n            })\n\n            // NOTE: get data\n            const data = await multicallReader.execute(Object.values(callsMap).flat(), {\n                failFirstByContract: false,\n                failFirstByClient: false,\n            })\n\n            // NOTE: data analysis\n            const marketDataAll: MarketDataAll = {}\n            Object.entries(callsMap).forEach(([key, value]) => {\n                const dataChunk = data.splice(0, value.length)\n                const indexPrice = bigNumber2BigAndScaleDown(dataChunk[0])\n                const indexTwapPrice = bigNumber2BigAndScaleDown(dataChunk[1])\n                const markPrice = fromSqrtX96(dataChunk[2].sqrtPriceX96)\n                const isPaused = dataChunk[3]\n                const isClosed = dataChunk[4]\n                marketDataAll[`${key}`] = {\n                    status: isClosed ? MarketStatus.CLOSED : isPaused ? MarketStatus.PAUSED : MarketStatus.ACTIVE,\n                    markPrice,\n                    indexPrice,\n                    indexTwapPrice,\n                }\n            })\n\n            // NOTE: emit market data all\n            this.emit(\"updated\", marketDataAll)\n        } catch (error) {\n            this.emit(\"updateError\", { error })\n        }\n    }\n}\n\nexport { Markets }\n"],"names":["Markets","Channel","constructor","perp","super","channelRegistry","this","_perp","_marketMap","_getMarketMap","marketMap","isEmptyObject","metadata","pools","console","warn","reduce","poolMap","address","baseSymbol","baseAddress","quoteSymbol","quoteAddress","tickerSymbol","getTickerSymbol","Market","getMarket","market","Object","values","find","invariant","ArgumentError","functionName","key","value","assertExist","TypeError","variableName","variableValue","type","async","marketsInfo","contractReader","getMarketsBaseTokenAndQuoteTokenAmount","_getEventSourceMap","fetchAndEmitUpdated","getMarketDataAll","bind","updated","ChannelEventSource","eventSourceStarter","cancel","poll","_b","_a","moduleConfigs","period","DEFAULT_PERIOD","initEventEmitter","logger","twapInterval","clearingHouseConfig","toNumber","contracts","multicallReader","MulticallReader","contract","multicall2","callsMap","entries","forEach","contractBaseToken","baseToken","attach","contractPool","pool","poolAddress","calls","contractName","ContractName","BASE_TOKEN","funcName","funcParams","POOL","data","execute","flat","failFirstByContract","failFirstByClient","marketDataAll","dataChunk","splice","length","indexPrice","bigNumber2BigAndScaleDown","indexTwapPrice","markPrice","fromSqrtX96","sqrtPriceX96","isPaused","isClosed","status","MarketStatus","CLOSED","PAUSED","ACTIVE","emit","error"],"mappings":"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"}