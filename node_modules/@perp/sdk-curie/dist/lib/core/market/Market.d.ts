import { Big } from "big.js";
import { Channel, ChannelEventSource } from "../../internal";
import { TickPriceMode } from "../../utils";
import type { PerpetualProtocol } from "../PerpetualProtocol";
declare type MarketEventName = "updateError" | "updated";
export declare enum MarketStatus {
    ACTIVE = "ACTIVE",
    PAUSED = "PAUSED",
    CLOSED = "CLOSED"
}
declare class Market extends Channel<MarketEventName> {
    private readonly _perp;
    readonly tickerSymbol: string;
    readonly poolAddress: string;
    readonly baseSymbol: string;
    readonly baseAddress: string;
    readonly quoteSymbol: string;
    readonly quoteAddress: string;
    private _cache;
    private readonly _contractReader;
    constructor(_perp: PerpetualProtocol, tickerSymbol: string, poolAddress: string, baseSymbol: string, baseAddress: string, quoteSymbol: string, quoteAddress: string);
    get tickSpacing(): number;
    get maxTick(): number;
    get minTick(): number;
    getTickFromPrice(price: Big, mode?: TickPriceMode): number;
    getPriceFromTick(tick: number): Big;
    getPriceFeedAggregator(): Promise<{
        address: string;
        contract: import("../../contracts/type").AggregatorV3Interface;
    }>;
    protected _getEventSourceMap(): {
        updated: ChannelEventSource<MarketEventName>;
        updateError: ChannelEventSource<MarketEventName>;
    };
    /**
     * Get market data and emit "updated" event
     */
    private _createFetchUpdateData;
    getStatus(): Promise<MarketStatus>;
    getClosedPrice(): Promise<Big>;
    getPrices({ cache }?: {
        cache?: boolean | undefined;
    }): Promise<{
        markPrice: Big;
        indexPrice: Big;
        indexTwapPrice: Big;
    }>;
    private _fetch;
}
export { Market };
