// package: injective.exchange.v1beta1
// file: injective/exchange/v1beta1/exchange.proto

import * as jspb from "google-protobuf";
import * as gogoproto_gogo_pb from "../../../gogoproto/gogo_pb";
import * as cosmos_base_v1beta1_coin_pb from "../../../cosmos/base/v1beta1/coin_pb";
import * as injective_oracle_v1beta1_oracle_pb from "../../../injective/oracle/v1beta1/oracle_pb";

export class Params extends jspb.Message {
  hasSpotMarketInstantListingFee(): boolean;
  clearSpotMarketInstantListingFee(): void;
  getSpotMarketInstantListingFee(): cosmos_base_v1beta1_coin_pb.Coin | undefined;
  setSpotMarketInstantListingFee(value?: cosmos_base_v1beta1_coin_pb.Coin): void;

  hasDerivativeMarketInstantListingFee(): boolean;
  clearDerivativeMarketInstantListingFee(): void;
  getDerivativeMarketInstantListingFee(): cosmos_base_v1beta1_coin_pb.Coin | undefined;
  setDerivativeMarketInstantListingFee(value?: cosmos_base_v1beta1_coin_pb.Coin): void;

  getDefaultSpotMakerFeeRate(): string;
  setDefaultSpotMakerFeeRate(value: string): void;

  getDefaultSpotTakerFeeRate(): string;
  setDefaultSpotTakerFeeRate(value: string): void;

  getDefaultDerivativeMakerFeeRate(): string;
  setDefaultDerivativeMakerFeeRate(value: string): void;

  getDefaultDerivativeTakerFeeRate(): string;
  setDefaultDerivativeTakerFeeRate(value: string): void;

  getDefaultInitialMarginRatio(): string;
  setDefaultInitialMarginRatio(value: string): void;

  getDefaultMaintenanceMarginRatio(): string;
  setDefaultMaintenanceMarginRatio(value: string): void;

  getDefaultFundingInterval(): number;
  setDefaultFundingInterval(value: number): void;

  getFundingMultiple(): number;
  setFundingMultiple(value: number): void;

  getRelayerFeeShareRate(): string;
  setRelayerFeeShareRate(value: string): void;

  getDefaultHourlyFundingRateCap(): string;
  setDefaultHourlyFundingRateCap(value: string): void;

  getDefaultHourlyInterestRate(): string;
  setDefaultHourlyInterestRate(value: string): void;

  getMaxDerivativeOrderSideCount(): number;
  setMaxDerivativeOrderSideCount(value: number): void;

  getInjRewardStakedRequirementThreshold(): string;
  setInjRewardStakedRequirementThreshold(value: string): void;

  getTradingRewardsVestingDuration(): number;
  setTradingRewardsVestingDuration(value: number): void;

  getLiquidatorRewardShareRate(): string;
  setLiquidatorRewardShareRate(value: string): void;

  hasBinaryOptionsMarketInstantListingFee(): boolean;
  clearBinaryOptionsMarketInstantListingFee(): void;
  getBinaryOptionsMarketInstantListingFee(): cosmos_base_v1beta1_coin_pb.Coin | undefined;
  setBinaryOptionsMarketInstantListingFee(value?: cosmos_base_v1beta1_coin_pb.Coin): void;

  getAtomicMarketOrderAccessLevel(): AtomicMarketOrderAccessLevelMap[keyof AtomicMarketOrderAccessLevelMap];
  setAtomicMarketOrderAccessLevel(value: AtomicMarketOrderAccessLevelMap[keyof AtomicMarketOrderAccessLevelMap]): void;

  getSpotAtomicMarketOrderFeeMultiplier(): string;
  setSpotAtomicMarketOrderFeeMultiplier(value: string): void;

  getDerivativeAtomicMarketOrderFeeMultiplier(): string;
  setDerivativeAtomicMarketOrderFeeMultiplier(value: string): void;

  getBinaryOptionsAtomicMarketOrderFeeMultiplier(): string;
  setBinaryOptionsAtomicMarketOrderFeeMultiplier(value: string): void;

  getMinimalProtocolFeeRate(): string;
  setMinimalProtocolFeeRate(value: string): void;

  getIsInstantDerivativeMarketLaunchEnabled(): boolean;
  setIsInstantDerivativeMarketLaunchEnabled(value: boolean): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Params.AsObject;
  static toObject(includeInstance: boolean, msg: Params): Params.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Params, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Params;
  static deserializeBinaryFromReader(message: Params, reader: jspb.BinaryReader): Params;
}

export namespace Params {
  export type AsObject = {
    spotMarketInstantListingFee?: cosmos_base_v1beta1_coin_pb.Coin.AsObject,
    derivativeMarketInstantListingFee?: cosmos_base_v1beta1_coin_pb.Coin.AsObject,
    defaultSpotMakerFeeRate: string,
    defaultSpotTakerFeeRate: string,
    defaultDerivativeMakerFeeRate: string,
    defaultDerivativeTakerFeeRate: string,
    defaultInitialMarginRatio: string,
    defaultMaintenanceMarginRatio: string,
    defaultFundingInterval: number,
    fundingMultiple: number,
    relayerFeeShareRate: string,
    defaultHourlyFundingRateCap: string,
    defaultHourlyInterestRate: string,
    maxDerivativeOrderSideCount: number,
    injRewardStakedRequirementThreshold: string,
    tradingRewardsVestingDuration: number,
    liquidatorRewardShareRate: string,
    binaryOptionsMarketInstantListingFee?: cosmos_base_v1beta1_coin_pb.Coin.AsObject,
    atomicMarketOrderAccessLevel: AtomicMarketOrderAccessLevelMap[keyof AtomicMarketOrderAccessLevelMap],
    spotAtomicMarketOrderFeeMultiplier: string,
    derivativeAtomicMarketOrderFeeMultiplier: string,
    binaryOptionsAtomicMarketOrderFeeMultiplier: string,
    minimalProtocolFeeRate: string,
    isInstantDerivativeMarketLaunchEnabled: boolean,
  }
}

export class MarketFeeMultiplier extends jspb.Message {
  getMarketId(): string;
  setMarketId(value: string): void;

  getFeeMultiplier(): string;
  setFeeMultiplier(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MarketFeeMultiplier.AsObject;
  static toObject(includeInstance: boolean, msg: MarketFeeMultiplier): MarketFeeMultiplier.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MarketFeeMultiplier, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MarketFeeMultiplier;
  static deserializeBinaryFromReader(message: MarketFeeMultiplier, reader: jspb.BinaryReader): MarketFeeMultiplier;
}

export namespace MarketFeeMultiplier {
  export type AsObject = {
    marketId: string,
    feeMultiplier: string,
  }
}

export class DerivativeMarket extends jspb.Message {
  getTicker(): string;
  setTicker(value: string): void;

  getOracleBase(): string;
  setOracleBase(value: string): void;

  getOracleQuote(): string;
  setOracleQuote(value: string): void;

  getOracleType(): injective_oracle_v1beta1_oracle_pb.OracleTypeMap[keyof injective_oracle_v1beta1_oracle_pb.OracleTypeMap];
  setOracleType(value: injective_oracle_v1beta1_oracle_pb.OracleTypeMap[keyof injective_oracle_v1beta1_oracle_pb.OracleTypeMap]): void;

  getOracleScaleFactor(): number;
  setOracleScaleFactor(value: number): void;

  getQuoteDenom(): string;
  setQuoteDenom(value: string): void;

  getMarketId(): string;
  setMarketId(value: string): void;

  getInitialMarginRatio(): string;
  setInitialMarginRatio(value: string): void;

  getMaintenanceMarginRatio(): string;
  setMaintenanceMarginRatio(value: string): void;

  getMakerFeeRate(): string;
  setMakerFeeRate(value: string): void;

  getTakerFeeRate(): string;
  setTakerFeeRate(value: string): void;

  getRelayerFeeShareRate(): string;
  setRelayerFeeShareRate(value: string): void;

  getIsperpetual(): boolean;
  setIsperpetual(value: boolean): void;

  getStatus(): MarketStatusMap[keyof MarketStatusMap];
  setStatus(value: MarketStatusMap[keyof MarketStatusMap]): void;

  getMinPriceTickSize(): string;
  setMinPriceTickSize(value: string): void;

  getMinQuantityTickSize(): string;
  setMinQuantityTickSize(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): DerivativeMarket.AsObject;
  static toObject(includeInstance: boolean, msg: DerivativeMarket): DerivativeMarket.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: DerivativeMarket, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): DerivativeMarket;
  static deserializeBinaryFromReader(message: DerivativeMarket, reader: jspb.BinaryReader): DerivativeMarket;
}

export namespace DerivativeMarket {
  export type AsObject = {
    ticker: string,
    oracleBase: string,
    oracleQuote: string,
    oracleType: injective_oracle_v1beta1_oracle_pb.OracleTypeMap[keyof injective_oracle_v1beta1_oracle_pb.OracleTypeMap],
    oracleScaleFactor: number,
    quoteDenom: string,
    marketId: string,
    initialMarginRatio: string,
    maintenanceMarginRatio: string,
    makerFeeRate: string,
    takerFeeRate: string,
    relayerFeeShareRate: string,
    isperpetual: boolean,
    status: MarketStatusMap[keyof MarketStatusMap],
    minPriceTickSize: string,
    minQuantityTickSize: string,
  }
}

export class BinaryOptionsMarket extends jspb.Message {
  getTicker(): string;
  setTicker(value: string): void;

  getOracleSymbol(): string;
  setOracleSymbol(value: string): void;

  getOracleProvider(): string;
  setOracleProvider(value: string): void;

  getOracleType(): injective_oracle_v1beta1_oracle_pb.OracleTypeMap[keyof injective_oracle_v1beta1_oracle_pb.OracleTypeMap];
  setOracleType(value: injective_oracle_v1beta1_oracle_pb.OracleTypeMap[keyof injective_oracle_v1beta1_oracle_pb.OracleTypeMap]): void;

  getOracleScaleFactor(): number;
  setOracleScaleFactor(value: number): void;

  getExpirationTimestamp(): number;
  setExpirationTimestamp(value: number): void;

  getSettlementTimestamp(): number;
  setSettlementTimestamp(value: number): void;

  getAdmin(): string;
  setAdmin(value: string): void;

  getQuoteDenom(): string;
  setQuoteDenom(value: string): void;

  getMarketId(): string;
  setMarketId(value: string): void;

  getMakerFeeRate(): string;
  setMakerFeeRate(value: string): void;

  getTakerFeeRate(): string;
  setTakerFeeRate(value: string): void;

  getRelayerFeeShareRate(): string;
  setRelayerFeeShareRate(value: string): void;

  getStatus(): MarketStatusMap[keyof MarketStatusMap];
  setStatus(value: MarketStatusMap[keyof MarketStatusMap]): void;

  getMinPriceTickSize(): string;
  setMinPriceTickSize(value: string): void;

  getMinQuantityTickSize(): string;
  setMinQuantityTickSize(value: string): void;

  getSettlementPrice(): string;
  setSettlementPrice(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): BinaryOptionsMarket.AsObject;
  static toObject(includeInstance: boolean, msg: BinaryOptionsMarket): BinaryOptionsMarket.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: BinaryOptionsMarket, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): BinaryOptionsMarket;
  static deserializeBinaryFromReader(message: BinaryOptionsMarket, reader: jspb.BinaryReader): BinaryOptionsMarket;
}

export namespace BinaryOptionsMarket {
  export type AsObject = {
    ticker: string,
    oracleSymbol: string,
    oracleProvider: string,
    oracleType: injective_oracle_v1beta1_oracle_pb.OracleTypeMap[keyof injective_oracle_v1beta1_oracle_pb.OracleTypeMap],
    oracleScaleFactor: number,
    expirationTimestamp: number,
    settlementTimestamp: number,
    admin: string,
    quoteDenom: string,
    marketId: string,
    makerFeeRate: string,
    takerFeeRate: string,
    relayerFeeShareRate: string,
    status: MarketStatusMap[keyof MarketStatusMap],
    minPriceTickSize: string,
    minQuantityTickSize: string,
    settlementPrice: string,
  }
}

export class ExpiryFuturesMarketInfo extends jspb.Message {
  getMarketId(): string;
  setMarketId(value: string): void;

  getExpirationTimestamp(): number;
  setExpirationTimestamp(value: number): void;

  getTwapStartTimestamp(): number;
  setTwapStartTimestamp(value: number): void;

  getExpirationTwapStartPriceCumulative(): string;
  setExpirationTwapStartPriceCumulative(value: string): void;

  getSettlementPrice(): string;
  setSettlementPrice(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): ExpiryFuturesMarketInfo.AsObject;
  static toObject(includeInstance: boolean, msg: ExpiryFuturesMarketInfo): ExpiryFuturesMarketInfo.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: ExpiryFuturesMarketInfo, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): ExpiryFuturesMarketInfo;
  static deserializeBinaryFromReader(message: ExpiryFuturesMarketInfo, reader: jspb.BinaryReader): ExpiryFuturesMarketInfo;
}

export namespace ExpiryFuturesMarketInfo {
  export type AsObject = {
    marketId: string,
    expirationTimestamp: number,
    twapStartTimestamp: number,
    expirationTwapStartPriceCumulative: string,
    settlementPrice: string,
  }
}

export class PerpetualMarketInfo extends jspb.Message {
  getMarketId(): string;
  setMarketId(value: string): void;

  getHourlyFundingRateCap(): string;
  setHourlyFundingRateCap(value: string): void;

  getHourlyInterestRate(): string;
  setHourlyInterestRate(value: string): void;

  getNextFundingTimestamp(): number;
  setNextFundingTimestamp(value: number): void;

  getFundingInterval(): number;
  setFundingInterval(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): PerpetualMarketInfo.AsObject;
  static toObject(includeInstance: boolean, msg: PerpetualMarketInfo): PerpetualMarketInfo.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: PerpetualMarketInfo, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): PerpetualMarketInfo;
  static deserializeBinaryFromReader(message: PerpetualMarketInfo, reader: jspb.BinaryReader): PerpetualMarketInfo;
}

export namespace PerpetualMarketInfo {
  export type AsObject = {
    marketId: string,
    hourlyFundingRateCap: string,
    hourlyInterestRate: string,
    nextFundingTimestamp: number,
    fundingInterval: number,
  }
}

export class PerpetualMarketFunding extends jspb.Message {
  getCumulativeFunding(): string;
  setCumulativeFunding(value: string): void;

  getCumulativePrice(): string;
  setCumulativePrice(value: string): void;

  getLastTimestamp(): number;
  setLastTimestamp(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): PerpetualMarketFunding.AsObject;
  static toObject(includeInstance: boolean, msg: PerpetualMarketFunding): PerpetualMarketFunding.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: PerpetualMarketFunding, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): PerpetualMarketFunding;
  static deserializeBinaryFromReader(message: PerpetualMarketFunding, reader: jspb.BinaryReader): PerpetualMarketFunding;
}

export namespace PerpetualMarketFunding {
  export type AsObject = {
    cumulativeFunding: string,
    cumulativePrice: string,
    lastTimestamp: number,
  }
}

export class DerivativeMarketSettlementInfo extends jspb.Message {
  getMarketId(): string;
  setMarketId(value: string): void;

  getSettlementPrice(): string;
  setSettlementPrice(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): DerivativeMarketSettlementInfo.AsObject;
  static toObject(includeInstance: boolean, msg: DerivativeMarketSettlementInfo): DerivativeMarketSettlementInfo.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: DerivativeMarketSettlementInfo, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): DerivativeMarketSettlementInfo;
  static deserializeBinaryFromReader(message: DerivativeMarketSettlementInfo, reader: jspb.BinaryReader): DerivativeMarketSettlementInfo;
}

export namespace DerivativeMarketSettlementInfo {
  export type AsObject = {
    marketId: string,
    settlementPrice: string,
  }
}

export class NextFundingTimestamp extends jspb.Message {
  getNextTimestamp(): number;
  setNextTimestamp(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): NextFundingTimestamp.AsObject;
  static toObject(includeInstance: boolean, msg: NextFundingTimestamp): NextFundingTimestamp.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: NextFundingTimestamp, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): NextFundingTimestamp;
  static deserializeBinaryFromReader(message: NextFundingTimestamp, reader: jspb.BinaryReader): NextFundingTimestamp;
}

export namespace NextFundingTimestamp {
  export type AsObject = {
    nextTimestamp: number,
  }
}

export class SpotMarket extends jspb.Message {
  getTicker(): string;
  setTicker(value: string): void;

  getBaseDenom(): string;
  setBaseDenom(value: string): void;

  getQuoteDenom(): string;
  setQuoteDenom(value: string): void;

  getMakerFeeRate(): string;
  setMakerFeeRate(value: string): void;

  getTakerFeeRate(): string;
  setTakerFeeRate(value: string): void;

  getRelayerFeeShareRate(): string;
  setRelayerFeeShareRate(value: string): void;

  getMarketId(): string;
  setMarketId(value: string): void;

  getStatus(): MarketStatusMap[keyof MarketStatusMap];
  setStatus(value: MarketStatusMap[keyof MarketStatusMap]): void;

  getMinPriceTickSize(): string;
  setMinPriceTickSize(value: string): void;

  getMinQuantityTickSize(): string;
  setMinQuantityTickSize(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): SpotMarket.AsObject;
  static toObject(includeInstance: boolean, msg: SpotMarket): SpotMarket.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: SpotMarket, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): SpotMarket;
  static deserializeBinaryFromReader(message: SpotMarket, reader: jspb.BinaryReader): SpotMarket;
}

export namespace SpotMarket {
  export type AsObject = {
    ticker: string,
    baseDenom: string,
    quoteDenom: string,
    makerFeeRate: string,
    takerFeeRate: string,
    relayerFeeShareRate: string,
    marketId: string,
    status: MarketStatusMap[keyof MarketStatusMap],
    minPriceTickSize: string,
    minQuantityTickSize: string,
  }
}

export class Deposit extends jspb.Message {
  getAvailableBalance(): string;
  setAvailableBalance(value: string): void;

  getTotalBalance(): string;
  setTotalBalance(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Deposit.AsObject;
  static toObject(includeInstance: boolean, msg: Deposit): Deposit.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Deposit, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Deposit;
  static deserializeBinaryFromReader(message: Deposit, reader: jspb.BinaryReader): Deposit;
}

export namespace Deposit {
  export type AsObject = {
    availableBalance: string,
    totalBalance: string,
  }
}

export class SubaccountTradeNonce extends jspb.Message {
  getNonce(): number;
  setNonce(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): SubaccountTradeNonce.AsObject;
  static toObject(includeInstance: boolean, msg: SubaccountTradeNonce): SubaccountTradeNonce.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: SubaccountTradeNonce, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): SubaccountTradeNonce;
  static deserializeBinaryFromReader(message: SubaccountTradeNonce, reader: jspb.BinaryReader): SubaccountTradeNonce;
}

export namespace SubaccountTradeNonce {
  export type AsObject = {
    nonce: number,
  }
}

export class OrderInfo extends jspb.Message {
  getSubaccountId(): string;
  setSubaccountId(value: string): void;

  getFeeRecipient(): string;
  setFeeRecipient(value: string): void;

  getPrice(): string;
  setPrice(value: string): void;

  getQuantity(): string;
  setQuantity(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): OrderInfo.AsObject;
  static toObject(includeInstance: boolean, msg: OrderInfo): OrderInfo.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: OrderInfo, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): OrderInfo;
  static deserializeBinaryFromReader(message: OrderInfo, reader: jspb.BinaryReader): OrderInfo;
}

export namespace OrderInfo {
  export type AsObject = {
    subaccountId: string,
    feeRecipient: string,
    price: string,
    quantity: string,
  }
}

export class SpotOrder extends jspb.Message {
  getMarketId(): string;
  setMarketId(value: string): void;

  hasOrderInfo(): boolean;
  clearOrderInfo(): void;
  getOrderInfo(): OrderInfo | undefined;
  setOrderInfo(value?: OrderInfo): void;

  getOrderType(): OrderTypeMap[keyof OrderTypeMap];
  setOrderType(value: OrderTypeMap[keyof OrderTypeMap]): void;

  getTriggerPrice(): string;
  setTriggerPrice(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): SpotOrder.AsObject;
  static toObject(includeInstance: boolean, msg: SpotOrder): SpotOrder.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: SpotOrder, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): SpotOrder;
  static deserializeBinaryFromReader(message: SpotOrder, reader: jspb.BinaryReader): SpotOrder;
}

export namespace SpotOrder {
  export type AsObject = {
    marketId: string,
    orderInfo?: OrderInfo.AsObject,
    orderType: OrderTypeMap[keyof OrderTypeMap],
    triggerPrice: string,
  }
}

export class SpotLimitOrder extends jspb.Message {
  hasOrderInfo(): boolean;
  clearOrderInfo(): void;
  getOrderInfo(): OrderInfo | undefined;
  setOrderInfo(value?: OrderInfo): void;

  getOrderType(): OrderTypeMap[keyof OrderTypeMap];
  setOrderType(value: OrderTypeMap[keyof OrderTypeMap]): void;

  getFillable(): string;
  setFillable(value: string): void;

  getTriggerPrice(): string;
  setTriggerPrice(value: string): void;

  getOrderHash(): Uint8Array | string;
  getOrderHash_asU8(): Uint8Array;
  getOrderHash_asB64(): string;
  setOrderHash(value: Uint8Array | string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): SpotLimitOrder.AsObject;
  static toObject(includeInstance: boolean, msg: SpotLimitOrder): SpotLimitOrder.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: SpotLimitOrder, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): SpotLimitOrder;
  static deserializeBinaryFromReader(message: SpotLimitOrder, reader: jspb.BinaryReader): SpotLimitOrder;
}

export namespace SpotLimitOrder {
  export type AsObject = {
    orderInfo?: OrderInfo.AsObject,
    orderType: OrderTypeMap[keyof OrderTypeMap],
    fillable: string,
    triggerPrice: string,
    orderHash: Uint8Array | string,
  }
}

export class SpotMarketOrder extends jspb.Message {
  hasOrderInfo(): boolean;
  clearOrderInfo(): void;
  getOrderInfo(): OrderInfo | undefined;
  setOrderInfo(value?: OrderInfo): void;

  getBalanceHold(): string;
  setBalanceHold(value: string): void;

  getOrderHash(): Uint8Array | string;
  getOrderHash_asU8(): Uint8Array;
  getOrderHash_asB64(): string;
  setOrderHash(value: Uint8Array | string): void;

  getOrderType(): OrderTypeMap[keyof OrderTypeMap];
  setOrderType(value: OrderTypeMap[keyof OrderTypeMap]): void;

  getTriggerPrice(): string;
  setTriggerPrice(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): SpotMarketOrder.AsObject;
  static toObject(includeInstance: boolean, msg: SpotMarketOrder): SpotMarketOrder.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: SpotMarketOrder, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): SpotMarketOrder;
  static deserializeBinaryFromReader(message: SpotMarketOrder, reader: jspb.BinaryReader): SpotMarketOrder;
}

export namespace SpotMarketOrder {
  export type AsObject = {
    orderInfo?: OrderInfo.AsObject,
    balanceHold: string,
    orderHash: Uint8Array | string,
    orderType: OrderTypeMap[keyof OrderTypeMap],
    triggerPrice: string,
  }
}

export class DerivativeOrder extends jspb.Message {
  getMarketId(): string;
  setMarketId(value: string): void;

  hasOrderInfo(): boolean;
  clearOrderInfo(): void;
  getOrderInfo(): OrderInfo | undefined;
  setOrderInfo(value?: OrderInfo): void;

  getOrderType(): OrderTypeMap[keyof OrderTypeMap];
  setOrderType(value: OrderTypeMap[keyof OrderTypeMap]): void;

  getMargin(): string;
  setMargin(value: string): void;

  getTriggerPrice(): string;
  setTriggerPrice(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): DerivativeOrder.AsObject;
  static toObject(includeInstance: boolean, msg: DerivativeOrder): DerivativeOrder.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: DerivativeOrder, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): DerivativeOrder;
  static deserializeBinaryFromReader(message: DerivativeOrder, reader: jspb.BinaryReader): DerivativeOrder;
}

export namespace DerivativeOrder {
  export type AsObject = {
    marketId: string,
    orderInfo?: OrderInfo.AsObject,
    orderType: OrderTypeMap[keyof OrderTypeMap],
    margin: string,
    triggerPrice: string,
  }
}

export class SubaccountOrderbookMetadata extends jspb.Message {
  getVanillaLimitOrderCount(): number;
  setVanillaLimitOrderCount(value: number): void;

  getReduceOnlyLimitOrderCount(): number;
  setReduceOnlyLimitOrderCount(value: number): void;

  getAggregateReduceOnlyQuantity(): string;
  setAggregateReduceOnlyQuantity(value: string): void;

  getAggregateVanillaQuantity(): string;
  setAggregateVanillaQuantity(value: string): void;

  getVanillaConditionalOrderCount(): number;
  setVanillaConditionalOrderCount(value: number): void;

  getReduceOnlyConditionalOrderCount(): number;
  setReduceOnlyConditionalOrderCount(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): SubaccountOrderbookMetadata.AsObject;
  static toObject(includeInstance: boolean, msg: SubaccountOrderbookMetadata): SubaccountOrderbookMetadata.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: SubaccountOrderbookMetadata, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): SubaccountOrderbookMetadata;
  static deserializeBinaryFromReader(message: SubaccountOrderbookMetadata, reader: jspb.BinaryReader): SubaccountOrderbookMetadata;
}

export namespace SubaccountOrderbookMetadata {
  export type AsObject = {
    vanillaLimitOrderCount: number,
    reduceOnlyLimitOrderCount: number,
    aggregateReduceOnlyQuantity: string,
    aggregateVanillaQuantity: string,
    vanillaConditionalOrderCount: number,
    reduceOnlyConditionalOrderCount: number,
  }
}

export class SubaccountOrder extends jspb.Message {
  getPrice(): string;
  setPrice(value: string): void;

  getQuantity(): string;
  setQuantity(value: string): void;

  getIsreduceonly(): boolean;
  setIsreduceonly(value: boolean): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): SubaccountOrder.AsObject;
  static toObject(includeInstance: boolean, msg: SubaccountOrder): SubaccountOrder.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: SubaccountOrder, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): SubaccountOrder;
  static deserializeBinaryFromReader(message: SubaccountOrder, reader: jspb.BinaryReader): SubaccountOrder;
}

export namespace SubaccountOrder {
  export type AsObject = {
    price: string,
    quantity: string,
    isreduceonly: boolean,
  }
}

export class SubaccountOrderData extends jspb.Message {
  hasOrder(): boolean;
  clearOrder(): void;
  getOrder(): SubaccountOrder | undefined;
  setOrder(value?: SubaccountOrder): void;

  getOrderHash(): Uint8Array | string;
  getOrderHash_asU8(): Uint8Array;
  getOrderHash_asB64(): string;
  setOrderHash(value: Uint8Array | string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): SubaccountOrderData.AsObject;
  static toObject(includeInstance: boolean, msg: SubaccountOrderData): SubaccountOrderData.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: SubaccountOrderData, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): SubaccountOrderData;
  static deserializeBinaryFromReader(message: SubaccountOrderData, reader: jspb.BinaryReader): SubaccountOrderData;
}

export namespace SubaccountOrderData {
  export type AsObject = {
    order?: SubaccountOrder.AsObject,
    orderHash: Uint8Array | string,
  }
}

export class DerivativeLimitOrder extends jspb.Message {
  hasOrderInfo(): boolean;
  clearOrderInfo(): void;
  getOrderInfo(): OrderInfo | undefined;
  setOrderInfo(value?: OrderInfo): void;

  getOrderType(): OrderTypeMap[keyof OrderTypeMap];
  setOrderType(value: OrderTypeMap[keyof OrderTypeMap]): void;

  getMargin(): string;
  setMargin(value: string): void;

  getFillable(): string;
  setFillable(value: string): void;

  getTriggerPrice(): string;
  setTriggerPrice(value: string): void;

  getOrderHash(): Uint8Array | string;
  getOrderHash_asU8(): Uint8Array;
  getOrderHash_asB64(): string;
  setOrderHash(value: Uint8Array | string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): DerivativeLimitOrder.AsObject;
  static toObject(includeInstance: boolean, msg: DerivativeLimitOrder): DerivativeLimitOrder.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: DerivativeLimitOrder, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): DerivativeLimitOrder;
  static deserializeBinaryFromReader(message: DerivativeLimitOrder, reader: jspb.BinaryReader): DerivativeLimitOrder;
}

export namespace DerivativeLimitOrder {
  export type AsObject = {
    orderInfo?: OrderInfo.AsObject,
    orderType: OrderTypeMap[keyof OrderTypeMap],
    margin: string,
    fillable: string,
    triggerPrice: string,
    orderHash: Uint8Array | string,
  }
}

export class DerivativeMarketOrder extends jspb.Message {
  hasOrderInfo(): boolean;
  clearOrderInfo(): void;
  getOrderInfo(): OrderInfo | undefined;
  setOrderInfo(value?: OrderInfo): void;

  getOrderType(): OrderTypeMap[keyof OrderTypeMap];
  setOrderType(value: OrderTypeMap[keyof OrderTypeMap]): void;

  getMargin(): string;
  setMargin(value: string): void;

  getMarginHold(): string;
  setMarginHold(value: string): void;

  getTriggerPrice(): string;
  setTriggerPrice(value: string): void;

  getOrderHash(): Uint8Array | string;
  getOrderHash_asU8(): Uint8Array;
  getOrderHash_asB64(): string;
  setOrderHash(value: Uint8Array | string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): DerivativeMarketOrder.AsObject;
  static toObject(includeInstance: boolean, msg: DerivativeMarketOrder): DerivativeMarketOrder.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: DerivativeMarketOrder, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): DerivativeMarketOrder;
  static deserializeBinaryFromReader(message: DerivativeMarketOrder, reader: jspb.BinaryReader): DerivativeMarketOrder;
}

export namespace DerivativeMarketOrder {
  export type AsObject = {
    orderInfo?: OrderInfo.AsObject,
    orderType: OrderTypeMap[keyof OrderTypeMap],
    margin: string,
    marginHold: string,
    triggerPrice: string,
    orderHash: Uint8Array | string,
  }
}

export class Position extends jspb.Message {
  getIslong(): boolean;
  setIslong(value: boolean): void;

  getQuantity(): string;
  setQuantity(value: string): void;

  getEntryPrice(): string;
  setEntryPrice(value: string): void;

  getMargin(): string;
  setMargin(value: string): void;

  getCumulativeFundingEntry(): string;
  setCumulativeFundingEntry(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Position.AsObject;
  static toObject(includeInstance: boolean, msg: Position): Position.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Position, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Position;
  static deserializeBinaryFromReader(message: Position, reader: jspb.BinaryReader): Position;
}

export namespace Position {
  export type AsObject = {
    islong: boolean,
    quantity: string,
    entryPrice: string,
    margin: string,
    cumulativeFundingEntry: string,
  }
}

export class MarketOrderIndicator extends jspb.Message {
  getMarketId(): string;
  setMarketId(value: string): void;

  getIsbuy(): boolean;
  setIsbuy(value: boolean): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): MarketOrderIndicator.AsObject;
  static toObject(includeInstance: boolean, msg: MarketOrderIndicator): MarketOrderIndicator.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: MarketOrderIndicator, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): MarketOrderIndicator;
  static deserializeBinaryFromReader(message: MarketOrderIndicator, reader: jspb.BinaryReader): MarketOrderIndicator;
}

export namespace MarketOrderIndicator {
  export type AsObject = {
    marketId: string,
    isbuy: boolean,
  }
}

export class TradeLog extends jspb.Message {
  getQuantity(): string;
  setQuantity(value: string): void;

  getPrice(): string;
  setPrice(value: string): void;

  getSubaccountId(): Uint8Array | string;
  getSubaccountId_asU8(): Uint8Array;
  getSubaccountId_asB64(): string;
  setSubaccountId(value: Uint8Array | string): void;

  getFee(): string;
  setFee(value: string): void;

  getOrderHash(): Uint8Array | string;
  getOrderHash_asU8(): Uint8Array;
  getOrderHash_asB64(): string;
  setOrderHash(value: Uint8Array | string): void;

  getFeeRecipientAddress(): Uint8Array | string;
  getFeeRecipientAddress_asU8(): Uint8Array;
  getFeeRecipientAddress_asB64(): string;
  setFeeRecipientAddress(value: Uint8Array | string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TradeLog.AsObject;
  static toObject(includeInstance: boolean, msg: TradeLog): TradeLog.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: TradeLog, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): TradeLog;
  static deserializeBinaryFromReader(message: TradeLog, reader: jspb.BinaryReader): TradeLog;
}

export namespace TradeLog {
  export type AsObject = {
    quantity: string,
    price: string,
    subaccountId: Uint8Array | string,
    fee: string,
    orderHash: Uint8Array | string,
    feeRecipientAddress: Uint8Array | string,
  }
}

export class PositionDelta extends jspb.Message {
  getIsLong(): boolean;
  setIsLong(value: boolean): void;

  getExecutionQuantity(): string;
  setExecutionQuantity(value: string): void;

  getExecutionMargin(): string;
  setExecutionMargin(value: string): void;

  getExecutionPrice(): string;
  setExecutionPrice(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): PositionDelta.AsObject;
  static toObject(includeInstance: boolean, msg: PositionDelta): PositionDelta.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: PositionDelta, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): PositionDelta;
  static deserializeBinaryFromReader(message: PositionDelta, reader: jspb.BinaryReader): PositionDelta;
}

export namespace PositionDelta {
  export type AsObject = {
    isLong: boolean,
    executionQuantity: string,
    executionMargin: string,
    executionPrice: string,
  }
}

export class DerivativeTradeLog extends jspb.Message {
  getSubaccountId(): Uint8Array | string;
  getSubaccountId_asU8(): Uint8Array;
  getSubaccountId_asB64(): string;
  setSubaccountId(value: Uint8Array | string): void;

  hasPositionDelta(): boolean;
  clearPositionDelta(): void;
  getPositionDelta(): PositionDelta | undefined;
  setPositionDelta(value?: PositionDelta): void;

  getPayout(): string;
  setPayout(value: string): void;

  getFee(): string;
  setFee(value: string): void;

  getOrderHash(): Uint8Array | string;
  getOrderHash_asU8(): Uint8Array;
  getOrderHash_asB64(): string;
  setOrderHash(value: Uint8Array | string): void;

  getFeeRecipientAddress(): Uint8Array | string;
  getFeeRecipientAddress_asU8(): Uint8Array;
  getFeeRecipientAddress_asB64(): string;
  setFeeRecipientAddress(value: Uint8Array | string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): DerivativeTradeLog.AsObject;
  static toObject(includeInstance: boolean, msg: DerivativeTradeLog): DerivativeTradeLog.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: DerivativeTradeLog, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): DerivativeTradeLog;
  static deserializeBinaryFromReader(message: DerivativeTradeLog, reader: jspb.BinaryReader): DerivativeTradeLog;
}

export namespace DerivativeTradeLog {
  export type AsObject = {
    subaccountId: Uint8Array | string,
    positionDelta?: PositionDelta.AsObject,
    payout: string,
    fee: string,
    orderHash: Uint8Array | string,
    feeRecipientAddress: Uint8Array | string,
  }
}

export class SubaccountPosition extends jspb.Message {
  hasPosition(): boolean;
  clearPosition(): void;
  getPosition(): Position | undefined;
  setPosition(value?: Position): void;

  getSubaccountId(): Uint8Array | string;
  getSubaccountId_asU8(): Uint8Array;
  getSubaccountId_asB64(): string;
  setSubaccountId(value: Uint8Array | string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): SubaccountPosition.AsObject;
  static toObject(includeInstance: boolean, msg: SubaccountPosition): SubaccountPosition.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: SubaccountPosition, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): SubaccountPosition;
  static deserializeBinaryFromReader(message: SubaccountPosition, reader: jspb.BinaryReader): SubaccountPosition;
}

export namespace SubaccountPosition {
  export type AsObject = {
    position?: Position.AsObject,
    subaccountId: Uint8Array | string,
  }
}

export class SubaccountDeposit extends jspb.Message {
  getSubaccountId(): Uint8Array | string;
  getSubaccountId_asU8(): Uint8Array;
  getSubaccountId_asB64(): string;
  setSubaccountId(value: Uint8Array | string): void;

  hasDeposit(): boolean;
  clearDeposit(): void;
  getDeposit(): Deposit | undefined;
  setDeposit(value?: Deposit): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): SubaccountDeposit.AsObject;
  static toObject(includeInstance: boolean, msg: SubaccountDeposit): SubaccountDeposit.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: SubaccountDeposit, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): SubaccountDeposit;
  static deserializeBinaryFromReader(message: SubaccountDeposit, reader: jspb.BinaryReader): SubaccountDeposit;
}

export namespace SubaccountDeposit {
  export type AsObject = {
    subaccountId: Uint8Array | string,
    deposit?: Deposit.AsObject,
  }
}

export class DepositUpdate extends jspb.Message {
  getDenom(): string;
  setDenom(value: string): void;

  clearDepositsList(): void;
  getDepositsList(): Array<SubaccountDeposit>;
  setDepositsList(value: Array<SubaccountDeposit>): void;
  addDeposits(value?: SubaccountDeposit, index?: number): SubaccountDeposit;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): DepositUpdate.AsObject;
  static toObject(includeInstance: boolean, msg: DepositUpdate): DepositUpdate.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: DepositUpdate, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): DepositUpdate;
  static deserializeBinaryFromReader(message: DepositUpdate, reader: jspb.BinaryReader): DepositUpdate;
}

export namespace DepositUpdate {
  export type AsObject = {
    denom: string,
    depositsList: Array<SubaccountDeposit.AsObject>,
  }
}

export class PointsMultiplier extends jspb.Message {
  getMakerPointsMultiplier(): string;
  setMakerPointsMultiplier(value: string): void;

  getTakerPointsMultiplier(): string;
  setTakerPointsMultiplier(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): PointsMultiplier.AsObject;
  static toObject(includeInstance: boolean, msg: PointsMultiplier): PointsMultiplier.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: PointsMultiplier, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): PointsMultiplier;
  static deserializeBinaryFromReader(message: PointsMultiplier, reader: jspb.BinaryReader): PointsMultiplier;
}

export namespace PointsMultiplier {
  export type AsObject = {
    makerPointsMultiplier: string,
    takerPointsMultiplier: string,
  }
}

export class TradingRewardCampaignBoostInfo extends jspb.Message {
  clearBoostedSpotMarketIdsList(): void;
  getBoostedSpotMarketIdsList(): Array<string>;
  setBoostedSpotMarketIdsList(value: Array<string>): void;
  addBoostedSpotMarketIds(value: string, index?: number): string;

  clearSpotMarketMultipliersList(): void;
  getSpotMarketMultipliersList(): Array<PointsMultiplier>;
  setSpotMarketMultipliersList(value: Array<PointsMultiplier>): void;
  addSpotMarketMultipliers(value?: PointsMultiplier, index?: number): PointsMultiplier;

  clearBoostedDerivativeMarketIdsList(): void;
  getBoostedDerivativeMarketIdsList(): Array<string>;
  setBoostedDerivativeMarketIdsList(value: Array<string>): void;
  addBoostedDerivativeMarketIds(value: string, index?: number): string;

  clearDerivativeMarketMultipliersList(): void;
  getDerivativeMarketMultipliersList(): Array<PointsMultiplier>;
  setDerivativeMarketMultipliersList(value: Array<PointsMultiplier>): void;
  addDerivativeMarketMultipliers(value?: PointsMultiplier, index?: number): PointsMultiplier;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TradingRewardCampaignBoostInfo.AsObject;
  static toObject(includeInstance: boolean, msg: TradingRewardCampaignBoostInfo): TradingRewardCampaignBoostInfo.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: TradingRewardCampaignBoostInfo, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): TradingRewardCampaignBoostInfo;
  static deserializeBinaryFromReader(message: TradingRewardCampaignBoostInfo, reader: jspb.BinaryReader): TradingRewardCampaignBoostInfo;
}

export namespace TradingRewardCampaignBoostInfo {
  export type AsObject = {
    boostedSpotMarketIdsList: Array<string>,
    spotMarketMultipliersList: Array<PointsMultiplier.AsObject>,
    boostedDerivativeMarketIdsList: Array<string>,
    derivativeMarketMultipliersList: Array<PointsMultiplier.AsObject>,
  }
}

export class CampaignRewardPool extends jspb.Message {
  getStartTimestamp(): number;
  setStartTimestamp(value: number): void;

  clearMaxCampaignRewardsList(): void;
  getMaxCampaignRewardsList(): Array<cosmos_base_v1beta1_coin_pb.Coin>;
  setMaxCampaignRewardsList(value: Array<cosmos_base_v1beta1_coin_pb.Coin>): void;
  addMaxCampaignRewards(value?: cosmos_base_v1beta1_coin_pb.Coin, index?: number): cosmos_base_v1beta1_coin_pb.Coin;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): CampaignRewardPool.AsObject;
  static toObject(includeInstance: boolean, msg: CampaignRewardPool): CampaignRewardPool.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: CampaignRewardPool, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): CampaignRewardPool;
  static deserializeBinaryFromReader(message: CampaignRewardPool, reader: jspb.BinaryReader): CampaignRewardPool;
}

export namespace CampaignRewardPool {
  export type AsObject = {
    startTimestamp: number,
    maxCampaignRewardsList: Array<cosmos_base_v1beta1_coin_pb.Coin.AsObject>,
  }
}

export class TradingRewardCampaignInfo extends jspb.Message {
  getCampaignDurationSeconds(): number;
  setCampaignDurationSeconds(value: number): void;

  clearQuoteDenomsList(): void;
  getQuoteDenomsList(): Array<string>;
  setQuoteDenomsList(value: Array<string>): void;
  addQuoteDenoms(value: string, index?: number): string;

  hasTradingRewardBoostInfo(): boolean;
  clearTradingRewardBoostInfo(): void;
  getTradingRewardBoostInfo(): TradingRewardCampaignBoostInfo | undefined;
  setTradingRewardBoostInfo(value?: TradingRewardCampaignBoostInfo): void;

  clearDisqualifiedMarketIdsList(): void;
  getDisqualifiedMarketIdsList(): Array<string>;
  setDisqualifiedMarketIdsList(value: Array<string>): void;
  addDisqualifiedMarketIds(value: string, index?: number): string;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TradingRewardCampaignInfo.AsObject;
  static toObject(includeInstance: boolean, msg: TradingRewardCampaignInfo): TradingRewardCampaignInfo.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: TradingRewardCampaignInfo, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): TradingRewardCampaignInfo;
  static deserializeBinaryFromReader(message: TradingRewardCampaignInfo, reader: jspb.BinaryReader): TradingRewardCampaignInfo;
}

export namespace TradingRewardCampaignInfo {
  export type AsObject = {
    campaignDurationSeconds: number,
    quoteDenomsList: Array<string>,
    tradingRewardBoostInfo?: TradingRewardCampaignBoostInfo.AsObject,
    disqualifiedMarketIdsList: Array<string>,
  }
}

export class FeeDiscountTierInfo extends jspb.Message {
  getMakerDiscountRate(): string;
  setMakerDiscountRate(value: string): void;

  getTakerDiscountRate(): string;
  setTakerDiscountRate(value: string): void;

  getStakedAmount(): string;
  setStakedAmount(value: string): void;

  getVolume(): string;
  setVolume(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): FeeDiscountTierInfo.AsObject;
  static toObject(includeInstance: boolean, msg: FeeDiscountTierInfo): FeeDiscountTierInfo.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: FeeDiscountTierInfo, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): FeeDiscountTierInfo;
  static deserializeBinaryFromReader(message: FeeDiscountTierInfo, reader: jspb.BinaryReader): FeeDiscountTierInfo;
}

export namespace FeeDiscountTierInfo {
  export type AsObject = {
    makerDiscountRate: string,
    takerDiscountRate: string,
    stakedAmount: string,
    volume: string,
  }
}

export class FeeDiscountSchedule extends jspb.Message {
  getBucketCount(): number;
  setBucketCount(value: number): void;

  getBucketDuration(): number;
  setBucketDuration(value: number): void;

  clearQuoteDenomsList(): void;
  getQuoteDenomsList(): Array<string>;
  setQuoteDenomsList(value: Array<string>): void;
  addQuoteDenoms(value: string, index?: number): string;

  clearTierInfosList(): void;
  getTierInfosList(): Array<FeeDiscountTierInfo>;
  setTierInfosList(value: Array<FeeDiscountTierInfo>): void;
  addTierInfos(value?: FeeDiscountTierInfo, index?: number): FeeDiscountTierInfo;

  clearDisqualifiedMarketIdsList(): void;
  getDisqualifiedMarketIdsList(): Array<string>;
  setDisqualifiedMarketIdsList(value: Array<string>): void;
  addDisqualifiedMarketIds(value: string, index?: number): string;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): FeeDiscountSchedule.AsObject;
  static toObject(includeInstance: boolean, msg: FeeDiscountSchedule): FeeDiscountSchedule.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: FeeDiscountSchedule, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): FeeDiscountSchedule;
  static deserializeBinaryFromReader(message: FeeDiscountSchedule, reader: jspb.BinaryReader): FeeDiscountSchedule;
}

export namespace FeeDiscountSchedule {
  export type AsObject = {
    bucketCount: number,
    bucketDuration: number,
    quoteDenomsList: Array<string>,
    tierInfosList: Array<FeeDiscountTierInfo.AsObject>,
    disqualifiedMarketIdsList: Array<string>,
  }
}

export class FeeDiscountTierTTL extends jspb.Message {
  getTier(): number;
  setTier(value: number): void;

  getTtlTimestamp(): number;
  setTtlTimestamp(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): FeeDiscountTierTTL.AsObject;
  static toObject(includeInstance: boolean, msg: FeeDiscountTierTTL): FeeDiscountTierTTL.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: FeeDiscountTierTTL, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): FeeDiscountTierTTL;
  static deserializeBinaryFromReader(message: FeeDiscountTierTTL, reader: jspb.BinaryReader): FeeDiscountTierTTL;
}

export namespace FeeDiscountTierTTL {
  export type AsObject = {
    tier: number,
    ttlTimestamp: number,
  }
}

export class AccountRewards extends jspb.Message {
  getAccount(): string;
  setAccount(value: string): void;

  clearRewardsList(): void;
  getRewardsList(): Array<cosmos_base_v1beta1_coin_pb.Coin>;
  setRewardsList(value: Array<cosmos_base_v1beta1_coin_pb.Coin>): void;
  addRewards(value?: cosmos_base_v1beta1_coin_pb.Coin, index?: number): cosmos_base_v1beta1_coin_pb.Coin;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): AccountRewards.AsObject;
  static toObject(includeInstance: boolean, msg: AccountRewards): AccountRewards.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: AccountRewards, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): AccountRewards;
  static deserializeBinaryFromReader(message: AccountRewards, reader: jspb.BinaryReader): AccountRewards;
}

export namespace AccountRewards {
  export type AsObject = {
    account: string,
    rewardsList: Array<cosmos_base_v1beta1_coin_pb.Coin.AsObject>,
  }
}

export class TradeRecords extends jspb.Message {
  getMarketId(): string;
  setMarketId(value: string): void;

  clearLatestTradeRecordsList(): void;
  getLatestTradeRecordsList(): Array<TradeRecord>;
  setLatestTradeRecordsList(value: Array<TradeRecord>): void;
  addLatestTradeRecords(value?: TradeRecord, index?: number): TradeRecord;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TradeRecords.AsObject;
  static toObject(includeInstance: boolean, msg: TradeRecords): TradeRecords.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: TradeRecords, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): TradeRecords;
  static deserializeBinaryFromReader(message: TradeRecords, reader: jspb.BinaryReader): TradeRecords;
}

export namespace TradeRecords {
  export type AsObject = {
    marketId: string,
    latestTradeRecordsList: Array<TradeRecord.AsObject>,
  }
}

export class SubaccountIDs extends jspb.Message {
  clearSubaccountIdsList(): void;
  getSubaccountIdsList(): Array<Uint8Array | string>;
  getSubaccountIdsList_asU8(): Array<Uint8Array>;
  getSubaccountIdsList_asB64(): Array<string>;
  setSubaccountIdsList(value: Array<Uint8Array | string>): void;
  addSubaccountIds(value: Uint8Array | string, index?: number): Uint8Array | string;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): SubaccountIDs.AsObject;
  static toObject(includeInstance: boolean, msg: SubaccountIDs): SubaccountIDs.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: SubaccountIDs, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): SubaccountIDs;
  static deserializeBinaryFromReader(message: SubaccountIDs, reader: jspb.BinaryReader): SubaccountIDs;
}

export namespace SubaccountIDs {
  export type AsObject = {
    subaccountIdsList: Array<Uint8Array | string>,
  }
}

export class TradeRecord extends jspb.Message {
  getTimestamp(): number;
  setTimestamp(value: number): void;

  getPrice(): string;
  setPrice(value: string): void;

  getQuantity(): string;
  setQuantity(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): TradeRecord.AsObject;
  static toObject(includeInstance: boolean, msg: TradeRecord): TradeRecord.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: TradeRecord, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): TradeRecord;
  static deserializeBinaryFromReader(message: TradeRecord, reader: jspb.BinaryReader): TradeRecord;
}

export namespace TradeRecord {
  export type AsObject = {
    timestamp: number,
    price: string,
    quantity: string,
  }
}

export class Level extends jspb.Message {
  getP(): string;
  setP(value: string): void;

  getQ(): string;
  setQ(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Level.AsObject;
  static toObject(includeInstance: boolean, msg: Level): Level.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Level, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Level;
  static deserializeBinaryFromReader(message: Level, reader: jspb.BinaryReader): Level;
}

export namespace Level {
  export type AsObject = {
    p: string,
    q: string,
  }
}

export interface AtomicMarketOrderAccessLevelMap {
  NOBODY: 0;
  BEGINBLOCKERSMARTCONTRACTSONLY: 1;
  SMARTCONTRACTSONLY: 2;
  EVERYONE: 3;
}

export const AtomicMarketOrderAccessLevel: AtomicMarketOrderAccessLevelMap;

export interface MarketStatusMap {
  UNSPECIFIED: 0;
  ACTIVE: 1;
  PAUSED: 2;
  DEMOLISHED: 3;
  EXPIRED: 4;
}

export const MarketStatus: MarketStatusMap;

export interface OrderTypeMap {
  UNSPECIFIED: 0;
  BUY: 1;
  SELL: 2;
  STOP_BUY: 3;
  STOP_SELL: 4;
  TAKE_BUY: 5;
  TAKE_SELL: 6;
  BUY_PO: 7;
  SELL_PO: 8;
  BUY_ATOMIC: 9;
  SELL_ATOMIC: 10;
}

export const OrderType: OrderTypeMap;

export interface ExecutionTypeMap {
  UNSPECIFIEDEXECUTIONTYPE: 0;
  MARKET: 1;
  LIMITFILL: 2;
  LIMITMATCHRESTINGORDER: 3;
  LIMITMATCHNEWORDER: 4;
  MARKETLIQUIDATION: 5;
  EXPIRYMARKETSETTLEMENT: 6;
}

export const ExecutionType: ExecutionTypeMap;

export interface OrderMaskMap {
  UNUSED: 0;
  ANY: 1;
  REGULAR: 2;
  CONDITIONAL: 4;
  DIRECTION_BUY_OR_HIGHER: 8;
  DIRECTION_SELL_OR_LOWER: 16;
  TYPE_MARKET: 32;
  TYPE_LIMIT: 64;
}

export const OrderMask: OrderMaskMap;

