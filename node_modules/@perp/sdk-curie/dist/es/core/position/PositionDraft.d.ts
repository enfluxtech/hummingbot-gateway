import { Channel, ChannelEventSource } from "../../internal";
import { GetPositionDraftRelatedDataReturn, GetQuoterSwapReturn } from "../contractReader";
import { PerpetualProtocol, PerpetualProtocolConnected } from "../PerpetualProtocol";
import Big from "big.js";
import { Market } from "../market";
import { PositionSide } from "./types";
export declare type PositionDraftEventName = "updateError" | "updated" | "buyingPowerUpdated";
export interface PositionDraftDataUpdatable {
    side?: PositionSide;
    amountInput?: Big;
    isAmountInputBase?: boolean;
}
export interface PositionDraftConstructorData {
    market: Market;
    side: PositionSide;
    amountInput: Big;
    isAmountInputBase: boolean;
}
export interface PositionDraftUserInputRelatedData {
    amountOutput: Big;
    isAmountOutputBase: boolean;
    entryPrice: Big;
    priceImpact: Big;
    transactionFee: Big;
    deltaAvailableBase: Big;
    deltaAvailableQuote: Big;
}
export declare class PositionDraft<EventName extends string = string> extends Channel<PositionDraftEventName | EventName> {
    protected readonly _perp: PerpetualProtocol | PerpetualProtocolConnected;
    private _cache;
    side: PositionSide;
    amountInput: Big;
    isAmountInputBase: boolean;
    market: Market;
    private _feeRatio;
    private _imRatio;
    private _contractReader;
    constructor(_perp: PerpetualProtocol | PerpetualProtocolConnected, { market, side, amountInput, isAmountInputBase, }: PositionDraftConstructorData);
    /**
     * When opening position, is trader selling BASE token in exchange for QUOTE token?
     */
    get isBaseToQuote(): boolean;
    /**
     * When opening position, is the user input for the same token as the token inputted to the pool?
     * NOTE: see truth table, https://docs.google.com/spreadsheets/d/1gVLSYVj98e0p2HaxQ7NdHCejd6S25sr9jgXlnzE1jqE/edit#gid=2106034965
     */
    get isExactInput(): boolean;
    /**
     * Calculate the upper/lower bound for slippage protection.
     * Formula: https://www.notion.so/perp/V2-Formula-for-opening-position-e8f7e481cf144b75977217114cecbdb9#4e6cd0d79c7a4565bb90835593cb7dcd
     **/
    getOppositeAmountBound(slippage: Big): Promise<Big>;
    protected _getEventSourceMap(): {
        updated: ChannelEventSource<PositionDraftEventName | EventName>;
        buyingPowerUpdated: ChannelEventSource<PositionDraftEventName | EventName>;
    };
    private _createFetchUpdateData;
    protected _handleMarketUpdate(): Promise<void>;
    getSwap({ cache }?: {
        cache?: boolean | undefined;
    }): Promise<GetQuoterSwapReturn>;
    getEntryPrice({ cache }?: {
        cache?: boolean | undefined;
    }): Promise<Big>;
    getPriceImpact({ cache }?: {
        cache?: boolean | undefined;
    }): Promise<Big>;
    getTransactionFee({ cache }?: {
        cache?: boolean | undefined;
    }): Promise<Big>;
    getBuyingPower({ cache }?: {
        cache?: boolean | undefined;
    }): Promise<Big>;
    private getExistingPositionSize;
    simulateOpenPosition(): Promise<{
        deltaBase: Big;
        deltaQuote: Big;
    }>;
    getRelatedData({ cache }?: {
        cache?: boolean | undefined;
    }): Promise<GetPositionDraftRelatedDataReturn>;
    private _fetch;
}
