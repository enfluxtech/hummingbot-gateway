{"version":3,"file":"ClearingHouse.js","sources":["../../../../src/core/clearingHouse/ClearingHouse.ts"],"sourcesContent":["import {\n    Channel,\n    ChannelEventSource,\n    DEFAULT_PERIOD,\n    MemoizedFetcher,\n    createMemoizedFetcher,\n    hasNumberChange,\n} from \"../../internal\"\nimport { PositionDraft, PositionDraftConstructorData } from \"../position/PositionDraft\"\nimport { big2BigNumberAndScaleUp, invariant, poll } from \"../../utils\"\nimport { constants, utils } from \"ethers\"\n\nimport { BIG_ONE } from \"../../constants\"\nimport Big from \"big.js\"\nimport { ClearingHouse as ContractClearingHouse } from \"../../contracts/type\"\nimport { ContractName } from \"../../contracts\"\nimport { Liquidity } from \"../liquidity/Liquidity\"\nimport { LiquidityDraft } from \"../liquidity/LiquidityDraft\"\nimport type { PerpetualProtocol } from \"../PerpetualProtocol\"\nimport { Position } from \"../position/Position\"\nimport { UnauthorizedError } from \"../../errors\"\nimport { getTransaction } from \"../../transactionSender\"\n\ninterface DraftPositionInput\n    extends Omit<\n        PositionDraftConstructorData,\n        \"market\" | \"wallet\" | \"baseTokenAddress\" | \"feeRatio\" | \"imRatio\" | \"marketMap\"\n    > {\n    tickerSymbol: string\n}\n\ntype ClearingHouseEventName = \"updated\" | \"updateError\"\n\ntype CacheKey = \"accountValue\"\ntype CacheValue = Big\n\nclass ClearingHouse extends Channel<ClearingHouseEventName> {\n    private _cache: Map<CacheKey, CacheValue> = new Map()\n\n    constructor(protected readonly _perp: PerpetualProtocol) {\n        super(_perp.channelRegistry)\n    }\n\n    createPositionDraft({ tickerSymbol, amountInput, isAmountInputBase, side }: DraftPositionInput) {\n        const market = this._perp.markets.getMarket({ tickerSymbol: tickerSymbol })\n        return new PositionDraft(this._perp, {\n            market,\n            amountInput,\n            isAmountInputBase,\n            side,\n        })\n    }\n\n    createLiquidityDraft({\n        tickerSymbol,\n        lowerTick,\n        upperTick,\n        rawQuoteAmount,\n        rawBaseAmount,\n    }: {\n        tickerSymbol: string\n        lowerTick: number\n        upperTick: number\n        rawQuoteAmount?: Big\n        rawBaseAmount?: Big\n    }) {\n        const market = this._perp.markets.getMarket({ tickerSymbol })\n        return new LiquidityDraft({\n            perp: this._perp,\n            market,\n            lowerTick,\n            upperTick,\n            rawQuoteAmount,\n            rawBaseAmount,\n        })\n    }\n\n    async openPosition(positionDraft: PositionDraft, slippage: Big, referralCode?: string) {\n        invariant(this._perp.hasConnected(), () => new UnauthorizedError({ functionName: \"openPosition\" }))\n\n        const oppositeAmountBound = await positionDraft.getOppositeAmountBound(slippage)\n        const referralCodeAsBytes = referralCode ? utils.formatBytes32String(referralCode) : constants.HashZero\n\n        return getTransaction<ContractClearingHouse, \"openPosition\">({\n            account: this._perp.wallet.account,\n            contract: this._perp.contracts.clearingHouse,\n            contractName: ContractName.CLEARINGHOUSE,\n            contractFunctionName: \"openPosition\",\n            args: [\n                {\n                    baseToken: positionDraft.market.baseAddress,\n                    isBaseToQuote: positionDraft.isBaseToQuote,\n                    isExactInput: positionDraft.isExactInput,\n                    amount: big2BigNumberAndScaleUp(positionDraft.amountInput),\n                    oppositeAmountBound: big2BigNumberAndScaleUp(oppositeAmountBound),\n                    sqrtPriceLimitX96: 0, // NOTE: this is for partial filled, disable by giving zero.\n                    deadline: constants.MaxUint256, // NOTE: not important yet\n                    referralCode: referralCodeAsBytes,\n                },\n            ],\n        })\n    }\n\n    async closePosition(position: Position, slippage: Big, referralCode?: string) {\n        invariant(this._perp.hasConnected(), () => new UnauthorizedError({ functionName: \"closePosition\" }))\n\n        const oppositeAmountBound = await position.getOppositeAmountBound(slippage)\n        const referralCodeAsBytes = referralCode ? utils.formatBytes32String(referralCode) : constants.HashZero\n\n        return getTransaction<ContractClearingHouse, \"closePosition\">({\n            account: this._perp.wallet.account,\n            contract: this._perp.contracts.clearingHouse,\n            contractName: ContractName.CLEARINGHOUSE,\n            contractFunctionName: \"closePosition\",\n            args: [\n                {\n                    baseToken: position.market.baseAddress,\n                    oppositeAmountBound: big2BigNumberAndScaleUp(oppositeAmountBound),\n                    sqrtPriceLimitX96: 0, // NOTE: this is for partial filled, disable by giving zero.\n                    deadline: constants.MaxUint256, // NOTE: not important yet\n                    referralCode: referralCodeAsBytes,\n                },\n            ],\n        })\n    }\n\n    async addLiquidity(liquidityDraft: LiquidityDraft, slippage: Big) {\n        invariant(this._perp.hasConnected(), () => new UnauthorizedError({ functionName: \"addLiquidity\" }))\n\n        const baseAmount = await liquidityDraft.getBaseAmount()\n        const quoteAmount = await liquidityDraft.getQuoteAmount()\n\n        const base = big2BigNumberAndScaleUp(baseAmount)\n        const quote = big2BigNumberAndScaleUp(quoteAmount)\n        const minBase = big2BigNumberAndScaleUp(baseAmount.mul(BIG_ONE.sub(slippage)))\n        const minQuote = big2BigNumberAndScaleUp(quoteAmount.mul(BIG_ONE.sub(slippage)))\n\n        return getTransaction<ContractClearingHouse, \"addLiquidity\">({\n            account: this._perp.wallet.account,\n            contract: this._perp.contracts.clearingHouse,\n            contractName: ContractName.CLEARINGHOUSE,\n            contractFunctionName: \"addLiquidity\",\n            args: [\n                {\n                    baseToken: liquidityDraft.market.baseAddress,\n                    base,\n                    quote,\n                    lowerTick: liquidityDraft.lowerTick,\n                    upperTick: liquidityDraft.upperTick,\n                    minBase,\n                    minQuote,\n                    deadline: constants.MaxUint256,\n                    useTakerBalance: false,\n                },\n            ],\n        })\n    }\n\n    async removeLiquidity(liquidity: Liquidity, ratio: Big, slippage: Big) {\n        invariant(this._perp.hasConnected(), () => new UnauthorizedError({ functionName: \"removeLiquidity\" }))\n\n        const { amountBase, amountQuote } = await liquidity.getLiquidityAmounts()\n\n        // TODO: so far we calculate minBase/minQuote by slippage directly\n        // instead of querying contract call like position do\n        const minBase = big2BigNumberAndScaleUp(amountBase.mul(ratio).mul(BIG_ONE.sub(slippage)))\n        const minQuote = big2BigNumberAndScaleUp(amountQuote.mul(ratio).mul(BIG_ONE.sub(slippage)))\n\n        return getTransaction<ContractClearingHouse, \"removeLiquidity\">({\n            account: this._perp.wallet.account,\n            contract: this._perp.contracts.clearingHouse,\n            contractName: ContractName.CLEARINGHOUSE,\n            contractFunctionName: \"removeLiquidity\",\n            args: [\n                {\n                    baseToken: liquidity.market.baseAddress,\n                    lowerTick: liquidity.lowerTick,\n                    upperTick: liquidity.upperTick,\n                    liquidity: big2BigNumberAndScaleUp(liquidity.liquidity.mul(ratio), 0),\n                    minBase,\n                    minQuote,\n                    deadline: constants.MaxUint256,\n                },\n            ],\n        })\n    }\n\n    async quitMarket(tickerSymbol: string) {\n        invariant(this._perp.hasConnected(), () => new UnauthorizedError({ functionName: \"quitMarket\" }))\n\n        const baseAddress = this._perp.markets.getMarket({ tickerSymbol: tickerSymbol }).baseAddress\n        const account = this._perp.wallet.account\n\n        return getTransaction<ContractClearingHouse, \"quitMarket\">({\n            account: this._perp.wallet.account,\n            contract: this._perp.contracts.clearingHouse,\n            contractName: ContractName.CLEARINGHOUSE,\n            contractFunctionName: \"quitMarket\",\n            args: [account, baseAddress],\n        })\n    }\n\n    protected _getEventSourceMap() {\n        const fetchAndEmitAccountValueUpdated = this._createFetchAndEmitAccountValueUpdated()\n        const updated = new ChannelEventSource<ClearingHouseEventName>({\n            eventSourceStarter: () =>\n                poll(fetchAndEmitAccountValueUpdated, this._perp.moduleConfigs?.clearingHouse?.period || DEFAULT_PERIOD)\n                    .cancel,\n            initEventEmitter: () => fetchAndEmitAccountValueUpdated(true, true),\n        })\n\n        return {\n            updated,\n        }\n    }\n\n    private async _fetchUpdateData<T>(fetcher: () => Promise<T>) {\n        try {\n            return await fetcher()\n        } catch (error) {\n            this.emit(\"updateError\", { error })\n        }\n    }\n\n    private _createFetchAndEmitAccountValueUpdated(): MemoizedFetcher {\n        return createMemoizedFetcher(\n            () => this._fetchUpdateData(() => this._fetch(\"accountValue\", { cache: false })),\n            () => this.emit(\"updated\", this),\n            (a, b) => (a && b ? hasNumberChange(a, b) : true),\n        )\n    }\n\n    async getAccountValue({ cache = true } = {}) {\n        return this._fetch(\"accountValue\", { cache })\n    }\n\n    private async _fetch(key: CacheKey, { cache = true } = {}) {\n        if (this._cache.has(key) && cache) {\n            return this._cache.get(key) as CacheValue\n        }\n\n        let result\n        switch (key) {\n            case \"accountValue\": {\n                invariant(this._perp.hasConnected(), () => new UnauthorizedError({ functionName: \"getAccountValue\" }))\n                result = await this._perp.contractReader.getAccountValue(this._perp.wallet.account)\n                break\n            }\n        }\n        this._cache.set(key, result)\n\n        return result\n    }\n}\n\nexport { ClearingHouse }\n"],"names":["ClearingHouse","Channel","constructor","_perp","super","channelRegistry","this","_cache","Map","createPositionDraft","tickerSymbol","amountInput","isAmountInputBase","side","market","markets","getMarket","PositionDraft","createLiquidityDraft","lowerTick","upperTick","rawQuoteAmount","rawBaseAmount","LiquidityDraft","perp","async","positionDraft","slippage","referralCode","invariant","hasConnected","UnauthorizedError","functionName","oppositeAmountBound","getOppositeAmountBound","referralCodeAsBytes","utils","formatBytes32String","constants","HashZero","getTransaction","account","wallet","contract","contracts","clearingHouse","contractName","ContractName","CLEARINGHOUSE","contractFunctionName","args","baseToken","baseAddress","isBaseToQuote","isExactInput","amount","big2BigNumberAndScaleUp","sqrtPriceLimitX96","deadline","MaxUint256","position","liquidityDraft","baseAmount","getBaseAmount","quoteAmount","getQuoteAmount","base","quote","minBase","mul","BIG_ONE","sub","minQuote","useTakerBalance","liquidity","ratio","amountBase","amountQuote","getLiquidityAmounts","_getEventSourceMap","fetchAndEmitAccountValueUpdated","_createFetchAndEmitAccountValueUpdated","updated","ChannelEventSource","eventSourceStarter","poll","_b","moduleConfigs","_a","period","DEFAULT_PERIOD","cancel","initEventEmitter","fetcher","error","emit","createMemoizedFetcher","_fetchUpdateData","_fetch","cache","a","b","hasNumberChange","key","has","get","result","contractReader","getAccountValue","set"],"mappings":"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"}