{"version":3,"file":"PerpetualProtocol.js","sources":["../../../src/core/PerpetualProtocol.ts"],"sourcesContent":["import { ChainId, ProviderConfig, RetryProvider, getRetryProvider, isSupportedChainId, getProvider } from \"../network\"\nimport { ChannelRegistry, ModuleConfig } from \"../internal\"\nimport { ClearingHouse, ClearingHouseConfig } from \"./clearingHouse\"\nimport { FailedPreconditionError, InitSDKError, UnsupportedChainError } from \"../errors\"\n\nimport { ContractReader } from \"./contractReader\"\nimport { Contracts } from \"../contracts\"\nimport { Liquidities } from \"./liquidity\"\nimport { Markets } from \"./market\"\nimport { Metadata } from \"../metadata\"\nimport { Positions } from \"./position\"\nimport { Signer, providers } from \"ethers\"\nimport { Vault } from \"./vault\"\nimport { Wallet } from \"./wallet\"\nimport { DelegateApproval, DelegateApprovalConfigs } from \"./clearingHouse/DelegateApproval\"\nimport { invariant } from \"../utils\"\nimport { LimitOrderBook } from \"./limitOrder\"\n\ninterface ModuleConfigs {\n    vault?: ModuleConfig\n    clearingHouse?: ModuleConfig\n    wallet?: ModuleConfig\n    market?: ModuleConfig\n    orders?: ModuleConfig\n    positions?: ModuleConfig\n    delegateApproval?: DelegateApprovalConfigs\n}\n\ninterface PerpetualProtocolConfig {\n    chainId: ChainId\n    providerConfigs: ProviderConfig[]\n    moduleConfigs?: ModuleConfigs\n}\n\nexport interface PerpetualProtocolInitialized extends PerpetualProtocol {\n    markets: Markets\n    clearingHouse: ClearingHouse\n}\n\nexport interface PerpetualProtocolConnected extends PerpetualProtocolInitialized {\n    wallet: Wallet\n    positions: Positions\n    liquidities: Liquidities\n    vault: Vault\n    delegateApproval: DelegateApproval\n    limitOrderBook: LimitOrderBook\n}\n\n/**\n * @date 28/12/2021\n * @class PerpetualProtocol\n * @member {ModuleConfigs} moduleConfigs (the default config value will be assigned in the each module)\n */\nclass PerpetualProtocol {\n    readonly providerConfigs: ProviderConfig[]\n    readonly moduleConfigs?: ModuleConfigs\n    readonly provider: RetryProvider\n    private _metadata?: Metadata\n    private _contracts?: Contracts\n    private _contractReader?: ContractReader\n    private readonly _chainId: number\n    private _channelRegistry: ChannelRegistry\n    private _markets?: Markets\n    private _wallet?: Wallet\n    private _vault?: Vault\n    // TODO: [TBD] rename clearingHouseConfig to clearingHouseMetadata?\n    private _clearingHouseConfig?: ClearingHouseConfig\n    private _clearingHouse?: ClearingHouse\n    private _positions?: Positions\n    private _liquidities?: Liquidities\n    private _delegateApproval?: DelegateApproval\n    private _limitOrderBook?: LimitOrderBook\n\n    get metadata() {\n        return this._metadata as Metadata\n    }\n    get contracts() {\n        return this._contracts as Contracts\n    }\n    get contractReader() {\n        return this._contractReader as ContractReader\n    }\n    get wallet() {\n        return this._wallet\n    }\n\n    get vault() {\n        return this._vault\n    }\n\n    get markets() {\n        invariant(\n            !!this._markets,\n            () =>\n                new FailedPreconditionError({\n                    functionName: \"markets\",\n                    stateName: \"perp\",\n                    stateValue: \"uninitialized\",\n                }),\n        )\n        return this._markets\n    }\n    get clearingHouseConfig() {\n        invariant(\n            !!this._clearingHouseConfig,\n            () =>\n                new FailedPreconditionError({\n                    functionName: \"clearingHouseConfig\",\n                    stateName: \"perp\",\n                    stateValue: \"uninitialized\",\n                }),\n        )\n        return this._clearingHouseConfig\n    }\n\n    get clearingHouse() {\n        return this._clearingHouse\n    }\n\n    get positions() {\n        return this._positions\n    }\n\n    get liquidities() {\n        return this._liquidities\n    }\n\n    get channelRegistry() {\n        return this._channelRegistry\n    }\n\n    get delegateApproval() {\n        return this._delegateApproval\n    }\n\n    get limitOrderBook() {\n        return this._limitOrderBook\n    }\n\n    constructor({ chainId, providerConfigs, moduleConfigs }: PerpetualProtocolConfig) {\n        // NOTE: throw error if the user try to use an unsupported chainId to init the sdk\n        if (!isSupportedChainId(chainId)) {\n            throw new UnsupportedChainError()\n        }\n        this._chainId = chainId\n        this.providerConfigs = providerConfigs\n        this.moduleConfigs = moduleConfigs\n\n        this._channelRegistry = new ChannelRegistry()\n        this.provider = getRetryProvider(providerConfigs)\n    }\n\n    async init() {\n        try {\n            this._metadata = await Metadata.create(this._chainId)\n            this._contracts = new Contracts({ metadata: this.metadata, provider: this.provider })\n            this._contractReader = new ContractReader({\n                metadata: this.metadata,\n                provider: this.provider,\n                contracts: this.contracts,\n            })\n            this._markets = new Markets(this)\n            this._clearingHouseConfig = await ClearingHouseConfig.create(this.contractReader)\n            this._clearingHouse = new ClearingHouse(this)\n        } catch (error: unknown) {\n            throw new InitSDKError(error as Error)\n        }\n    }\n\n    async connect({ signer }: { signer: Signer }) {\n        if (!isSupportedChainId(await signer.getChainId())) {\n            throw new UnsupportedChainError()\n        }\n\n        const account = await signer.getAddress()\n        this.contracts.connect(signer)\n\n        // TODO: analyze the RPC call amount\n        // if (signer.provider) {\n        //     // NOTE: This casting is necessary due that\n        //     // `signer.provider` is `Provider` type, which is `BaseProvider`'s parent class\n        //     // but we wanna handle JsonRpcProvider specifically\n        //     this.provider.addUserProvider((signer as providers.JsonRpcSigner).provider)\n        // }\n\n        this._wallet = new Wallet(this, account)\n        this._vault = new Vault(this, account)\n\n        if (this.hasConnected()) {\n            this._delegateApproval = new DelegateApproval(this, this.moduleConfigs?.delegateApproval)\n            this._limitOrderBook = new LimitOrderBook(this)\n            this._positions = new Positions(this)\n            this._liquidities = new Liquidities(this)\n        }\n    }\n\n    hasInitialized(): this is PerpetualProtocolInitialized {\n        return !!this._markets && !!this._clearingHouse\n    }\n\n    hasConnected(): this is PerpetualProtocolConnected {\n        return this.hasInitialized() && !!this._wallet\n    }\n\n    destroy() {\n        this._channelRegistry.cleanUp()\n    }\n}\n\nexport { PerpetualProtocol }\n"],"names":["constructor","chainId","providerConfigs","moduleConfigs","isSupportedChainId","UnsupportedChainError","this","_chainId","_channelRegistry","ChannelRegistry","provider","getRetryProvider","metadata","_metadata","contracts","_contracts","contractReader","_contractReader","wallet","_wallet","vault","_vault","markets","invariant","_markets","FailedPreconditionError","functionName","stateName","stateValue","clearingHouseConfig","_clearingHouseConfig","clearingHouse","_clearingHouse","positions","_positions","liquidities","_liquidities","channelRegistry","delegateApproval","_delegateApproval","limitOrderBook","_limitOrderBook","async","Metadata","create","Contracts","ContractReader","Markets","ClearingHouseConfig","ClearingHouse","error","InitSDKError","signer","getChainId","account","getAddress","connect","Wallet","Vault","hasConnected","DelegateApproval","_a","LimitOrderBook","Positions","Liquidities","hasInitialized","destroy","cleanUp"],"mappings":"qqCAqDA,MAsFIA,aAAYC,QAAEA,EAAOC,gBAAEA,EAAeC,cAAEA,IAEpC,IAAKC,EAAAA,mBAAmBH,GACpB,MAAM,IAAII,EAAqBA,sBAEnCC,KAAKC,SAAWN,EAChBK,KAAKJ,gBAAkBA,EACvBI,KAAKH,cAAgBA,EAErBG,KAAKE,iBAAmB,IAAIC,EAAAA,gBAC5BH,KAAKI,SAAWC,mBAAiBT,EACpC,CA7EGU,eACA,OAAON,KAAKO,SACf,CACGC,gBACA,OAAOR,KAAKS,UACf,CACGC,qBACA,OAAOV,KAAKW,eACf,CACGC,aACA,OAAOZ,KAAKa,OACf,CAEGC,YACA,OAAOd,KAAKe,MACf,CAEGC,cAUA,OATAC,EAAAA,YACMjB,KAAKkB,UACP,IACI,IAAIC,EAAAA,wBAAwB,CACxBC,aAAc,UACdC,UAAW,OACXC,WAAY,oBAGjBtB,KAAKkB,QACf,CACGK,0BAUA,OATAN,EAAAA,YACMjB,KAAKwB,sBACP,IACI,IAAIL,EAAAA,wBAAwB,CACxBC,aAAc,sBACdC,UAAW,OACXC,WAAY,oBAGjBtB,KAAKwB,oBACf,CAEGC,oBACA,OAAOzB,KAAK0B,cACf,CAEGC,gBACA,OAAO3B,KAAK4B,UACf,CAEGC,kBACA,OAAO7B,KAAK8B,YACf,CAEGC,sBACA,OAAO/B,KAAKE,gBACf,CAEG8B,uBACA,OAAOhC,KAAKiC,iBACf,CAEGC,qBACA,OAAOlC,KAAKmC,eACf,CAeDC,aACI,IACIpC,KAAKO,gBAAkB8B,EAAAA,SAASC,OAAOtC,KAAKC,UAC5CD,KAAKS,WAAa,IAAI8B,EAASA,UAAC,CAAEjC,SAAUN,KAAKM,SAAUF,SAAUJ,KAAKI,WAC1EJ,KAAKW,gBAAkB,IAAI6B,iBAAe,CACtClC,SAAUN,KAAKM,SACfF,SAAUJ,KAAKI,SACfI,UAAWR,KAAKQ,YAEpBR,KAAKkB,SAAW,IAAIuB,EAAOA,QAACzC,MAC5BA,KAAKwB,2BAA6BkB,EAAAA,oBAAoBJ,OAAOtC,KAAKU,gBAClEV,KAAK0B,eAAiB,IAAIiB,EAAaA,cAAC3C,KAG3C,CAFC,MAAO4C,GACL,MAAM,IAAIC,EAAAA,aAAaD,EAC1B,CACJ,CAEDR,eAAcU,OAAEA,UACZ,IAAKhD,EAAAA,yBAAyBgD,EAAOC,cACjC,MAAM,IAAIhD,EAAqBA,sBAGnC,MAAMiD,QAAgBF,EAAOG,aAC7BjD,KAAKQ,UAAU0C,QAAQJ,GAUvB9C,KAAKa,QAAU,IAAIsC,EAAMA,OAACnD,KAAMgD,GAChChD,KAAKe,OAAS,IAAIqC,EAAKA,MAACpD,KAAMgD,GAE1BhD,KAAKqD,iBACLrD,KAAKiC,kBAAoB,IAAIqB,EAAAA,iBAAiBtD,KAA0B,QAApBuD,EAAAvD,KAAKH,qBAAe,IAAA0D,OAAA,EAAAA,EAAAvB,kBACxEhC,KAAKmC,gBAAkB,IAAIqB,EAAcA,eAACxD,MAC1CA,KAAK4B,WAAa,IAAI6B,EAASA,UAACzD,MAChCA,KAAK8B,aAAe,IAAI4B,EAAWA,YAAC1D,MAE3C,CAED2D,iBACI,QAAS3D,KAAKkB,YAAclB,KAAK0B,cACpC,CAED2B,eACI,OAAOrD,KAAK2D,oBAAsB3D,KAAKa,OAC1C,CAED+C,UACI5D,KAAKE,iBAAiB2D,SACzB"}