"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatCall = void 0;
const ethers_1 = require("ethers");
const utils_1 = require("ethers/lib/utils");
const colors_1 = require("../colors");
const utils_2 = require("../utils");
const param_1 = require("./param");
const result_1 = require("./result");
async function formatCall(to, input, ret, value, gas, dependencies) {
    const toBytecode = await dependencies.provider.send("eth_getCode", [to]);
    const names = await dependencies.artifacts.getAllFullyQualifiedNames();
    let contractName;
    let result;
    let result2;
    let functionFragment;
    for (const name of names) {
        const _artifact = await dependencies.artifacts.readArtifact(name);
        const iface = new utils_1.Interface(_artifact.abi);
        // try to find the contract name
        if ((0, utils_2.compareBytecode)(_artifact.deployedBytecode, toBytecode) > 0.5 ||
            (to === ethers_1.ethers.constants.AddressZero && toBytecode.length <= 2)) {
            // if bytecode of "to" is the same as the deployed bytecode
            // we can use the artifact name
            contractName = _artifact.contractName;
        }
        // try to parse the arguments
        try {
            // if this doesnt throw, we likely found an Artifact that recognizes the input
            const signature = input.slice(0, 10);
            result = iface.decodeFunctionData(signature, input);
            try {
                result2 = iface.decodeFunctionResult(signature, ret);
            }
            catch (_a) { }
            functionFragment = iface.getFunction(signature);
        }
        catch (_b) { }
        // if we got both the contract name and arguments parsed so far, we can stop
        if (contractName && result) {
            break;
        }
    }
    const extra = [];
    if ((value = ethers_1.BigNumber.from(value)).gt(0)) {
        extra.push(`value: ${(0, param_1.formatParam)(value, dependencies)}`);
    }
    if ((gas = ethers_1.BigNumber.from(gas)).gt(0) && dependencies.tracerEnv.gasCost) {
        extra.push(`gas: ${(0, param_1.formatParam)(gas, dependencies)}`);
    }
    if (result && functionFragment) {
        const inputArgs = (0, result_1.formatResult)(result, functionFragment, { decimals: -1, isInput: true, shorten: false }, dependencies);
        const outputArgs = result2
            ? (0, result_1.formatResult)(result2, functionFragment, { decimals: -1, isInput: false, shorten: true }, dependencies)
            : "";
        const nameTag = (0, utils_2.getFromNameTags)(to, dependencies);
        return `${nameTag
            ? (0, colors_1.colorContract)(nameTag)
            : contractName
                ? (0, colors_1.colorContract)(contractName)
                : `<${(0, colors_1.colorContract)("UnknownContract")} ${(0, param_1.formatParam)(to, dependencies)}>`}.${(0, colors_1.colorFunction)(functionFragment.name)}${extra.length !== 0 ? `{${extra.join(",")}}` : ""}(${inputArgs})${outputArgs ? ` => (${outputArgs})` : ""}`;
    }
    // TODO add flag to hide unrecognized stuff
    if (toBytecode.length > 2 && contractName) {
        return `${(0, colors_1.colorContract)(contractName)}.<${(0, colors_1.colorFunction)("UnknownFunction")}>${extra.length !== 0 ? `{${extra.join(",")}}` : ""}(${(0, colors_1.colorKey)("input=")}${input}, ${(0, colors_1.colorKey)("ret=")}${ret})`;
    }
    else {
        return `${(0, colors_1.colorFunction)("UnknownContractAndFunction")}${extra.length !== 0 ? `{${extra.join(",")}}` : ""}(${(0, colors_1.colorKey)("to=")}${to}, ${(0, colors_1.colorKey)("input=")}${input}, ${(0, colors_1.colorKey)("ret=")}${ret})`;
    }
}
exports.formatCall = formatCall;
//# sourceMappingURL=call.js.map