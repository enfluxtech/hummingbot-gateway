"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("../../contracts/Contracts.js"),t=require("../../errors/errors.js"),r=require("../../internal/Channel.js"),a=require("../../internal/ChannelEventSource.js"),s=require("../../utils/formatters.js"),n=require("../../internal/config.js"),c=require("../../utils/assertions.js"),i=require("../../utils/errorChecker.js"),o=require("../../utils/getTickerSymbol.js"),u=require("../../utils/is.js");require("../../utils/tick.js");var l=require("../../utils/poll.js"),m=require("../../utils/logger.js"),d=require("../contractReader/MulticallReader.js"),p=require("./Market.js");class k extends r.Channel{constructor(e){super(e.channelRegistry),this._perp=e,this._marketMap=this._getMarketMap()}get marketMap(){return this._marketMap}_getMarketMap(){return u.isEmptyObject(this._perp.metadata.pools)?(console.warn("Metadata pools is empty!"),{}):this._perp.metadata.pools.reduce(((e,{address:t,baseSymbol:r,baseAddress:a,quoteSymbol:s,quoteAddress:n})=>{const c=o.getTickerSymbol(r,s);return{...e,[c]:new p.Market(this._perp,c,t,r,a,s,n)}}),{})}getMarket({tickerSymbol:e,baseAddress:r}){let a;return a=e?this._marketMap[e]:Object.values(this._marketMap).find((e=>e.baseAddress===r)),i.invariant(!!a,(()=>new t.ArgumentError({functionName:"getMarket",key:e?"tickerSymbol":"baseAddress",value:e||r}))),c.assertExist(a,(()=>new t.TypeError({functionName:"getMarket",variableName:"market",variableValue:a,type:"market"}))),a}async getMarketsBaseQuoteAmount(e){return this._perp.contractReader.getMarketsBaseTokenAndQuoteTokenAmount(e)}_getEventSourceMap(){const e=this.getMarketDataAll.bind(this);return{updated:new a.ChannelEventSource({eventSourceStarter:()=>{var t,r;const{cancel:a}=l.poll(e,(null===(r=null===(t=this._perp.moduleConfigs)||void 0===t?void 0:t.market)||void 0===r?void 0:r.period)||n.DEFAULT_PERIOD);return a},initEventEmitter:()=>e()})}}async getMarketDataAll(){try{m.logger("getMarketDataAll");const t=this._perp.clearingHouseConfig.twapInterval.toNumber(),r=this._perp.contracts,a=new d.MulticallReader({contract:this._perp.contracts.multicall2}),n={};Object.entries(this._marketMap).forEach((([a,s])=>{const c=r.baseToken.attach(s.baseAddress),i=r.pool.attach(s.poolAddress),o=[{contract:c,contractName:e.ContractName.BASE_TOKEN,funcName:"getIndexPrice",funcParams:[0]},{contract:c,contractName:e.ContractName.BASE_TOKEN,funcName:"getIndexPrice",funcParams:[t]},{contract:i,contractName:e.ContractName.POOL,funcName:"slot0",funcParams:[]},{contract:c,contractName:e.ContractName.BASE_TOKEN,funcName:"isPaused",funcParams:[]},{contract:c,contractName:e.ContractName.BASE_TOKEN,funcName:"isClosed",funcParams:[]}];n[`${a}`]=o}));const c=await a.execute(Object.values(n).flat(),{failFirstByContract:!1,failFirstByClient:!1}),i={};Object.entries(n).forEach((([e,t])=>{const r=c.splice(0,t.length),a=s.bigNumber2BigAndScaleDown(r[0]),n=s.bigNumber2BigAndScaleDown(r[1]),o=s.fromSqrtX96(r[2].sqrtPriceX96),u=r[3],l=r[4];i[`${e}`]={status:l?p.MarketStatus.CLOSED:u?p.MarketStatus.PAUSED:p.MarketStatus.ACTIVE,markPrice:o,indexPrice:a,indexTwapPrice:n}})),this.emit("updated",i)}catch(e){this.emit("updateError",{error:e})}}}exports.Markets=k;
//# sourceMappingURL=Markets.js.map
