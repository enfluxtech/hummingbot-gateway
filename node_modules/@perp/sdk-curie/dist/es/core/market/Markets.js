import{ContractName as t}from"../../contracts/Contracts.js";import{ArgumentError as e,TypeError as r}from"../../errors/errors.js";import{Channel as a}from"../../internal/Channel.js";import{ChannelEventSource as s}from"../../internal/ChannelEventSource.js";import{bigNumber2BigAndScaleDown as o,fromSqrtX96 as n}from"../../utils/formatters.js";import{DEFAULT_PERIOD as i}from"../../internal/config.js";import{assertExist as c}from"../../utils/assertions.js";import{invariant as m}from"../../utils/errorChecker.js";import{getTickerSymbol as l}from"../../utils/getTickerSymbol.js";import{isEmptyObject as p}from"../../utils/is.js";import"../../utils/tick.js";import{poll as u}from"../../utils/poll.js";import{logger as d}from"../../utils/logger.js";import{MulticallReader as f}from"../contractReader/MulticallReader.js";import{Market as k,MarketStatus as h}from"./Market.js";class g extends a{constructor(t){super(t.channelRegistry),this._perp=t,this._marketMap=this._getMarketMap()}get marketMap(){return this._marketMap}_getMarketMap(){return p(this._perp.metadata.pools)?(console.warn("Metadata pools is empty!"),{}):this._perp.metadata.pools.reduce(((t,{address:e,baseSymbol:r,baseAddress:a,quoteSymbol:s,quoteAddress:o})=>{const n=l(r,s);return{...t,[n]:new k(this._perp,n,e,r,a,s,o)}}),{})}getMarket({tickerSymbol:t,baseAddress:a}){let s;return s=t?this._marketMap[t]:Object.values(this._marketMap).find((t=>t.baseAddress===a)),m(!!s,(()=>new e({functionName:"getMarket",key:t?"tickerSymbol":"baseAddress",value:t||a}))),c(s,(()=>new r({functionName:"getMarket",variableName:"market",variableValue:s,type:"market"}))),s}async getMarketsBaseQuoteAmount(t){return this._perp.contractReader.getMarketsBaseTokenAndQuoteTokenAmount(t)}_getEventSourceMap(){const t=this.getMarketDataAll.bind(this);return{updated:new s({eventSourceStarter:()=>{var e,r;const{cancel:a}=u(t,(null===(r=null===(e=this._perp.moduleConfigs)||void 0===e?void 0:e.market)||void 0===r?void 0:r.period)||i);return a},initEventEmitter:()=>t()})}}async getMarketDataAll(){try{d("getMarketDataAll");const e=this._perp.clearingHouseConfig.twapInterval.toNumber(),r=this._perp.contracts,a=new f({contract:this._perp.contracts.multicall2}),s={};Object.entries(this._marketMap).forEach((([a,o])=>{const n=r.baseToken.attach(o.baseAddress),i=r.pool.attach(o.poolAddress),c=[{contract:n,contractName:t.BASE_TOKEN,funcName:"getIndexPrice",funcParams:[0]},{contract:n,contractName:t.BASE_TOKEN,funcName:"getIndexPrice",funcParams:[e]},{contract:i,contractName:t.POOL,funcName:"slot0",funcParams:[]},{contract:n,contractName:t.BASE_TOKEN,funcName:"isPaused",funcParams:[]},{contract:n,contractName:t.BASE_TOKEN,funcName:"isClosed",funcParams:[]}];s[`${a}`]=c}));const i=await a.execute(Object.values(s).flat(),{failFirstByContract:!1,failFirstByClient:!1}),c={};Object.entries(s).forEach((([t,e])=>{const r=i.splice(0,e.length),a=o(r[0]),s=o(r[1]),m=n(r[2].sqrtPriceX96),l=r[3],p=r[4];c[`${t}`]={status:p?h.CLOSED:l?h.PAUSED:h.ACTIVE,markPrice:m,indexPrice:a,indexTwapPrice:s}})),this.emit("updated",c)}catch(t){this.emit("updateError",{error:t})}}}export{g as Markets};
//# sourceMappingURL=Markets.js.map
