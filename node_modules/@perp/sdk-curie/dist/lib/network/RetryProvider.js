"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("exponential-backoff"),r=require("../errors/errors.js"),t=require("ethers");require("big.js");var i=require("../utils/errorChecker.js");require("../constants/envVariables.js"),require("../constants/numbers.js"),require("../utils/tick.js");function n(e){var i,n,o,s,a;return e.code===t.errors.SERVER_ERROR||e.code===t.errors.TIMEOUT||(null===(i=e.message)||void 0===i?void 0:i.includes("header not found"))||(null===(n=e.message)||void 0===n?void 0:n.includes("429"))&&(null===(o=e.message)||void 0===o?void 0:o.includes("status code"))||(null===(a=null===(s=e.data)||void 0===s?void 0:s.message)||void 0===a?void 0:a.includes("your node is running with state pruning"))||e instanceof r.RpcTimeoutError}class o extends t.providers.BaseProvider{constructor(e,t=1){i.invariant(e.length>=1,(()=>new r.ArgumentError({functionName:"RetryProvider Constructor",key:"providers",value:"empty"})));super(e[0].getNetwork()),this._providerConnectionList=e.map((e=>o.getInitialProviderConnection(e))),this.retryLoopLimit=t}get providerConnectionList(){return this._userProviderConnection?[...this._providerConnectionList,this._userProviderConnection]:this._providerConnectionList}addUserProvider(e){this._userProviderConnection=o.getInitialProviderConnection(e)}removeUserProvider(){this._userProviderConnection=void 0}detectNetwork(){return this._networkPromise}async getBlockNumber(){return this._iterateProviders((e=>e.getBlockNumber()))}async getChainStatus(){return this._iterateProviders((async e=>{const[r,t]=await Promise.all([e.getBlockNumber(),e.send("eth_syncing",[])]);return{blockNumber:r,isSyncing:t}}))}async perform(e,r){if("sendTransaction"===e){return await this._handleSendTransaction(r)}return this._iterateProviders((async t=>t.perform(e,r)))}async _handleSendTransaction(e){const r=await Promise.any(this.providerConnectionList.map((({provider:r})=>r.sendTransaction(e.signedTransaction).then((e=>e.hash),(e=>e)))));for(let e=0;e<r.length;e++){const t=r[e];if("string"==typeof t)return t}throw r[0]}_getCandidateProviderConnection(e){const r=(new Date).valueOf(),t=e.find((({nextRetryTimestamp:e})=>e<=r));if(t)return t;return e.reduce(((e,r)=>e.nextRetryTimestamp<=r.nextRetryTimestamp?e:r))}_updateProviderStatus(e,r){if(r)e.nextRetryTimestamp=0;else{const r=(new Date).valueOf();e.nextRetryTimestamp=r+3e5}}async _providerTimeoutBenchmark(){return new Promise(((e,t)=>{setTimeout((()=>t(new r.RpcTimeoutError)),1e4)}))}async _iterateProviders(e){const r=[];let t=0;for(;;){if(t>=this.retryLoopLimit*this.providerConnectionList.length)return this._retryWithBackoff(e,r);t++;const i=this._getCandidateProviderConnection(this.providerConnectionList);try{const r=await Promise.race([e(i.provider),this._providerTimeoutBenchmark()]);return this._updateProviderStatus(i,!0),r}catch(e){if(!n(e))throw e;this._updateProviderStatus(i,!1),r.push(e)}}}async _retryWithBackoff(t,i){const o=this._getCandidateProviderConnection(this.providerConnectionList);try{return await e.backOff((()=>t(o.provider)),{numOfAttempts:6,startingDelay:1e3,timeMultiple:2,retry:(e,r)=>n(e)})}catch(e){throw new r.RpcMaxRetryError({rawErrors:[...i,e]})}}static getInitialProviderConnection(e){return{provider:e,nextRetryTimestamp:0}}}exports.RetryProvider=o;
//# sourceMappingURL=RetryProvider.js.map
