import"cross-fetch/polyfill";import{UnsupportedChainError as t,FailedPreconditionError as e}from"../errors/errors.js";import"ethers";import"../network/RetryProvider.js";import{MetadataUrlCoreByChainId as r,MetadataUrlPeripheryByChainId as s}from"../network/constants.js";import{isSupportedChainId as o}from"../network/utils.js";import"big.js";import{invariant as a}from"../utils/errorChecker.js";import"../constants/envVariables.js";import"../constants/numbers.js";import"../utils/tick.js";class n{constructor(t,e,r,s){this.contracts=t,this.externalContracts=e,this.rawPools=r,this.pools=this._normalizePools(this.rawPools),this.collaterals=s}static async create(t){const{contracts:e,externalContracts:r,pools:s,collaterals:o}=await n._fetch(t);return new n(e,r,s,o)}static async _fetch(n){a(o(n),(()=>new t));const c=r[n];a(!!c,(t=>new e({functionName:"_fetchMarketMetaData",stateName:"metadataUrl",stateValue:c,rawError:t})));const l=s[n];a(!!l,(t=>new e({functionName:"_fetchMarketMetaData",stateName:"metadataUrlPeriphery",stateValue:l,rawError:t})));const[i,m]=await Promise.all([fetch(c).then((t=>t.json())).then((t=>t)),fetch(l).then((t=>t.json())).then((t=>t))]);return{...i,contracts:{...i.contracts,...m.contracts}}}findCollateralByAddress(t){return this.collaterals.find((e=>e.address===t))}_normalizePools(t){const e=/^v(\w+)/;return t.map((t=>({...t,address:t.address.toLowerCase(),baseAddress:t.baseAddress.toLowerCase(),quoteAddress:t.quoteAddress.toLowerCase(),baseSymbol:t.baseSymbol.replace(e,"$1"),quoteSymbol:t.quoteSymbol.replace(e,"$1")})))}}export{n as Metadata};
//# sourceMappingURL=Metadata.js.map
