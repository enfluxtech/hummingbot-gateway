import t from"big.js";import"../../constants/envVariables.js";import{RATIO_DECIMAL as e}from"../../constants/numbers.js";import{ContractName as a}from"../../contracts/Contracts.js";import{Channel as c}from"../../internal/Channel.js";import{ChannelEventSource as n}from"../../internal/ChannelEventSource.js";import{createMemoizedFetcher as r,hasNumberArrChange as o,hasNumberChange as l}from"../../internal/createMemoizedFetcher.js";import{DEFAULT_PERIOD as i}from"../../internal/config.js";import{bigNumber2BigAndScaleDown as s,scaleDownDecimals as h}from"../../utils/formatters.js";import"../../utils/tick.js";import{poll as m}from"../../utils/poll.js";import{logger as d}from"../../utils/logger.js";import"ethers";import"../../errors/errors.js";import{MulticallReader as u}from"../contractReader/MulticallReader.js";import{NonSettlementCollateralToken as p}from"./NonSettlementCollateralToken.js";import{SettlementToken as f}from"./SettlementToken.js";class E extends c{constructor(t,e){super(t.channelRegistry),this._perp=t,this.account=e,this._collateralTokenList=[],this._cache=new Map,this._contractVault=t.contracts.vault,this._contractReader=t.contractReader,this._settlementToken=new f(t,t.contracts.settlementToken),this._collateralTokenList.push(this._settlementToken),t.contracts.collateralTokenMap.forEach((e=>{this._collateralTokenList.push(new p(t,e.contract,e.priceFeedContract))}))}get settlementToken(){return this._settlementToken}get collateralTokenList(){return this._collateralTokenList}async getAllowanceList({cache:t=!0}={}){return this._fetch("allowanceList",{cache:t})}async getBalanceList({cache:t=!0}={}){return this._fetch("balanceList",{cache:t})}async getBalanceEth({cache:t=!0}={}){return this._fetch("balanceEth",{cache:t})}async getCollateralTokenPriceList({cache:t=!0}={}){return this._fetch("collateralTokenPriceList",{cache:t})}async approve(t,e){return t.approve(this.account,this._contractVault.address,e)}_getEventSourceMap(){const t=this._createFetchAndEmitAllowanceListUpdated(),e=new n({eventSourceStarter:()=>{var e,a;return m(t,(null===(a=null===(e=this._perp.moduleConfigs)||void 0===e?void 0:e.wallet)||void 0===a?void 0:a.period)||i).cancel},initEventEmitter:()=>t(!0,!0)}),a=this._createFetchAndEmitBalanceListUpdated(),c=new n({eventSourceStarter:()=>{var t,e;return m(a,(null===(e=null===(t=this._perp.moduleConfigs)||void 0===t?void 0:t.wallet)||void 0===e?void 0:e.period)||i).cancel},initEventEmitter:()=>a(!0,!0)}),r=this._createFetchAndEmitBalanceEthUpdated(),o=new n({eventSourceStarter:()=>{var t,e;return m(r,(null===(e=null===(t=this._perp.moduleConfigs)||void 0===t?void 0:t.wallet)||void 0===e?void 0:e.period)||i).cancel},initEventEmitter:()=>r(!0,!0)}),l=this._createFetchAndEmitCollateralTokenPriceListUpdated(),s=new n({eventSourceStarter:()=>{var t,e;return m(l,(null===(e=null===(t=this._perp.moduleConfigs)||void 0===t?void 0:t.wallet)||void 0===e?void 0:e.period)||i).cancel},initEventEmitter:()=>l(!0,!0)}),h=this.getWalletDataAll.bind(this);return{allowanceListUpdated:e,balanceListUpdated:c,balanceEthUpdated:o,collateralTokenPriceListUpdated:s,updatedWalletDataAll:new n({eventSourceStarter:()=>{var t,e;return m(h,(null===(e=null===(t=this._perp.moduleConfigs)||void 0===t?void 0:t.wallet)||void 0===e?void 0:e.period)||i).cancel},initEventEmitter:()=>h()})}}async _fetchUpdateData(t){try{return await t()}catch(t){this.emit("updateError",{error:t})}}async _fetch(t,{cache:e=!0}={}){if(this._cache.has(t)&&e)return this._cache.get(t);let a;switch(t){case"allowanceList":{const t=this._collateralTokenList,e=this._contractVault.address;a=await Promise.all(t.map((t=>t.allowance(this.account,e))));break}case"balanceList":{const t=this._collateralTokenList;a=await Promise.all(t.map((t=>t.balanceOf(this.account))));break}case"balanceEth":a=await this._contractReader.getNativeBalance(this.account);break;case"collateralTokenPriceList":{const t=this._collateralTokenList;a=await Promise.all(t.map((t=>t.price())));break}}return this._cache.set(t,a),a}_createFetchAndEmitAllowanceListUpdated(){return r((()=>this._fetchUpdateData((()=>this._fetch("allowanceList",{cache:!1})))),(()=>this.emit("allowanceListUpdated",this)),((t,e)=>!t||!e||o(t,e)))}_createFetchAndEmitBalanceListUpdated(){return r((()=>this._fetchUpdateData((()=>this._fetch("balanceList",{cache:!1})))),(()=>this.emit("balanceListUpdated",this)),((t,e)=>!t||!e||o(t,e)))}_createFetchAndEmitBalanceEthUpdated(){return r((()=>this._fetchUpdateData((()=>this._fetch("balanceEth",{cache:!1})))),(()=>this.emit("balanceEthUpdated",this)),((t,e)=>!t||!e||l(t,e)))}_createFetchAndEmitCollateralTokenPriceListUpdated(){return r((()=>this._fetchUpdateData((()=>this._fetch("collateralTokenPriceList",{cache:!1})))),(()=>this.emit("collateralTokenPriceListUpdated",this)),((t,e)=>!t||!e||t!==e))}async getWalletDataAll(){try{d("getWalletDataAll");const t=this.account,e=this._perp.contracts,c=new u({contract:e.multicall2}),n={};this._collateralTokenList.forEach((e=>{const c=e instanceof f,r=e.address,o=e.contract,l=[c?{contract:o,contractName:a.SETTLEMENT_TOKEN,funcName:"decimals",funcParams:[]}:{contract:o,contractName:a.COLLATERAL_TOKENS,funcName:"decimals",funcParams:[]},c?{contract:e.contract,contractName:a.SETTLEMENT_TOKEN,funcName:"allowance",funcParams:[t,this._contractVault.address]}:{contract:e.contract,contractName:a.COLLATERAL_TOKENS,funcName:"allowance",funcParams:[t,this._contractVault.address]},c?{contract:o,contractName:a.SETTLEMENT_TOKEN,funcName:"balanceOf",funcParams:[t]}:{contract:o,contractName:a.COLLATERAL_TOKENS,funcName:"balanceOf",funcParams:[t]}],i=c?void 0:{contract:e.priceFeedContract,contractName:a.CHAINLINK_PRICE_FEED,funcName:"decimals",funcParams:[]},s=c?void 0:{contract:e.priceFeedContract,contractName:a.CHAINLINK_PRICE_FEED,funcName:"getPrice",funcParams:[0]};i&&l.push(i),s&&l.push(s),n[`${r}`]=l}));const r=await c.execute(Object.values(n).flat()),o={};Object.entries(n).forEach((([t,e])=>{const a=r.splice(0,e.length),c=a[0],n=s(a[1],c),l=s(a[2],c),i=a[3],h=a[4];o[`${t}`]={allowance:n,balance:l,price:i&&h?s(h,i).toNumber():1}})),this.emit("updatedWalletDataAll",o)}catch(t){this.emit("updateError",{error:t})}}async getWalletDataAllCollateralInfo(){const c=this._perp.contracts,n=this._collateralTokenList,r=new u({contract:c.multicall2}),o={};n.forEach((t=>{const e=t instanceof f,n=t.contract,r=t.address,l=e?{contract:n,contractName:a.SETTLEMENT_TOKEN,funcName:"decimals",funcParams:[]}:{contract:n,contractName:a.COLLATERAL_TOKENS,funcName:"decimals",funcParams:[]},i=e?{contract:n,contractName:a.SETTLEMENT_TOKEN,funcName:"balanceOf",funcParams:[c.vault.address]}:{contract:n,contractName:a.COLLATERAL_TOKENS,funcName:"balanceOf",funcParams:[c.vault.address]},s=e?void 0:{contract:n,contractName:a.COLLATERAL_TOKENS,funcName:"symbol",funcParams:[]},h=e?void 0:{contract:n,contractName:a.COLLATERAL_TOKENS,funcName:"name",funcParams:[]},m=e?void 0:{contract:c.collateralManager,contractName:a.COLLATERAL_MANAGER,funcName:"getCollateralConfig",funcParams:[r]},d=[l,i];s&&d.push(s),h&&d.push(h),m&&d.push(m),o[`${r}`]=d}));const l=await r.execute(Object.values(o).flat()),i={};return Object.entries(o).forEach((([a,c])=>{const n=l.splice(0,c.length),r=n[0],o=s(n[1],r),m=n[2]||"USDC",d=n[3]||"USDC Coin",u=n[4],p=(null==u?void 0:u.collateralRatio)?h(t(u.collateralRatio),e).toNumber():1,f=(null==u?void 0:u.depositCap)?s(u.depositCap,r):void 0;i[`${a}`]={symbol:m,name:d,weight:p,depositCap:f,depositedAmount:o}})),i}}export{E as Wallet};
//# sourceMappingURL=Wallet.js.map
