{"version":3,"file":"Channel.js","sources":["../../../src/internal/Channel.ts"],"sourcesContent":["import { ChannelEventSource } from \"./ChannelEventSource\"\nimport { ChannelRegistry } from \"./ChannelRegistry\"\n\nexport type EventHandler = (...any: any[]) => void | Promise<void>\n\ntype EventHandlersMap<EventName extends string> = {\n    [key in EventName]?: EventHandler[] | undefined\n}\n\ntype EventSourceMap<EventName extends string> = {\n    [key in EventName]?: ChannelEventSource<EventName>\n}\n\n/**\n * @date 16/12/2021\n * @export\n * @class Channel\n * @template EventName\n * @member {ChannelConfig} _config (channel config)\n * @member {ChannelRegistry} _channelRegistry (register the channel instance under this scope)\n * @member {EventSourceMap} _eventSourceMap (a channel can bind several event sources; event source can trigger the channel to emit an event)\n * @member {EventHandlersMap} _eventHandlersMap ()\n */\nexport class Channel<EventName extends string = string> {\n    private _eventSourceMap: EventSourceMap<EventName> = {}\n    private _eventHandlersMap: EventHandlersMap<EventName> = {}\n\n    constructor(protected readonly _channelRegistry?: ChannelRegistry<EventName>) {\n        if (this._getEventSourceMap) {\n            this._eventSourceMap = this._getEventSourceMap()\n        }\n    }\n\n    get hasNoHandlers() {\n        return Object.keys(this._eventHandlersMap).length === 0\n    }\n\n    on(eventName: EventName, handler: EventHandler) {\n        this._tryRegistryAdd()\n\n        const eventSource = this._eventSourceMap[eventName]\n\n        this._eventHandlersMap[eventName] = this._eventHandlersMap[eventName] || []\n        this._eventHandlersMap[eventName]?.push(handler)\n\n        // NOTE: should be called after handler is inside _eventHandlersMap\n        eventSource?.callInitEventEmitter(eventName)\n\n        const isFirstHandler = this._eventHandlersMap[eventName]?.length === 1\n        if (isFirstHandler) {\n            eventSource?.tryStart(eventName)\n        }\n        return () => this.off(eventName, handler)\n    }\n\n    off(eventName: EventName, handler: EventHandler) {\n        this._eventHandlersMap[eventName] = this._eventHandlersMap[eventName]?.filter(\n            existingHandler => existingHandler !== handler,\n        )\n        const isLastHandler = this._eventHandlersMap[eventName]?.length === 0\n        if (isLastHandler) {\n            this._tryEventSourceStop(eventName)\n        }\n\n        this._tryRegistryRemove()\n    }\n\n    offEvent(eventName: EventName) {\n        delete this._eventHandlersMap[eventName]\n        this._tryEventSourceStop(eventName)\n        this._tryRegistryRemove()\n    }\n\n    offAll() {\n        this._eventHandlersMap = {}\n        Object.keys(this._eventSourceMap).forEach(eventName => {\n            this._tryEventSourceStop(eventName as EventName)\n        })\n        this._tryRegistryRemove()\n    }\n\n    once(eventName: EventName, handler: EventHandler) {\n        const _handler: EventHandler = (...args) => {\n            handler(...args)\n            this.off(eventName, _handler)\n        }\n        this.on(eventName, _handler)\n    }\n\n    emit(eventName: EventName, ...args: any[]) {\n        this._eventHandlersMap[eventName]?.forEach(handler => {\n            handler(...args)\n        })\n    }\n\n    getHandlers(eventName: EventName) {\n        return this._eventHandlersMap[eventName] || null\n    }\n\n    // NOTE: Config the source of events, i.e. who & how this.emit is invoked.\n    protected _getEventSourceMap?(): EventSourceMap<EventName>\n\n    // NOTE: Register when adding the first event handler.\n    private _tryRegistryAdd() {\n        if (this.hasNoHandlers) {\n            this._channelRegistry?.register(this)\n        }\n    }\n\n    // NOTE: Unregister when removing the last event handler.\n    private _tryRegistryRemove() {\n        if (this.hasNoHandlers) {\n            this._channelRegistry?.unregister(this)\n        }\n    }\n\n    private _tryEventSourceStop(eventName: EventName) {\n        const eventSource = this._eventSourceMap[eventName]\n        eventSource?.tryStop(eventName)\n    }\n}\n"],"names":["constructor","_channelRegistry","this","_eventSourceMap","_eventHandlersMap","_getEventSourceMap","hasNoHandlers","Object","keys","length","on","eventName","handler","_tryRegistryAdd","eventSource","_a","push","callInitEventEmitter","_b","tryStart","off","filter","existingHandler","_tryEventSourceStop","_tryRegistryRemove","offEvent","offAll","forEach","once","_handler","args","emit","getHandlers","register","unregister","tryStop"],"mappings":"0FA2BIA,YAA+BC,GAAAC,KAAgBD,iBAAhBA,EAHvBC,KAAeC,gBAA8B,GAC7CD,KAAiBE,kBAAgC,GAGjDF,KAAKG,qBACLH,KAAKC,gBAAkBD,KAAKG,qBAEnC,CAEGC,oBACA,OAAsD,IAA/CC,OAAOC,KAAKN,KAAKE,mBAAmBK,MAC9C,CAEDC,GAAGC,EAAsBC,WACrBV,KAAKW,kBAEL,MAAMC,EAAcZ,KAAKC,gBAAgBQ,GAEzCT,KAAKE,kBAAkBO,GAAaT,KAAKE,kBAAkBO,IAAc,GACxC,QAAjCI,EAAAb,KAAKE,kBAAkBO,UAAU,IAAAI,GAAAA,EAAEC,KAAKJ,GAGxCE,SAAAA,EAAaG,qBAAqBN,GAMlC,OAJqE,KAAb,QAAjCO,EAAAhB,KAAKE,kBAAkBO,UAAU,IAAAO,OAAA,EAAAA,EAAET,UAEtDK,SAAAA,EAAaK,SAASR,IAEnB,IAAMT,KAAKkB,IAAIT,EAAWC,EACpC,CAEDQ,IAAIT,EAAsBC,WACtBV,KAAKE,kBAAkBO,GAAgD,QAAnCI,EAAAb,KAAKE,kBAAkBO,UAAY,IAAAI,OAAA,EAAAA,EAAAM,QACnEC,GAAmBA,IAAoBV,IAEyB,KAAb,QAAjCM,EAAAhB,KAAKE,kBAAkBO,UAAU,IAAAO,OAAA,EAAAA,EAAET,SAErDP,KAAKqB,oBAAoBZ,GAG7BT,KAAKsB,oBACR,CAEDC,SAASd,UACET,KAAKE,kBAAkBO,GAC9BT,KAAKqB,oBAAoBZ,GACzBT,KAAKsB,oBACR,CAEDE,SACIxB,KAAKE,kBAAoB,GACzBG,OAAOC,KAAKN,KAAKC,iBAAiBwB,SAAQhB,IACtCT,KAAKqB,oBAAoBZ,EAAuB,IAEpDT,KAAKsB,oBACR,CAEDI,KAAKjB,EAAsBC,GACvB,MAAMiB,EAAyB,IAAIC,KAC/BlB,KAAWkB,GACX5B,KAAKkB,IAAIT,EAAWkB,EAAS,EAEjC3B,KAAKQ,GAAGC,EAAWkB,EACtB,CAEDE,KAAKpB,KAAyBmB,SACO,QAAjCf,EAAAb,KAAKE,kBAAkBO,UAAU,IAAAI,GAAAA,EAAEY,SAAQf,IACvCA,KAAWkB,EAAK,GAEvB,CAEDE,YAAYrB,GACR,OAAOT,KAAKE,kBAAkBO,IAAc,IAC/C,CAMOE,wBACAX,KAAKI,gBACgB,QAArBS,EAAAb,KAAKD,wBAAgB,IAAAc,GAAAA,EAAEkB,SAAS/B,MAEvC,CAGOsB,2BACAtB,KAAKI,gBACgB,QAArBS,EAAAb,KAAKD,wBAAgB,IAAAc,GAAAA,EAAEmB,WAAWhC,MAEzC,CAEOqB,oBAAoBZ,GACxB,MAAMG,EAAcZ,KAAKC,gBAAgBQ,GACzCG,SAAAA,EAAaqB,QAAQxB,EACxB"}