{"version":3,"file":"RetryProvider.js","sources":["../../../src/network/RetryProvider.ts"],"sourcesContent":["import { backOff } from \"exponential-backoff\"\nimport { ArgumentError, RpcMaxRetryError, RpcTimeoutError } from \"../errors\"\nimport { providers, errors } from \"ethers\"\n\nimport { invariant } from \"../utils\"\n\nconst DEFAULT_RETRY_LOOP_LIMIT = 1 // time for looping all providers\nconst PROVIDER_RETRY_COOL_DOWN_MSEC = 5 * 60 * 1000\nconst PROVIDER_REQUEST_TIMEOUT_MSEC = 10 * 1000\n\nexport interface ChainStatus {\n    blockNumber: number\n    isSyncing: boolean\n}\n\ninterface ProviderConnection {\n    provider: providers.JsonRpcProvider\n    nextRetryTimestamp: number // NOTE: 0 means it's alive.\n}\n\nfunction isRetryableError(error: any) {\n    return (\n        error.code === errors.SERVER_ERROR ||\n        error.code === errors.TIMEOUT ||\n        error.message?.includes(\"header not found\") ||\n        (error.message?.includes(\"429\") && error.message?.includes(\"status code\")) ||\n        error.data?.message?.includes(\"your node is running with state pruning\") ||\n        error instanceof RpcTimeoutError\n    )\n}\n\nexport class RetryProvider extends providers.BaseProvider {\n    readonly retryLoopLimit: number\n    private readonly _providerConnectionList: ProviderConnection[] // NOTE: prioritized, 1st is the most primary one.\n    private _userProviderConnection?: ProviderConnection // NOTE: could be metamask, wallet connect\n\n    constructor(providers: providers.JsonRpcProvider[], retryLoopLimit = DEFAULT_RETRY_LOOP_LIMIT) {\n        invariant(\n            providers.length >= 1,\n            () =>\n                new ArgumentError({\n                    functionName: \"RetryProvider Constructor\",\n                    key: \"providers\",\n                    value: \"empty\",\n                }),\n        )\n\n        // TODO: check all providers have the same network, See implementation in FallbackProvider\n        const network = providers[0].getNetwork()\n        super(network)\n        this._providerConnectionList = providers.map<ProviderConnection>(provider =>\n            RetryProvider.getInitialProviderConnection(provider),\n        )\n        this.retryLoopLimit = retryLoopLimit\n    }\n\n    get providerConnectionList(): ProviderConnection[] {\n        return this._userProviderConnection\n            ? [...this._providerConnectionList, this._userProviderConnection]\n            : this._providerConnectionList\n    }\n\n    public addUserProvider(provider: providers.JsonRpcProvider) {\n        this._userProviderConnection = RetryProvider.getInitialProviderConnection(provider)\n    }\n\n    public removeUserProvider() {\n        this._userProviderConnection = undefined\n    }\n\n    // TODO: check all providers have the same network and return the network\n    public detectNetwork() {\n        return this._networkPromise\n    }\n\n    public async getBlockNumber(): Promise<number> {\n        return this._iterateProviders(provider => provider.getBlockNumber())\n    }\n\n    public async getChainStatus(): Promise<ChainStatus> {\n        return this._iterateProviders(async provider => {\n            const [blockNumber, isSyncing] = await Promise.all([\n                provider.getBlockNumber(),\n                provider.send(\"eth_syncing\", []),\n            ])\n\n            return {\n                blockNumber,\n                isSyncing,\n            }\n        })\n    }\n\n    /** NOTE:\n     * To reproduce retry limit error throw by ethers.js, reduce the `attemptLimit` of function `_fetchData()` to 1.\n     * see details in: @ethersproject/web/lib.esm/index.js.\n     *\n     * Reference: https://github.com/ethers-io/ethers.js/issues/427#issuecomment-465329448\n     **/\n    public async perform(method: string, params: any) {\n        // NOTE: contract write\n        if (method === \"sendTransaction\") {\n            const result = await this._handleSendTransaction(params)\n            return result\n        }\n\n        // NOTE: contract read\n        return this._iterateProviders(async provider => {\n            return provider.perform(method, params)\n        })\n    }\n\n    // NOTE: Copied from ethers.js perform()\n    private async _handleSendTransaction(params: any) {\n        const results: Array<string | Error> = await Promise.any(\n            this.providerConnectionList.map(({ provider }) => {\n                return provider.sendTransaction(params.signedTransaction).then(\n                    result => {\n                        return result.hash\n                    },\n                    error => {\n                        return error\n                    },\n                )\n            }),\n        )\n\n        // NOTE: Any success is good enough (other errors are likely \"already seen\" errors)\n        for (let i = 0; i < results.length; i++) {\n            const result = results[i]\n            if (typeof result === \"string\") {\n                return result\n            }\n        }\n\n        // NOTE: All results are errors, throw the first error.\n        throw results[0]\n    }\n\n    /**\n     * Return the first \"supposedly-alive\" provider if any. Otherwise, return the one that has been marked dead for the longest.\n     *\n     * A provider is \"supposedly-alive\" if it has never been tried, or is alive when last used.\n     * The earlier the provider appears in the list, the higher the priority.\n     */\n    private _getCandidateProviderConnection(providerConnectionList: ProviderConnection[]): ProviderConnection {\n        const currentTimestamp = new Date().valueOf()\n        const firstAliveProvider = providerConnectionList.find(\n            ({ nextRetryTimestamp: reliveCheckTimestamp }) => reliveCheckTimestamp <= currentTimestamp,\n        )\n        if (firstAliveProvider) {\n            return firstAliveProvider\n        }\n\n        const oldestDeadProvider = providerConnectionList.reduce((providerConnectionA, providerConnectionB) => {\n            return providerConnectionA.nextRetryTimestamp <= providerConnectionB.nextRetryTimestamp\n                ? providerConnectionA\n                : providerConnectionB\n        })\n        return oldestDeadProvider\n    }\n\n    private _updateProviderStatus(providerConnection: ProviderConnection, isAlive: boolean) {\n        if (isAlive) {\n            providerConnection.nextRetryTimestamp = 0\n        } else {\n            const currentTimestamp = new Date().valueOf()\n            providerConnection.nextRetryTimestamp = currentTimestamp + PROVIDER_RETRY_COOL_DOWN_MSEC\n        }\n    }\n\n    private async _providerTimeoutBenchmark() {\n        return new Promise((_, reject) => {\n            setTimeout(() => reject(new RpcTimeoutError()), PROVIDER_REQUEST_TIMEOUT_MSEC)\n        })\n    }\n\n    private async _iterateProviders(func: (provider: providers.JsonRpcProvider) => Promise<any>) {\n        const serverErrors = []\n        let attempts = 0\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            if (attempts >= this.retryLoopLimit * this.providerConnectionList.length) {\n                return this._retryWithBackoff(func, serverErrors)\n            }\n            attempts++\n            const providerConnection = this._getCandidateProviderConnection(this.providerConnectionList)\n            try {\n                const result = await Promise.race([func(providerConnection.provider), this._providerTimeoutBenchmark()])\n                this._updateProviderStatus(providerConnection, true)\n                return result\n            } catch (error: any) {\n                if (isRetryableError(error)) {\n                    // NOTE: Suppress server error or timeout error to retry with next provider.\n                    this._updateProviderStatus(providerConnection, false)\n                    serverErrors.push(error)\n                } else {\n                    // NOTE: For other errors, abort retrying and throw the error.\n                    throw error\n                }\n            }\n        }\n    }\n\n    private async _retryWithBackoff(func: (provider: providers.JsonRpcProvider) => Promise<any>, errors: any) {\n        const providerConnection = this._getCandidateProviderConnection(this.providerConnectionList)\n        try {\n            return await backOff(() => func(providerConnection.provider), {\n                numOfAttempts: 6, // retry 5 times\n                startingDelay: 1000, // 1 sec.\n                timeMultiple: 2,\n                retry: (error: any, attemptNumber: number) => {\n                    return isRetryableError(error)\n                },\n            })\n        } catch (e: any) {\n            throw new RpcMaxRetryError({ rawErrors: [...errors, e] })\n        }\n    }\n\n    static getInitialProviderConnection(provider: providers.JsonRpcProvider): ProviderConnection {\n        return { provider, nextRetryTimestamp: 0 }\n    }\n}\n"],"names":["isRetryableError","error","code","errors","SERVER_ERROR","TIMEOUT","_a","message","includes","_b","_c","_e","_d","data","RpcTimeoutError","RetryProvider","providers","BaseProvider","constructor","retryLoopLimit","invariant","length","ArgumentError","functionName","key","value","super","getNetwork","this","_providerConnectionList","map","provider","getInitialProviderConnection","providerConnectionList","_userProviderConnection","addUserProvider","removeUserProvider","undefined","detectNetwork","_networkPromise","async","_iterateProviders","getBlockNumber","blockNumber","isSyncing","Promise","all","send","method","params","_handleSendTransaction","perform","results","any","sendTransaction","signedTransaction","then","result","hash","i","_getCandidateProviderConnection","currentTimestamp","Date","valueOf","firstAliveProvider","find","nextRetryTimestamp","reliveCheckTimestamp","reduce","providerConnectionA","providerConnectionB","_updateProviderStatus","providerConnection","isAlive","_","reject","setTimeout","func","serverErrors","attempts","_retryWithBackoff","race","_providerTimeoutBenchmark","push","backOff","numOfAttempts","startingDelay","timeMultiple","retry","attemptNumber","e","RpcMaxRetryError","rawErrors","static"],"mappings":"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"}