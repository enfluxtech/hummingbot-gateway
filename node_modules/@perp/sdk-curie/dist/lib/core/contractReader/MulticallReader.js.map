{"version":3,"file":"MulticallReader.js","sources":["../../../../src/core/contractReader/MulticallReader.ts"],"sourcesContent":["import { BaseContract, utils } from \"ethers\"\n\nimport { ContractName } from \"../../contracts\"\nimport { Multicall2 } from \"../../contracts/type\"\nimport {\n    ContractReadError,\n    ContractReadErrorParams,\n    MulticallDecodeError,\n    MulticallEncodeError,\n    MulticallReadError,\n} from \"../../errors\"\n\ninterface MulticallReaderConfig {\n    contract: Multicall2\n}\n\nexport interface ContractCall {\n    contract: BaseContract\n    contractName: ContractName\n    funcName: string\n    funcParams: any[]\n}\n\ntype ReturnObj = Record<ContractName, any[]>\n\ntype OptionalParam = {\n    failFirstByContract?: boolean\n    failFirstByClient?: boolean\n    returnByContractAndFuncName?: boolean\n}\n\nexport class MulticallReader {\n    readonly contract: Multicall2\n\n    constructor({ contract }: MulticallReaderConfig) {\n        this.contract = contract\n    }\n\n    // TODO: add type check to make sure the funcName is exist in the certain contract (https://app.asana.com/0/1200351496528172/1201094806109445/f)\n    async execute(calls: ContractCall[], options?: OptionalParam): Promise<utils.Result> {\n        const {\n            failFirstByContract = true,\n            failFirstByClient = true,\n            returnByContractAndFuncName = false,\n        } = options || {}\n        const callRequests = calls.map(call => {\n            try {\n                const callData = call.contract.interface.encodeFunctionData(call.funcName, call.funcParams)\n                return {\n                    target: call.contract.address,\n                    callData,\n                }\n            } catch (error) {\n                throw new MulticallEncodeError<Multicall2>({\n                    contractName: ContractName.MULTICALL2,\n                    contractFunctionName: \"tryAggregate\",\n                    args: { callFuncNam: call.funcName, callFuncParams: call.funcParams },\n                    rawError: error as Error,\n                })\n            }\n        })\n\n        let response\n        try {\n            response = await this.contract.callStatic.tryAggregate(failFirstByContract, callRequests)\n        } catch (error) {\n            throw new MulticallReadError<Multicall2>({\n                contractName: ContractName.MULTICALL2,\n                contractFunctionName: \"tryAggregate\",\n                rawError: error as Error,\n            })\n        }\n\n        const callResult = response.map(({ success, returnData }, index) => {\n            const call = calls[index]\n\n            if (failFirstByClient || success) {\n                try {\n                    const result = call.contract.interface.decodeFunctionResult(call.funcName, returnData)\n                    return result.length <= 1 ? result[0] : result\n                } catch (error) {\n                    throw new MulticallDecodeError<Multicall2>({\n                        contractName: ContractName.MULTICALL2,\n                        contractFunctionName: \"tryAggregate\",\n                        args: { callFuncNam: call.funcName, returnData },\n                        rawError: error as Error,\n                    })\n                }\n            } else {\n                let rawError = new Error()\n\n                // Next 5 lines from: https://ethereum.stackexchange.com/questions/83528/how-can-i-get-the-revert-reason-of-a-call-in-solidity-so-that-i-can-use-it-in-th/83577#83577\n                if (returnData.length >= 68) {\n                    const reasonBytes = `0x${returnData.substr(10)}`\n                    const reason = utils.toUtf8String(reasonBytes).trim()\n                    rawError = new Error(reason)\n                }\n\n                const funcName = call.funcName\n                const params: ContractReadErrorParams<any> = {\n                    contractName: funcName,\n                    contractFunctionName: call.funcName,\n                    args: call.funcParams,\n                    rawError,\n                }\n\n                return new ContractReadError<typeof call.contract>(params)\n            }\n        })\n\n        if (returnByContractAndFuncName) {\n            const result = callResult.reduce((resultMap, curr, index) => {\n                const call = calls[index]\n                const key = `${call.contractName}.${call.funcName}`\n                const existingResultArray = resultMap[key]\n                resultMap[key] = existingResultArray ? [...existingResultArray, curr] : [curr]\n                return resultMap\n            }, {} as ReturnObj)\n\n            return result\n        }\n\n        return callResult\n    }\n}\n"],"names":["constructor","contract","this","async","calls","options","failFirstByContract","failFirstByClient","returnByContractAndFuncName","callRequests","map","call","callData","interface","encodeFunctionData","funcName","funcParams","target","address","error","MulticallEncodeError","contractName","ContractName","MULTICALL2","contractFunctionName","args","callFuncNam","callFuncParams","rawError","response","callStatic","tryAggregate","MulticallReadError","callResult","success","returnData","index","Error","length","reasonBytes","substr","reason","utils","toUtf8String","trim","params","ContractReadError","result","decodeFunctionResult","MulticallDecodeError","reduce","resultMap","curr","key","existingResultArray"],"mappings":"wMAkCIA,aAAYC,SAAEA,IACVC,KAAKD,SAAWA,CACnB,CAGDE,cAAcC,EAAuBC,GACjC,MAAMC,oBACFA,GAAsB,EAAIC,kBAC1BA,GAAoB,EAAIC,4BACxBA,GAA8B,GAC9BH,GAAW,GACTI,EAAeL,EAAMM,KAAIC,IAC3B,IACI,MAAMC,EAAWD,EAAKV,SAASY,UAAUC,mBAAmBH,EAAKI,SAAUJ,EAAKK,YAChF,MAAO,CACHC,OAAQN,EAAKV,SAASiB,QACtBN,WASP,CAPC,MAAOO,GACL,MAAM,IAAIC,EAAAA,qBAAiC,CACvCC,aAAcC,EAAYA,aAACC,WAC3BC,qBAAsB,eACtBC,KAAM,CAAEC,YAAaf,EAAKI,SAAUY,eAAgBhB,EAAKK,YACzDY,SAAUT,GAEjB,KAGL,IAAIU,EACJ,IACIA,QAAiB3B,KAAKD,SAAS6B,WAAWC,aAAazB,EAAqBG,EAO/E,CANC,MAAOU,GACL,MAAM,IAAIa,EAAAA,mBAA+B,CACrCX,aAAcC,EAAYA,aAACC,WAC3BC,qBAAsB,eACtBI,SAAUT,GAEjB,CAED,MAAMc,EAAaJ,EAASnB,KAAI,EAAGwB,UAASC,cAAcC,KACtD,MAAMzB,EAAOP,EAAMgC,GAEnB,IAAI7B,IAAqB2B,EAYlB,CACH,IAAIN,EAAW,IAAIS,MAGnB,GAAIF,EAAWG,QAAU,GAAI,CACzB,MAAMC,EAAc,KAAKJ,EAAWK,OAAO,MACrCC,EAASC,EAAAA,MAAMC,aAAaJ,GAAaK,OAC/ChB,EAAW,IAAIS,MAAMI,EACxB,CAED,MACMI,EAAuC,CACzCxB,aAFaV,EAAKI,SAGlBS,qBAAsBb,EAAKI,SAC3BU,KAAMd,EAAKK,WACXY,YAGJ,OAAO,IAAIkB,EAAAA,kBAAwCD,EACtD,CA9BG,IACI,MAAME,EAASpC,EAAKV,SAASY,UAAUmC,qBAAqBrC,EAAKI,SAAUoB,GAC3E,OAAOY,EAAOT,QAAU,EAAIS,EAAO,GAAKA,CAQ3C,CAPC,MAAO5B,GACL,MAAM,IAAI8B,EAAAA,qBAAiC,CACvC5B,aAAcC,EAAYA,aAACC,WAC3BC,qBAAsB,eACtBC,KAAM,CAAEC,YAAaf,EAAKI,SAAUoB,cACpCP,SAAUT,GAEjB,CAoBJ,IAGL,GAAIX,EAA6B,CAS7B,OAReyB,EAAWiB,QAAO,CAACC,EAAWC,EAAMhB,KAC/C,MAAMzB,EAAOP,EAAMgC,GACbiB,EAAM,GAAG1C,EAAKU,gBAAgBV,EAAKI,WACnCuC,EAAsBH,EAAUE,GAEtC,OADAF,EAAUE,GAAOC,EAAsB,IAAIA,EAAqBF,GAAQ,CAACA,GAClED,CAAS,GACjB,CAAe,EAGrB,CAED,OAAOlB,CACV"}