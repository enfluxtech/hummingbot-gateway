import { providers } from "ethers";
export interface ChainStatus {
    blockNumber: number;
    isSyncing: boolean;
}
interface ProviderConnection {
    provider: providers.JsonRpcProvider;
    nextRetryTimestamp: number;
}
export declare class RetryProvider extends providers.BaseProvider {
    readonly retryLoopLimit: number;
    private readonly _providerConnectionList;
    private _userProviderConnection?;
    constructor(providers: providers.JsonRpcProvider[], retryLoopLimit?: number);
    get providerConnectionList(): ProviderConnection[];
    addUserProvider(provider: providers.JsonRpcProvider): void;
    removeUserProvider(): void;
    detectNetwork(): Promise<providers.Network>;
    getBlockNumber(): Promise<number>;
    getChainStatus(): Promise<ChainStatus>;
    /** NOTE:
     * To reproduce retry limit error throw by ethers.js, reduce the `attemptLimit` of function `_fetchData()` to 1.
     * see details in: @ethersproject/web/lib.esm/index.js.
     *
     * Reference: https://github.com/ethers-io/ethers.js/issues/427#issuecomment-465329448
     **/
    perform(method: string, params: any): Promise<any>;
    private _handleSendTransaction;
    /**
     * Return the first "supposedly-alive" provider if any. Otherwise, return the one that has been marked dead for the longest.
     *
     * A provider is "supposedly-alive" if it has never been tried, or is alive when last used.
     * The earlier the provider appears in the list, the higher the priority.
     */
    private _getCandidateProviderConnection;
    private _updateProviderStatus;
    private _providerTimeoutBenchmark;
    private _iterateProviders;
    private _retryWithBackoff;
    static getInitialProviderConnection(provider: providers.JsonRpcProvider): ProviderConnection;
}
export {};
