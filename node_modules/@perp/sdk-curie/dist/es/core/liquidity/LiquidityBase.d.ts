import { Channel, ChannelEventSource, ChannelRegistry } from "../../internal";
import Big from "big.js";
import { Market } from "../market";
export declare enum RangeType {
    RANGE_UNINITIALIZED = "RANGE_UNINITIALIZED",
    RANGE_INVALID = "RANGE_INVALID",
    RANGE_INSIDE = "RANGE_INSIDE",
    RANGE_AT_LEFT = "RANGE_AT_LEFT",
    RANGE_AT_RIGHT = "RANGE_AT_RIGHT"
}
declare type LiquidityBaseEventName = "updateError" | "updated";
export interface EventPayloadRangeTypeUpdated {
    rangeType: RangeType;
    markPrice: Big;
}
export interface LiquidityBaseConstructorData {
    market: Market;
}
export declare class LiquidityBase<EventName extends string = ""> extends Channel<EventName | LiquidityBaseEventName> {
    readonly market: Market;
    protected _lowerTick: number;
    protected _upperTick: number;
    protected _markPrice?: Big;
    constructor({ market }: LiquidityBaseConstructorData, _channelRegistry?: ChannelRegistry);
    get lowerTick(): number;
    get upperTick(): number;
    get lowerTickPrice(): Big;
    get upperTickPrice(): Big;
    getRangeType({ cache }?: {
        cache?: boolean | undefined;
    }): Promise<RangeType.RANGE_INVALID | RangeType.RANGE_INSIDE | RangeType.RANGE_AT_LEFT | RangeType.RANGE_AT_RIGHT>;
    protected _getEventSourceMap(): {
        updated: ChannelEventSource<LiquidityBaseEventName | EventName>;
        updateError: ChannelEventSource<LiquidityBaseEventName | EventName>;
    };
    static getRangeTypeByMarkPrice(markPrice: Big, lowerTickPrice: Big, upperTickPrice: Big): RangeType.RANGE_INVALID | RangeType.RANGE_INSIDE | RangeType.RANGE_AT_LEFT | RangeType.RANGE_AT_RIGHT;
    static getLiquidityFromBaseToken(markPriceSqrtX96: Big, upperPriceSqrtX96: Big, amount: Big): Big;
    static getLiquidityFromQuoteToken(markPriceSqrtX96: Big, lowerPriceSqrtX96: Big, amount: Big): Big;
    static getBaseTokenAmountFromLiquidity(priceASqrtX96: Big, priceBSqrtX96: Big, liquidity: Big): Big;
    static getQuoteTokenAmountFromLiquidity(priceASqrtX96: Big, priceBSqrtX96: Big, liquidity: Big): Big;
    /**
     * Computes the maximum amount of liquidity received for a given amount of token0, token1,
     * and the prices at the tick boundaries.
     * @param sqrtRatioCurrentX96 the current price
     * @param sqrtRatioAX96 price at lower boundary
     * @param sqrtRatioBX96 price at upper boundary
     * @param baseAmount base token amount
     * @param quoteAmount quote token amount
     *
     * NOTE: code can be referenced to uniswap contract and sdk
     * https://github.com/Uniswap/v3-sdk/blob/main/src/utils/maxLiquidityForAmounts.ts#L68
     * https://github.com/Uniswap/v3-periphery/blob/main/contracts/libraries/LiquidityAmounts.sol#L56
     */
    static maxLiquidityForAmounts(sqrtRatioCurrentX96: Big, sqrtRatioAX96: Big, sqrtRatioBX96: Big, baseAmount: Big, quoteAmount: Big): Big;
}
export {};
