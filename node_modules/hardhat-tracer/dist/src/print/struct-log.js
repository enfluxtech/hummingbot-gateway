"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.printStructLog = void 0;
const constants_1 = require("../constants");
const utils_1 = require("../utils");
const call_1 = require("../opcodes/call");
const callcode_1 = require("../opcodes/callcode");
const create_1 = require("../opcodes/create");
const create2_1 = require("../opcodes/create2");
const delegatecall_1 = require("../opcodes/delegatecall");
const log0_1 = require("../opcodes/log0");
const log1_1 = require("../opcodes/log1");
const log2_1 = require("../opcodes/log2");
const log3_1 = require("../opcodes/log3");
const log4_1 = require("../opcodes/log4");
const revert_1 = require("../opcodes/revert");
const sload_1 = require("../opcodes/sload");
const sstore_1 = require("../opcodes/sstore");
const staticcall_1 = require("../opcodes/staticcall");
const add_1 = require("../opcodes/add");
const sub_1 = require("../opcodes/sub");
const mul_1 = require("../opcodes/mul");
const eq_1 = require("../opcodes/eq");
const lt_1 = require("../opcodes/lt");
const gt_1 = require("../opcodes/gt");
const sha3_1 = require("../opcodes/sha3");
const mload_1 = require("../opcodes/mload");
const mstore_1 = require("../opcodes/mstore");
/**
 * Prints the given structLog to the console.
 * @param structLog StructLog to print
 * @param index Index of the structLog in the trace (used for finding return data structLog)
 * @param structLogs reference to the array of all structLogs
 * @param addressStack reference to the stack of addresses
 * @param dependencies Tracer dependencies
 */
async function printStructLog(structLog, index, structLogs, addressStack, dependencies) {
    // if running in logs mode exit if opcode is not a LOG
    if ((0, utils_1.isOnlyLogs)(dependencies.tracerEnv) && !structLog.op.startsWith("LOG")) {
        return;
    }
    switch (structLog.op) {
        case "CREATE":
            addressStack.push(await (0, create_1.printCreate)(structLog, index, structLogs, dependencies));
            break;
        case "CREATE2":
            addressStack.push(await (0, create2_1.printCreate2)(structLog, index, structLogs, dependencies));
            break;
        case "CALL":
            addressStack.push(await (0, call_1.printCall)(structLog, index, structLogs, dependencies));
            break;
        case "CALLCODE":
            await (0, callcode_1.printCallCode)(structLog, index, structLogs, dependencies);
            break;
        case "STATICCALL":
            addressStack.push(await (0, staticcall_1.printStaticCall)(structLog, index, structLogs, dependencies));
            break;
        case "DELEGATECALL":
            addressStack.push(addressStack[addressStack.length - 1]);
            await (0, delegatecall_1.printDelegateCall)(structLog, index, structLogs, dependencies);
            break;
        case "LOG0":
            await (0, log0_1.printLog0)(structLog, addressStack[addressStack.length - 1], dependencies);
            break;
        case "LOG1":
            await (0, log1_1.printLog1)(structLog, addressStack[addressStack.length - 1], dependencies);
            break;
        case "LOG2":
            await (0, log2_1.printLog2)(structLog, addressStack[addressStack.length - 1], dependencies);
            break;
        case "LOG3":
            await (0, log3_1.printLog3)(structLog, addressStack[addressStack.length - 1], dependencies);
            break;
        case "LOG4":
            await (0, log4_1.printLog4)(structLog, addressStack[addressStack.length - 1], dependencies);
            break;
        case "SLOAD":
            if (dependencies.tracerEnv.sloads) {
                await (0, sload_1.printSload)(structLog, index, structLogs, dependencies);
            }
            break;
        case "SSTORE":
            if (dependencies.tracerEnv.sstores) {
                await (0, sstore_1.printSstore)(structLog, dependencies);
            }
            break;
        case "REVERT":
            await (0, revert_1.printRevert)(structLog, dependencies);
            addressStack.pop();
            break;
        case "RETURN":
            addressStack.pop();
            break;
        case "STOP":
            addressStack.pop();
            break;
        default:
            if (dependencies.tracerEnv.opcodes.includes(structLog.op)) {
                switch (structLog.op) {
                    case "ADD":
                        await (0, add_1.printAdd)(structLog, index, structLogs, dependencies);
                        break;
                    case "SUB":
                        await (0, sub_1.printSub)(structLog, index, structLogs, dependencies);
                        break;
                    case "MUL":
                        await (0, mul_1.printMul)(structLog, index, structLogs, dependencies);
                        break;
                    case "DIV":
                        await (0, mul_1.printMul)(structLog, index, structLogs, dependencies);
                        break;
                    case "EQ":
                        await (0, eq_1.printEq)(structLog, index, structLogs, dependencies);
                        break;
                    case "LT":
                        await (0, lt_1.printLt)(structLog, index, structLogs, dependencies);
                        break;
                    case "GT":
                        await (0, gt_1.printGt)(structLog, index, structLogs, dependencies);
                        break;
                    case "SHA3":
                        await (0, sha3_1.printSha3)(structLog, index, structLogs, dependencies);
                        break;
                    case "MLOAD":
                        await (0, mload_1.printMload)(structLog, index, structLogs, dependencies);
                        break;
                    case "MSTORE":
                        await (0, mstore_1.printMstore)(structLog, dependencies);
                        break;
                    default:
                        console.log(constants_1.DEPTH_INDENTATION.repeat(structLog.depth) + structLog.op);
                }
            }
            break;
    }
}
exports.printStructLog = printStructLog;
//# sourceMappingURL=struct-log.js.map