import"../../constants/envVariables.js";import{ERC20_DECIMAL_DIGITS as e,BIG_ZERO as t}from"../../constants/numbers.js";import{ChannelEventSource as i}from"../../internal/ChannelEventSource.js";import{toSqrtX96 as r,scaleDownDecimals as s}from"../../utils/formatters.js";import{LiquidityBase as a,RangeType as c}from"./LiquidityBase.js";import{Position as o,PositionType as n}from"../position/Position.js";import"big.js";import"../../utils/tick.js";import{PositionSide as u}from"../position/types.js";import{FailedPreconditionError as h}from"../../errors/errors.js";import"ethers";import"../../contracts/Contracts.js";class m extends a{constructor({perp:e,id:t,liquidity:i,lowerTick:r,upperTick:s,baseDebt:a,quoteDebt:c,...o},n){super(o,n),this._cache=new Map,this._perp=e,this.id=t,this.liquidity=i,this._lowerTick=r,this._upperTick=s,this._baseDebt=a,this._quoteDebt=c}get baseDebt(){return this._baseDebt}get quoteDebt(){return this._quoteDebt}_getEventSourceMap(){return{...super._getEventSourceMap(),updated:new i({eventSourceStarter:()=>this.market.on("updated",this._handleMarketUpdate.bind(this))})}}async _handleMarketUpdate(){try{await this._fetch("liquidityPendingFee",{cache:!1}),this.emit("updated",this)}catch(e){this.emit("updateError",e)}}async getPendingFee({cache:e=!0}={}){return this._fetch("liquidityPendingFee",{cache:e})}async getLiquidityAmounts({cache:e=!0}={}){const[{markPrice:t},i]=await Promise.all([this.market.getPrices({cache:e}),this.getRangeType({cache:e})]),{amountQuote:r,amountBase:s}=m.getLiquidityAmounts({markPrice:t,lowerTickPrice:this.lowerTickPrice,upperTickPrice:this.upperTickPrice,liquidity:this.liquidity,rangeType:i});return{amountQuote:r,amountBase:s}}async getMakerPositionImpermanent({cache:e=!0}={}){const[{markPrice:t},i]=await Promise.all([this.market.getPrices({cache:e}),this.getRangeType({cache:e})]),{amountQuote:r,amountBase:s}=m.getLiquidityAmounts({markPrice:t,lowerTickPrice:this.lowerTickPrice,upperTickPrice:this.upperTickPrice,liquidity:this.liquidity,rangeType:i});return await this._getMakerPositionImpermanent(s,r)}async getLiquidityValue({cache:e=!0}={}){const[{markPrice:t},i]=await Promise.all([this.market.getPrices({cache:e}),this.getRangeType({cache:e})]),{amountBase:r,amountQuote:s}=m.getLiquidityAmounts({markPrice:t,lowerTickPrice:this.lowerTickPrice,upperTickPrice:this.upperTickPrice,liquidity:this.liquidity,rangeType:i});return r.mul(t).add(s)}async _getMakerPositionImpermanent(e,t){const i=e.sub(this.baseDebt),r=t.sub(this.quoteDebt);let s;return i.eq(0)||(s=new o({perp:this._perp,type:n.MAKER,market:this.market,side:i.gt(0)?u.LONG:u.SHORT,sizeAbs:i.abs(),openNotionalAbs:r.abs(),entryPrice:r.div(i).abs()})),s}static getLiquidityAmounts({markPrice:i,lowerTickPrice:a,upperTickPrice:o,liquidity:n,rangeType:u}){const p=r(i),d=r(o),k=r(a);let l,y;switch(u){case c.RANGE_AT_LEFT:l=m.getQuoteTokenAmountFromLiquidity(d,k,n),y=t;break;case c.RANGE_AT_RIGHT:y=m.getBaseTokenAmountFromLiquidity(d,k,n),l=t;break;case c.RANGE_INSIDE:l=m.getQuoteTokenAmountFromLiquidity(p,k,n),y=m.getBaseTokenAmountFromLiquidity(p,d,n);break;default:throw new h({functionName:"getLiquidityAmounts",stateName:"rangeType",stateValue:u})}return{amountQuote:s(l,e),amountBase:s(y,e)}}async _fetch(e,{cache:t=!0}={}){if(this._cache.has(e)&&t)return this._cache.get(e);let i;if("liquidityPendingFee"===e)i=await this._perp.contractReader.getLiquidityPendingFee({trader:this._perp.wallet.account,baseTokenAddress:this.market.baseAddress,lowerTick:this._lowerTick,upperTick:this._upperTick});return this._cache.set(e,i),i}static same(e,t){return e.id===t.id&&e.liquidity.eq(t.liquidity)&&e.baseDebt.eq(t.baseDebt)&&e.quoteDebt.eq(t.quoteDebt)}}export{m as Liquidity};
//# sourceMappingURL=Liquidity.js.map
