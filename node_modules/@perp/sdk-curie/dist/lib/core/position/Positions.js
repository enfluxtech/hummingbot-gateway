"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),require("../../constants/envVariables.js");var e=require("../../constants/numbers.js"),t=require("../../internal/Channel.js"),a=require("../../internal/ChannelEventSource.js"),i=require("../../utils/formatters.js"),o=require("../../internal/config.js"),n=require("./Position.js"),r=require("big.js"),s=require("../../utils/errorChecker.js");require("../../utils/tick.js");var c=require("../../utils/poll.js"),l=require("../../utils/logger.js"),u=require("./types.js"),d=require("../../errors/errors.js");require("ethers");var P=require("../../contracts/Contracts.js"),m=require("../contractReader/MulticallReader.js"),g=require("../clearingHouse/utils.js");function h(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var p=h(r);class k extends t.Channel{constructor(e){super(e.channelRegistry),this._perp=e,this._cache=new Map}_getEventSourceMap(){const e=this.getPositionDataAll.bind(this);return{updated:new a.ChannelEventSource({eventSourceStarter:()=>{var t,a;return c.poll(e,(null===(a=null===(t=this._perp.moduleConfigs)||void 0===t?void 0:t.positions)||void 0===a?void 0:a.period)||o.DEFAULT_PERIOD).cancel},initEventEmitter:()=>e()})}}async getTakerPositions({cache:e=!0}={}){const t=this._perp.markets.marketMap,a=[],[i,o,r]=await Promise.all([this._fetch("takerPositionSizeList",{cache:e}),this._fetch("takerOpenNotionalList",{cache:e}),this._fetch("liquidationPriceList",{cache:e})]);return Object.values(t).forEach(((e,t)=>{const s=i[t],c=o[t],l=r[t];s.eq(0)||a.push(new n.Position({perp:this._perp,type:n.PositionType.TAKER,market:e,side:s.gte(0)?u.PositionSide.LONG:u.PositionSide.SHORT,sizeAbs:s.abs(),openNotionalAbs:c.abs(),entryPrice:c.div(s).abs(),liquidationPrice:l}))})),a}async getMakerPositions({cache:t=!0}={}){const a=this._perp.markets.marketMap,[i,o]=await Promise.all([this._fetch("totalPositionSizeList",{cache:t}),this._fetch("totalOpenNotionalList",{cache:t})]),r=await this.getTakerPositions({cache:t}),s=[];return Object.values(a).forEach(((t,a)=>{const c=r.find((e=>e.market.baseSymbol===t.baseSymbol)),l=(null==c?void 0:c.sizeOriginal)||e.BIG_ZERO,d=(null==c?void 0:c.openNotionalOriginal)||e.BIG_ZERO,P=i[a].sub(l),m=o[a].sub(d);P.eq(0)||s.push(new n.Position({perp:this._perp,type:n.PositionType.MAKER,market:t,side:P.gte(0)?u.PositionSide.LONG:u.PositionSide.SHORT,sizeAbs:P.abs(),openNotionalAbs:m.abs(),entryPrice:m.div(P).abs()}))})),s}async getTakerPositionByTickerSymbol(e,{cache:t=!0}={}){return(await this.getTakerPositions({cache:t})).find((t=>t.market.tickerSymbol===e))}async getMakerPositionByTickerSymbol(e,{cache:t=!0}={}){return(await this.getMakerPositions({cache:t})).find((t=>t.market.tickerSymbol===e))}async getTakerPosition(e,{cache:t=!0}={}){return(await this.getTakerPositions({cache:t})).find((t=>t.market.baseAddress===e))}async getMakerPosition(e,{cache:t=!0}={}){return(await this.getMakerPositions({cache:t})).find((t=>t.market.baseAddress===e))}async getTotalPositionValue(t,{cache:a=!0}={}){const i=await this._fetch("totalPositionValueList",{cache:a}),o=Object.values(this._perp.markets.marketMap).findIndex((e=>e.baseAddress===t));return-1===o?e.BIG_ZERO:i[o]}async getTotalPositionValueFromAllMarkets({cache:e=!0}={}){const t=await this.getTotalMakerPositionValueFromAllMarkets({cache:e}),a=await this.getTotalTakerPositionValueFromAllMarkets();return t.add(a)}async getTotalTakerPositionValueFromAllMarkets({cache:t=!0}={}){const a=await this.getTakerPositions({cache:t});let i=e.BIG_ZERO;for(const e of a){const a=e.sizeOriginal,{indexPrice:o}=await e.market.getPrices({cache:t});i=i.add(a.mul(o))}return i}async getTotalMakerPositionValueFromAllMarkets({cache:t=!0}={}){const a=await this.getMakerPositions({cache:t});let i=e.BIG_ZERO;for(const e of a){const a=e.sizeOriginal,{indexPrice:o}=await e.market.getPrices({cache:t});i=i.add(a.mul(o))}return i}async getTotalUnrealizedPnlFromAllMarkets({cache:e=!0}={}){const t=await this.getTotalMakerUnrealizedPnlFromAllMarkets({cache:e}),a=await this.getTotalTakerUnrealizedPnlFromAllMarkets({cache:e});return t.add(a)}async getTotalTakerUnrealizedPnlFromAllMarkets({cache:t=!0}={}){const a=await this.getTakerPositions({cache:t});let i=e.BIG_ZERO;for(const e of a)i=i.add(await e.getUnrealizedPnl());return i}async getTotalMakerUnrealizedPnlFromAllMarkets({cache:t=!0}={}){const a=await this.getMakerPositions({cache:t});let i=e.BIG_ZERO;for(const e of a)i=i.add(await e.getUnrealizedPnl());return i}async getTotalPendingFundingPayments({cache:e=!0}={}){return this._fetch("pendingFundingPayments",{cache:e})}async getAccountMarginRatio({cache:e=!0}={}){s.invariant(this._perp.hasConnected(),(()=>new d.UnauthorizedError({functionName:"getMarginRatio"})));const t=await this._fetch("totalAbsPositionValue",{cache:e});if(t.eq(0))return;return(await this._perp.vault.getAccountValue({cache:e})).div(t)}async getAccountLeverage({cache:t=!0}={}){const a=await this.getAccountMarginRatio({cache:t});if(a&&!(null==a?void 0:a.eq(0)))return e.BIG_ONE.div(a)}async _fetch(e,{cache:t=!0}={}){if(this._cache.has(e)&&t)return this._cache.get(e);const a=this._perp.markets.marketMap,i=this._perp.wallet.account,o=[a,i];let n;switch(e){case"takerPositionSizeList":n=await this._perp.contractReader.getTakerPositionSizeList(...o);break;case"takerOpenNotionalList":n=await this._perp.contractReader.getTakerOpenNotionalList(...o);break;case"totalPositionSizeList":n=await this._perp.contractReader.getTotalPositionSizeList(...o);break;case"totalOpenNotionalList":n=await this._perp.contractReader.getTotalOpenNotionalList(...o);break;case"pendingFundingPayments":n=await this._perp.contractReader.getPendingFundingPayments(...o);break;case"liquidationPriceList":n=await this._perp.contractReader.getLiquidationPriceList(...o);break;case"totalPositionValueList":n=await this._perp.contractReader.getTotalPositionValueList(...o);break;case"totalAbsPositionValue":n=await this._perp.contractReader.getTotalAbsPositionValue(i)}return this._cache.set(e,n),n}async getPositionDataAll(){try{l.logger("getPositionDataAll");const t=this._perp.markets.marketMap,a=this._perp.contracts,o=this._perp.wallet.account,r=new m.MulticallReader({contract:a.multicall2}),s={};Object.entries(t).forEach((([e,t])=>{const i=t.baseAddress,n=t.poolAddress,r=[{contract:a.accountBalance,contractName:P.ContractName.ACCOUNT_BALANCE,funcName:"getTakerPositionSize",funcParams:[o,i]},{contract:a.accountBalance,contractName:P.ContractName.ACCOUNT_BALANCE,funcName:"getTakerOpenNotional",funcParams:[o,i]},{contract:a.perpPortal,contractName:P.ContractName.PerpPortal,funcName:"getLiquidationPrice",funcParams:[o,i]},{contract:a.accountBalance,contractName:P.ContractName.ACCOUNT_BALANCE,funcName:"getTotalPositionSize",funcParams:[o,i]},{contract:a.accountBalance,contractName:P.ContractName.ACCOUNT_BALANCE,funcName:"getTotalOpenNotional",funcParams:[o,i]},{contract:a.exchange,contractName:P.ContractName.EXCHANGE,funcName:"getPendingFundingPayment",funcParams:[o,i]},{contract:a.baseToken.attach(i),contractName:P.ContractName.BASE_TOKEN,funcName:"getIndexPrice",funcParams:[0]},{contract:a.pool.attach(n),contractName:P.ContractName.POOL,funcName:"slot0",funcParams:[]}];s[`${e}`]=r}));const c=await r.execute(Object.values(s).flat(),{failFirstByContract:!1,failFirstByClient:!1}),d={};Object.entries(s).forEach((([e,a])=>{const o=c.splice(0,a.length),r=i.bigNumber2BigAndScaleDown(o[0]),s=i.bigNumber2BigAndScaleDown(o[1]),l=i.bigNumber2BigAndScaleDown(o[2]),P=i.bigNumber2BigAndScaleDown(o[3]),m=i.bigNumber2BigAndScaleDown(o[4]),g=i.bigNumber2BigAndScaleDown(o[5]),h=i.bigNumber2BigAndScaleDown(o[6]),p=i.fromSqrtX96(o[7].sqrtPriceX96);let k,b;r.eq(0)||(k=new n.Position({perp:this._perp,type:n.PositionType.TAKER,market:t[`${e}`],side:r.gte(0)?u.PositionSide.LONG:u.PositionSide.SHORT,sizeAbs:r.abs(),openNotionalAbs:s.abs(),entryPrice:s.div(r).abs(),liquidationPrice:l}),b=r.mul(h));const N=P.minus(r),A=m.minus(s);let f,T;N.eq(0)||(f=new n.Position({perp:this._perp,type:n.PositionType.MAKER,market:t[`${e}`],side:N.gte(0)?u.PositionSide.LONG:u.PositionSide.SHORT,sizeAbs:N.abs(),openNotionalAbs:A.abs(),entryPrice:A.div(N).abs()}),T=N.mul(h)),d[`${e}`]={takerPosition:k,takerPositionValue:b,makerPosition:f,makerPositionValue:T,pendingFundingPayment:g,indexPrice:h,markPrice:p}}));const h=[],k={},b={};Object.entries(d).forEach((([e,t])=>{(function(e){return void 0!==e.takerPosition})(t)&&(k[`${e}`]=t),function(e){return void 0!==e.makerPosition}(t)&&(b[`${e}`]=t)})),Object.values(k).forEach((e=>{const t={contract:a.quoter,contractName:P.ContractName.QUOTER,funcName:"swap",funcParams:[{baseToken:e.takerPosition.market.baseAddress,isBaseToQuote:e.takerPosition.isBaseToQuote,isExactInput:e.takerPosition.isExactInput,amount:i.big2BigNumberAndScaleUp(e.takerPosition.sizeAbs),sqrtPriceLimitX96:0}]};h.push(t)})),Object.values(b).forEach((e=>{const t={contract:a.quoter,contractName:P.ContractName.QUOTER,funcName:"swap",funcParams:[{baseToken:e.makerPosition.market.baseAddress,isBaseToQuote:e.makerPosition.isBaseToQuote,isExactInput:e.makerPosition.isExactInput,amount:i.big2BigNumberAndScaleUp(e.makerPosition.sizeAbs),sqrtPriceLimitX96:0}]};h.push(t)})),h.push({contract:a.accountBalance,contractName:P.ContractName.ACCOUNT_BALANCE,funcName:"getTotalAbsPositionValue",funcParams:[o]}),h.push({contract:a.vault,contractName:P.ContractName.VAULT,funcName:"getAccountValue",funcParams:[o]});const N=await r.execute(h),A=N.splice(0,Object.keys(k).length),f=N.splice(0,Object.keys(b).length),T=i.bigNumber2BigAndScaleDown(N.shift()),w=i.bigNumber2BigAndScaleDown(N.shift(),e.SETTLEMENT_TOKEN_DECIMAL),_=T.eq(0)?void 0:w.div(T),E=_?p.default(1).div(_):void 0,O=Object.values(k).reduce(((e,t)=>e.add(t.takerPositionValue)),p.default(0)),S=Object.values(b).reduce(((e,t)=>e.add(t.makerPositionValue)),p.default(0));let y=p.default(0);Object.values(k).forEach(((e,t)=>{const{deltaAvailableQuote:a,exchangedPositionSize:o,exchangedPositionNotional:n}=A[t],r=e.takerPosition.side===u.PositionSide.LONG,s=i.bigNumber2BigAndScaleDown(a),c=i.bigNumber2BigAndScaleDown(n),l=i.bigNumber2BigAndScaleDown(o),d=g.getUnrealizedPnl({isLong:r,deltaAvailableQuote:s,openNotionalAbs:e.takerPosition.openNotionalAbs}),P=g.getSwapRate({amountBase:l,amountQuote:c}),m=g.getPriceImpact({price:P,markPrice:e.markPrice}),h=this._perp.clearingHouseConfig.marketExchangeFeeRatios[e.takerPosition.market.baseAddress],p=g.getTransactionFee({isBaseToQuote:e.takerPosition.isBaseToQuote,exchangedPositionNotional:c,deltaAvailableQuote:s,feeRatio:h});e.takerPosUnrealizedPnl=d,e.takerPosExitPrice=P,e.takerPosExitPriceImpact=m,e.takerPosExitTxFee=p,y=y.add(d)}));let v=p.default(0);Object.values(b).forEach(((e,t)=>{const{deltaAvailableQuote:a,exchangedPositionSize:o,exchangedPositionNotional:n}=f[t],r=e.makerPosition.side===u.PositionSide.LONG,s=i.bigNumber2BigAndScaleDown(a),c=i.bigNumber2BigAndScaleDown(n),l=i.bigNumber2BigAndScaleDown(o),d=g.getUnrealizedPnl({isLong:r,deltaAvailableQuote:s,openNotionalAbs:e.makerPosition.openNotionalAbs}),P=g.getSwapRate({amountBase:l,amountQuote:c}),m=g.getPriceImpact({price:P,markPrice:e.markPrice}),h=this._perp.clearingHouseConfig.marketExchangeFeeRatios[e.makerPosition.market.baseAddress],p=g.getTransactionFee({isBaseToQuote:e.makerPosition.isBaseToQuote,exchangedPositionNotional:c,deltaAvailableQuote:s,feeRatio:h});e.makerPosUnrealizedPnl=d,e.makerPosExitPrice=P,e.makerPosExitPriceImpact=m,e.makerPosExitTxFee=p,v=v.add(d)}));const B={totalTakerPositionValue:O,totalMakerPositionValue:S,totalTakerUnrealizedPnl:y,totalMakerUnrealizedPnl:v,totalUnrealizedPnl:y.add(v),accountPosValueAbs:T,accountMarginRatio:_,accountLeverage:E};this.emit("updated",{positionDataAllByMarket:d,positionDataAllCrossMarket:B})}catch(e){this.emit("updateError",{error:e})}}}exports.Positions=k;
//# sourceMappingURL=Positions.js.map
