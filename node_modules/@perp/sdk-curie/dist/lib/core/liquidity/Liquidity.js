"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),require("../../constants/envVariables.js");var e=require("../../constants/numbers.js"),t=require("../../internal/ChannelEventSource.js"),i=require("../../utils/formatters.js"),r=require("./LiquidityBase.js"),s=require("../position/Position.js");require("big.js"),require("../../utils/tick.js");var a=require("../position/types.js"),c=require("../../errors/errors.js");require("ethers"),require("../../contracts/Contracts.js");class n extends r.LiquidityBase{constructor({perp:e,id:t,liquidity:i,lowerTick:r,upperTick:s,baseDebt:a,quoteDebt:c,...n},u){super(n,u),this._cache=new Map,this._perp=e,this.id=t,this.liquidity=i,this._lowerTick=r,this._upperTick=s,this._baseDebt=a,this._quoteDebt=c}get baseDebt(){return this._baseDebt}get quoteDebt(){return this._quoteDebt}_getEventSourceMap(){return{...super._getEventSourceMap(),updated:new t.ChannelEventSource({eventSourceStarter:()=>this.market.on("updated",this._handleMarketUpdate.bind(this))})}}async _handleMarketUpdate(){try{await this._fetch("liquidityPendingFee",{cache:!1}),this.emit("updated",this)}catch(e){this.emit("updateError",e)}}async getPendingFee({cache:e=!0}={}){return this._fetch("liquidityPendingFee",{cache:e})}async getLiquidityAmounts({cache:e=!0}={}){const[{markPrice:t},i]=await Promise.all([this.market.getPrices({cache:e}),this.getRangeType({cache:e})]),{amountQuote:r,amountBase:s}=n.getLiquidityAmounts({markPrice:t,lowerTickPrice:this.lowerTickPrice,upperTickPrice:this.upperTickPrice,liquidity:this.liquidity,rangeType:i});return{amountQuote:r,amountBase:s}}async getMakerPositionImpermanent({cache:e=!0}={}){const[{markPrice:t},i]=await Promise.all([this.market.getPrices({cache:e}),this.getRangeType({cache:e})]),{amountQuote:r,amountBase:s}=n.getLiquidityAmounts({markPrice:t,lowerTickPrice:this.lowerTickPrice,upperTickPrice:this.upperTickPrice,liquidity:this.liquidity,rangeType:i});return await this._getMakerPositionImpermanent(s,r)}async getLiquidityValue({cache:e=!0}={}){const[{markPrice:t},i]=await Promise.all([this.market.getPrices({cache:e}),this.getRangeType({cache:e})]),{amountBase:r,amountQuote:s}=n.getLiquidityAmounts({markPrice:t,lowerTickPrice:this.lowerTickPrice,upperTickPrice:this.upperTickPrice,liquidity:this.liquidity,rangeType:i});return r.mul(t).add(s)}async _getMakerPositionImpermanent(e,t){const i=e.sub(this.baseDebt),r=t.sub(this.quoteDebt);let c;return i.eq(0)||(c=new s.Position({perp:this._perp,type:s.PositionType.MAKER,market:this.market,side:i.gt(0)?a.PositionSide.LONG:a.PositionSide.SHORT,sizeAbs:i.abs(),openNotionalAbs:r.abs(),entryPrice:r.div(i).abs()})),c}static getLiquidityAmounts({markPrice:t,lowerTickPrice:s,upperTickPrice:a,liquidity:u,rangeType:o}){const h=i.toSqrtX96(t),d=i.toSqrtX96(a),p=i.toSqrtX96(s);let l,m;switch(o){case r.RangeType.RANGE_AT_LEFT:l=n.getQuoteTokenAmountFromLiquidity(d,p,u),m=e.BIG_ZERO;break;case r.RangeType.RANGE_AT_RIGHT:m=n.getBaseTokenAmountFromLiquidity(d,p,u),l=e.BIG_ZERO;break;case r.RangeType.RANGE_INSIDE:l=n.getQuoteTokenAmountFromLiquidity(h,p,u),m=n.getBaseTokenAmountFromLiquidity(h,d,u);break;default:throw new c.FailedPreconditionError({functionName:"getLiquidityAmounts",stateName:"rangeType",stateValue:o})}return{amountQuote:i.scaleDownDecimals(l,e.ERC20_DECIMAL_DIGITS),amountBase:i.scaleDownDecimals(m,e.ERC20_DECIMAL_DIGITS)}}async _fetch(e,{cache:t=!0}={}){if(this._cache.has(e)&&t)return this._cache.get(e);let i;if("liquidityPendingFee"===e)i=await this._perp.contractReader.getLiquidityPendingFee({trader:this._perp.wallet.account,baseTokenAddress:this.market.baseAddress,lowerTick:this._lowerTick,upperTick:this._upperTick});return this._cache.set(e,i),i}static same(e,t){return e.id===t.id&&e.liquidity.eq(t.liquidity)&&e.baseDebt.eq(t.baseDebt)&&e.quoteDebt.eq(t.quoteDebt)}}exports.Liquidity=n;
//# sourceMappingURL=Liquidity.js.map
