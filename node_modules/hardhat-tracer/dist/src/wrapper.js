"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.wrapEthersProvider = exports.wrapHardhatProvider = void 0;
const ethers_1 = require("ethers");
const backwards_compatibility_1 = require("hardhat/internal/core/providers/backwards-compatibility");
const wrapper_1 = require("hardhat/internal/core/providers/wrapper");
const print_1 = require("./print");
const utils_1 = require("./utils");
/**
 * Wrapped provider which extends requests
 */
class TracerWrapper extends wrapper_1.ProviderWrapper {
    constructor(dependencies) {
        super(dependencies.provider);
        this.txPrinted = {};
        this.dependencies = dependencies;
    }
    async request(args) {
        var _a;
        let result;
        let error;
        try {
            result = await this.dependencies.provider.send(args.method, args.params);
        }
        catch (_error) {
            error = _error;
        }
        if (this.dependencies.tracerEnv.enabled &&
            (result != null || error != null) &&
            (args.method === "eth_sendTransaction" ||
                args.method === "eth_sendRawTransaction" ||
                args.method === "eth_getTransactionReceipt")) {
            let hash = result !== null && result !== void 0 ? result : error === null || error === void 0 ? void 0 : error.transactionHash;
            let receipt;
            if (typeof result === "object" && result !== null) {
                hash = (_a = result.transactionHash) !== null && _a !== void 0 ? _a : result.hash;
                receipt = result;
            }
            else {
                receipt = await this.dependencies.provider.send("eth_getTransactionReceipt", [hash]);
            }
            if (!this.txPrinted[hash] && receipt !== null) {
                this.txPrinted[hash] = true;
                const dependenciesExtended = Object.assign(Object.assign({}, this.dependencies), { nameTags: Object.assign({}, this.dependencies.tracerEnv.nameTags) });
                try {
                    await (0, print_1.printDebugTraceOrLogs)(hash, dependenciesExtended);
                }
                catch (error) {
                    console.log("error in request wrapper:", error);
                }
            }
        }
        if (error) {
            throw error;
        }
        return result;
    }
}
/**
 * Add hardhat-tracer to your environment
 * @param hre: HardhatRuntimeEnvironment - required to get access to contract artifacts and tracer env
 */
function wrapHardhatProvider(hre) {
    var _a;
    const tracerProvider = new TracerWrapper({
        artifacts: hre.artifacts,
        tracerEnv: hre.tracer,
        provider: hre.network.provider,
    });
    const compatibleProvider = new backwards_compatibility_1.BackwardsCompatibilityProviderAdapter(tracerProvider);
    hre.network.provider = compatibleProvider;
    // ensure env is present
    hre.tracer = (_a = hre.tracer) !== null && _a !== void 0 ? _a : (0, utils_1.getTracerEnvFromUserInput)(hre.tracer);
}
exports.wrapHardhatProvider = wrapHardhatProvider;
/**
 * Wrap hardhat-tracer over an ethers provider
 * @param provider an ethers provider to attach hardhat-tracer logic
 * @param artifacts hre.artifacts
 * @param tracerEnv hre.tracer
 * @returns
 */
function wrapEthersProvider(provider, artifacts, tracerEnv) {
    // ensure env is present
    tracerEnv = (0, utils_1.getTracerEnvFromUserInput)(tracerEnv);
    const tracerProvider = new TracerWrapper({ provider, artifacts, tracerEnv });
    const compatibleProvider = new backwards_compatibility_1.BackwardsCompatibilityProviderAdapter(tracerProvider);
    return new ethers_1.ethers.providers.Web3Provider(compatibleProvider);
}
exports.wrapEthersProvider = wrapEthersProvider;
//# sourceMappingURL=wrapper.js.map