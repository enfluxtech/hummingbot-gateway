import { Channel, ChannelEventSource, ChannelRegistry } from "../../internal";
import Big from "big.js";
import { GetQuoterSwapReturn } from "../contractReader";
import { Market } from "../market";
import type { PerpetualProtocol } from "../PerpetualProtocol";
import { PositionSide } from "./types";
declare type PositionEventName = "updated" | "updateError";
export declare enum PositionType {
    TAKER = "TAKER",
    MAKER = "MAKER"
}
interface PositionConstructorData {
    perp: PerpetualProtocol;
    type: PositionType;
    market: Market;
    side: PositionSide;
    sizeAbs: Big;
    openNotionalAbs: Big;
    entryPrice: Big;
    liquidationPrice?: Big;
}
export interface PositionDataDerived {
    markPrice: Big;
    indexPrice: Big;
    indexTwapPrice: Big;
    unrealizedPnl: Big;
    positionNotional: Big;
    positionNotionalTwap: Big;
    exitPrice: Big;
    priceImpact: Big;
    transactionFee: Big;
    liquidationPrice?: Big;
}
export declare class Position extends Channel<PositionEventName> {
    readonly market: Market;
    private _cache;
    readonly side: PositionSide;
    readonly sizeAbs: Big;
    readonly openNotionalAbs: Big;
    readonly entryPrice: Big;
    readonly liquidationPrice?: Big;
    readonly type: PositionType;
    private readonly _perp;
    constructor({ perp, market, side, sizeAbs, openNotionalAbs, entryPrice, liquidationPrice, type }: PositionConstructorData, _channelRegistry?: ChannelRegistry);
    get sizeOriginal(): Big;
    get openNotionalOriginal(): Big;
    /**
     * When closing position, is trader selling BASE token in exchange for QUOTE token?
     */
    get isBaseToQuote(): boolean;
    /**
     * When closing position, is BASE token being SOLD? (Since position size is always measured by BASE)
     * NOTE: see truth table, https://docs.google.com/spreadsheets/d/1gVLSYVj98e0p2HaxQ7NdHCejd6S25sr9jgXlnzE1jqE/edit#gid=2106034965
     */
    get isExactInput(): boolean;
    getSwap({ cache }?: {
        cache?: boolean | undefined;
    }): Promise<GetQuoterSwapReturn>;
    getExitPrice({ cache }?: {
        cache?: boolean | undefined;
    }): Promise<Big>;
    getPriceImpact({ cache }?: {
        cache?: boolean | undefined;
    }): Promise<Big>;
    getUnrealizedPnl({ cache }?: {
        cache?: boolean | undefined;
    }): Promise<Big>;
    getTransactionFee({ cache }?: {
        cache?: boolean | undefined;
    }): Promise<Big>;
    private _handleMarketUpdate;
    protected _getEventSourceMap(): {
        updated: ChannelEventSource<PositionEventName>;
    };
    /**
     * Calculate the upper/lower bound for slippage protection.
     * Formula: https://www.notion.so/perp/V2-Formula-for-opening-position-e8f7e481cf144b75977217114cecbdb9#3802018734c2426aa59d9426fe98b097
     **/
    getOppositeAmountBound(slippage: Big): Promise<Big>;
    static same(positionA: Position, positionB: Position): boolean;
    private _fetch;
}
export {};
