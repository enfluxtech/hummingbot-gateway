import{errors as t,constants as e}from"ethers";import"../../constants/envVariables.js";import{SETTLEMENT_TOKEN_DECIMAL as a,COLLATERAL_TOKEN_DECIMAL as n,RATIO_DECIMAL as r}from"../../constants/numbers.js";import{ContractName as c}from"../../contracts/Contracts.js";import{ContractReadError as o,ContractErrorCode as s,InsufficientLiquidityError as i,NotEnoughFreeCollateralError as u,UniswapBrokerInsufficientLiquidityError as l,OverPriceLimitAfterSwapError as g,MarketNumberExceedsError as m}from"../../errors/errors.js";import{extractContractErrorCode as d}from"../../errors/extractErrorCode.js";import N from"big.js";import{errorGuardAsync as T}from"../../utils/errorChecker.js";import{bigNumber2BigAndScaleDown as A,scaleDownDecimals as w,big2BigNumberAndScaleUp as p,fromSqrtX96 as E}from"../../utils/formatters.js";import"../../utils/tick.js";import{logger as k}from"../../utils/logger.js";import{MulticallReader as y}from"./MulticallReader.js";import{contractCallsParserForErrorHandling as P,genKeyFromContractAndFuncName as O}from"./utils.js";class C{constructor({contracts:t,provider:e,metadata:a}){this.contracts=t,this._provider=e,this._metadata=a,this._multicallReader=new y({contract:t.multicall2})}async getNativeBalance(t){return T((async()=>{k("getNativeBalance");const e=await this._provider.getBalance(t);return A(e)}),(e=>new o({contractName:"ethers",contractFunctionName:"getNativeBalance",args:{account:t},rawError:e})))}async getAccountValue(t){return T((async()=>{k("getAccountValue");const e=await this.contracts.vault.getAccountValue(t);return A(e,a)}),(e=>new o({contractName:c.VAULT,contractFunctionName:"getAccountValue",args:{account:t},rawError:e})))}async getFreeCollateral(t){return T((async()=>{k("getFreeCollateral");const e=await this.contracts.vault.getFreeCollateral(t);return A(e,n)}),(e=>new o({contractName:c.VAULT,contractFunctionName:"getFreeCollateral",args:{account:t},rawError:e})))}async getFreeCollateralByToken(t,e){return T((async()=>{k("getFreeCollateralByToken::token::decimals"),k("getFreeCollateralByToken::vault::GetFreeCollateralByToken");const a=e.address,n=await e.decimals(),r=await this.contracts.vault.getFreeCollateralByToken(t,a);return A(r,n)}),(a=>new o({contractName:c.VAULT,contractFunctionName:"getFreeCollateralByToken",args:{account:t,tokenAddress:e.address},rawError:a})))}async getVaultBalanceOfSettlementToken(t){return T((async()=>{k("getVaultBalanceOfSettlementToken");const e=await this.contracts.vault.getSettlementTokenValue(t);return A(e,a)}),(e=>new o({contractName:c.VAULT,contractFunctionName:"getSettlementTokenValue",args:{account:t},rawError:e})))}async getVaultBalanceByToken(t,e){return T((async()=>{k("getVaultBalanceByToken::token::decimals"),k("getVaultBalanceByToken::vault::GetBalanceByToken");const a=e.address,n=await e.decimals(),r=await this.contracts.vault.getBalanceByToken(t,a);return A(r,n)}),(a=>new o({contractName:c.VAULT,contractFunctionName:"getBalanceByToken",args:{account:t,tokenAddress:e.address},rawError:a})))}async getCollateralConfig(t){return T((async()=>{k("getCollateralConfig::collateralManager::getCollateralConfig"),k("getCollateralConfig::collateralToken::decimals");const e=this.contracts.collateralManager,a=await e.getCollateralConfig(t),n=a.priceFeed,c=a.collateralRatio,o=a.discountRatio,s=a.depositCap,i=this.contracts.collateralTokenMap.get(t),u=await(null==i?void 0:i.contract.decimals());return{priceFeed:n,collateralRatio:w(N(c),r).toNumber(),discountRatio:w(N(o),r).toNumber(),depositCap:A(s,u)}}),(e=>new o({contractName:c.COLLATERAL_MANAGER,contractFunctionName:"getCollateralConfig",args:{tokenAddress:t},rawError:e})))}async getAllowanceByToken(t,e,a){return T((async()=>{var n;k("getAllowanceByToken:token::allowance"),k("getAllowanceByToken:token::decimals");const r=null===(n=this.contracts.collateralTokenMap.get(a))||void 0===n?void 0:n.contract;if(!r)throw new Error(`Collateral token ${a} not found`);const[c,o]=await Promise.all([r.allowance(t,e),r.decimals()]);return A(c,o)}),(n=>new o({contractName:c.COLLATERAL_TOKENS,contractFunctionName:"allowance",args:{account:t,spender:e,tokenAddress:a},rawError:n})))}async getAllowanceOfSettlementToken(t,e){return T((async()=>{k("getAllowanceOfSettlementToken");const n=this.contracts.settlementToken,r=await n.allowance(t,e);return A(r,a)}),(a=>new o({contractName:c.SETTLEMENT_TOKEN,contractFunctionName:"allowance",args:{account:t,spender:e},rawError:a})))}async getBalanceByToken(t,e,a){return T((async()=>{var n;k("getBalanceByToken");const r=null===(n=this.contracts.collateralTokenMap.get(e))||void 0===n?void 0:n.contract;if(!r)throw new Error(`Collateral token ${e} not found`);const c=await r.balanceOf(t);return A(c,a)}),(n=>new o({contractName:c.COLLATERAL_TOKENS,contractFunctionName:"balanceOf",args:{account:t,tokenAddress:e,decimals:a},rawError:n})))}async getBalanceOfSettlementToken(t){return T((async()=>{k("getBalanceOfSettlementToken");const e=this.contracts.settlementToken,n=await e.balanceOf(t);return A(n,a)}),(e=>new o({contractName:c.SETTLEMENT_TOKEN,contractFunctionName:"balanceOf",args:{account:t},rawError:e})))}async getPriceFeedAggregator(t){return T((async()=>{k("getPriceFeedAggregator::contractBaseToken::getPriceFeed"),k("getPriceFeedAggregator::contractPriceFeed::getAggregator");const e=this.contracts.baseToken.attach(t),a=await e.getPriceFeed(),n=this.contracts.baseTokenPriceFeed.attach(a);return T((async()=>{const t=await n.getAggregator();return{address:t,contract:this.contracts.baseTokenPriceFeedAggregator.attach(t)}}),(e=>new o({contractName:c.CHAINLINK_PRICE_FEED,contractFunctionName:"getAggregator",context:{baseTokenAddress:t},rawError:e})))}),(e=>new o({contractName:c.BASE_TOKEN,contractFunctionName:"getPriceFeed",context:{baseTokenAddress:t},rawError:e})))}async isMarketPaused(t){return T((async()=>{k("isMarketPaused");const e=this.contracts.baseToken.attach(t);return await e.isPaused()}),(e=>new o({contractName:c.BASE_TOKEN,contractFunctionName:"isPaused",context:{baseTokenAddress:t},rawError:e})))}async isMarketClosed(t){return T((async()=>{k("isMarketClosed");const e=this.contracts.baseToken.attach(t);return await e.isClosed()}),(e=>new o({contractName:c.BASE_TOKEN,contractFunctionName:"isClosed",context:{baseTokenAddress:t},rawError:e})))}async getMarketStatus(t){const e=[{contract:this.contracts.baseToken.attach(t),contractName:c.BASE_TOKEN,funcName:"isPaused",funcParams:[]},{contract:this.contracts.baseToken.attach(t),contractName:c.BASE_TOKEN,funcName:"isClosed",funcParams:[]}];return T((async()=>{k("getMarketStatus");const[t,a]=await this._multicallReader.execute(e);return{isPaused:t,isClosed:a}}),(t=>new o({contractName:c.MULTICALL2,contractFunctionName:"tryAggregate",args:P(e),rawError:t})))}async getClosedPrice(t){return T((async()=>{k("getClosedPrice");const e=this.contracts.baseToken.attach(t),a=await e.getClosedPrice();return A(a)}),(e=>new o({contractName:c.BASE_TOKEN,contractFunctionName:"getClosedPrice",context:{baseTokenAddress:t},rawError:e})))}async getIndexPrice(t,e=0){return T((async()=>{k("getIndexPrice");const a=this.contracts.baseToken.attach(t),n=await a.getIndexPrice(e);return A(n)}),(a=>new o({contractName:c.BASE_TOKEN,contractFunctionName:"getIndexPrice",args:{interval:e},context:{baseTokenAddress:t},rawError:a})))}async getSlot0(t){return T((async()=>(k("getSlot0"),await this.contracts.pool.attach(t).slot0())),(t=>new o({contractName:c.POOL,contractFunctionName:"slot0",rawError:t})))}async getQuoterSwap({baseTokenAddress:e,isBaseToQuote:a,isExactInput:n,amount:r}){return T((async()=>{k("getQuoterSwap");const{deltaAvailableBase:t,deltaAvailableQuote:c,exchangedPositionNotional:o,exchangedPositionSize:s}=await this.contracts.quoter.callStatic.swap({baseToken:e,isBaseToQuote:a,isExactInput:n,amount:p(r),sqrtPriceLimitX96:0}),i=A(t),u=A(c);return{deltaAvailableBase:i,deltaAvailableQuote:u,exchangedPositionNotional:A(o),exchangedPositionSize:A(s),output:a===n?u:i}}),(u=>{const l={contractName:c.QUOTER,contractFunctionName:"swap",args:{baseToken:e,isBaseToQuote:a,isExactInput:n,amount:p(r),sqrtPriceLimitX96:0},rawError:u};return u.code===t.CALL_EXCEPTION&&u.reason===s.QUOTER_INSUFFICIENT_LIQUIDITY?new i(l):new o(l)}))}async getLiquidityPendingFee({trader:t,baseTokenAddress:e,lowerTick:a,upperTick:n}){return T((async()=>{k("getLiquidityPendingFee");const r=await this.contracts.orderBook.getPendingFee(t,e,a,n);return A(r)}),(r=>new o({contractName:c.ORDERBOOK,contractFunctionName:"getPendingFee",args:{trader:t,baseTokenAddress:e,lowerTick:a,upperTick:n},rawError:r})))}async getOpenLiquidityIdsByMarket({trader:t,baseTokenAddress:e}){return T((async()=>(k("getOpenLiquidityIdsByMarket"),this.contracts.orderBook.getOpenOrderIds(t,e))),(a=>new o({contractName:c.ORDERBOOK,contractFunctionName:"getOpenOrderIds",args:{trader:t,baseTokenAddress:e},rawError:a})))}async getOpenLiquidityIds(t,e){const a=Object.values(t).map((({baseAddress:t})=>({contract:this.contracts.orderBook,contractName:c.ORDERBOOK,funcName:"getOpenOrderIds",funcParams:[e,t]})));return T((async()=>{k("getOpenLiquidityIds");return await this._multicallReader.execute([...a])}),(t=>new o({contractName:c.MULTICALL2,contractFunctionName:"tryAggregate",args:P(a),rawError:t})))}async getOpenLiquidities(t,e){const a=await this.getOpenLiquidityIds(t,e),n=[];return Object.values(t).forEach((({baseAddress:t},e)=>{n.push(...a[e].map((t=>({contract:this.contracts.orderBook,contractName:c.ORDERBOOK,funcName:"getOpenOrderById",funcParams:[t]}))))})),T((async()=>{k("getOpenLiquidities");const t=await this._multicallReader.execute([...n]);let e=0;return a.map(((n,r)=>{const c=a[r].length,o=t.slice(e,e+c);return e+=c,o.map((({baseDebt:t,quoteDebt:e,liquidity:a,lowerTick:n,upperTick:r})=>({baseDebt:A(t),quoteDebt:A(e),liquidity:new N(a),lowerTick:n,upperTick:r})))}))}),(t=>new o({contractName:c.MULTICALL2,contractFunctionName:"tryAggregate",args:P(n),rawError:t})))}async getOpenLiquiditiesByMarket({trader:t,baseTokenAddress:e}){const a=(await this.getOpenLiquidityIdsByMarket({trader:t,baseTokenAddress:e})).map((t=>({contract:this.contracts.orderBook,contractName:c.ORDERBOOK,funcName:"getOpenOrderById",funcParams:[t]})));return T((async()=>{k("getOpenLiquiditiesByMarket");return(await this._multicallReader.execute(a)).map((({baseDebt:t,quoteDebt:e,liquidity:a,lowerTick:n,upperTick:r})=>({baseDebt:A(t),quoteDebt:A(e),liquidity:A(a),lowerTick:n,upperTick:r})))}),(t=>new o({contractName:c.MULTICALL2,contractFunctionName:"tryAggregate",args:P(a),rawError:t})))}async getOpenOrder({trader:t,baseTokenAddress:e,lowerTick:a,upperTick:n}){return T((async()=>{k("getOpenOrder");const r=await this.contracts.orderBook.getOpenOrder(t,e,a,n);return{baseDebt:A(r.baseDebt),quoteDebt:A(r.quoteDebt),liquidity:A(r.liquidity),lowerTick:r.lowerTick,upperTick:r.upperTick}}),(r=>new o({contractName:c.ORDERBOOK,contractFunctionName:"getOpenOrder",args:{trader:t,baseTokenAddress:e,lowerTick:a,upperTick:n},rawError:r})))}async getTotalTokenAmountInPoolAndPendingFeeOfAllMarkets(t,e){const a=Object.values(t).map((({baseAddress:t})=>({contract:this.contracts.orderBook,contractName:c.ORDERBOOK,funcName:"getTotalTokenAmountInPoolAndPendingFee",funcParams:[e,t,!1]})));return T((async()=>{k("getTotalTokenAmountInPoolAndPendingFeeOfAllMarkets");const e=await this._multicallReader.execute([...a]);return Object.values(t).reduce(((t,a,n)=>{const[r,c]=e[n];return{...t,[a.baseAddress]:{totalTokenAmount:A(r),totalPendingFee:A(c)}}}),{})}),(t=>new o({contractName:c.MULTICALL2,contractFunctionName:"tryAggregate",args:P(a),rawError:t})))}async simulateOpenPosition({baseTokenAddress:t,isBaseToQuote:a,isExactInput:n,amount:r,oppositeAmountBound:i}){const N={baseToken:t,isBaseToQuote:a,isExactInput:n,amount:p(r),oppositeAmountBound:p(i),sqrtPriceLimitX96:0,deadline:e.MaxUint256,referralCode:e.HashZero};return T((async()=>{k("simulateOpenPosition");const{base:t,quote:e}=await this.contracts.clearingHouse.callStatic.openPosition(N);return{deltaBase:A(t),deltaQuote:A(e)}}),(t=>{const e={contractName:c.CLEARINGHOUSE,contractFunctionName:"openPosition",args:N,rawError:t},a=d(t);return a===s.NOT_ENOUGH_FREE_COLLATERAL?new u({...e,contractErrorCode:a}):a===s.UNISWAP_BROKER_INSUFFICIENT_LIQUIDITY?new l({...e,contractErrorCode:a}):a===s.OVER_PRICE_LIMIT_AFTER_SWAP?new g({contractName:c.CLEARINGHOUSE,contractFunctionName:"swap",contractErrorCode:a,rawError:t}):a===s.MARKET_NUMBER_EXCEEDS?new m({contractName:c.ACCOUNT_BALANCE,contractFunctionName:"registerBaseToken",contractErrorCode:a,rawError:t}):new o(e)}))}async getMarketsBaseTokenAndQuoteTokenAmount(t){const e=t.map((t=>{const{baseToken:e,pool:a}=t;return{contract:this.contracts.createIERC20Token(e),contractName:c.Token0,funcName:"balanceOf",funcParams:[a]}})),a=t.map((t=>{const{quoteToken:e,pool:a}=t;return{contract:this.contracts.createIERC20Token(e),contractName:c.Token1,funcName:"balanceOf",funcParams:[a]}})),n=[...e,...a];return T((async()=>{k("getMarketsBaseTokenAndQuoteTokenAmount");const r=await this._multicallReader.execute(n,{returnByContractAndFuncName:!0}),c=r[O(a[0])],o=r[O(e[0])];return t.reduce(((t,e,a)=>{const{pool:n}=e;return{...t,[n]:{quoteAmount:A(c[a]).toString(),baseAmount:A(o[a]).toString()}}}),{})}),(t=>new o({contractName:c.MULTICALL2,contractFunctionName:"tryAggregate",args:P(n),rawError:t})))}async getClearingHouseMetadata(){const t={contract:this.contracts.clearingHouseConfig,contractName:c.CLEARINGHOUSE_CONFIG,funcName:"getMmRatio",funcParams:[]},e={contract:this.contracts.clearingHouseConfig,contractName:c.CLEARINGHOUSE_CONFIG,funcName:"getImRatio",funcParams:[]},a={contract:this.contracts.clearingHouseConfig,contractName:c.CLEARINGHOUSE_CONFIG,funcName:"getMaxFundingRate",funcParams:[]},n={contract:this.contracts.clearingHouseConfig,contractName:c.CLEARINGHOUSE_CONFIG,funcName:"getTwapInterval",funcParams:[]},s=this._metadata.pools.map((t=>t.baseAddress)),i=s.map((t=>({contract:this.contracts.marketRegistry,contractName:c.MARKET_REGISTRY,funcName:"getMarketInfo",funcParams:[t]}))),u=this._metadata.pools.map((t=>t.address)),l=u.map((t=>({contract:this.contracts.pool.attach(t),contractName:c.POOL,funcName:"tickSpacing",funcParams:[]}))),g=[t,e,a,n,...i,...l];return T((async()=>{k("getClearingHouseMetadata");const c=await this._multicallReader.execute(g,{returnByContractAndFuncName:!0}),[o]=c[O(t)],[m]=c[O(e)],[d]=c[O(a)],[T]=c[O(n)],A=c[O(i[0])],p=c[O(l[0])],E=s.reduce(((t,e,a)=>(t[e]=w(new N(A[a].exchangeFeeRatio),r),t)),{}),y=s.reduce(((t,e,a)=>(t[e]=w(new N(A[a].insuranceFundFeeRatio),r),t)),{}),P=u.reduce(((t,e,a)=>(t[e]=p[a],t)),{});return{mmRatio:new N(o),imRatio:new N(m),maxFundingRate:new N(d),twapInterval:new N(T),exchangeFeeRatios:E,insuranceFundFeeRatios:y,tickSpacings:P}}),(t=>new o({contractName:c.MULTICALL2,contractFunctionName:"tryAggregate",args:P(g),rawError:t})))}async getTakerPositionSizeList(t,e){const a=Object.values(t).map((({baseAddress:t})=>({contract:this.contracts.accountBalance,contractName:c.ACCOUNT_BALANCE,funcName:"getTakerPositionSize",funcParams:[e,t]})));return T((async()=>{k("getTakerPositionSizeList");return(await this._multicallReader.execute([...a])).map((t=>A(t)))}),(t=>new o({contractName:c.MULTICALL2,contractFunctionName:"tryAggregate",args:P(a),rawError:t})))}async getTotalPositionSizeList(t,e){const a=Object.values(t).map((({baseAddress:t})=>({contract:this.contracts.accountBalance,contractName:c.ACCOUNT_BALANCE,funcName:"getTotalPositionSize",funcParams:[e,t]})));return T((async()=>{k("getTotalPositionSizeList");return(await this._multicallReader.execute([...a])).map((t=>A(t)))}),(t=>new o({contractName:c.MULTICALL2,contractFunctionName:"tryAggregate",args:P(a),rawError:t})))}async getTakerOpenNotionalList(t,e){const a=Object.values(t).map((({baseAddress:t})=>({contract:this.contracts.accountBalance,contractName:c.ACCOUNT_BALANCE,funcName:"getTakerOpenNotional",funcParams:[e,t]})));return T((async()=>{k("getTakerOpenNotionalList");return(await this._multicallReader.execute([...a])).map((t=>A(t)))}),(t=>new o({contractName:c.MULTICALL2,contractFunctionName:"tryAggregate",args:P(a),rawError:t})))}async getTotalOpenNotionalList(t,e){const a=Object.values(t).map((({baseAddress:t})=>({contract:this.contracts.accountBalance,contractName:c.ACCOUNT_BALANCE,funcName:"getTotalOpenNotional",funcParams:[e,t]})));return T((async()=>{k("getTotalOpenNotionalList");return(await this._multicallReader.execute([...a])).map((t=>A(t)))}),(t=>new o({contractName:c.MULTICALL2,contractFunctionName:"tryAggregate",args:P(a),rawError:t})))}async getTotalPositionValueList(t,e){const a=Object.values(t).map((({baseAddress:t})=>({contract:this.contracts.accountBalance,contractName:c.ACCOUNT_BALANCE,funcName:"getTotalPositionValue",funcParams:[e,t]})));return T((async()=>{k("getTotalPositionValueList");return(await this._multicallReader.execute([...a])).map((t=>A(t)))}),(t=>new o({contractName:c.MULTICALL2,contractFunctionName:"tryAggregate",args:P(a),rawError:t})))}async getPendingFundingPayments(t,e){const a=Object.values(t).map((({baseAddress:t})=>({contract:this.contracts.exchange,contractName:c.EXCHANGE,funcName:"getPendingFundingPayment",funcParams:[e,t]})));return T((async()=>{k("getPendingFundingPayments");const e=await this._multicallReader.execute([...a]);return Object.values(t).reduce(((t,a,n)=>({...t,[a.tickerSymbol]:A(e[n])})),{})}),(t=>new o({contractName:c.MULTICALL2,contractFunctionName:"tryAggregate",args:P(a),rawError:t})))}async getMarketData(t){const e=[{contract:this.contracts.pool.attach(t.poolAddress),contractName:c.POOL,funcName:"slot0",funcParams:[]},{contract:this.contracts.baseToken.attach(t.baseAddress),contractName:c.BASE_TOKEN,funcName:"getIndexPrice",funcParams:[0]},{contract:this.contracts.baseToken.attach(t.baseAddress),contractName:c.BASE_TOKEN,funcName:"getIndexPrice",funcParams:[t.twapTimeRange]}];return T((async()=>{k("getMarketData");const t=await this._multicallReader.execute(e),[a,n,r]=t.map(((t,e)=>{if(0===e){const{sqrtPriceX96:e}=t;return E(e)}return A(t)}));return{markPrice:a,indexPrice:n,indexTwapPrice:r}}),(t=>new o({contractName:c.MULTICALL2,contractFunctionName:"tryAggregate",args:P(e),rawError:t})))}async getPositionDraftRelatedData({trader:e,marketBaseAddresses:a,currentMarketBaseSize:n,currentMarketBaseAddress:r}){const u={contract:this.contracts.quoter,contractName:c.QUOTER,funcName:"swap",funcParams:[{baseToken:r,isBaseToQuote:!0,isExactInput:!0,amount:p(n),sqrtPriceLimitX96:0}]},l={contract:this.contracts.accountBalance,contractName:c.ACCOUNT_BALANCE,funcName:"getPnlAndPendingFee",funcParams:[e]},g=a.filter((t=>t!==r)),m=g.map((t=>({contract:this.contracts.accountBalance,contractName:c.ACCOUNT_BALANCE,funcName:"getBase",funcParams:[e,t]}))),d=g.map((t=>({contract:this.contracts.baseToken.attach(t),contractName:c.BASE_TOKEN,funcName:"getIndexPrice",funcParams:[0]}))),N=a.map((t=>({contract:this.contracts.accountBalance,contractName:c.ACCOUNT_BALANCE,funcName:"getQuote",funcParams:[e,t]}))),w=[u,l,...m,...d,...N];return T((async()=>{k("getPositionDraftRelatedData");const t=await this._multicallReader.execute(w,{returnByContractAndFuncName:!0,failFirstByClient:!1,failFirstByContract:!1}),[{deltaAvailableBase:e,deltaAvailableQuote:a,exchangedPositionNotional:n,exchangedPositionSize:r}]=t[O(u)],[[c,o,s]]=t[O(l)],i=t[O(m[0])],g=t[O(d[0])],T=t[O(N[0])],p=e&&A(e),E=a&&A(a);return{swap:{deltaAvailableBase:p,deltaAvailableQuote:E,exchangedPositionNotional:n&&A(n),exchangedPositionSize:r&&A(r),output:E},getPnlAndPendingFee:{owedPNL:A(c),unrealizedPNL:A(o),pendingFee:A(s)},otherBaseDebts:i.map((t=>A(t))),otherMarketIndexPrices:g.map((t=>A(t))),quoteDebts:T.map((t=>A(t)))}}),(e=>{if(e.code===t.CALL_EXCEPTION&&e.reason===s.QUOTER_INSUFFICIENT_LIQUIDITY){const t={contractName:c.QUOTER,contractFunctionName:"swap",args:u.funcParams[0],rawError:e};return new i(t)}return new o({contractName:c.MULTICALL2,contractFunctionName:"tryAggregate",args:P(w),rawError:e})}))}async getAccountValues(t){const e=[{contract:this.contracts.vault,contractName:c.VAULT,funcName:"getFreeCollateral",funcParams:[t]},{contract:this.contracts.clearingHouse,contractName:c.CLEARINGHOUSE,funcName:"getAccountValue",funcParams:[t]}];return T((async()=>{k("getAccountValues");const t=await this._multicallReader.execute(e);return{freeCollateral:A(t[0],n),accountValue:A(t[1])}}),(t=>new o({contractName:c.MULTICALL2,contractFunctionName:"tryAggregate",args:P(e),rawError:t})))}async getTotalPositionValue(t,e){return T((async()=>{k("getTotalPositionValue");const a=await this.contracts.accountBalance.getTotalPositionValue(t,e);return A(a)}),(a=>new o({contractName:c.ACCOUNT_BALANCE,contractFunctionName:"getTotalPositionValue",args:{trader:t,baseToken:e},rawError:a})))}async getTotalAbsPositionValue(t){return T((async()=>{k("getTotalAbsPositionValue");const e=await this.contracts.accountBalance.getTotalAbsPositionValue(t);return A(e)}),(e=>new o({contractName:c.ACCOUNT_BALANCE,contractFunctionName:"getTotalAbsPositionValue",args:{trader:t},rawError:e})))}async getLiquidationPrice(t,e){return T((async()=>{k("getLiquidationPrice");const a=await this.contracts.perpPortal.getLiquidationPrice(t,e);return A(a)}),(a=>new o({contractName:c.PerpPortal,contractFunctionName:"getLiquidationPrice",args:{trader:t,baseToken:e},rawError:a})))}async getLiquidationPriceList(t,e){const a=Object.values(t).map((({baseAddress:t})=>({contract:this.contracts.perpPortal,contractName:c.PerpPortal,funcName:"getLiquidationPrice",funcParams:[e,t]})));return T((async()=>{k("getLiquidationPriceList");return(await this._multicallReader.execute([...a])).map((t=>A(t)))}),(t=>new o({contractName:c.MULTICALL2,contractFunctionName:"tryAggregate",args:P(a),rawError:t})))}async getClearingHouseOpenPositionAction(){return T((async()=>(k("getClearingHouseOpenPositionAction"),await this.contracts.delegateApproval.getClearingHouseOpenPositionAction())),(t=>new o({contractName:c.DelegateApproval,contractFunctionName:"getClearingHouseOpenPositionAction",rawError:t})))}async canOpenPositionFor(t,e){return T((async()=>(k("canOpenPositionFor"),await this.contracts.delegateApproval.canOpenPositionFor(t,e))),(t=>new o({contractName:c.DelegateApproval,contractFunctionName:"canOpenPositionFor",rawError:t})))}}export{C as ContractReader};
//# sourceMappingURL=ContractReader.js.map
