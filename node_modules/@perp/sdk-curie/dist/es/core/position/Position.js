import{Channel as e}from"../../internal/Channel.js";import{ChannelEventSource as t}from"../../internal/ChannelEventSource.js";import"../../constants/envVariables.js";import"../../constants/numbers.js";import i from"big.js";import"ethers";import{getSwapRate as s,getPriceImpact as a,getUnrealizedPnl as n,getTransactionFee as r}from"../clearingHouse/utils.js";import{PositionSide as o}from"./types.js";var c;!function(e){e.TAKER="TAKER",e.MAKER="MAKER"}(c||(c={}));class h extends e{constructor({perp:e,market:t,side:i,sizeAbs:s,openNotionalAbs:a,entryPrice:n,liquidationPrice:r,type:o},c){super(c),this._cache=new Map,this._perp=e,this.market=t,this.side=i,this.sizeAbs=s,this.openNotionalAbs=a,this.entryPrice=n,this.liquidationPrice=r,this.type=o}get sizeOriginal(){return this.sizeAbs.mul(this.side===o.LONG?1:-1)}get openNotionalOriginal(){return this.openNotionalAbs.mul(this.side===o.LONG?-1:1)}get isBaseToQuote(){return this.side===o.LONG}get isExactInput(){return this.side===o.LONG}async getSwap({cache:e=!0}={}){return this._fetch("swap",{cache:e})}async getExitPrice({cache:e=!0}={}){const{exchangedPositionSize:t,exchangedPositionNotional:i}=await this._fetch("swap",{cache:e});return s({amountBase:t,amountQuote:i})}async getPriceImpact({cache:e=!0}={}){const t=await this.getExitPrice({cache:e}),{markPrice:i}=await this.market.getPrices({cache:e});return a({price:t,markPrice:i})}async getUnrealizedPnl({cache:e=!0}={}){const{deltaAvailableQuote:t}=await this._fetch("swap",{cache:e}),i=this.side===o.LONG;return n({isLong:i,deltaAvailableQuote:t,openNotionalAbs:this.openNotionalAbs})}async getTransactionFee({cache:e=!0}={}){const{deltaAvailableQuote:t,exchangedPositionNotional:i}=await this._fetch("swap",{cache:e}),s=this._perp.clearingHouseConfig.marketExchangeFeeRatios[this.market.baseAddress];return r({isBaseToQuote:this.isBaseToQuote,exchangedPositionNotional:i,deltaAvailableQuote:t,feeRatio:s})}async _handleMarketUpdate(){try{await this._fetch("swap",{cache:!1}),this.emit("updated",this)}catch(e){this.emit("updateError",e)}}_getEventSourceMap(){return{updated:new t({eventSourceStarter:()=>this.market.on("updated",this._handleMarketUpdate.bind(this)),initEventEmitter:e=>{"updated"===e&&this.emit("updated",this)}})}}async getOppositeAmountBound(e){const{output:t}=await this._fetch("swap",{cache:!1});let s;return this.isExactInput?s=t.mul(new i(1).sub(e)):(s=t.mul(new i(1).add(e)),e.eq(0)&&!this.isBaseToQuote&&(s=s.add(new i(1).mul(1e-18)))),s}static same(e,t){return e.market.tickerSymbol===t.market.tickerSymbol&&e.side===t.side&&e.sizeAbs.eq(t.sizeAbs)}async _fetch(e,{cache:t=!0}={}){if(this._cache.has(e)&&t)return this._cache.get(e);let i;if("swap"===e)i=await this._perp.contractReader.getQuoterSwap({baseTokenAddress:this.market.baseAddress,amount:this.sizeAbs,isBaseToQuote:this.isBaseToQuote,isExactInput:this.isExactInput});return this._cache.set(e,i),i}}export{h as Position,c as PositionType};
//# sourceMappingURL=Position.js.map
