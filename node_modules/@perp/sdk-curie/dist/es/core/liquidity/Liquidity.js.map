{"version":3,"file":"Liquidity.js","sources":["../../../../src/core/liquidity/Liquidity.ts"],"sourcesContent":["import { BIG_ZERO, ERC20_DECIMAL_DIGITS } from \"../../constants\"\nimport { ChannelEventSource, ChannelRegistry } from \"../../internal\"\nimport { LiquidityBase, LiquidityBaseConstructorData, RangeType } from \"./LiquidityBase\"\nimport { Position, PositionSide, PositionType } from \"../position\"\nimport { scaleDownDecimals, toSqrtX96 } from \"../../utils\"\n\nimport Big from \"big.js\"\nimport { FailedPreconditionError } from \"../../errors\"\nimport { PerpetualProtocolConnected } from \"../PerpetualProtocol\"\n\ntype LiquidityEventName = \"updated\" | \"updateError\"\n\ntype CacheKey = \"liquidityPendingFee\"\ntype CacheValue = Big\n\nexport interface EventPayloadLiquidityFeeUpdated {\n    fee: Big\n}\n\nexport interface EventPayloadLiquidityAmountsUpdated {\n    amountQuote: Big\n    amountBase: Big\n    makerPositionImpermanent: Position\n}\n\nexport interface LiquidityConstructorData extends LiquidityBaseConstructorData {\n    perp: PerpetualProtocolConnected\n    id: string\n    liquidity: Big\n    lowerTick: number\n    upperTick: number\n    baseDebt: Big\n    quoteDebt: Big\n}\n\nexport class Liquidity extends LiquidityBase<LiquidityEventName> {\n    private _cache: Map<CacheKey, CacheValue> = new Map()\n    readonly _perp: PerpetualProtocolConnected\n    readonly id: string\n    readonly liquidity: Big\n\n    protected _lowerTick: number\n    protected _upperTick: number\n\n    private _baseDebt: Big\n    private _quoteDebt: Big\n\n    constructor(\n        { perp, id, liquidity, lowerTick, upperTick, baseDebt, quoteDebt, ...data }: LiquidityConstructorData,\n        _channelRegistry?: ChannelRegistry,\n    ) {\n        super(data, _channelRegistry)\n        this._perp = perp\n        this.id = id\n        this.liquidity = liquidity\n        this._lowerTick = lowerTick\n        this._upperTick = upperTick\n        this._baseDebt = baseDebt\n        this._quoteDebt = quoteDebt\n    }\n\n    get baseDebt() {\n        return this._baseDebt\n    }\n\n    get quoteDebt() {\n        return this._quoteDebt\n    }\n\n    protected _getEventSourceMap() {\n        const eventSourceMap = super._getEventSourceMap()\n        const updateDataEventSource = new ChannelEventSource<LiquidityEventName>({\n            eventSourceStarter: () => {\n                return this.market.on(\"updated\", this._handleMarketUpdate.bind(this))\n            },\n        })\n\n        return {\n            ...eventSourceMap,\n            updated: updateDataEventSource,\n        }\n    }\n\n    protected async _handleMarketUpdate() {\n        try {\n            await this._fetch(\"liquidityPendingFee\", { cache: false })\n            this.emit(\"updated\", this)\n        } catch (error) {\n            this.emit(\"updateError\", error)\n        }\n    }\n\n    async getPendingFee({ cache = true } = {}) {\n        return this._fetch(\"liquidityPendingFee\", { cache })\n    }\n\n    async getLiquidityAmounts({ cache = true } = {}) {\n        const [{ markPrice }, rangeType] = await Promise.all([\n            this.market.getPrices({ cache }),\n            this.getRangeType({ cache }),\n        ])\n\n        const { amountQuote, amountBase } = Liquidity.getLiquidityAmounts({\n            markPrice,\n            lowerTickPrice: this.lowerTickPrice,\n            upperTickPrice: this.upperTickPrice,\n            liquidity: this.liquidity,\n            rangeType,\n        })\n\n        return {\n            amountQuote,\n            amountBase,\n        }\n    }\n\n    async getMakerPositionImpermanent({ cache = true } = {}) {\n        const [{ markPrice }, rangeType] = await Promise.all([\n            this.market.getPrices({ cache }),\n            this.getRangeType({ cache }),\n        ])\n        const { amountQuote, amountBase } = Liquidity.getLiquidityAmounts({\n            markPrice,\n            lowerTickPrice: this.lowerTickPrice,\n            upperTickPrice: this.upperTickPrice,\n            liquidity: this.liquidity,\n            rangeType,\n        })\n        const makerPositionImpermanent = await this._getMakerPositionImpermanent(amountBase, amountQuote)\n        return makerPositionImpermanent\n    }\n\n    async getLiquidityValue({ cache = true } = {}) {\n        const [{ markPrice }, rangeType] = await Promise.all([\n            this.market.getPrices({ cache }),\n            this.getRangeType({ cache }),\n        ])\n        const { amountBase, amountQuote } = Liquidity.getLiquidityAmounts({\n            markPrice,\n            lowerTickPrice: this.lowerTickPrice,\n            upperTickPrice: this.upperTickPrice,\n            liquidity: this.liquidity,\n            rangeType,\n        })\n        const amountBaseAsQuote = amountBase.mul(markPrice)\n        const amountLiquidity = amountBaseAsQuote.add(amountQuote)\n        return amountLiquidity\n    }\n\n    // NOTE: Need to move to Positions in the future.\n    private async _getMakerPositionImpermanent(amountBase: Big, amountQuote: Big) {\n        const makerPositionImpermanentRaw = amountBase.sub(this.baseDebt)\n        const makerPositionImpermanentRawOpenNotional = amountQuote.sub(this.quoteDebt)\n        let makerPositionImpermanent\n        if (!makerPositionImpermanentRaw.eq(0)) {\n            makerPositionImpermanent = new Position({\n                perp: this._perp,\n                type: PositionType.MAKER,\n                market: this.market,\n                side: makerPositionImpermanentRaw.gt(0) ? PositionSide.LONG : PositionSide.SHORT,\n                sizeAbs: makerPositionImpermanentRaw.abs(),\n                openNotionalAbs: makerPositionImpermanentRawOpenNotional.abs(),\n                entryPrice: makerPositionImpermanentRawOpenNotional.div(makerPositionImpermanentRaw).abs(),\n            })\n        }\n        return makerPositionImpermanent\n    }\n\n    static getLiquidityAmounts({\n        markPrice,\n        lowerTickPrice,\n        upperTickPrice,\n        liquidity,\n        rangeType,\n    }: {\n        markPrice: Big\n        lowerTickPrice: Big\n        upperTickPrice: Big\n        liquidity: Big\n        rangeType: RangeType\n    }) {\n        const markPriceSqrtX96 = toSqrtX96(markPrice)\n        const upperPriceSqrtX96 = toSqrtX96(upperTickPrice)\n        const lowerPriceSqrtX96 = toSqrtX96(lowerTickPrice)\n\n        let erc20DecimalAmountQuote, erc20DecimalAmountBase\n        switch (rangeType) {\n            case RangeType.RANGE_AT_LEFT: {\n                erc20DecimalAmountQuote = Liquidity.getQuoteTokenAmountFromLiquidity(\n                    upperPriceSqrtX96,\n                    lowerPriceSqrtX96,\n                    liquidity,\n                )\n                erc20DecimalAmountBase = BIG_ZERO\n                break\n            }\n            case RangeType.RANGE_AT_RIGHT: {\n                erc20DecimalAmountBase = Liquidity.getBaseTokenAmountFromLiquidity(\n                    upperPriceSqrtX96,\n                    lowerPriceSqrtX96,\n                    liquidity,\n                )\n                erc20DecimalAmountQuote = BIG_ZERO\n                break\n            }\n            case RangeType.RANGE_INSIDE: {\n                erc20DecimalAmountQuote = Liquidity.getQuoteTokenAmountFromLiquidity(\n                    markPriceSqrtX96,\n                    lowerPriceSqrtX96,\n                    liquidity,\n                )\n                erc20DecimalAmountBase = Liquidity.getBaseTokenAmountFromLiquidity(\n                    markPriceSqrtX96,\n                    upperPriceSqrtX96,\n                    liquidity,\n                )\n                break\n            }\n            default: {\n                throw new FailedPreconditionError({\n                    functionName: \"getLiquidityAmounts\",\n                    stateName: \"rangeType\",\n                    stateValue: rangeType,\n                })\n            }\n        }\n\n        return {\n            amountQuote: scaleDownDecimals(erc20DecimalAmountQuote, ERC20_DECIMAL_DIGITS),\n            amountBase: scaleDownDecimals(erc20DecimalAmountBase, ERC20_DECIMAL_DIGITS),\n        }\n    }\n\n    private async _fetch(key: \"liquidityPendingFee\", obj?: { cache: boolean }): Promise<Big>\n    private async _fetch(key: CacheKey, { cache = true } = {}) {\n        if (this._cache.has(key) && cache) {\n            return this._cache.get(key) as CacheValue\n        }\n\n        let result\n        switch (key) {\n            case \"liquidityPendingFee\": {\n                result = await this._perp.contractReader.getLiquidityPendingFee({\n                    trader: this._perp.wallet.account,\n                    baseTokenAddress: this.market.baseAddress,\n                    lowerTick: this._lowerTick,\n                    upperTick: this._upperTick,\n                })\n                break\n            }\n        }\n        this._cache.set(key, result)\n\n        return result\n    }\n\n    static same(liquidityA: Liquidity, liquidityB: Liquidity) {\n        return (\n            liquidityA.id === liquidityB.id &&\n            liquidityA.liquidity.eq(liquidityB.liquidity) &&\n            liquidityA.baseDebt.eq(liquidityB.baseDebt) &&\n            liquidityA.quoteDebt.eq(liquidityB.quoteDebt)\n        )\n    }\n}\n"],"names":["Liquidity","LiquidityBase","constructor","perp","id","liquidity","lowerTick","upperTick","baseDebt","quoteDebt","data","_channelRegistry","super","this","_cache","Map","_perp","_lowerTick","_upperTick","_baseDebt","_quoteDebt","_getEventSourceMap","updated","ChannelEventSource","eventSourceStarter","market","on","_handleMarketUpdate","bind","async","_fetch","cache","emit","error","markPrice","rangeType","Promise","all","getPrices","getRangeType","amountQuote","amountBase","getLiquidityAmounts","lowerTickPrice","upperTickPrice","_getMakerPositionImpermanent","mul","add","makerPositionImpermanentRaw","sub","makerPositionImpermanentRawOpenNotional","makerPositionImpermanent","eq","Position","type","PositionType","MAKER","side","gt","PositionSide","LONG","SHORT","sizeAbs","abs","openNotionalAbs","entryPrice","div","static","markPriceSqrtX96","toSqrtX96","upperPriceSqrtX96","lowerPriceSqrtX96","erc20DecimalAmountQuote","erc20DecimalAmountBase","RangeType","RANGE_AT_LEFT","getQuoteTokenAmountFromLiquidity","BIG_ZERO","RANGE_AT_RIGHT","getBaseTokenAmountFromLiquidity","RANGE_INSIDE","FailedPreconditionError","functionName","stateName","stateValue","scaleDownDecimals","ERC20_DECIMAL_DIGITS","key","has","get","result","contractReader","getLiquidityPendingFee","trader","wallet","account","baseTokenAddress","baseAddress","set","liquidityA","liquidityB"],"mappings":"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"}