{"version":3,"file":"formatters.js","sources":["../../../src/utils/formatters.ts"],"sourcesContent":["import { ERC20_DECIMAL_DIGITS, Q96 } from \"../constants\"\n\nimport Big from \"big.js\"\nimport { BigNumber } from \"ethers\"\n\nexport function bigNumber2Big(value: BigNumber): Big {\n    return new Big(value.toString())\n}\n\nexport function bigNumber2BigAndScaleDown(value: BigNumber, decimals: number = ERC20_DECIMAL_DIGITS): Big {\n    return scaleDownDecimals(bigNumber2Big(value), decimals)\n}\n\nexport function big2BigNumberAndScaleUp(value: Big, decimals: number = ERC20_DECIMAL_DIGITS): BigNumber {\n    return BigNumber.from(scaleUpDecimals(value, decimals).toFixed(0))\n}\n\nexport function fromSqrtX96(value: BigNumber) {\n    return bigNumber2Big(value).div(Q96).pow(2)\n}\n\nexport function toSqrtX96(value: Big) {\n    return value.sqrt().mul(Q96)\n}\n\nexport function encodePriceSqrt(amount1: Big, amount0: Big) {\n    return BigNumber.from(amount1.div(amount0).sqrt().mul(Q96).round().toString())\n}\n\nexport function scaleDownDecimals(number: Big, decimals: number) {\n    return number.div(new Big(10).pow(decimals))\n}\n\nexport function scaleUpDecimals(number: Big, decimals: number) {\n    return number.mul(new Big(10).pow(decimals))\n}\n\n/**\n * get how many decimals need to be shown.\n * @example getLeastSignificantDigit(new Big(123.123456)) -> 3 (123.123)\n * @example getLeastSignificantDigit(new Big(12345.12345)) -> 1 (12345.1)\n * @example getLeastSignificantDigit(new Big(12345)) -> 1 (12345.0)\n * @example getLeastSignificantDigit(new Big(0.12345678)) -> 6 (0.123456)\n * @example getLeastSignificantDigit(new Big(0.000012345678)) -> 10 (0.0000123456)\n * @param value the quote asset amount\n * @returns how many decimals need to be shown\n */\nexport function getLeastSignificantDigit(value: string | number | Big, displayLength = 6, minimal = 1): number {\n    const number = Number(value)\n    if (isNaN(number)) {\n        return minimal\n    }\n\n    const big = new Big(number || 0)\n    const fixed = big.toFixed()\n    const firstNonZeroMatched = fixed.match(/[1-9]/)\n    let dotIndex = fixed.indexOf(\".\")\n\n    if (dotIndex === -1) {\n        // the number is an integer, set the dotIndex to last char\n        dotIndex = fixed.length\n    }\n\n    if (!firstNonZeroMatched) {\n        return minimal\n    }\n\n    if (big.gt(1)) {\n        return Math.max(displayLength - dotIndex, minimal)\n    } else {\n        // -2 is for \"0.\" these two chars\n        return displayLength + (firstNonZeroMatched?.index ?? 0 - 2)\n    }\n}\n"],"names":["bigNumber2Big","value","Big","toString","bigNumber2BigAndScaleDown","decimals","ERC20_DECIMAL_DIGITS","scaleDownDecimals","big2BigNumberAndScaleUp","BigNumber","from","scaleUpDecimals","toFixed","fromSqrtX96","div","Q96","pow","toSqrtX96","sqrt","mul","encodePriceSqrt","amount1","amount0","round","number","getLeastSignificantDigit","displayLength","minimal","Number","isNaN","big","fixed","firstNonZeroMatched","match","dotIndex","indexOf","length","gt","Math","max","_a","index"],"mappings":"sKAKM,SAAUA,EAAcC,GAC1B,OAAO,IAAIC,EAAID,EAAME,WACzB,UAEgBC,EAA0BH,EAAkBI,EAAmBC,GAC3E,OAAOC,EAAkBP,EAAcC,GAAQI,EACnD,UAEgBG,EAAwBP,EAAYI,EAAmBC,GACnE,OAAOG,EAAUC,KAAKC,EAAgBV,EAAOI,GAAUO,QAAQ,GACnE,CAEM,SAAUC,EAAYZ,GACxB,OAAOD,EAAcC,GAAOa,IAAIC,GAAKC,IAAI,EAC7C,CAEM,SAAUC,EAAUhB,GACtB,OAAOA,EAAMiB,OAAOC,IAAIJ,EAC5B,CAEgB,SAAAK,EAAgBC,EAAcC,GAC1C,OAAOb,EAAUC,KAAKW,EAAQP,IAAIQ,GAASJ,OAAOC,IAAIJ,GAAKQ,QAAQpB,WACvE,CAEgB,SAAAI,EAAkBiB,EAAanB,GAC3C,OAAOmB,EAAOV,IAAI,IAAIZ,EAAI,IAAIc,IAAIX,GACtC,CAEgB,SAAAM,EAAgBa,EAAanB,GACzC,OAAOmB,EAAOL,IAAI,IAAIjB,EAAI,IAAIc,IAAIX,GACtC,CAYM,SAAUoB,EAAyBxB,EAA8ByB,EAAgB,EAAGC,EAAU,SAChG,MAAMH,EAASI,OAAO3B,GACtB,GAAI4B,MAAML,GACN,OAAOG,EAGX,MAAMG,EAAM,IAAI5B,EAAIsB,GAAU,GACxBO,EAAQD,EAAIlB,UACZoB,EAAsBD,EAAME,MAAM,SACxC,IAAIC,EAAWH,EAAMI,QAAQ,KAO7B,OALkB,IAAdD,IAEAA,EAAWH,EAAMK,QAGhBJ,EAIDF,EAAIO,GAAG,GACAC,KAAKC,IAAIb,EAAgBQ,EAAUP,GAGnCD,GAA+C,QAA9Bc,EAAAR,aAAmB,EAAnBA,EAAqBS,aAAS,IAAAD,EAAAA,GAAA,GAP/Cb,CASf"}