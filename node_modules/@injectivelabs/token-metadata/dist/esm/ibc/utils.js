import { canonicalChannelIds, canonicalChannelsToChainMapFromInjective, } from './channels';
import { TokenType } from '../types';
export const isIbcTokenCanonical = (token) => {
    const { denom } = token;
    if (!denom.startsWith('ibc/') || !token.ibc) {
        return false;
    }
    const pathParts = token.ibc.path.replace('transfer/', '').split('/');
    /** More than one channelId */
    if (pathParts.length > 1) {
        return false;
    }
    const [channelId] = pathParts;
    return canonicalChannelIds.includes(channelId);
};
export const getChannelIdFromPath = (path) => {
    const pathParts = path.replace('transfer/', '').split('/');
    const [channelId] = pathParts;
    return channelId;
};
export const getIbcDestinationChain = ({ channelPaths, channel, index, token, }) => {
    if (token.tokenType !== TokenType.Ibc) {
        return '';
    }
    const canonicalChannel = channel;
    if (canonicalChannelsToChainMapFromInjective[canonicalChannel]) {
        return canonicalChannelsToChainMapFromInjective[canonicalChannel].chainB;
    }
    if (index === channelPaths.length - 1) {
        return token.name;
    }
    return '';
};
export const formatNonCanonicalIbcTokenName = (token) => {
    const formattedDenomTrace = token.ibc.channelId.replaceAll('transfer/', '');
    const channelToLastChain = formattedDenomTrace.split('/').shift();
    const lastChain = canonicalChannelsToChainMapFromInjective[channelToLastChain]
        ? canonicalChannelsToChainMapFromInjective[channelToLastChain].chainB
        : 'Unknown';
    return `${token.ibc.baseDenom.toUpperCase()}-${lastChain.toLowerCase()}-${channelToLastChain}`;
};
//# sourceMappingURL=utils.js.map