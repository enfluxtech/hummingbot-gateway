"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("../../internal/Channel.js"),t=require("../../internal/ChannelEventSource.js"),r=require("../../internal/createMemoizedFetcher.js"),s=require("../../internal/config.js");require("big.js");var a,i=require("../../utils/formatters.js"),c=require("../../utils/tick.js"),n=require("../../utils/poll.js");require("../../constants/envVariables.js"),require("../../constants/numbers.js"),exports.MarketStatus=void 0,(a=exports.MarketStatus||(exports.MarketStatus={})).ACTIVE="ACTIVE",a.PAUSED="PAUSED",a.CLOSED="CLOSED";class o extends e.Channel{constructor(e,t,r,s,a,i,c){super(e.channelRegistry),this._perp=e,this.tickerSymbol=t,this.poolAddress=r,this.baseSymbol=s,this.baseAddress=a,this.quoteSymbol=i,this.quoteAddress=c,this._cache=new Map,this._perp=e,this.poolAddress=r,this.baseAddress=a,this.quoteAddress=c,this._contractReader=this._perp.contractReader}get tickSpacing(){return this._perp.clearingHouseConfig.marketTickSpacings[this.poolAddress]}get maxTick(){return c.getMaxTickByTickSpacing(this.tickSpacing)}get minTick(){return c.getMinTickByTickSpacing(this.tickSpacing)}getTickFromPrice(e,t){return c.getTickFromPrice(e,this.tickSpacing,t)}getPriceFromTick(e){return c.tickToPrice(e)}getPriceFeedAggregator(){return this._contractReader.getPriceFeedAggregator(this.baseAddress)}_getEventSourceMap(){const e=this._createFetchUpdateData(),r=new t.ChannelEventSource({eventSourceStarter:()=>{var t,r;const{cancel:a}=n.poll(e,(null===(r=null===(t=this._perp.moduleConfigs)||void 0===t?void 0:t.market)||void 0===r?void 0:r.period)||s.DEFAULT_PERIOD);return a},initEventEmitter:()=>e(!0,!0)});return{updated:r,updateError:r}}_createFetchUpdateData(){return r.createMemoizedFetcher((async()=>{try{const e=this._perp.clearingHouseConfig.twapInterval.toNumber(),t=await this._contractReader.getMarketData({poolAddress:this.poolAddress,baseAddress:this.baseAddress,twapTimeRange:e}),{markPrice:r,indexPrice:s,indexTwapPrice:a}=t;return this._cache.set("markPrice",r),this._cache.set("indexPrice",s),this._cache.set("indexTwapPrice",a),t}catch(e){this.emit("updateError",{error:e})}}).bind(this),(()=>{this.emit("updated",this)}),((e,t)=>!e||!t||r.hasNumbersChange(e,t)))}async getStatus(){const{isPaused:e,isClosed:t}=await this._fetch("marketStatus",{cache:!1});return t?exports.MarketStatus.CLOSED:e?exports.MarketStatus.PAUSED:exports.MarketStatus.ACTIVE}async getClosedPrice(){return await this._fetch("closedPrice")}async getPrices({cache:e=!0}={}){const[t,r,s]=await Promise.all([this._fetch("markPrice",{cache:e}),this._fetch("indexPrice",{cache:e}),this._fetch("indexTwapPrice",{cache:e})]);return{markPrice:t,indexPrice:r,indexTwapPrice:s}}async _fetch(e,{cache:t=!0}={}){if(this._cache.has(e)&&t)return this._cache.get(e);let r;switch(e){case"indexPrice":r=await this._contractReader.getIndexPrice(this.baseAddress);break;case"markPrice":{const{sqrtPriceX96:e}=await this._contractReader.getSlot0(this.poolAddress);r=i.fromSqrtX96(e);break}case"indexTwapPrice":{const e=this._perp.clearingHouseConfig.twapInterval.toNumber();r=await this._contractReader.getIndexPrice(this.baseAddress,e);break}case"isMarketPaused":r=await this._contractReader.isMarketPaused(this.baseAddress);break;case"isMarketClosed":r=await this._contractReader.isMarketClosed(this.baseAddress);break;case"marketStatus":r=await this._contractReader.getMarketStatus(this.baseAddress);break;case"closedPrice":r=await this._contractReader.getClosedPrice(this.baseAddress)}return this._cache.set(e,r),r}}exports.Market=o;
//# sourceMappingURL=Market.js.map
