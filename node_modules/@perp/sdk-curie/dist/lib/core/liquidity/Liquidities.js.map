{"version":3,"file":"Liquidities.js","sources":["../../../../src/core/liquidity/Liquidities.ts"],"sourcesContent":["import Big from \"big.js\"\nimport { Result } from \"ethers/lib/utils\"\n\nimport { BIG_ZERO } from \"../../constants\"\nimport { ContractName } from \"../../contracts\"\nimport { Channel, ChannelEventSource, DEFAULT_PERIOD, MemoizedFetcher, createMemoizedFetcher } from \"../../internal\"\nimport { bigNumber2BigAndScaleDown, fromSqrtX96, logger, poll } from \"../../utils\"\nimport {\n    ContractCall,\n    GetOpenLiquidityReturn,\n    GetTotalTokenAmountInPoolAndPendingFeeOfAllMarketsReturn,\n    MulticallReader,\n} from \"../contractReader\"\nimport { PerpetualProtocolConnected } from \"../PerpetualProtocol\"\nimport { Liquidity } from \"./Liquidity\"\n\nexport interface UpdatedDataReturn {\n    openLiquiditiesFromMarkets: { [marketBaseAddress: string]: Liquidity[] }\n    totalPendingFees: { [marketBaseAddress: string]: Big }\n}\n\ntype LiquiditiesEventName = \"updateError\" | \"updated\" | \"updatedLiquidityDataAll\"\n\ntype CacheKey = \"openLiquidities\" | \"totalTokenAmountInPoolAndPendingFeeOfAllMarkets\"\ntype CacheValue = GetOpenLiquidityReturn | GetTotalTokenAmountInPoolAndPendingFeeOfAllMarketsReturn\n\nclass Liquidities extends Channel<LiquiditiesEventName> {\n    private _cache: Map<CacheKey, CacheValue> = new Map()\n    private readonly _fetchAndEmitUpdated: MemoizedFetcher\n\n    constructor(private readonly _perp: PerpetualProtocolConnected) {\n        super(_perp.channelRegistry)\n        this._fetchAndEmitUpdated = createMemoizedFetcher(\n            () => this._fetchUpdateData(),\n            () => {\n                this.emit(\"updated\", this)\n            },\n            (a, b) => (a && b ? this._compareUpdatedData(a, b) : true),\n        )\n    }\n\n    private _compareUpdatedData(a: UpdatedDataReturn, b: UpdatedDataReturn) {\n        const aFees = Object.values(a.totalPendingFees)\n        const bFees = Object.values(b.totalPendingFees)\n        const aLiquiditiesFromMarkets = Object.values(a.openLiquiditiesFromMarkets)\n        const bLiquiditiesFromMarkets = Object.values(b.openLiquiditiesFromMarkets)\n\n        const hasDifferentLiquidityLengthInSomeMarkets = aLiquiditiesFromMarkets.some((liquidities, marketIndex) => {\n            return liquidities.length !== bLiquiditiesFromMarkets[marketIndex].length\n        })\n\n        if (hasDifferentLiquidityLengthInSomeMarkets) {\n            return true\n        }\n\n        return (\n            aLiquiditiesFromMarkets.some((liquidities, marketIndex) => {\n                return liquidities.some((liquidity, index) => {\n                    return !Liquidity.same(liquidity, bLiquiditiesFromMarkets[marketIndex][index])\n                })\n            }) || aFees.some((fee, index) => !bFees[index].eq(fee))\n        )\n    }\n\n    protected _getEventSourceMap() {\n        const updateDataEventSource = new ChannelEventSource<LiquiditiesEventName>({\n            eventSourceStarter: () =>\n                poll(this._fetchAndEmitUpdated, this._perp.moduleConfigs?.orders?.period || DEFAULT_PERIOD).cancel,\n            initEventEmitter: () => this._fetchAndEmitUpdated(false, true),\n        })\n\n        // NOTE: getLiquidityDataAll\n        const fetchAndEmitUpdatedLiquidityDataAll = this.getLiquidityDataAll.bind(this)\n        const updateDataEventSourceLiquidityDataAll = new ChannelEventSource({\n            eventSourceStarter: () => {\n                return poll(\n                    fetchAndEmitUpdatedLiquidityDataAll,\n                    this._perp.moduleConfigs?.orders?.period || DEFAULT_PERIOD,\n                ).cancel\n            },\n            initEventEmitter: () => fetchAndEmitUpdatedLiquidityDataAll(),\n        })\n\n        return {\n            updated: updateDataEventSource,\n            // NOTE: getLiquidityDataAll\n            updatedLiquidityDataAll: updateDataEventSourceLiquidityDataAll,\n        }\n    }\n\n    private async _fetchUpdateData() {\n        try {\n            const result = await Promise.all([\n                this.getOpenLiquiditiesFromMarkets({ cache: false }),\n                this.getTotalPendingFees({ cache: false }),\n            ])\n\n            return {\n                openLiquiditiesFromMarkets: result[0],\n                totalPendingFees: result[1],\n            }\n        } catch (e) {\n            this.emit(\"updateError\")\n        }\n    }\n\n    async getTotalLiquidities({ cache = true } = {}) {\n        const openLiquidities = await this.getOpenLiquiditiesFromMarkets({ cache })\n\n        const openLiquiditiesInTheMarkets = Object.values(openLiquidities)\n        const marketBaseAddresses = Object.keys(openLiquidities)\n        const result: { [marketBaseAddress: string]: Big } = {}\n\n        for (let i = 0; i < openLiquiditiesInTheMarkets.length; i++) {\n            const openLiquiditiesInTheMarket = openLiquiditiesInTheMarkets[i]\n            const baseAddress = marketBaseAddresses[i]\n            const liquidityValues = await Promise.all(\n                openLiquiditiesInTheMarket.map(openLiquidity => openLiquidity.getLiquidityValue()),\n            )\n            result[baseAddress] = liquidityValues.reduce((acc, value) => acc.add(value), BIG_ZERO)\n        }\n\n        return result\n    }\n\n    async getTotalLiquidityByMarket(baseAddress: string, { cache = true } = {}) {\n        const openLiquidities = await this.getOpenLiquiditiesByMarket(baseAddress, { cache })\n        const liquidityValues = await Promise.all(\n            openLiquidities.map(openLiquidity => openLiquidity.getLiquidityValue()),\n        )\n        return liquidityValues.reduce((acc, value) => acc.add(value), BIG_ZERO)\n    }\n\n    // total pending fees of all markets\n    async getTotalPendingFees({ cache = true } = {}) {\n        const result = await this._fetch(\"totalTokenAmountInPoolAndPendingFeeOfAllMarkets\", { cache })\n        return Object.values(this._perp.markets.marketMap).reduce((acc, market) => {\n            acc[market.baseAddress] = result[market.baseAddress].totalPendingFee\n            return acc\n        }, {} as { [marketBaseAddress: string]: Big })\n    }\n\n    async getTotalPendingFeeByMarket(baseAddress: string, { cache = true } = {}) {\n        const result = await this.getTotalPendingFees({ cache })\n        return result?.[baseAddress]\n    }\n\n    async getOpenLiquiditiesFromMarkets({ cache = true } = {}) {\n        const liquidities = await this._fetch(\"openLiquidities\", { cache })\n        return Object.values(this._perp.markets.marketMap).reduce((acc, market, index) => {\n            acc[market.baseAddress] = liquidities[index].map(\n                ({ liquidity, baseDebt, quoteDebt, lowerTick, upperTick }) =>\n                    new Liquidity(\n                        {\n                            perp: this._perp,\n                            id: `${market.baseAddress}-${lowerTick}-${upperTick}`,\n                            liquidity,\n                            upperTick,\n                            lowerTick,\n                            baseDebt,\n                            quoteDebt,\n                            market,\n                        },\n                        this._perp.channelRegistry,\n                    ),\n            )\n            return acc\n        }, {} as { [marketBaseAddress: string]: Liquidity[] })\n    }\n\n    async getOpenLiquiditiesByMarket(baseAddress: string, { cache = true } = {}) {\n        const liquidities = await this._fetch(\"openLiquidities\", { cache })\n        const index = Object.values(this._perp.markets.marketMap).findIndex(\n            market => market.baseAddress === baseAddress,\n        )\n        if (index === -1) {\n            return []\n        }\n\n        return liquidities[index].map(\n            ({ liquidity, baseDebt, quoteDebt, lowerTick, upperTick }) =>\n                new Liquidity(\n                    {\n                        perp: this._perp,\n                        id: `${baseAddress}-${lowerTick}-${upperTick}`,\n                        liquidity,\n                        upperTick,\n                        lowerTick,\n                        baseDebt,\n                        quoteDebt,\n                        market: this._perp.markets.getMarket({ baseAddress }),\n                    },\n                    this._perp.channelRegistry,\n                ),\n        )\n    }\n\n    private async _fetch(key: \"openLiquidities\", obj?: { cache: boolean }): Promise<GetOpenLiquidityReturn>\n    private async _fetch(\n        key: \"totalTokenAmountInPoolAndPendingFeeOfAllMarkets\",\n        obj?: { cache: boolean },\n    ): Promise<GetTotalTokenAmountInPoolAndPendingFeeOfAllMarketsReturn>\n    private async _fetch(key: CacheKey, { cache = true } = {}) {\n        if (this._cache.has(key) && cache) {\n            return this._cache.get(key) as CacheValue\n        }\n\n        const marketMap = this._perp.markets.marketMap\n        const trader = this._perp.wallet.account\n        const args = [marketMap, trader] as const\n\n        let result\n        switch (key) {\n            case \"openLiquidities\": {\n                result = await this._perp.contractReader.getOpenLiquidities(...args)\n                break\n            }\n            case \"totalTokenAmountInPoolAndPendingFeeOfAllMarkets\": {\n                result = await this._perp.contractReader.getTotalTokenAmountInPoolAndPendingFeeOfAllMarkets(...args)\n                break\n            }\n        }\n        this._cache.set(key, result)\n\n        return result\n    }\n\n    protected async getLiquidityDataAll() {\n        try {\n            logger(\"getLiquidityDataAll\")\n            const account = this._perp.wallet.account\n            const marketMap = this._perp.markets.marketMap\n            const contracts = this._perp.contracts\n            const multicallReader = new MulticallReader({ contract: this._perp.contracts.multicall2 })\n\n            // NOTE: first calls batch\n            const callsMap: { [key: string]: ContractCall[] } = {}\n            Object.entries(marketMap).forEach(([tickerSymbol, market]) => {\n                const baseAddress = market.baseAddress\n                const calls = [\n                    // NOTE: getTotalTokenAmountInPoolAndPendingFee\n                    {\n                        contract: contracts.orderBook,\n                        contractName: ContractName.ORDERBOOK,\n                        funcName: \"getTotalTokenAmountInPoolAndPendingFee\",\n                        funcParams: [account, baseAddress, false],\n                    },\n                    // NOTE: getOpenOrderIds\n                    {\n                        contract: contracts.orderBook,\n                        contractName: ContractName.ORDERBOOK,\n                        funcName: \"getOpenOrderIds\",\n                        funcParams: [account, baseAddress],\n                    },\n                    // NOTE: get market price\n                    {\n                        contract: contracts.pool.attach(market.poolAddress),\n                        contractName: ContractName.POOL,\n                        funcName: \"slot0\",\n                        funcParams: [],\n                    },\n                ]\n                callsMap[tickerSymbol] = calls\n            })\n\n            // NOTE: get data\n            const data = await multicallReader.execute(Object.values(callsMap).flat(), {\n                failFirstByContract: false,\n                failFirstByClient: false,\n            })\n\n            // NOTE: data analysis\n            const parsedData: Record<string, Omit<LiquidityData, \"openLiquidities\" | \"totalLiquidityValue\">> = {}\n            Object.entries(callsMap).forEach(([key, value]) => {\n                const dataChunk = data.splice(0, value.length)\n                const [totalTokenAmount, totalPendingFee] = dataChunk[0]\n                const openOrderIds = dataChunk[1]\n                const markPrice = fromSqrtX96(dataChunk[2].sqrtPriceX96)\n                parsedData[key] = {\n                    totalPendingFee: bigNumber2BigAndScaleDown(totalPendingFee),\n                    openOrderIds,\n                    markPrice,\n                }\n            })\n\n            // NOTE: get order by id\n            const callsBatch2: ContractCall[] = []\n            Object.values(parsedData).forEach(liquidityData => {\n                const openOrderIds = liquidityData.openOrderIds\n                openOrderIds.forEach(id => {\n                    callsBatch2.push({\n                        contract: contracts.orderBook,\n                        contractName: ContractName.ORDERBOOK,\n                        funcName: \"getOpenOrderById\",\n                        funcParams: [id],\n                    })\n                })\n            })\n\n            // NOTE: get data batch2\n            const dataBatch2 = await multicallReader.execute(callsBatch2, {\n                failFirstByContract: false,\n                failFirstByClient: false,\n            })\n\n            // NOTE: data batch2 analysis\n            const liquidityDataAll: LiquidityDataAll = {}\n            Object.entries(parsedData).forEach(([tickerSymbol, value]) => {\n                const market = marketMap[tickerSymbol]\n                const dataChunk = dataBatch2.splice(0, value.openOrderIds.length)\n                const openLiquidities: Liquidity[] = []\n                let totalLiquidityValue = Big(0)\n                dataChunk.forEach(({ liquidity, baseDebt, quoteDebt, lowerTick, upperTick }: Result) => {\n                    const _liquidity = new Liquidity(\n                        {\n                            perp: this._perp,\n                            id: `${market.baseAddress}-${lowerTick}-${upperTick}`,\n                            liquidity: new Big(liquidity),\n                            upperTick,\n                            lowerTick,\n                            baseDebt: bigNumber2BigAndScaleDown(baseDebt),\n                            quoteDebt: bigNumber2BigAndScaleDown(quoteDebt),\n                            market,\n                        },\n                        this._perp.channelRegistry,\n                    )\n                    const rangeType = Liquidity.getRangeTypeByMarkPrice(\n                        value.markPrice,\n                        _liquidity.lowerTickPrice,\n                        _liquidity.upperTickPrice,\n                    )\n                    const { amountQuote, amountBase } = Liquidity.getLiquidityAmounts({\n                        markPrice: value.markPrice,\n                        lowerTickPrice: _liquidity.lowerTickPrice,\n                        upperTickPrice: _liquidity.upperTickPrice,\n                        liquidity: _liquidity.liquidity,\n                        rangeType,\n                    })\n                    const amountBaseAsQuote = amountBase.mul(value.markPrice)\n                    totalLiquidityValue = totalLiquidityValue.add(amountBaseAsQuote.add(amountQuote))\n                    openLiquidities.push(_liquidity)\n                })\n                liquidityDataAll[tickerSymbol] = {\n                    ...value,\n                    totalLiquidityValue,\n                    openLiquidities,\n                }\n            })\n\n            this.emit(\"updatedLiquidityDataAll\", liquidityDataAll)\n        } catch (error) {\n            this.emit(\"updateError\", { error })\n        }\n    }\n}\n\nexport { Liquidities }\n\nexport interface LiquidityData {\n    totalPendingFee: Big\n    totalLiquidityValue: Big\n    openOrderIds: number[]\n    openLiquidities: Liquidity[]\n    markPrice: Big\n}\nexport type LiquidityDataAll = Record<string, LiquidityData>\n"],"names":["Liquidities","Channel","constructor","_perp","super","channelRegistry","this","_cache","Map","_fetchAndEmitUpdated","createMemoizedFetcher","_fetchUpdateData","emit","a","b","_compareUpdatedData","aFees","Object","values","totalPendingFees","bFees","aLiquiditiesFromMarkets","openLiquiditiesFromMarkets","bLiquiditiesFromMarkets","some","liquidities","marketIndex","length","liquidity","index","Liquidity","same","fee","eq","_getEventSourceMap","updateDataEventSource","ChannelEventSource","eventSourceStarter","_a","_b","poll","moduleConfigs","orders","period","DEFAULT_PERIOD","cancel","initEventEmitter","fetchAndEmitUpdatedLiquidityDataAll","getLiquidityDataAll","bind","updated","updatedLiquidityDataAll","async","result","Promise","all","getOpenLiquiditiesFromMarkets","cache","getTotalPendingFees","e","openLiquidities","openLiquiditiesInTheMarkets","marketBaseAddresses","keys","i","openLiquiditiesInTheMarket","baseAddress","liquidityValues","map","openLiquidity","getLiquidityValue","reduce","acc","value","add","BIG_ZERO","getOpenLiquiditiesByMarket","_fetch","markets","marketMap","market","totalPendingFee","baseDebt","quoteDebt","lowerTick","upperTick","perp","id","findIndex","getMarket","key","has","get","args","wallet","account","contractReader","getOpenLiquidities","getTotalTokenAmountInPoolAndPendingFeeOfAllMarkets","set","logger","contracts","multicallReader","MulticallReader","contract","multicall2","callsMap","entries","forEach","tickerSymbol","calls","orderBook","contractName","ContractName","ORDERBOOK","funcName","funcParams","pool","attach","poolAddress","POOL","data","execute","flat","failFirstByContract","failFirstByClient","parsedData","dataChunk","splice","totalTokenAmount","openOrderIds","markPrice","fromSqrtX96","sqrtPriceX96","bigNumber2BigAndScaleDown","callsBatch2","liquidityData","push","dataBatch2","liquidityDataAll","totalLiquidityValue","Big","_liquidity","rangeType","getRangeTypeByMarkPrice","lowerTickPrice","upperTickPrice","amountQuote","amountBase","getLiquidityAmounts","amountBaseAsQuote","mul","error"],"mappings":"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"}