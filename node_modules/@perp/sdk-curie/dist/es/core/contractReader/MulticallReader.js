import{utils as t}from"ethers";import{ContractName as r}from"../../contracts/Contracts.js";import{MulticallEncodeError as c,MulticallReadError as a,MulticallDecodeError as n,ContractReadError as e}from"../../errors/errors.js";class o{constructor({contract:t}){this.contract=t}async execute(o,s){const{failFirstByContract:u=!0,failFirstByClient:m=!0,returnByContractAndFuncName:i=!1}=s||{},f=o.map((t=>{try{const r=t.contract.interface.encodeFunctionData(t.funcName,t.funcParams);return{target:t.contract.address,callData:r}}catch(a){throw new c({contractName:r.MULTICALL2,contractFunctionName:"tryAggregate",args:{callFuncNam:t.funcName,callFuncParams:t.funcParams},rawError:a})}}));let g;try{g=await this.contract.callStatic.tryAggregate(u,f)}catch(t){throw new a({contractName:r.MULTICALL2,contractFunctionName:"tryAggregate",rawError:t})}const l=g.map((({success:c,returnData:a},s)=>{const u=o[s];if(!m&&!c){let r=new Error;if(a.length>=68){const c=`0x${a.substr(10)}`,n=t.toUtf8String(c).trim();r=new Error(n)}const c={contractName:u.funcName,contractFunctionName:u.funcName,args:u.funcParams,rawError:r};return new e(c)}try{const t=u.contract.interface.decodeFunctionResult(u.funcName,a);return t.length<=1?t[0]:t}catch(t){throw new n({contractName:r.MULTICALL2,contractFunctionName:"tryAggregate",args:{callFuncNam:u.funcName,returnData:a},rawError:t})}}));if(i){return l.reduce(((t,r,c)=>{const a=o[c],n=`${a.contractName}.${a.funcName}`,e=t[n];return t[n]=e?[...e,r]:[r],t}),{})}return l}}export{o as MulticallReader};
//# sourceMappingURL=MulticallReader.js.map
