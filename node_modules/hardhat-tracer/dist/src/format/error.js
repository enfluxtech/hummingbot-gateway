"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatError = void 0;
const utils_1 = require("ethers/lib/utils");
const colors_1 = require("../colors");
const object_1 = require("./object");
const param_1 = require("./param");
const result_1 = require("./result");
async function formatError(revertData, dependencies) {
    const commonErrors = [
        "function Error(string reason)",
        "function Panic(uint256 code)",
    ];
    try {
        const iface = new utils_1.Interface(commonErrors);
        const parsed = iface.parseTransaction({
            data: revertData,
        });
        if (parsed.name === "Panic") {
            const panicCode = parsed.args.code.toNumber();
            let situation = "";
            switch (panicCode) {
                case 0x01:
                    situation = "assert false";
                    break;
                case 0x11:
                    situation = "arithmetic overflow or underflow";
                    break;
                case 0x12:
                    situation = "divide or modulo by zero";
                    break;
                case 0x21:
                    situation = "value invalid for enum";
                    break;
                case 0x22:
                    situation = "access incorrectly encoded storage byte array";
                    break;
                case 0x31:
                    situation = "pop on empty array";
                    break;
                case 0x32:
                    situation = "array index out of bounds";
                    break;
                case 0x41:
                    situation = "allocating too much memory";
                    break;
                case 0x51:
                    situation = "zero internal function";
                    break;
            }
            return `${(0, colors_1.colorError)(parsed.name)}(${(0, object_1.formatObject)({
                code: panicCode,
                situation,
            })})`;
        }
        const formatted = (0, result_1.formatResult)(parsed.args, parsed.functionFragment, { decimals: -1, isInput: true, shorten: false }, dependencies);
        return `${(0, colors_1.colorError)(parsed.name)}(${formatted})`;
    }
    catch (_a) { }
    // if error not common then try to parse it as a custom error
    const names = await dependencies.artifacts.getAllFullyQualifiedNames();
    for (const name of names) {
        const artifact = await dependencies.artifacts.readArtifact(name);
        const iface = new utils_1.Interface(artifact.abi);
        try {
            const errorDesc = iface.parseError(revertData);
            return `${(0, colors_1.colorError)(errorDesc.name)}(${(0, result_1.formatResult)(errorDesc.args, errorDesc.errorFragment, { decimals: -1, isInput: true, shorten: false }, dependencies)})`;
        }
        catch (_b) { }
    }
    return `${(0, colors_1.colorError)("UnknownError")}(${(0, param_1.formatParam)(revertData, dependencies)})`;
}
exports.formatError = formatError;
//# sourceMappingURL=error.js.map