import"../../constants/envVariables.js";import{BIG_ZERO as t,BIG_ONE as e,SETTLEMENT_TOKEN_DECIMAL as a}from"../../constants/numbers.js";import{Channel as i}from"../../internal/Channel.js";import{ChannelEventSource as o}from"../../internal/ChannelEventSource.js";import{bigNumber2BigAndScaleDown as s,fromSqrtX96 as n,big2BigNumberAndScaleUp as r}from"../../utils/formatters.js";import{DEFAULT_PERIOD as c}from"../../internal/config.js";import{Position as l,PositionType as u}from"./Position.js";import m from"big.js";import{invariant as h}from"../../utils/errorChecker.js";import"../../utils/tick.js";import{poll as P}from"../../utils/poll.js";import{logger as p}from"../../utils/logger.js";import{PositionSide as d}from"./types.js";import{UnauthorizedError as k}from"../../errors/errors.js";import"ethers";import{ContractName as g}from"../../contracts/Contracts.js";import{MulticallReader as f}from"../contractReader/MulticallReader.js";import{getUnrealizedPnl as b,getSwapRate as A,getPriceImpact as T,getTransactionFee as N}from"../clearingHouse/utils.js";class y extends i{constructor(t){super(t.channelRegistry),this._perp=t,this._cache=new Map}_getEventSourceMap(){const t=this.getPositionDataAll.bind(this);return{updated:new o({eventSourceStarter:()=>{var e,a;return P(t,(null===(a=null===(e=this._perp.moduleConfigs)||void 0===e?void 0:e.positions)||void 0===a?void 0:a.period)||c).cancel},initEventEmitter:()=>t()})}}async getTakerPositions({cache:t=!0}={}){const e=this._perp.markets.marketMap,a=[],[i,o,s]=await Promise.all([this._fetch("takerPositionSizeList",{cache:t}),this._fetch("takerOpenNotionalList",{cache:t}),this._fetch("liquidationPriceList",{cache:t})]);return Object.values(e).forEach(((t,e)=>{const n=i[e],r=o[e],c=s[e];n.eq(0)||a.push(new l({perp:this._perp,type:u.TAKER,market:t,side:n.gte(0)?d.LONG:d.SHORT,sizeAbs:n.abs(),openNotionalAbs:r.abs(),entryPrice:r.div(n).abs(),liquidationPrice:c}))})),a}async getMakerPositions({cache:e=!0}={}){const a=this._perp.markets.marketMap,[i,o]=await Promise.all([this._fetch("totalPositionSizeList",{cache:e}),this._fetch("totalOpenNotionalList",{cache:e})]),s=await this.getTakerPositions({cache:e}),n=[];return Object.values(a).forEach(((e,a)=>{const r=s.find((t=>t.market.baseSymbol===e.baseSymbol)),c=(null==r?void 0:r.sizeOriginal)||t,m=(null==r?void 0:r.openNotionalOriginal)||t,h=i[a].sub(c),P=o[a].sub(m);h.eq(0)||n.push(new l({perp:this._perp,type:u.MAKER,market:e,side:h.gte(0)?d.LONG:d.SHORT,sizeAbs:h.abs(),openNotionalAbs:P.abs(),entryPrice:P.div(h).abs()}))})),n}async getTakerPositionByTickerSymbol(t,{cache:e=!0}={}){return(await this.getTakerPositions({cache:e})).find((e=>e.market.tickerSymbol===t))}async getMakerPositionByTickerSymbol(t,{cache:e=!0}={}){return(await this.getMakerPositions({cache:e})).find((e=>e.market.tickerSymbol===t))}async getTakerPosition(t,{cache:e=!0}={}){return(await this.getTakerPositions({cache:e})).find((e=>e.market.baseAddress===t))}async getMakerPosition(t,{cache:e=!0}={}){return(await this.getMakerPositions({cache:e})).find((e=>e.market.baseAddress===t))}async getTotalPositionValue(e,{cache:a=!0}={}){const i=await this._fetch("totalPositionValueList",{cache:a}),o=Object.values(this._perp.markets.marketMap).findIndex((t=>t.baseAddress===e));return-1===o?t:i[o]}async getTotalPositionValueFromAllMarkets({cache:t=!0}={}){const e=await this.getTotalMakerPositionValueFromAllMarkets({cache:t}),a=await this.getTotalTakerPositionValueFromAllMarkets();return e.add(a)}async getTotalTakerPositionValueFromAllMarkets({cache:e=!0}={}){const a=await this.getTakerPositions({cache:e});let i=t;for(const t of a){const a=t.sizeOriginal,{indexPrice:o}=await t.market.getPrices({cache:e});i=i.add(a.mul(o))}return i}async getTotalMakerPositionValueFromAllMarkets({cache:e=!0}={}){const a=await this.getMakerPositions({cache:e});let i=t;for(const t of a){const a=t.sizeOriginal,{indexPrice:o}=await t.market.getPrices({cache:e});i=i.add(a.mul(o))}return i}async getTotalUnrealizedPnlFromAllMarkets({cache:t=!0}={}){const e=await this.getTotalMakerUnrealizedPnlFromAllMarkets({cache:t}),a=await this.getTotalTakerUnrealizedPnlFromAllMarkets({cache:t});return e.add(a)}async getTotalTakerUnrealizedPnlFromAllMarkets({cache:e=!0}={}){const a=await this.getTakerPositions({cache:e});let i=t;for(const t of a)i=i.add(await t.getUnrealizedPnl());return i}async getTotalMakerUnrealizedPnlFromAllMarkets({cache:e=!0}={}){const a=await this.getMakerPositions({cache:e});let i=t;for(const t of a)i=i.add(await t.getUnrealizedPnl());return i}async getTotalPendingFundingPayments({cache:t=!0}={}){return this._fetch("pendingFundingPayments",{cache:t})}async getAccountMarginRatio({cache:t=!0}={}){h(this._perp.hasConnected(),(()=>new k({functionName:"getMarginRatio"})));const e=await this._fetch("totalAbsPositionValue",{cache:t});if(e.eq(0))return;return(await this._perp.vault.getAccountValue({cache:t})).div(e)}async getAccountLeverage({cache:t=!0}={}){const a=await this.getAccountMarginRatio({cache:t});if(a&&!(null==a?void 0:a.eq(0)))return e.div(a)}async _fetch(t,{cache:e=!0}={}){if(this._cache.has(t)&&e)return this._cache.get(t);const a=this._perp.markets.marketMap,i=this._perp.wallet.account,o=[a,i];let s;switch(t){case"takerPositionSizeList":s=await this._perp.contractReader.getTakerPositionSizeList(...o);break;case"takerOpenNotionalList":s=await this._perp.contractReader.getTakerOpenNotionalList(...o);break;case"totalPositionSizeList":s=await this._perp.contractReader.getTotalPositionSizeList(...o);break;case"totalOpenNotionalList":s=await this._perp.contractReader.getTotalOpenNotionalList(...o);break;case"pendingFundingPayments":s=await this._perp.contractReader.getPendingFundingPayments(...o);break;case"liquidationPriceList":s=await this._perp.contractReader.getLiquidationPriceList(...o);break;case"totalPositionValueList":s=await this._perp.contractReader.getTotalPositionValueList(...o);break;case"totalAbsPositionValue":s=await this._perp.contractReader.getTotalAbsPositionValue(i)}return this._cache.set(t,s),s}async getPositionDataAll(){try{p("getPositionDataAll");const t=this._perp.markets.marketMap,e=this._perp.contracts,i=this._perp.wallet.account,o=new f({contract:e.multicall2}),c={};Object.entries(t).forEach((([t,a])=>{const o=a.baseAddress,s=a.poolAddress,n=[{contract:e.accountBalance,contractName:g.ACCOUNT_BALANCE,funcName:"getTakerPositionSize",funcParams:[i,o]},{contract:e.accountBalance,contractName:g.ACCOUNT_BALANCE,funcName:"getTakerOpenNotional",funcParams:[i,o]},{contract:e.perpPortal,contractName:g.PerpPortal,funcName:"getLiquidationPrice",funcParams:[i,o]},{contract:e.accountBalance,contractName:g.ACCOUNT_BALANCE,funcName:"getTotalPositionSize",funcParams:[i,o]},{contract:e.accountBalance,contractName:g.ACCOUNT_BALANCE,funcName:"getTotalOpenNotional",funcParams:[i,o]},{contract:e.exchange,contractName:g.EXCHANGE,funcName:"getPendingFundingPayment",funcParams:[i,o]},{contract:e.baseToken.attach(o),contractName:g.BASE_TOKEN,funcName:"getIndexPrice",funcParams:[0]},{contract:e.pool.attach(s),contractName:g.POOL,funcName:"slot0",funcParams:[]}];c[`${t}`]=n}));const h=await o.execute(Object.values(c).flat(),{failFirstByContract:!1,failFirstByClient:!1}),P={};Object.entries(c).forEach((([e,a])=>{const i=h.splice(0,a.length),o=s(i[0]),r=s(i[1]),c=s(i[2]),m=s(i[3]),p=s(i[4]),k=s(i[5]),g=s(i[6]),f=n(i[7].sqrtPriceX96);let b,A;o.eq(0)||(b=new l({perp:this._perp,type:u.TAKER,market:t[`${e}`],side:o.gte(0)?d.LONG:d.SHORT,sizeAbs:o.abs(),openNotionalAbs:r.abs(),entryPrice:r.div(o).abs(),liquidationPrice:c}),A=o.mul(g));const T=m.minus(o),N=p.minus(r);let y,O;T.eq(0)||(y=new l({perp:this._perp,type:u.MAKER,market:t[`${e}`],side:T.gte(0)?d.LONG:d.SHORT,sizeAbs:T.abs(),openNotionalAbs:N.abs(),entryPrice:N.div(T).abs()}),O=T.mul(g)),P[`${e}`]={takerPosition:b,takerPositionValue:A,makerPosition:y,makerPositionValue:O,pendingFundingPayment:k,indexPrice:g,markPrice:f}}));const k=[],y={},O={};Object.entries(P).forEach((([t,e])=>{(function(t){return void 0!==t.takerPosition})(e)&&(y[`${t}`]=e),function(t){return void 0!==t.makerPosition}(e)&&(O[`${t}`]=e)})),Object.values(y).forEach((t=>{const a={contract:e.quoter,contractName:g.QUOTER,funcName:"swap",funcParams:[{baseToken:t.takerPosition.market.baseAddress,isBaseToQuote:t.takerPosition.isBaseToQuote,isExactInput:t.takerPosition.isExactInput,amount:r(t.takerPosition.sizeAbs),sqrtPriceLimitX96:0}]};k.push(a)})),Object.values(O).forEach((t=>{const a={contract:e.quoter,contractName:g.QUOTER,funcName:"swap",funcParams:[{baseToken:t.makerPosition.market.baseAddress,isBaseToQuote:t.makerPosition.isBaseToQuote,isExactInput:t.makerPosition.isExactInput,amount:r(t.makerPosition.sizeAbs),sqrtPriceLimitX96:0}]};k.push(a)})),k.push({contract:e.accountBalance,contractName:g.ACCOUNT_BALANCE,funcName:"getTotalAbsPositionValue",funcParams:[i]}),k.push({contract:e.vault,contractName:g.VAULT,funcName:"getAccountValue",funcParams:[i]});const w=await o.execute(k),_=w.splice(0,Object.keys(y).length),v=w.splice(0,Object.keys(O).length),E=s(w.shift()),L=s(w.shift(),a),M=E.eq(0)?void 0:L.div(E),j=M?m(1).div(M):void 0,z=Object.values(y).reduce(((t,e)=>t.add(e.takerPositionValue)),m(0)),x=Object.values(O).reduce(((t,e)=>t.add(e.makerPositionValue)),m(0));let R=m(0);Object.values(y).forEach(((t,e)=>{const{deltaAvailableQuote:a,exchangedPositionSize:i,exchangedPositionNotional:o}=_[e],n=t.takerPosition.side===d.LONG,r=s(a),c=s(o),l=s(i),u=b({isLong:n,deltaAvailableQuote:r,openNotionalAbs:t.takerPosition.openNotionalAbs}),m=A({amountBase:l,amountQuote:c}),h=T({price:m,markPrice:t.markPrice}),P=this._perp.clearingHouseConfig.marketExchangeFeeRatios[t.takerPosition.market.baseAddress],p=N({isBaseToQuote:t.takerPosition.isBaseToQuote,exchangedPositionNotional:c,deltaAvailableQuote:r,feeRatio:P});t.takerPosUnrealizedPnl=u,t.takerPosExitPrice=m,t.takerPosExitPriceImpact=h,t.takerPosExitTxFee=p,R=R.add(u)}));let C=m(0);Object.values(O).forEach(((t,e)=>{const{deltaAvailableQuote:a,exchangedPositionSize:i,exchangedPositionNotional:o}=v[e],n=t.makerPosition.side===d.LONG,r=s(a),c=s(o),l=s(i),u=b({isLong:n,deltaAvailableQuote:r,openNotionalAbs:t.makerPosition.openNotionalAbs}),m=A({amountBase:l,amountQuote:c}),h=T({price:m,markPrice:t.markPrice}),P=this._perp.clearingHouseConfig.marketExchangeFeeRatios[t.makerPosition.market.baseAddress],p=N({isBaseToQuote:t.makerPosition.isBaseToQuote,exchangedPositionNotional:c,deltaAvailableQuote:r,feeRatio:P});t.makerPosUnrealizedPnl=u,t.makerPosExitPrice=m,t.makerPosExitPriceImpact=h,t.makerPosExitTxFee=p,C=C.add(u)}));const B={totalTakerPositionValue:z,totalMakerPositionValue:x,totalTakerUnrealizedPnl:R,totalMakerUnrealizedPnl:C,totalUnrealizedPnl:R.add(C),accountPosValueAbs:E,accountMarginRatio:M,accountLeverage:j};this.emit("updated",{positionDataAllByMarket:P,positionDataAllCrossMarket:B})}catch(t){this.emit("updateError",{error:t})}}}export{y as Positions};
//# sourceMappingURL=Positions.js.map
