// package: injective.exchange.v1beta1
// file: injective/exchange/v1beta1/events.proto

import * as jspb from "google-protobuf";
import * as gogoproto_gogo_pb from "../../../gogoproto/gogo_pb";
import * as cosmos_base_v1beta1_coin_pb from "../../../cosmos/base/v1beta1/coin_pb";
import * as injective_oracle_v1beta1_oracle_pb from "../../../injective/oracle/v1beta1/oracle_pb";
import * as injective_exchange_v1beta1_exchange_pb from "../../../injective/exchange/v1beta1/exchange_pb";

export class EventBatchSpotExecution extends jspb.Message {
  getMarketId(): string;
  setMarketId(value: string): void;

  getIsBuy(): boolean;
  setIsBuy(value: boolean): void;

  getExecutiontype(): injective_exchange_v1beta1_exchange_pb.ExecutionTypeMap[keyof injective_exchange_v1beta1_exchange_pb.ExecutionTypeMap];
  setExecutiontype(value: injective_exchange_v1beta1_exchange_pb.ExecutionTypeMap[keyof injective_exchange_v1beta1_exchange_pb.ExecutionTypeMap]): void;

  clearTradesList(): void;
  getTradesList(): Array<injective_exchange_v1beta1_exchange_pb.TradeLog>;
  setTradesList(value: Array<injective_exchange_v1beta1_exchange_pb.TradeLog>): void;
  addTrades(value?: injective_exchange_v1beta1_exchange_pb.TradeLog, index?: number): injective_exchange_v1beta1_exchange_pb.TradeLog;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventBatchSpotExecution.AsObject;
  static toObject(includeInstance: boolean, msg: EventBatchSpotExecution): EventBatchSpotExecution.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventBatchSpotExecution, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventBatchSpotExecution;
  static deserializeBinaryFromReader(message: EventBatchSpotExecution, reader: jspb.BinaryReader): EventBatchSpotExecution;
}

export namespace EventBatchSpotExecution {
  export type AsObject = {
    marketId: string,
    isBuy: boolean,
    executiontype: injective_exchange_v1beta1_exchange_pb.ExecutionTypeMap[keyof injective_exchange_v1beta1_exchange_pb.ExecutionTypeMap],
    tradesList: Array<injective_exchange_v1beta1_exchange_pb.TradeLog.AsObject>,
  }
}

export class EventBatchDerivativeExecution extends jspb.Message {
  getMarketId(): string;
  setMarketId(value: string): void;

  getIsBuy(): boolean;
  setIsBuy(value: boolean): void;

  getIsLiquidation(): boolean;
  setIsLiquidation(value: boolean): void;

  getCumulativeFunding(): string;
  setCumulativeFunding(value: string): void;

  getExecutiontype(): injective_exchange_v1beta1_exchange_pb.ExecutionTypeMap[keyof injective_exchange_v1beta1_exchange_pb.ExecutionTypeMap];
  setExecutiontype(value: injective_exchange_v1beta1_exchange_pb.ExecutionTypeMap[keyof injective_exchange_v1beta1_exchange_pb.ExecutionTypeMap]): void;

  clearTradesList(): void;
  getTradesList(): Array<injective_exchange_v1beta1_exchange_pb.DerivativeTradeLog>;
  setTradesList(value: Array<injective_exchange_v1beta1_exchange_pb.DerivativeTradeLog>): void;
  addTrades(value?: injective_exchange_v1beta1_exchange_pb.DerivativeTradeLog, index?: number): injective_exchange_v1beta1_exchange_pb.DerivativeTradeLog;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventBatchDerivativeExecution.AsObject;
  static toObject(includeInstance: boolean, msg: EventBatchDerivativeExecution): EventBatchDerivativeExecution.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventBatchDerivativeExecution, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventBatchDerivativeExecution;
  static deserializeBinaryFromReader(message: EventBatchDerivativeExecution, reader: jspb.BinaryReader): EventBatchDerivativeExecution;
}

export namespace EventBatchDerivativeExecution {
  export type AsObject = {
    marketId: string,
    isBuy: boolean,
    isLiquidation: boolean,
    cumulativeFunding: string,
    executiontype: injective_exchange_v1beta1_exchange_pb.ExecutionTypeMap[keyof injective_exchange_v1beta1_exchange_pb.ExecutionTypeMap],
    tradesList: Array<injective_exchange_v1beta1_exchange_pb.DerivativeTradeLog.AsObject>,
  }
}

export class EventLostFundsFromLiquidation extends jspb.Message {
  getMarketId(): string;
  setMarketId(value: string): void;

  getSubaccountId(): Uint8Array | string;
  getSubaccountId_asU8(): Uint8Array;
  getSubaccountId_asB64(): string;
  setSubaccountId(value: Uint8Array | string): void;

  getLostFundsFromAvailableDuringPayout(): string;
  setLostFundsFromAvailableDuringPayout(value: string): void;

  getLostFundsFromOrderCancels(): string;
  setLostFundsFromOrderCancels(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventLostFundsFromLiquidation.AsObject;
  static toObject(includeInstance: boolean, msg: EventLostFundsFromLiquidation): EventLostFundsFromLiquidation.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventLostFundsFromLiquidation, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventLostFundsFromLiquidation;
  static deserializeBinaryFromReader(message: EventLostFundsFromLiquidation, reader: jspb.BinaryReader): EventLostFundsFromLiquidation;
}

export namespace EventLostFundsFromLiquidation {
  export type AsObject = {
    marketId: string,
    subaccountId: Uint8Array | string,
    lostFundsFromAvailableDuringPayout: string,
    lostFundsFromOrderCancels: string,
  }
}

export class EventBatchDerivativePosition extends jspb.Message {
  getMarketId(): string;
  setMarketId(value: string): void;

  clearPositionsList(): void;
  getPositionsList(): Array<injective_exchange_v1beta1_exchange_pb.SubaccountPosition>;
  setPositionsList(value: Array<injective_exchange_v1beta1_exchange_pb.SubaccountPosition>): void;
  addPositions(value?: injective_exchange_v1beta1_exchange_pb.SubaccountPosition, index?: number): injective_exchange_v1beta1_exchange_pb.SubaccountPosition;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventBatchDerivativePosition.AsObject;
  static toObject(includeInstance: boolean, msg: EventBatchDerivativePosition): EventBatchDerivativePosition.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventBatchDerivativePosition, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventBatchDerivativePosition;
  static deserializeBinaryFromReader(message: EventBatchDerivativePosition, reader: jspb.BinaryReader): EventBatchDerivativePosition;
}

export namespace EventBatchDerivativePosition {
  export type AsObject = {
    marketId: string,
    positionsList: Array<injective_exchange_v1beta1_exchange_pb.SubaccountPosition.AsObject>,
  }
}

export class EventDerivativeMarketPaused extends jspb.Message {
  getMarketId(): string;
  setMarketId(value: string): void;

  getSettlePrice(): string;
  setSettlePrice(value: string): void;

  getTotalMissingFunds(): string;
  setTotalMissingFunds(value: string): void;

  getMissingFundsRate(): string;
  setMissingFundsRate(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventDerivativeMarketPaused.AsObject;
  static toObject(includeInstance: boolean, msg: EventDerivativeMarketPaused): EventDerivativeMarketPaused.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventDerivativeMarketPaused, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventDerivativeMarketPaused;
  static deserializeBinaryFromReader(message: EventDerivativeMarketPaused, reader: jspb.BinaryReader): EventDerivativeMarketPaused;
}

export namespace EventDerivativeMarketPaused {
  export type AsObject = {
    marketId: string,
    settlePrice: string,
    totalMissingFunds: string,
    missingFundsRate: string,
  }
}

export class EventBinaryOptionsMarketUpdate extends jspb.Message {
  hasMarket(): boolean;
  clearMarket(): void;
  getMarket(): injective_exchange_v1beta1_exchange_pb.BinaryOptionsMarket | undefined;
  setMarket(value?: injective_exchange_v1beta1_exchange_pb.BinaryOptionsMarket): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventBinaryOptionsMarketUpdate.AsObject;
  static toObject(includeInstance: boolean, msg: EventBinaryOptionsMarketUpdate): EventBinaryOptionsMarketUpdate.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventBinaryOptionsMarketUpdate, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventBinaryOptionsMarketUpdate;
  static deserializeBinaryFromReader(message: EventBinaryOptionsMarketUpdate, reader: jspb.BinaryReader): EventBinaryOptionsMarketUpdate;
}

export namespace EventBinaryOptionsMarketUpdate {
  export type AsObject = {
    market?: injective_exchange_v1beta1_exchange_pb.BinaryOptionsMarket.AsObject,
  }
}

export class EventNewSpotOrders extends jspb.Message {
  getMarketId(): string;
  setMarketId(value: string): void;

  clearBuyOrdersList(): void;
  getBuyOrdersList(): Array<injective_exchange_v1beta1_exchange_pb.SpotLimitOrder>;
  setBuyOrdersList(value: Array<injective_exchange_v1beta1_exchange_pb.SpotLimitOrder>): void;
  addBuyOrders(value?: injective_exchange_v1beta1_exchange_pb.SpotLimitOrder, index?: number): injective_exchange_v1beta1_exchange_pb.SpotLimitOrder;

  clearSellOrdersList(): void;
  getSellOrdersList(): Array<injective_exchange_v1beta1_exchange_pb.SpotLimitOrder>;
  setSellOrdersList(value: Array<injective_exchange_v1beta1_exchange_pb.SpotLimitOrder>): void;
  addSellOrders(value?: injective_exchange_v1beta1_exchange_pb.SpotLimitOrder, index?: number): injective_exchange_v1beta1_exchange_pb.SpotLimitOrder;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventNewSpotOrders.AsObject;
  static toObject(includeInstance: boolean, msg: EventNewSpotOrders): EventNewSpotOrders.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventNewSpotOrders, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventNewSpotOrders;
  static deserializeBinaryFromReader(message: EventNewSpotOrders, reader: jspb.BinaryReader): EventNewSpotOrders;
}

export namespace EventNewSpotOrders {
  export type AsObject = {
    marketId: string,
    buyOrdersList: Array<injective_exchange_v1beta1_exchange_pb.SpotLimitOrder.AsObject>,
    sellOrdersList: Array<injective_exchange_v1beta1_exchange_pb.SpotLimitOrder.AsObject>,
  }
}

export class EventNewDerivativeOrders extends jspb.Message {
  getMarketId(): string;
  setMarketId(value: string): void;

  clearBuyOrdersList(): void;
  getBuyOrdersList(): Array<injective_exchange_v1beta1_exchange_pb.DerivativeLimitOrder>;
  setBuyOrdersList(value: Array<injective_exchange_v1beta1_exchange_pb.DerivativeLimitOrder>): void;
  addBuyOrders(value?: injective_exchange_v1beta1_exchange_pb.DerivativeLimitOrder, index?: number): injective_exchange_v1beta1_exchange_pb.DerivativeLimitOrder;

  clearSellOrdersList(): void;
  getSellOrdersList(): Array<injective_exchange_v1beta1_exchange_pb.DerivativeLimitOrder>;
  setSellOrdersList(value: Array<injective_exchange_v1beta1_exchange_pb.DerivativeLimitOrder>): void;
  addSellOrders(value?: injective_exchange_v1beta1_exchange_pb.DerivativeLimitOrder, index?: number): injective_exchange_v1beta1_exchange_pb.DerivativeLimitOrder;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventNewDerivativeOrders.AsObject;
  static toObject(includeInstance: boolean, msg: EventNewDerivativeOrders): EventNewDerivativeOrders.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventNewDerivativeOrders, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventNewDerivativeOrders;
  static deserializeBinaryFromReader(message: EventNewDerivativeOrders, reader: jspb.BinaryReader): EventNewDerivativeOrders;
}

export namespace EventNewDerivativeOrders {
  export type AsObject = {
    marketId: string,
    buyOrdersList: Array<injective_exchange_v1beta1_exchange_pb.DerivativeLimitOrder.AsObject>,
    sellOrdersList: Array<injective_exchange_v1beta1_exchange_pb.DerivativeLimitOrder.AsObject>,
  }
}

export class EventCancelSpotOrder extends jspb.Message {
  getMarketId(): string;
  setMarketId(value: string): void;

  hasOrder(): boolean;
  clearOrder(): void;
  getOrder(): injective_exchange_v1beta1_exchange_pb.SpotLimitOrder | undefined;
  setOrder(value?: injective_exchange_v1beta1_exchange_pb.SpotLimitOrder): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventCancelSpotOrder.AsObject;
  static toObject(includeInstance: boolean, msg: EventCancelSpotOrder): EventCancelSpotOrder.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventCancelSpotOrder, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventCancelSpotOrder;
  static deserializeBinaryFromReader(message: EventCancelSpotOrder, reader: jspb.BinaryReader): EventCancelSpotOrder;
}

export namespace EventCancelSpotOrder {
  export type AsObject = {
    marketId: string,
    order?: injective_exchange_v1beta1_exchange_pb.SpotLimitOrder.AsObject,
  }
}

export class EventSpotMarketUpdate extends jspb.Message {
  hasMarket(): boolean;
  clearMarket(): void;
  getMarket(): injective_exchange_v1beta1_exchange_pb.SpotMarket | undefined;
  setMarket(value?: injective_exchange_v1beta1_exchange_pb.SpotMarket): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventSpotMarketUpdate.AsObject;
  static toObject(includeInstance: boolean, msg: EventSpotMarketUpdate): EventSpotMarketUpdate.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventSpotMarketUpdate, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventSpotMarketUpdate;
  static deserializeBinaryFromReader(message: EventSpotMarketUpdate, reader: jspb.BinaryReader): EventSpotMarketUpdate;
}

export namespace EventSpotMarketUpdate {
  export type AsObject = {
    market?: injective_exchange_v1beta1_exchange_pb.SpotMarket.AsObject,
  }
}

export class EventPerpetualMarketUpdate extends jspb.Message {
  hasMarket(): boolean;
  clearMarket(): void;
  getMarket(): injective_exchange_v1beta1_exchange_pb.DerivativeMarket | undefined;
  setMarket(value?: injective_exchange_v1beta1_exchange_pb.DerivativeMarket): void;

  hasPerpetualMarketInfo(): boolean;
  clearPerpetualMarketInfo(): void;
  getPerpetualMarketInfo(): injective_exchange_v1beta1_exchange_pb.PerpetualMarketInfo | undefined;
  setPerpetualMarketInfo(value?: injective_exchange_v1beta1_exchange_pb.PerpetualMarketInfo): void;

  hasFunding(): boolean;
  clearFunding(): void;
  getFunding(): injective_exchange_v1beta1_exchange_pb.PerpetualMarketFunding | undefined;
  setFunding(value?: injective_exchange_v1beta1_exchange_pb.PerpetualMarketFunding): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventPerpetualMarketUpdate.AsObject;
  static toObject(includeInstance: boolean, msg: EventPerpetualMarketUpdate): EventPerpetualMarketUpdate.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventPerpetualMarketUpdate, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventPerpetualMarketUpdate;
  static deserializeBinaryFromReader(message: EventPerpetualMarketUpdate, reader: jspb.BinaryReader): EventPerpetualMarketUpdate;
}

export namespace EventPerpetualMarketUpdate {
  export type AsObject = {
    market?: injective_exchange_v1beta1_exchange_pb.DerivativeMarket.AsObject,
    perpetualMarketInfo?: injective_exchange_v1beta1_exchange_pb.PerpetualMarketInfo.AsObject,
    funding?: injective_exchange_v1beta1_exchange_pb.PerpetualMarketFunding.AsObject,
  }
}

export class EventExpiryFuturesMarketUpdate extends jspb.Message {
  hasMarket(): boolean;
  clearMarket(): void;
  getMarket(): injective_exchange_v1beta1_exchange_pb.DerivativeMarket | undefined;
  setMarket(value?: injective_exchange_v1beta1_exchange_pb.DerivativeMarket): void;

  hasExpiryFuturesMarketInfo(): boolean;
  clearExpiryFuturesMarketInfo(): void;
  getExpiryFuturesMarketInfo(): injective_exchange_v1beta1_exchange_pb.ExpiryFuturesMarketInfo | undefined;
  setExpiryFuturesMarketInfo(value?: injective_exchange_v1beta1_exchange_pb.ExpiryFuturesMarketInfo): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventExpiryFuturesMarketUpdate.AsObject;
  static toObject(includeInstance: boolean, msg: EventExpiryFuturesMarketUpdate): EventExpiryFuturesMarketUpdate.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventExpiryFuturesMarketUpdate, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventExpiryFuturesMarketUpdate;
  static deserializeBinaryFromReader(message: EventExpiryFuturesMarketUpdate, reader: jspb.BinaryReader): EventExpiryFuturesMarketUpdate;
}

export namespace EventExpiryFuturesMarketUpdate {
  export type AsObject = {
    market?: injective_exchange_v1beta1_exchange_pb.DerivativeMarket.AsObject,
    expiryFuturesMarketInfo?: injective_exchange_v1beta1_exchange_pb.ExpiryFuturesMarketInfo.AsObject,
  }
}

export class EventPerpetualMarketFundingUpdate extends jspb.Message {
  getMarketId(): string;
  setMarketId(value: string): void;

  hasFunding(): boolean;
  clearFunding(): void;
  getFunding(): injective_exchange_v1beta1_exchange_pb.PerpetualMarketFunding | undefined;
  setFunding(value?: injective_exchange_v1beta1_exchange_pb.PerpetualMarketFunding): void;

  getIsHourlyFunding(): boolean;
  setIsHourlyFunding(value: boolean): void;

  getFundingRate(): string;
  setFundingRate(value: string): void;

  getMarkPrice(): string;
  setMarkPrice(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventPerpetualMarketFundingUpdate.AsObject;
  static toObject(includeInstance: boolean, msg: EventPerpetualMarketFundingUpdate): EventPerpetualMarketFundingUpdate.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventPerpetualMarketFundingUpdate, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventPerpetualMarketFundingUpdate;
  static deserializeBinaryFromReader(message: EventPerpetualMarketFundingUpdate, reader: jspb.BinaryReader): EventPerpetualMarketFundingUpdate;
}

export namespace EventPerpetualMarketFundingUpdate {
  export type AsObject = {
    marketId: string,
    funding?: injective_exchange_v1beta1_exchange_pb.PerpetualMarketFunding.AsObject,
    isHourlyFunding: boolean,
    fundingRate: string,
    markPrice: string,
  }
}

export class EventSubaccountDeposit extends jspb.Message {
  getSrcAddress(): string;
  setSrcAddress(value: string): void;

  getSubaccountId(): Uint8Array | string;
  getSubaccountId_asU8(): Uint8Array;
  getSubaccountId_asB64(): string;
  setSubaccountId(value: Uint8Array | string): void;

  hasAmount(): boolean;
  clearAmount(): void;
  getAmount(): cosmos_base_v1beta1_coin_pb.Coin | undefined;
  setAmount(value?: cosmos_base_v1beta1_coin_pb.Coin): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventSubaccountDeposit.AsObject;
  static toObject(includeInstance: boolean, msg: EventSubaccountDeposit): EventSubaccountDeposit.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventSubaccountDeposit, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventSubaccountDeposit;
  static deserializeBinaryFromReader(message: EventSubaccountDeposit, reader: jspb.BinaryReader): EventSubaccountDeposit;
}

export namespace EventSubaccountDeposit {
  export type AsObject = {
    srcAddress: string,
    subaccountId: Uint8Array | string,
    amount?: cosmos_base_v1beta1_coin_pb.Coin.AsObject,
  }
}

export class EventSubaccountWithdraw extends jspb.Message {
  getSubaccountId(): Uint8Array | string;
  getSubaccountId_asU8(): Uint8Array;
  getSubaccountId_asB64(): string;
  setSubaccountId(value: Uint8Array | string): void;

  getDstAddress(): string;
  setDstAddress(value: string): void;

  hasAmount(): boolean;
  clearAmount(): void;
  getAmount(): cosmos_base_v1beta1_coin_pb.Coin | undefined;
  setAmount(value?: cosmos_base_v1beta1_coin_pb.Coin): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventSubaccountWithdraw.AsObject;
  static toObject(includeInstance: boolean, msg: EventSubaccountWithdraw): EventSubaccountWithdraw.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventSubaccountWithdraw, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventSubaccountWithdraw;
  static deserializeBinaryFromReader(message: EventSubaccountWithdraw, reader: jspb.BinaryReader): EventSubaccountWithdraw;
}

export namespace EventSubaccountWithdraw {
  export type AsObject = {
    subaccountId: Uint8Array | string,
    dstAddress: string,
    amount?: cosmos_base_v1beta1_coin_pb.Coin.AsObject,
  }
}

export class EventSubaccountBalanceTransfer extends jspb.Message {
  getSrcSubaccountId(): string;
  setSrcSubaccountId(value: string): void;

  getDstSubaccountId(): string;
  setDstSubaccountId(value: string): void;

  hasAmount(): boolean;
  clearAmount(): void;
  getAmount(): cosmos_base_v1beta1_coin_pb.Coin | undefined;
  setAmount(value?: cosmos_base_v1beta1_coin_pb.Coin): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventSubaccountBalanceTransfer.AsObject;
  static toObject(includeInstance: boolean, msg: EventSubaccountBalanceTransfer): EventSubaccountBalanceTransfer.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventSubaccountBalanceTransfer, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventSubaccountBalanceTransfer;
  static deserializeBinaryFromReader(message: EventSubaccountBalanceTransfer, reader: jspb.BinaryReader): EventSubaccountBalanceTransfer;
}

export namespace EventSubaccountBalanceTransfer {
  export type AsObject = {
    srcSubaccountId: string,
    dstSubaccountId: string,
    amount?: cosmos_base_v1beta1_coin_pb.Coin.AsObject,
  }
}

export class EventBatchDepositUpdate extends jspb.Message {
  clearDepositUpdatesList(): void;
  getDepositUpdatesList(): Array<injective_exchange_v1beta1_exchange_pb.DepositUpdate>;
  setDepositUpdatesList(value: Array<injective_exchange_v1beta1_exchange_pb.DepositUpdate>): void;
  addDepositUpdates(value?: injective_exchange_v1beta1_exchange_pb.DepositUpdate, index?: number): injective_exchange_v1beta1_exchange_pb.DepositUpdate;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventBatchDepositUpdate.AsObject;
  static toObject(includeInstance: boolean, msg: EventBatchDepositUpdate): EventBatchDepositUpdate.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventBatchDepositUpdate, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventBatchDepositUpdate;
  static deserializeBinaryFromReader(message: EventBatchDepositUpdate, reader: jspb.BinaryReader): EventBatchDepositUpdate;
}

export namespace EventBatchDepositUpdate {
  export type AsObject = {
    depositUpdatesList: Array<injective_exchange_v1beta1_exchange_pb.DepositUpdate.AsObject>,
  }
}

export class DerivativeMarketOrderCancel extends jspb.Message {
  hasMarketOrder(): boolean;
  clearMarketOrder(): void;
  getMarketOrder(): injective_exchange_v1beta1_exchange_pb.DerivativeMarketOrder | undefined;
  setMarketOrder(value?: injective_exchange_v1beta1_exchange_pb.DerivativeMarketOrder): void;

  getCancelQuantity(): string;
  setCancelQuantity(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): DerivativeMarketOrderCancel.AsObject;
  static toObject(includeInstance: boolean, msg: DerivativeMarketOrderCancel): DerivativeMarketOrderCancel.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: DerivativeMarketOrderCancel, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): DerivativeMarketOrderCancel;
  static deserializeBinaryFromReader(message: DerivativeMarketOrderCancel, reader: jspb.BinaryReader): DerivativeMarketOrderCancel;
}

export namespace DerivativeMarketOrderCancel {
  export type AsObject = {
    marketOrder?: injective_exchange_v1beta1_exchange_pb.DerivativeMarketOrder.AsObject,
    cancelQuantity: string,
  }
}

export class EventCancelDerivativeOrder extends jspb.Message {
  getMarketId(): string;
  setMarketId(value: string): void;

  getIslimitcancel(): boolean;
  setIslimitcancel(value: boolean): void;

  hasLimitOrder(): boolean;
  clearLimitOrder(): void;
  getLimitOrder(): injective_exchange_v1beta1_exchange_pb.DerivativeLimitOrder | undefined;
  setLimitOrder(value?: injective_exchange_v1beta1_exchange_pb.DerivativeLimitOrder): void;

  hasMarketOrderCancel(): boolean;
  clearMarketOrderCancel(): void;
  getMarketOrderCancel(): DerivativeMarketOrderCancel | undefined;
  setMarketOrderCancel(value?: DerivativeMarketOrderCancel): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventCancelDerivativeOrder.AsObject;
  static toObject(includeInstance: boolean, msg: EventCancelDerivativeOrder): EventCancelDerivativeOrder.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventCancelDerivativeOrder, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventCancelDerivativeOrder;
  static deserializeBinaryFromReader(message: EventCancelDerivativeOrder, reader: jspb.BinaryReader): EventCancelDerivativeOrder;
}

export namespace EventCancelDerivativeOrder {
  export type AsObject = {
    marketId: string,
    islimitcancel: boolean,
    limitOrder?: injective_exchange_v1beta1_exchange_pb.DerivativeLimitOrder.AsObject,
    marketOrderCancel?: DerivativeMarketOrderCancel.AsObject,
  }
}

export class EventFeeDiscountSchedule extends jspb.Message {
  hasSchedule(): boolean;
  clearSchedule(): void;
  getSchedule(): injective_exchange_v1beta1_exchange_pb.FeeDiscountSchedule | undefined;
  setSchedule(value?: injective_exchange_v1beta1_exchange_pb.FeeDiscountSchedule): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventFeeDiscountSchedule.AsObject;
  static toObject(includeInstance: boolean, msg: EventFeeDiscountSchedule): EventFeeDiscountSchedule.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventFeeDiscountSchedule, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventFeeDiscountSchedule;
  static deserializeBinaryFromReader(message: EventFeeDiscountSchedule, reader: jspb.BinaryReader): EventFeeDiscountSchedule;
}

export namespace EventFeeDiscountSchedule {
  export type AsObject = {
    schedule?: injective_exchange_v1beta1_exchange_pb.FeeDiscountSchedule.AsObject,
  }
}

export class EventTradingRewardCampaignUpdate extends jspb.Message {
  hasCampaignInfo(): boolean;
  clearCampaignInfo(): void;
  getCampaignInfo(): injective_exchange_v1beta1_exchange_pb.TradingRewardCampaignInfo | undefined;
  setCampaignInfo(value?: injective_exchange_v1beta1_exchange_pb.TradingRewardCampaignInfo): void;

  clearCampaignRewardPoolsList(): void;
  getCampaignRewardPoolsList(): Array<injective_exchange_v1beta1_exchange_pb.CampaignRewardPool>;
  setCampaignRewardPoolsList(value: Array<injective_exchange_v1beta1_exchange_pb.CampaignRewardPool>): void;
  addCampaignRewardPools(value?: injective_exchange_v1beta1_exchange_pb.CampaignRewardPool, index?: number): injective_exchange_v1beta1_exchange_pb.CampaignRewardPool;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventTradingRewardCampaignUpdate.AsObject;
  static toObject(includeInstance: boolean, msg: EventTradingRewardCampaignUpdate): EventTradingRewardCampaignUpdate.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventTradingRewardCampaignUpdate, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventTradingRewardCampaignUpdate;
  static deserializeBinaryFromReader(message: EventTradingRewardCampaignUpdate, reader: jspb.BinaryReader): EventTradingRewardCampaignUpdate;
}

export namespace EventTradingRewardCampaignUpdate {
  export type AsObject = {
    campaignInfo?: injective_exchange_v1beta1_exchange_pb.TradingRewardCampaignInfo.AsObject,
    campaignRewardPoolsList: Array<injective_exchange_v1beta1_exchange_pb.CampaignRewardPool.AsObject>,
  }
}

export class EventTradingRewardDistribution extends jspb.Message {
  clearAccountRewardsList(): void;
  getAccountRewardsList(): Array<injective_exchange_v1beta1_exchange_pb.AccountRewards>;
  setAccountRewardsList(value: Array<injective_exchange_v1beta1_exchange_pb.AccountRewards>): void;
  addAccountRewards(value?: injective_exchange_v1beta1_exchange_pb.AccountRewards, index?: number): injective_exchange_v1beta1_exchange_pb.AccountRewards;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventTradingRewardDistribution.AsObject;
  static toObject(includeInstance: boolean, msg: EventTradingRewardDistribution): EventTradingRewardDistribution.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventTradingRewardDistribution, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventTradingRewardDistribution;
  static deserializeBinaryFromReader(message: EventTradingRewardDistribution, reader: jspb.BinaryReader): EventTradingRewardDistribution;
}

export namespace EventTradingRewardDistribution {
  export type AsObject = {
    accountRewardsList: Array<injective_exchange_v1beta1_exchange_pb.AccountRewards.AsObject>,
  }
}

export class EventNewConditionalDerivativeOrder extends jspb.Message {
  getMarketId(): string;
  setMarketId(value: string): void;

  hasOrder(): boolean;
  clearOrder(): void;
  getOrder(): injective_exchange_v1beta1_exchange_pb.DerivativeOrder | undefined;
  setOrder(value?: injective_exchange_v1beta1_exchange_pb.DerivativeOrder): void;

  getHash(): Uint8Array | string;
  getHash_asU8(): Uint8Array;
  getHash_asB64(): string;
  setHash(value: Uint8Array | string): void;

  getIsMarket(): boolean;
  setIsMarket(value: boolean): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventNewConditionalDerivativeOrder.AsObject;
  static toObject(includeInstance: boolean, msg: EventNewConditionalDerivativeOrder): EventNewConditionalDerivativeOrder.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventNewConditionalDerivativeOrder, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventNewConditionalDerivativeOrder;
  static deserializeBinaryFromReader(message: EventNewConditionalDerivativeOrder, reader: jspb.BinaryReader): EventNewConditionalDerivativeOrder;
}

export namespace EventNewConditionalDerivativeOrder {
  export type AsObject = {
    marketId: string,
    order?: injective_exchange_v1beta1_exchange_pb.DerivativeOrder.AsObject,
    hash: Uint8Array | string,
    isMarket: boolean,
  }
}

export class EventCancelConditionalDerivativeOrder extends jspb.Message {
  getMarketId(): string;
  setMarketId(value: string): void;

  getIslimitcancel(): boolean;
  setIslimitcancel(value: boolean): void;

  hasLimitOrder(): boolean;
  clearLimitOrder(): void;
  getLimitOrder(): injective_exchange_v1beta1_exchange_pb.DerivativeLimitOrder | undefined;
  setLimitOrder(value?: injective_exchange_v1beta1_exchange_pb.DerivativeLimitOrder): void;

  hasMarketOrder(): boolean;
  clearMarketOrder(): void;
  getMarketOrder(): injective_exchange_v1beta1_exchange_pb.DerivativeMarketOrder | undefined;
  setMarketOrder(value?: injective_exchange_v1beta1_exchange_pb.DerivativeMarketOrder): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventCancelConditionalDerivativeOrder.AsObject;
  static toObject(includeInstance: boolean, msg: EventCancelConditionalDerivativeOrder): EventCancelConditionalDerivativeOrder.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventCancelConditionalDerivativeOrder, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventCancelConditionalDerivativeOrder;
  static deserializeBinaryFromReader(message: EventCancelConditionalDerivativeOrder, reader: jspb.BinaryReader): EventCancelConditionalDerivativeOrder;
}

export namespace EventCancelConditionalDerivativeOrder {
  export type AsObject = {
    marketId: string,
    islimitcancel: boolean,
    limitOrder?: injective_exchange_v1beta1_exchange_pb.DerivativeLimitOrder.AsObject,
    marketOrder?: injective_exchange_v1beta1_exchange_pb.DerivativeMarketOrder.AsObject,
  }
}

export class EventConditionalDerivativeOrderTrigger extends jspb.Message {
  getMarketId(): Uint8Array | string;
  getMarketId_asU8(): Uint8Array;
  getMarketId_asB64(): string;
  setMarketId(value: Uint8Array | string): void;

  getIslimittrigger(): boolean;
  setIslimittrigger(value: boolean): void;

  getTriggeredOrderHash(): Uint8Array | string;
  getTriggeredOrderHash_asU8(): Uint8Array;
  getTriggeredOrderHash_asB64(): string;
  setTriggeredOrderHash(value: Uint8Array | string): void;

  getPlacedOrderHash(): Uint8Array | string;
  getPlacedOrderHash_asU8(): Uint8Array;
  getPlacedOrderHash_asB64(): string;
  setPlacedOrderHash(value: Uint8Array | string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventConditionalDerivativeOrderTrigger.AsObject;
  static toObject(includeInstance: boolean, msg: EventConditionalDerivativeOrderTrigger): EventConditionalDerivativeOrderTrigger.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventConditionalDerivativeOrderTrigger, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventConditionalDerivativeOrderTrigger;
  static deserializeBinaryFromReader(message: EventConditionalDerivativeOrderTrigger, reader: jspb.BinaryReader): EventConditionalDerivativeOrderTrigger;
}

export namespace EventConditionalDerivativeOrderTrigger {
  export type AsObject = {
    marketId: Uint8Array | string,
    islimittrigger: boolean,
    triggeredOrderHash: Uint8Array | string,
    placedOrderHash: Uint8Array | string,
  }
}

export class EventOrderFail extends jspb.Message {
  getAccount(): Uint8Array | string;
  getAccount_asU8(): Uint8Array;
  getAccount_asB64(): string;
  setAccount(value: Uint8Array | string): void;

  clearHashesList(): void;
  getHashesList(): Array<Uint8Array | string>;
  getHashesList_asU8(): Array<Uint8Array>;
  getHashesList_asB64(): Array<string>;
  setHashesList(value: Array<Uint8Array | string>): void;
  addHashes(value: Uint8Array | string, index?: number): Uint8Array | string;

  clearFlagsList(): void;
  getFlagsList(): Array<number>;
  setFlagsList(value: Array<number>): void;
  addFlags(value: number, index?: number): number;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventOrderFail.AsObject;
  static toObject(includeInstance: boolean, msg: EventOrderFail): EventOrderFail.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventOrderFail, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventOrderFail;
  static deserializeBinaryFromReader(message: EventOrderFail, reader: jspb.BinaryReader): EventOrderFail;
}

export namespace EventOrderFail {
  export type AsObject = {
    account: Uint8Array | string,
    hashesList: Array<Uint8Array | string>,
    flagsList: Array<number>,
  }
}

export class EventAtomicMarketOrderFeeMultipliersUpdated extends jspb.Message {
  clearMarketFeeMultipliersList(): void;
  getMarketFeeMultipliersList(): Array<injective_exchange_v1beta1_exchange_pb.MarketFeeMultiplier>;
  setMarketFeeMultipliersList(value: Array<injective_exchange_v1beta1_exchange_pb.MarketFeeMultiplier>): void;
  addMarketFeeMultipliers(value?: injective_exchange_v1beta1_exchange_pb.MarketFeeMultiplier, index?: number): injective_exchange_v1beta1_exchange_pb.MarketFeeMultiplier;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventAtomicMarketOrderFeeMultipliersUpdated.AsObject;
  static toObject(includeInstance: boolean, msg: EventAtomicMarketOrderFeeMultipliersUpdated): EventAtomicMarketOrderFeeMultipliersUpdated.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventAtomicMarketOrderFeeMultipliersUpdated, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventAtomicMarketOrderFeeMultipliersUpdated;
  static deserializeBinaryFromReader(message: EventAtomicMarketOrderFeeMultipliersUpdated, reader: jspb.BinaryReader): EventAtomicMarketOrderFeeMultipliersUpdated;
}

export namespace EventAtomicMarketOrderFeeMultipliersUpdated {
  export type AsObject = {
    marketFeeMultipliersList: Array<injective_exchange_v1beta1_exchange_pb.MarketFeeMultiplier.AsObject>,
  }
}

export class EventOrderbookUpdate extends jspb.Message {
  clearSpotUpdatesList(): void;
  getSpotUpdatesList(): Array<OrderbookUpdate>;
  setSpotUpdatesList(value: Array<OrderbookUpdate>): void;
  addSpotUpdates(value?: OrderbookUpdate, index?: number): OrderbookUpdate;

  clearDerivativeUpdatesList(): void;
  getDerivativeUpdatesList(): Array<OrderbookUpdate>;
  setDerivativeUpdatesList(value: Array<OrderbookUpdate>): void;
  addDerivativeUpdates(value?: OrderbookUpdate, index?: number): OrderbookUpdate;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventOrderbookUpdate.AsObject;
  static toObject(includeInstance: boolean, msg: EventOrderbookUpdate): EventOrderbookUpdate.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventOrderbookUpdate, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventOrderbookUpdate;
  static deserializeBinaryFromReader(message: EventOrderbookUpdate, reader: jspb.BinaryReader): EventOrderbookUpdate;
}

export namespace EventOrderbookUpdate {
  export type AsObject = {
    spotUpdatesList: Array<OrderbookUpdate.AsObject>,
    derivativeUpdatesList: Array<OrderbookUpdate.AsObject>,
  }
}

export class OrderbookUpdate extends jspb.Message {
  getSeq(): number;
  setSeq(value: number): void;

  hasOrderbook(): boolean;
  clearOrderbook(): void;
  getOrderbook(): Orderbook | undefined;
  setOrderbook(value?: Orderbook): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): OrderbookUpdate.AsObject;
  static toObject(includeInstance: boolean, msg: OrderbookUpdate): OrderbookUpdate.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: OrderbookUpdate, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): OrderbookUpdate;
  static deserializeBinaryFromReader(message: OrderbookUpdate, reader: jspb.BinaryReader): OrderbookUpdate;
}

export namespace OrderbookUpdate {
  export type AsObject = {
    seq: number,
    orderbook?: Orderbook.AsObject,
  }
}

export class Orderbook extends jspb.Message {
  getMarketId(): Uint8Array | string;
  getMarketId_asU8(): Uint8Array;
  getMarketId_asB64(): string;
  setMarketId(value: Uint8Array | string): void;

  clearBuyLevelsList(): void;
  getBuyLevelsList(): Array<injective_exchange_v1beta1_exchange_pb.Level>;
  setBuyLevelsList(value: Array<injective_exchange_v1beta1_exchange_pb.Level>): void;
  addBuyLevels(value?: injective_exchange_v1beta1_exchange_pb.Level, index?: number): injective_exchange_v1beta1_exchange_pb.Level;

  clearSellLevelsList(): void;
  getSellLevelsList(): Array<injective_exchange_v1beta1_exchange_pb.Level>;
  setSellLevelsList(value: Array<injective_exchange_v1beta1_exchange_pb.Level>): void;
  addSellLevels(value?: injective_exchange_v1beta1_exchange_pb.Level, index?: number): injective_exchange_v1beta1_exchange_pb.Level;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Orderbook.AsObject;
  static toObject(includeInstance: boolean, msg: Orderbook): Orderbook.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Orderbook, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Orderbook;
  static deserializeBinaryFromReader(message: Orderbook, reader: jspb.BinaryReader): Orderbook;
}

export namespace Orderbook {
  export type AsObject = {
    marketId: Uint8Array | string,
    buyLevelsList: Array<injective_exchange_v1beta1_exchange_pb.Level.AsObject>,
    sellLevelsList: Array<injective_exchange_v1beta1_exchange_pb.Level.AsObject>,
  }
}

