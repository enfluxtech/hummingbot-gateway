"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var r=require("ethers"),t=require("../../contracts/Contracts.js"),a=require("../../errors/errors.js");exports.MulticallReader=class{constructor({contract:r}){this.contract=r}async execute(c,e){const{failFirstByContract:n=!0,failFirstByClient:o=!0,returnByContractAndFuncName:u=!1}=e||{},s=c.map((r=>{try{const t=r.contract.interface.encodeFunctionData(r.funcName,r.funcParams);return{target:r.contract.address,callData:t}}catch(c){throw new a.MulticallEncodeError({contractName:t.ContractName.MULTICALL2,contractFunctionName:"tryAggregate",args:{callFuncNam:r.funcName,callFuncParams:r.funcParams},rawError:c})}}));let l;try{l=await this.contract.callStatic.tryAggregate(n,s)}catch(r){throw new a.MulticallReadError({contractName:t.ContractName.MULTICALL2,contractFunctionName:"tryAggregate",rawError:r})}const i=l.map((({success:e,returnData:n},u)=>{const s=c[u];if(!o&&!e){let t=new Error;if(n.length>=68){const a=`0x${n.substr(10)}`,c=r.utils.toUtf8String(a).trim();t=new Error(c)}const c={contractName:s.funcName,contractFunctionName:s.funcName,args:s.funcParams,rawError:t};return new a.ContractReadError(c)}try{const r=s.contract.interface.decodeFunctionResult(s.funcName,n);return r.length<=1?r[0]:r}catch(r){throw new a.MulticallDecodeError({contractName:t.ContractName.MULTICALL2,contractFunctionName:"tryAggregate",args:{callFuncNam:s.funcName,returnData:n},rawError:r})}}));if(u){return i.reduce(((r,t,a)=>{const e=c[a],n=`${e.contractName}.${e.funcName}`,o=r[n];return r[n]=o?[...o,t]:[t],r}),{})}return i}};
//# sourceMappingURL=MulticallReader.js.map
