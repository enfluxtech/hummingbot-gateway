{"version":3,"file":"PositionDraft.js","sources":["../../../../src/core/position/PositionDraft.ts"],"sourcesContent":["import { Channel, ChannelEventSource, MemoizedFetcher, createMemoizedFetcher, hasNumberChange } from \"../../internal\"\nimport { ContractReader, GetPositionDraftRelatedDataReturn, GetQuoterSwapReturn } from \"../contractReader\"\nimport { PerpetualProtocol, PerpetualProtocolConnected } from \"../PerpetualProtocol\"\nimport {\n    getBuyingPower,\n    getNextAccountValue,\n    getNextFreeCollateral,\n    getNextOpenOrderMarginReq,\n    getNextTotalCollateralValue,\n    getPriceImpact,\n    getSwapRate,\n    getTransactionFee,\n} from \"../clearingHouse/utils\"\n\nimport { BIG_ZERO } from \"../../constants\"\nimport Big from \"big.js\"\nimport { Market } from \"../market\"\nimport { PositionSide } from \"./types\"\nimport { UnauthorizedError } from \"../../errors\"\nimport { invariant } from \"../../utils\"\n\ntype CacheKey = \"swap\" | \"relatedData\"\n\ntype CacheValue = GetQuoterSwapReturn | GetPositionDraftRelatedDataReturn\n\nexport type PositionDraftEventName = \"updateError\" | \"updated\" | \"buyingPowerUpdated\"\n\nexport interface PositionDraftDataUpdatable {\n    side?: PositionSide\n    amountInput?: Big\n    isAmountInputBase?: boolean\n}\n\nexport interface PositionDraftConstructorData {\n    market: Market\n    side: PositionSide\n    amountInput: Big\n    isAmountInputBase: boolean\n}\n\nexport interface PositionDraftUserInputRelatedData {\n    amountOutput: Big\n    isAmountOutputBase: boolean\n    entryPrice: Big\n    priceImpact: Big\n    transactionFee: Big\n    deltaAvailableBase: Big\n    deltaAvailableQuote: Big\n}\n\n// NOTE:\n// If we wanna calculate the \"nextXXXX\" (like nextFreeCollateral), could find the previous\n// formula in this release.\n// https://github.com/perpetual-protocol/perp-exchange/blob/release/2.7.x/src/sdk-react/clearingHouse/usePositionDraftDetail.ts#L34\nexport class PositionDraft<EventName extends string = string> extends Channel<PositionDraftEventName | EventName> {\n    private _cache: Map<CacheKey, CacheValue> = new Map()\n\n    side: PositionSide\n    amountInput: Big\n    isAmountInputBase: boolean\n    market: Market\n\n    private _feeRatio: Big\n    private _imRatio: Big\n    private _contractReader: ContractReader\n\n    constructor(\n        protected readonly _perp: PerpetualProtocol | PerpetualProtocolConnected,\n        {\n            market,\n            side = PositionSide.LONG,\n            amountInput = BIG_ZERO,\n            isAmountInputBase = false,\n        }: PositionDraftConstructorData,\n    ) {\n        super(_perp.channelRegistry)\n\n        this.market = market\n        this.side = side\n        this.amountInput = amountInput\n        this.isAmountInputBase = isAmountInputBase\n\n        this._feeRatio = _perp.clearingHouseConfig.marketExchangeFeeRatios[market.baseAddress]\n        this._imRatio = _perp.clearingHouseConfig.imRatio\n        this._contractReader = _perp.contractReader\n    }\n\n    /**\n     * When opening position, is trader selling BASE token in exchange for QUOTE token?\n     */\n    get isBaseToQuote() {\n        return this.side === PositionSide.SHORT // NOTE: Opening a SHORT is equivalent to SELL BASE token.\n    }\n\n    /**\n     * When opening position, is the user input for the same token as the token inputted to the pool?\n     * NOTE: see truth table, https://docs.google.com/spreadsheets/d/1gVLSYVj98e0p2HaxQ7NdHCejd6S25sr9jgXlnzE1jqE/edit#gid=2106034965\n     */\n    get isExactInput() {\n        if (this.isBaseToQuote) {\n            // NOTE: Trader selling BASE => when the trader enters amount for BASE token, it's the desired exact amount to input to pool.\n            return this.isAmountInputBase\n        } else {\n            // NOTE: Trader selling QUOTE => when the trader enters amount for QUOTE token, it's the desired exact amount to input to pool.\n            return !this.isAmountInputBase\n        }\n    }\n\n    /**\n     * Calculate the upper/lower bound for slippage protection.\n     * Formula: https://www.notion.so/perp/V2-Formula-for-opening-position-e8f7e481cf144b75977217114cecbdb9#4e6cd0d79c7a4565bb90835593cb7dcd\n     **/\n    async getOppositeAmountBound(slippage: Big) {\n        const { output } = await this._fetch(\"swap\", { cache: false })\n\n        let result\n        if (this.isExactInput) {\n            result = output.mul(new Big(1).sub(slippage))\n        } else {\n            result = output.mul(new Big(1).add(slippage))\n            if (slippage.eq(0) && !this.isBaseToQuote) {\n                // when slippage = 0, isBaseToQuote = false, and isExactInput = false, contract will have rounding issue.\n                result = result.add(new Big(1).mul(10 ** -18))\n            }\n        }\n        return result\n    }\n\n    // NOTE: before initEventEmitter issue get solved,\n    // below logics get triggered multiple times when initizlied which caused performance issue.\n    protected _getEventSourceMap() {\n        const fetchAndEmitUpdated = this._createFetchUpdateData()\n\n        const marketUpdated = new ChannelEventSource<PositionDraftEventName | EventName>({\n            eventSourceStarter: () => {\n                return this.market.on(\"updated\", async () => {\n                    this._handleMarketUpdate()\n                })\n            },\n        })\n\n        const buyingPowerUpdated = new ChannelEventSource<PositionDraftEventName | EventName>({\n            eventSourceStarter: () => {\n                invariant(\n                    this._perp.hasConnected(),\n                    () => new UnauthorizedError({ functionName: \"_getEventSourceMap\" }),\n                )\n                const removeVaultUpdated = this._perp.vault.on(\"updated\", () => {\n                    fetchAndEmitUpdated(false, true)\n                })\n                const removePositionsUpdated = this._perp.positions.on(\"updated\", () => {\n                    fetchAndEmitUpdated(false, true)\n                })\n                return () => {\n                    removeVaultUpdated()\n                    removePositionsUpdated()\n                }\n            },\n        })\n\n        return {\n            updated: marketUpdated,\n            buyingPowerUpdated,\n        }\n    }\n\n    private _createFetchUpdateData(): MemoizedFetcher {\n        const getBuyingPowerData = async () => {\n            try {\n                const result = await this.getBuyingPower({\n                    cache: false,\n                })\n                return result\n            } catch (error) {\n                this.emit(\"updateError\", { error })\n            }\n        }\n        return createMemoizedFetcher(\n            () => getBuyingPowerData(),\n            () => {\n                this.emit(\"buyingPowerUpdated\", this)\n            },\n            (a, b) => {\n                return a && b ? hasNumberChange(a, b) : true\n            },\n        )\n    }\n\n    protected async _handleMarketUpdate() {\n        if (this.amountInput.lte(0)) {\n            return\n        }\n        try {\n            await this._fetch(\"swap\", { cache: false })\n\n            if (this._perp.hasConnected()) {\n                await this._fetch(\"relatedData\", { cache: false })\n            }\n\n            this.emit(\"updated\", this)\n        } catch (e) {\n            this.emit(\"updateError\", { error: e })\n        }\n    }\n\n    async getSwap({ cache = true } = {}) {\n        return this._fetch(\"swap\", { cache })\n    }\n\n    public async getEntryPrice({ cache = true } = {}) {\n        const { exchangedPositionSize, exchangedPositionNotional } = await this._fetch(\"swap\", { cache })\n        const entryPrice = getSwapRate({\n            amountBase: exchangedPositionSize,\n            amountQuote: exchangedPositionNotional,\n        })\n        return entryPrice\n    }\n\n    public async getPriceImpact({ cache = true } = {}) {\n        const entryPrice = await this.getEntryPrice({ cache })\n        const { markPrice } = await this.market.getPrices({ cache })\n        const priceImpact = getPriceImpact({\n            price: entryPrice,\n            markPrice,\n        })\n        return priceImpact\n    }\n\n    public async getTransactionFee({ cache = true } = {}) {\n        const { deltaAvailableQuote, exchangedPositionNotional } = await this._fetch(\"swap\", { cache })\n        const transactionFee = getTransactionFee({\n            isBaseToQuote: this.isBaseToQuote,\n            exchangedPositionNotional,\n            deltaAvailableQuote,\n            feeRatio: this._feeRatio,\n        })\n        return transactionFee\n    }\n\n    public async getBuyingPower({ cache = true } = {}) {\n        invariant(this._perp.hasConnected(), () => new UnauthorizedError({ functionName: \"getBuyingPower\" }))\n        const [\n            { indexTwapPrice },\n            relatedData,\n            accountValue,\n            freeCollateral,\n            existingPositionValue,\n            existingPositionSize,\n        ] = await Promise.all([\n            this.market.getPrices({ cache }),\n            this._fetch(\"relatedData\", { cache }),\n            this._perp.clearingHouse.getAccountValue({ cache }),\n            this._perp.vault.getFreeCollateral({ cache }),\n            this._perp.positions.getTotalPositionValue(this.market.baseAddress, { cache }),\n            this.getExistingPositionSize(), // _fetch(\"relatedData\") already fetched it\n        ])\n\n        const { deltaAvailableBase = BIG_ZERO, deltaAvailableQuote = BIG_ZERO } = relatedData.swap\n        const isLong = this.side === PositionSide.LONG\n        const signedDeltaAvailableBase = deltaAvailableBase.mul(isLong ? 1 : -1)\n        const signedDeltaAvailableQuote = deltaAvailableQuote.mul(isLong ? -1 : 1)\n        const nextAccountValue = getNextAccountValue({\n            indexTwapPrice,\n            accountValue,\n            signedDeltaAvailableBase,\n            signedDeltaAvailableQuote,\n        })\n        const totalUnrealizedPNLFromAllMarkets = await this._perp.positions.getTotalUnrealizedPnlFromAllMarkets()\n        const nextTotalCollateralValue = getNextTotalCollateralValue({\n            nextAccountValue,\n            signedDeltaAvailableBase,\n            signedDeltaAvailableQuote,\n            indexTwapPrice,\n            totalUnrealizedPNLFromAllMarkets,\n        })\n\n        const { otherBaseDebts, otherMarketIndexPrices, quoteDebts } = relatedData\n\n        const sumOfOtherBaseDebtValue = BIG_ZERO\n        for (let i = 0; i < otherBaseDebts.length; i++) {\n            const baseDebt = otherBaseDebts[i]\n            const baseIndexPrice = otherMarketIndexPrices[i]\n            if (baseDebt.lt(0)) {\n                sumOfOtherBaseDebtValue.add(baseDebt.mul(baseIndexPrice))\n            }\n        }\n\n        const sumOfQuoteDebtValue = quoteDebts.reduce(\n            (sigmaQuoteBalance, quoteDebt) => sigmaQuoteBalance.add(quoteDebt),\n            BIG_ZERO,\n        )\n        const nextOpenOrderMarginReq = getNextOpenOrderMarginReq({\n            sumOfOtherBaseDebtValue,\n            sumOfQuoteDebtValue,\n            thisBaseBalance: existingPositionSize,\n            signedDeltaAvailableBase,\n            signedDeltaAvailableQuote,\n            indexTwapPrice,\n            imRatio: this._imRatio,\n        })\n\n        const nextFreeCollateral = getNextFreeCollateral({\n            nextTotalCollateralValue,\n            nextAccountValue,\n            nextOpenOrderMarginReq,\n        })\n\n        const buyingPower = getBuyingPower({\n            imRatio: this._imRatio,\n            freeCollateral,\n            existingPositionValue,\n            side: this.side,\n            nextFreeCollateral,\n        })\n\n        // FIXME:\n        // it seems that `getNextTotalCollateralValue` turned to negative when margin ratio < imRatio\n        // it's hard to reproduce above issue. Might need to figure out the negative issue somehow.\n        // temporary, we directly pass 0 when negative happens\n        return buyingPower.lt(0) ? Big(0) : buyingPower\n    }\n\n    private async getExistingPositionSize({ cache = true } = {}) {\n        invariant(this._perp.hasConnected(), () => new UnauthorizedError({ functionName: \"getExistingPositionSize\" }))\n        const makerPosition = await this._perp.positions.getTakerPosition(this.market.baseAddress, { cache })\n        const takerPosition = await this._perp.positions.getMakerPosition(this.market.baseAddress)\n        return Big(makerPosition?.sizeAbs || 0).add(takerPosition?.sizeAbs || 0)\n    }\n\n    public async simulateOpenPosition() {\n        // TODO: we couldn't get slippage in sdk level, this might be changed in the future\n        // const oppositeAmountBound = await this.getOppositeAmountBound(slippage)\n        return this._contractReader.simulateOpenPosition({\n            baseTokenAddress: this.market.baseAddress,\n            isBaseToQuote: this.isBaseToQuote,\n            isExactInput: this.isExactInput,\n            amount: this.amountInput,\n            oppositeAmountBound: BIG_ZERO,\n        })\n    }\n\n    async getRelatedData({ cache = true } = {}) {\n        return this._fetch(\"relatedData\", { cache })\n    }\n\n    private async _fetch(key: \"swap\", obj?: { cache: boolean }): Promise<GetQuoterSwapReturn>\n    private async _fetch(key: \"relatedData\", obj?: { cache: boolean }): Promise<GetPositionDraftRelatedDataReturn>\n    private async _fetch(key: CacheKey, { cache = true } = {}) {\n        if (this._cache.has(key) && cache) {\n            return this._cache.get(key)\n        }\n\n        let result\n        switch (key) {\n            case \"swap\": {\n                result = await this._perp.contractReader.getQuoterSwap({\n                    baseTokenAddress: this.market.baseAddress,\n                    amount: this.amountInput,\n                    isBaseToQuote: this.isBaseToQuote,\n                    isExactInput: this.isExactInput,\n                })\n                break\n            }\n            case \"relatedData\": {\n                invariant(this._perp.hasConnected(), () => new UnauthorizedError({ functionName: \"getRelatedData\" }))\n                const existingPositionSize = await this.getExistingPositionSize({ cache: false })\n                result = await this._perp.contractReader.getPositionDraftRelatedData({\n                    trader: this._perp.wallet.account,\n                    marketBaseAddresses: Object.values(this._perp.markets.marketMap).map(market => market.baseAddress),\n                    currentMarketBaseSize: existingPositionSize,\n                    currentMarketBaseAddress: this.market.baseAddress,\n                })\n            }\n        }\n        this._cache.set(key, result)\n\n        return result\n    }\n}\n"],"names":["PositionDraft","Channel","constructor","_perp","market","side","PositionSide","LONG","amountInput","BIG_ZERO","isAmountInputBase","super","channelRegistry","this","_cache","Map","_feeRatio","clearingHouseConfig","marketExchangeFeeRatios","baseAddress","_imRatio","imRatio","_contractReader","contractReader","isBaseToQuote","SHORT","isExactInput","async","slippage","output","_fetch","cache","result","mul","Big","sub","add","eq","_getEventSourceMap","fetchAndEmitUpdated","_createFetchUpdateData","updated","ChannelEventSource","eventSourceStarter","on","_handleMarketUpdate","buyingPowerUpdated","invariant","hasConnected","UnauthorizedError","functionName","removeVaultUpdated","vault","removePositionsUpdated","positions","getBuyingPowerData","getBuyingPower","error","emit","createMemoizedFetcher","a","b","hasNumberChange","lte","e","exchangedPositionSize","exchangedPositionNotional","getSwapRate","amountBase","amountQuote","entryPrice","getEntryPrice","markPrice","getPrices","getPriceImpact","price","deltaAvailableQuote","getTransactionFee","feeRatio","indexTwapPrice","relatedData","accountValue","freeCollateral","existingPositionValue","existingPositionSize","Promise","all","clearingHouse","getAccountValue","getFreeCollateral","getTotalPositionValue","getExistingPositionSize","deltaAvailableBase","swap","isLong","signedDeltaAvailableBase","signedDeltaAvailableQuote","nextAccountValue","getNextAccountValue","totalUnrealizedPNLFromAllMarkets","getTotalUnrealizedPnlFromAllMarkets","nextTotalCollateralValue","getNextTotalCollateralValue","otherBaseDebts","otherMarketIndexPrices","quoteDebts","sumOfOtherBaseDebtValue","i","length","baseDebt","baseIndexPrice","lt","sumOfQuoteDebtValue","reduce","sigmaQuoteBalance","quoteDebt","nextOpenOrderMarginReq","getNextOpenOrderMarginReq","thisBaseBalance","nextFreeCollateral","getNextFreeCollateral","buyingPower","makerPosition","getTakerPosition","takerPosition","getMakerPosition","sizeAbs","simulateOpenPosition","baseTokenAddress","amount","oppositeAmountBound","key","has","get","getQuoterSwap","getPositionDraftRelatedData","trader","wallet","account","marketBaseAddresses","Object","values","markets","marketMap","map","currentMarketBaseSize","currentMarketBaseAddress","set"],"mappings":"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"}