// package: injective.peggy.v1
// file: injective/peggy/v1/events.proto

import * as jspb from "google-protobuf";
import * as gogoproto_gogo_pb from "../../../gogoproto/gogo_pb";
import * as injective_peggy_v1_attestation_pb from "../../../injective/peggy/v1/attestation_pb";
import * as injective_peggy_v1_types_pb from "../../../injective/peggy/v1/types_pb";

export class EventAttestationObserved extends jspb.Message {
  getAttestationType(): injective_peggy_v1_attestation_pb.ClaimTypeMap[keyof injective_peggy_v1_attestation_pb.ClaimTypeMap];
  setAttestationType(value: injective_peggy_v1_attestation_pb.ClaimTypeMap[keyof injective_peggy_v1_attestation_pb.ClaimTypeMap]): void;

  getBridgeContract(): string;
  setBridgeContract(value: string): void;

  getBridgeChainId(): number;
  setBridgeChainId(value: number): void;

  getAttestationId(): Uint8Array | string;
  getAttestationId_asU8(): Uint8Array;
  getAttestationId_asB64(): string;
  setAttestationId(value: Uint8Array | string): void;

  getNonce(): number;
  setNonce(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventAttestationObserved.AsObject;
  static toObject(includeInstance: boolean, msg: EventAttestationObserved): EventAttestationObserved.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventAttestationObserved, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventAttestationObserved;
  static deserializeBinaryFromReader(message: EventAttestationObserved, reader: jspb.BinaryReader): EventAttestationObserved;
}

export namespace EventAttestationObserved {
  export type AsObject = {
    attestationType: injective_peggy_v1_attestation_pb.ClaimTypeMap[keyof injective_peggy_v1_attestation_pb.ClaimTypeMap],
    bridgeContract: string,
    bridgeChainId: number,
    attestationId: Uint8Array | string,
    nonce: number,
  }
}

export class EventBridgeWithdrawCanceled extends jspb.Message {
  getBridgeContract(): string;
  setBridgeContract(value: string): void;

  getBridgeChainId(): number;
  setBridgeChainId(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventBridgeWithdrawCanceled.AsObject;
  static toObject(includeInstance: boolean, msg: EventBridgeWithdrawCanceled): EventBridgeWithdrawCanceled.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventBridgeWithdrawCanceled, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventBridgeWithdrawCanceled;
  static deserializeBinaryFromReader(message: EventBridgeWithdrawCanceled, reader: jspb.BinaryReader): EventBridgeWithdrawCanceled;
}

export namespace EventBridgeWithdrawCanceled {
  export type AsObject = {
    bridgeContract: string,
    bridgeChainId: number,
  }
}

export class EventOutgoingBatch extends jspb.Message {
  getDenom(): string;
  setDenom(value: string): void;

  getOrchestratorAddress(): string;
  setOrchestratorAddress(value: string): void;

  getBatchNonce(): number;
  setBatchNonce(value: number): void;

  getBatchTimeout(): number;
  setBatchTimeout(value: number): void;

  clearBatchTxIdsList(): void;
  getBatchTxIdsList(): Array<number>;
  setBatchTxIdsList(value: Array<number>): void;
  addBatchTxIds(value: number, index?: number): number;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventOutgoingBatch.AsObject;
  static toObject(includeInstance: boolean, msg: EventOutgoingBatch): EventOutgoingBatch.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventOutgoingBatch, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventOutgoingBatch;
  static deserializeBinaryFromReader(message: EventOutgoingBatch, reader: jspb.BinaryReader): EventOutgoingBatch;
}

export namespace EventOutgoingBatch {
  export type AsObject = {
    denom: string,
    orchestratorAddress: string,
    batchNonce: number,
    batchTimeout: number,
    batchTxIdsList: Array<number>,
  }
}

export class EventOutgoingBatchCanceled extends jspb.Message {
  getBridgeContract(): string;
  setBridgeContract(value: string): void;

  getBridgeChainId(): number;
  setBridgeChainId(value: number): void;

  getBatchId(): number;
  setBatchId(value: number): void;

  getNonce(): number;
  setNonce(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventOutgoingBatchCanceled.AsObject;
  static toObject(includeInstance: boolean, msg: EventOutgoingBatchCanceled): EventOutgoingBatchCanceled.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventOutgoingBatchCanceled, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventOutgoingBatchCanceled;
  static deserializeBinaryFromReader(message: EventOutgoingBatchCanceled, reader: jspb.BinaryReader): EventOutgoingBatchCanceled;
}

export namespace EventOutgoingBatchCanceled {
  export type AsObject = {
    bridgeContract: string,
    bridgeChainId: number,
    batchId: number,
    nonce: number,
  }
}

export class EventValsetUpdateRequest extends jspb.Message {
  getValsetNonce(): number;
  setValsetNonce(value: number): void;

  getValsetHeight(): number;
  setValsetHeight(value: number): void;

  clearValsetMembersList(): void;
  getValsetMembersList(): Array<injective_peggy_v1_types_pb.BridgeValidator>;
  setValsetMembersList(value: Array<injective_peggy_v1_types_pb.BridgeValidator>): void;
  addValsetMembers(value?: injective_peggy_v1_types_pb.BridgeValidator, index?: number): injective_peggy_v1_types_pb.BridgeValidator;

  getRewardAmount(): string;
  setRewardAmount(value: string): void;

  getRewardToken(): string;
  setRewardToken(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventValsetUpdateRequest.AsObject;
  static toObject(includeInstance: boolean, msg: EventValsetUpdateRequest): EventValsetUpdateRequest.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventValsetUpdateRequest, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventValsetUpdateRequest;
  static deserializeBinaryFromReader(message: EventValsetUpdateRequest, reader: jspb.BinaryReader): EventValsetUpdateRequest;
}

export namespace EventValsetUpdateRequest {
  export type AsObject = {
    valsetNonce: number,
    valsetHeight: number,
    valsetMembersList: Array<injective_peggy_v1_types_pb.BridgeValidator.AsObject>,
    rewardAmount: string,
    rewardToken: string,
  }
}

export class EventSetOrchestratorAddresses extends jspb.Message {
  getValidatorAddress(): string;
  setValidatorAddress(value: string): void;

  getOrchestratorAddress(): string;
  setOrchestratorAddress(value: string): void;

  getOperatorEthAddress(): string;
  setOperatorEthAddress(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventSetOrchestratorAddresses.AsObject;
  static toObject(includeInstance: boolean, msg: EventSetOrchestratorAddresses): EventSetOrchestratorAddresses.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventSetOrchestratorAddresses, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventSetOrchestratorAddresses;
  static deserializeBinaryFromReader(message: EventSetOrchestratorAddresses, reader: jspb.BinaryReader): EventSetOrchestratorAddresses;
}

export namespace EventSetOrchestratorAddresses {
  export type AsObject = {
    validatorAddress: string,
    orchestratorAddress: string,
    operatorEthAddress: string,
  }
}

export class EventValsetConfirm extends jspb.Message {
  getValsetNonce(): number;
  setValsetNonce(value: number): void;

  getOrchestratorAddress(): string;
  setOrchestratorAddress(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventValsetConfirm.AsObject;
  static toObject(includeInstance: boolean, msg: EventValsetConfirm): EventValsetConfirm.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventValsetConfirm, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventValsetConfirm;
  static deserializeBinaryFromReader(message: EventValsetConfirm, reader: jspb.BinaryReader): EventValsetConfirm;
}

export namespace EventValsetConfirm {
  export type AsObject = {
    valsetNonce: number,
    orchestratorAddress: string,
  }
}

export class EventSendToEth extends jspb.Message {
  getOutgoingTxId(): number;
  setOutgoingTxId(value: number): void;

  getSender(): string;
  setSender(value: string): void;

  getReceiver(): string;
  setReceiver(value: string): void;

  getAmount(): string;
  setAmount(value: string): void;

  getBridgeFee(): string;
  setBridgeFee(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventSendToEth.AsObject;
  static toObject(includeInstance: boolean, msg: EventSendToEth): EventSendToEth.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventSendToEth, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventSendToEth;
  static deserializeBinaryFromReader(message: EventSendToEth, reader: jspb.BinaryReader): EventSendToEth;
}

export namespace EventSendToEth {
  export type AsObject = {
    outgoingTxId: number,
    sender: string,
    receiver: string,
    amount: string,
    bridgeFee: string,
  }
}

export class EventConfirmBatch extends jspb.Message {
  getBatchNonce(): number;
  setBatchNonce(value: number): void;

  getOrchestratorAddress(): string;
  setOrchestratorAddress(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventConfirmBatch.AsObject;
  static toObject(includeInstance: boolean, msg: EventConfirmBatch): EventConfirmBatch.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventConfirmBatch, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventConfirmBatch;
  static deserializeBinaryFromReader(message: EventConfirmBatch, reader: jspb.BinaryReader): EventConfirmBatch;
}

export namespace EventConfirmBatch {
  export type AsObject = {
    batchNonce: number,
    orchestratorAddress: string,
  }
}

export class EventAttestationVote extends jspb.Message {
  getEventNonce(): number;
  setEventNonce(value: number): void;

  getAttestationId(): Uint8Array | string;
  getAttestationId_asU8(): Uint8Array;
  getAttestationId_asB64(): string;
  setAttestationId(value: Uint8Array | string): void;

  getVoter(): string;
  setVoter(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventAttestationVote.AsObject;
  static toObject(includeInstance: boolean, msg: EventAttestationVote): EventAttestationVote.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventAttestationVote, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventAttestationVote;
  static deserializeBinaryFromReader(message: EventAttestationVote, reader: jspb.BinaryReader): EventAttestationVote;
}

export namespace EventAttestationVote {
  export type AsObject = {
    eventNonce: number,
    attestationId: Uint8Array | string,
    voter: string,
  }
}

export class EventDepositClaim extends jspb.Message {
  getEventNonce(): number;
  setEventNonce(value: number): void;

  getEventHeight(): number;
  setEventHeight(value: number): void;

  getAttestationId(): Uint8Array | string;
  getAttestationId_asU8(): Uint8Array;
  getAttestationId_asB64(): string;
  setAttestationId(value: Uint8Array | string): void;

  getEthereumSender(): string;
  setEthereumSender(value: string): void;

  getCosmosReceiver(): string;
  setCosmosReceiver(value: string): void;

  getTokenContract(): string;
  setTokenContract(value: string): void;

  getAmount(): string;
  setAmount(value: string): void;

  getOrchestratorAddress(): string;
  setOrchestratorAddress(value: string): void;

  getData(): string;
  setData(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventDepositClaim.AsObject;
  static toObject(includeInstance: boolean, msg: EventDepositClaim): EventDepositClaim.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventDepositClaim, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventDepositClaim;
  static deserializeBinaryFromReader(message: EventDepositClaim, reader: jspb.BinaryReader): EventDepositClaim;
}

export namespace EventDepositClaim {
  export type AsObject = {
    eventNonce: number,
    eventHeight: number,
    attestationId: Uint8Array | string,
    ethereumSender: string,
    cosmosReceiver: string,
    tokenContract: string,
    amount: string,
    orchestratorAddress: string,
    data: string,
  }
}

export class EventWithdrawClaim extends jspb.Message {
  getEventNonce(): number;
  setEventNonce(value: number): void;

  getEventHeight(): number;
  setEventHeight(value: number): void;

  getAttestationId(): Uint8Array | string;
  getAttestationId_asU8(): Uint8Array;
  getAttestationId_asB64(): string;
  setAttestationId(value: Uint8Array | string): void;

  getBatchNonce(): number;
  setBatchNonce(value: number): void;

  getTokenContract(): string;
  setTokenContract(value: string): void;

  getOrchestratorAddress(): string;
  setOrchestratorAddress(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventWithdrawClaim.AsObject;
  static toObject(includeInstance: boolean, msg: EventWithdrawClaim): EventWithdrawClaim.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventWithdrawClaim, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventWithdrawClaim;
  static deserializeBinaryFromReader(message: EventWithdrawClaim, reader: jspb.BinaryReader): EventWithdrawClaim;
}

export namespace EventWithdrawClaim {
  export type AsObject = {
    eventNonce: number,
    eventHeight: number,
    attestationId: Uint8Array | string,
    batchNonce: number,
    tokenContract: string,
    orchestratorAddress: string,
  }
}

export class EventERC20DeployedClaim extends jspb.Message {
  getEventNonce(): number;
  setEventNonce(value: number): void;

  getEventHeight(): number;
  setEventHeight(value: number): void;

  getAttestationId(): Uint8Array | string;
  getAttestationId_asU8(): Uint8Array;
  getAttestationId_asB64(): string;
  setAttestationId(value: Uint8Array | string): void;

  getCosmosDenom(): string;
  setCosmosDenom(value: string): void;

  getTokenContract(): string;
  setTokenContract(value: string): void;

  getName(): string;
  setName(value: string): void;

  getSymbol(): string;
  setSymbol(value: string): void;

  getDecimals(): number;
  setDecimals(value: number): void;

  getOrchestratorAddress(): string;
  setOrchestratorAddress(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventERC20DeployedClaim.AsObject;
  static toObject(includeInstance: boolean, msg: EventERC20DeployedClaim): EventERC20DeployedClaim.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventERC20DeployedClaim, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventERC20DeployedClaim;
  static deserializeBinaryFromReader(message: EventERC20DeployedClaim, reader: jspb.BinaryReader): EventERC20DeployedClaim;
}

export namespace EventERC20DeployedClaim {
  export type AsObject = {
    eventNonce: number,
    eventHeight: number,
    attestationId: Uint8Array | string,
    cosmosDenom: string,
    tokenContract: string,
    name: string,
    symbol: string,
    decimals: number,
    orchestratorAddress: string,
  }
}

export class EventValsetUpdateClaim extends jspb.Message {
  getEventNonce(): number;
  setEventNonce(value: number): void;

  getEventHeight(): number;
  setEventHeight(value: number): void;

  getAttestationId(): Uint8Array | string;
  getAttestationId_asU8(): Uint8Array;
  getAttestationId_asB64(): string;
  setAttestationId(value: Uint8Array | string): void;

  getValsetNonce(): number;
  setValsetNonce(value: number): void;

  clearValsetMembersList(): void;
  getValsetMembersList(): Array<injective_peggy_v1_types_pb.BridgeValidator>;
  setValsetMembersList(value: Array<injective_peggy_v1_types_pb.BridgeValidator>): void;
  addValsetMembers(value?: injective_peggy_v1_types_pb.BridgeValidator, index?: number): injective_peggy_v1_types_pb.BridgeValidator;

  getRewardAmount(): string;
  setRewardAmount(value: string): void;

  getRewardToken(): string;
  setRewardToken(value: string): void;

  getOrchestratorAddress(): string;
  setOrchestratorAddress(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventValsetUpdateClaim.AsObject;
  static toObject(includeInstance: boolean, msg: EventValsetUpdateClaim): EventValsetUpdateClaim.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventValsetUpdateClaim, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventValsetUpdateClaim;
  static deserializeBinaryFromReader(message: EventValsetUpdateClaim, reader: jspb.BinaryReader): EventValsetUpdateClaim;
}

export namespace EventValsetUpdateClaim {
  export type AsObject = {
    eventNonce: number,
    eventHeight: number,
    attestationId: Uint8Array | string,
    valsetNonce: number,
    valsetMembersList: Array<injective_peggy_v1_types_pb.BridgeValidator.AsObject>,
    rewardAmount: string,
    rewardToken: string,
    orchestratorAddress: string,
  }
}

export class EventCancelSendToEth extends jspb.Message {
  getOutgoingTxId(): number;
  setOutgoingTxId(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventCancelSendToEth.AsObject;
  static toObject(includeInstance: boolean, msg: EventCancelSendToEth): EventCancelSendToEth.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventCancelSendToEth, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventCancelSendToEth;
  static deserializeBinaryFromReader(message: EventCancelSendToEth, reader: jspb.BinaryReader): EventCancelSendToEth;
}

export namespace EventCancelSendToEth {
  export type AsObject = {
    outgoingTxId: number,
  }
}

export class EventSubmitBadSignatureEvidence extends jspb.Message {
  getBadEthSignature(): string;
  setBadEthSignature(value: string): void;

  getBadEthSignatureSubject(): string;
  setBadEthSignatureSubject(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): EventSubmitBadSignatureEvidence.AsObject;
  static toObject(includeInstance: boolean, msg: EventSubmitBadSignatureEvidence): EventSubmitBadSignatureEvidence.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: EventSubmitBadSignatureEvidence, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): EventSubmitBadSignatureEvidence;
  static deserializeBinaryFromReader(message: EventSubmitBadSignatureEvidence, reader: jspb.BinaryReader): EventSubmitBadSignatureEvidence;
}

export namespace EventSubmitBadSignatureEvidence {
  export type AsObject = {
    badEthSignature: string,
    badEthSignatureSubject: string,
  }
}

